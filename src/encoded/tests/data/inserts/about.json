[
    {
        "name": "home",
        "title": "Home",
        "status": "released",
        "uuid": "b7d70724-3fb7-41c6-893c-f90be5c95ae2",
        "layout": {
            "rows": [
                {
                    "cols": [
                        {"blocks": ["#block1"]}
                    ]
                },
                {
                    "cols": [
                        {"blocks": ["#block2"]},
                        {"blocks": ["#block3"]},
                        {"blocks": ["#block4"]}
                    ]
                }
            ],
            "blocks": [
                {
                    "@id": "#block1",
                    "@type": "richtextblock",
                    "body": "<div class=\"project-info site-title\">\n    <h1>ENCODE: The Encyclopedia of DNA Elements</h1>\n</div>\n<div id=\"info-box\" class=\"project-info text-panel\">\n  <p>The ENCODE project dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.</p>\n</div>"
                },
                {
                    "@id": "#block2",
                    "@type": "richtextblock",
                    "body": "<h2>Transcriptome</h2>\n<p>Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.</p>"
                },
                {
                    "@id": "#block3",
                    "@type": "richtextblock",
                    "body": "<h2>Regulation</h2>\n<p>Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum.</p>"
                },
                {
                    "@id": "#block4",
                    "@type": "teaserblock",
                    "image": "/images/8a91ae78-731a-4a92-ae7c-273214be408a/",
                    "body": "<h2>Chromatin Structure</h2>",
                    "href": "/about/chromatin-structure"
                }
            ]
        }
    },
    {
        "name": "about",
        "title": "About",
        "status": "released",
        "uuid": "092a47cf-8d7b-4ff0-bf5d-9b16c89a8827",
        "layout": {
            "rows": [
                {
                    "cols": [
                        {
                            "className": "col-md-12 class_override",
                            "blocks": ["#block1"]
                        }
                    ]
                },
                {
                    "cols": [
                        {"blocks": ["#block2", "#block3"]},
                        {"blocks": ["#block4"]}
                    ]
                }
            ],
            "blocks": [
                {
                    "@id": "#block1",
                    "@type": "richtextblock",
                    "body": "<h1>About</h1>"
                },
                {
                    "@id": "#block2",
                    "@type": "richtextblock",
                    "body": "<h2>Antibodies</h2>"
                },
                {
                    "@id": "#block3",
                    "@type": "searchblock",
                    "search": "?type=antibody_approval"
                },
                {
                    "@id": "#block4",
                    "@type": "itemblock",
                    "item": "/images/b4589f52-521e-45db-8dfa-378d92cbbd86/"
                }
            ]
        }
    },
    {
        "name": "encode_rest_api",
        "title": "The ENCODE REST API",
        "status": "in progress",
        "uuid": "9493f567-c0b9-4910-abbd-5e798f5a9265",
        "layout": {
            "rows": [
                {
                    "cols": [
                        {
                            "blocks": [
                                "#block2"
                            ]
                        }
                    ]
                }
            ],
            "blocks": [
                {
                    "body": "<h2>Introduction</h2> <p>Direct interaction with the ENCODE DCC metadata database is typically done through scripts you write and execute on your own Mac, PC or server. Your scripts interact with the database through an industry-standard, HTTP-based, RESTful interface. Data objects exchanged with the server conform to the standard JSON format. JSON is a defined data interchange format that is used web-wide. If you&rsquo;re familiar with JavaScript&rsquo;s object literal notation or Python&rsquo;s dictionary datatype, then JSON-formatted text will look familiar. You will almost certainly use libraries for your language of choice to handle the network connection and parse the objects returned (<a href=\"http://docs.python-requests.org/en/latest/\">requests</a>&nbsp;and <a href=\"http://docs.python.org/2/library/json.html\">json</a> for Python, for example). We have written example scripts you can look at <a href=\"https://github.com/ENCODE-DCC/submission_sample_scripts\">here</a>.</p> <h2>Quickstart Examples</h2> <p>While getting objects from the database, updating existing objects or adding new objects can often be done in just a few lines of code, here are some quick ways of testing your connection and exploring the ENCODE data objects without writing any code.</p> <h3>Prerequisites</h3> <ol> <li>A JSON pretty-printer plugin for your web browser, such as JSONView (for Chrome <a href=\"https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc?hl=en\">here</a>, for <a href=\"https://addons.mozilla.org/en-us/firefox/addon/jsonview/\">Firefox</a>).</li> <li>The curl command, which ships with Mac OSX and all major LINUX/UNIX implementations. If you don&rsquo;t have curl, an executable can be downloaded from <a href=\"http://curl.haxx.se/dlwiz/?type=bin\">here</a>.&nbsp;You will find curl useful later for debugging your scripts (it always works), so if you don&rsquo;t already have it, you&rsquo;ll want to get it.</li> </ol> <h3>ENCODE JSON in your browser</h3> <p>Look at biosample ENCBS000AAA here:</p><p><a class=\"url\" href=\"https://www.encodedcc.org/biosamples/ENCBS000AAA/\">https://www.encodedcc.org/biosamples/ENCBS000AAA/</a></p> <figure class=\"fig fig-align-right\"> <img src=\"/images/1a0df3d4-2496-4d1f-ba4f-519bc2a22cfd/@@download/attachment/ENCBS000AAA.png\"><figcaption><span>Figure 1</span>: Publicly released ENCODE object</figcaption></figure> <p>You should see something like Figure 1. You don&rsquo;t need to sign in to the server to see this publicly-released ENCODE object.</p> <p>Now change the URL to be</p> <p><a class=\"url\" href=\"https://www.encodedcc.org/biosamples/ENCBS000AAA/?format=json\">https://www.encodedcc.org/biosamples/ENCBS000AAA/?format=json</a></p> <figure class=\"fig fig-align-left\"> <img src=\"/images/218ffd6c-d595-4bbc-8fa4-7c82a5855d4a/@@download/attachment/ENCBS000AAA-json.png\"><figcaption><span>Figure 2</span>: ENCODE object viewed as JSON</figcaption></figure><p>You should see something like Figure 2:</p> <p>By adding the /?format=json parameter, you've instructed the ENCODE webserver to send you the raw contents of the database record for ENCBS000AAA, in JSON format. Rather than being rendered in your browser, you see the native JSON object as it is stored in the ENCODE database. This is a biosample object, and you will see all the properties and their values for this object. You need a JSON pretty printer (see prerequisites above) in order to make sense of the JSON. Notice that many of the object&rsquo;s properties contain other (nested) objects.</p> <p>Notice also that the object has its own URL, and that the URL corresponds to the object&rsquo;s accession number. This always works to access ENCODE objects. In fact, because accession numbers are unique, you can construct a URL from the accession number alone and the server will return your object. For example <a class=\"url\" href=\"https://www.encodedcc.org/ENCBS000AAA\">https://www.encodedcc.org/ENCBS000AAA</a></p> <p>As you learn more about the ENCODE REST API, you&rsquo;ll see that when you retrieve objects (using the HTTP &ldquo;GET&rdquo; method) from the server, they always come back as JSON. When you create new objects (using the HTTP &ldquo;POST&rdquo; method) or update existing objects (using the HTTP &ldquo;PATCH&rdquo; method), you always format a JSON object on your side and send that to the server.</p> <h3>A simple command-line GET</h3> <p>Try this in a terminal window:</p> <pre><code>$ curl -H \"Accept: application/json\" https://www.encodedcc.org/biosamples/ENCBS000AAA/</code></pre> <figure class=\"fig fig-align-left\"> <img src=\"/images/5bc125bf-cff4-4129-87ed-56d23d983dc1/@@download/attachment/curl-output.png\"><figcaption><span>Figure 3</span>: Publicly released ENCODE object</figcaption></figure> <p>You should see lots of text that starts with something like Figure 3. Your command instructs curl to download the database record for the ENCODE biosample ENCBS000AAA in JSON format (it&rdquo;s the same object rendered above and at <a class=\"url\" href=\"https://www.encodedcc.org/biosamples/ENCBS000AAA/\">https://www.encodedcc.org/biosamples/ENCBS000AAA/</a>). In fact, the ENCODE server sees that the request is coming from something other than a web browser running the ENCODE web app, so it returns the object in JSON format. All curl is really doing is downloading the &ldquo;web page&rdquo; that corresponds to that ENCODE record. Transport is by HTTP, just like a web browser.</p> <p>This sort of JSON-formatted text is sometimes referred to as a &ldquo;JSON document.&rdquo; You can redirect the output to a file:</p> <pre><code>$ curl -H \"Accept: application/json\" https://www.encodedcc.org/biosamples/ENCBS000AAA/ > ENCBS000AAA.json</code><code>$ more ENBS000AAA.json</code></pre> <p>If you supply an invalid identifier (like an accession number that doesn&rsquo;t refer to anything), you&rsquo;ll see something like:</p> <pre><code>{\"status\": \"error\", \"code\": 404, \"description\": \"The resource could not be found.\" ... }</code></pre> <p>From this you can see that even error responses come back in JSON format. This makes parsing the results of your queries much easier.</p> <h3>REST, JSON and curl in perspective</h3> <p>As you develop your scripts, curl can be a valuable testing tool. If you can get an object with a curl command, you should be able to get it with your script. You can use curl to push new objects to the database and modify existing ones, too, but in a production environment you will want the control of a script over the one-off convenience of command line curl.</p> <p>The important thing to remember is that each ENCODE object is accessible via a simple URL containing an identifier (like an accession number) for that object. That&rsquo;s all curl does, that&rsquo;s all your browser does, and that&rsquo;s all your scripts will do. The resource you GET, using that URL, will be in JSON format. You will then use a library to parse the JSON and construct a native data structure (like a Python dictionary). Similarly, to submit new metadata (or update existing metadata), you will make JSON in your script (usually from a native data structure like a Python dictionary) and then use HTTP methods POST or PATCH to a URL.</p> <p>The ENCODE REST API uses GET, POST and PATCH to transport JSON-formatted information between the server and your scripts.</p> <h2>The ENCODE REST API</h2> <h3>Prerequisites</h3> <ul><li>A library or module for your language of choice that supports HTTP. The &dquo;requests&rdquo; library (<a href=\"http://docs.python-requests.org/en/latest/\">here</a>) for Python is good, and will be used for examples in this documentation.</li> <li>A library or module for parsing JSON-structured text and building native data structures. The Python &ldquo;json&rdquo; library (<a href=\"http://docs.python.org/2.7/library/json.html\">here</a>) is good.</li> <li>To PATCH or POST, or to GET unreleased ENCODE objects, a &ldquo;key pair&rdquo; for an ENCODE server. Key pairs for <a class=\"url\" href=\"https://www.encodedcc.org/\">https://www.encodedcc.org</a> and <a class=\"url\" href=\"https://test.encodedcc.org\">https://test.encodedcc.org</a> are available from your wrangler. A key pair consists of an access_key_id and a secret_access_key and they are used to authenticate every transaction with the ENCODE server.</li> <li>\"submits_for\" privileges for at least one lab to POST. Your ENCODE Wrangler can check your privileges.</li> <li>\"submits_for\" privileges for the lab that owns the object to PATCH. Your ENCODE Wrangler can check your privileges.</li></ul> <h3>GET</h3> <p>The HTTP GET request is used to retrieve objects from the ENCODE server.</p> <pre><code>#!/usr/bin/env python2<br># -*- coding: latin-1 -*-<br>'''GET an object from an ENCODE server'''<br /><br />import requests, json<br /><br /># Force return from the server in JSON format<br />HEADERS = {'accept': 'application/json'}<br /><br /># This URL locates the ENCODE biosample with accession number ENCBS000AAA<br />URL = \"https://www.encodedcc.org/biosample/ENCBS000AAA/?frame=object\"<br /><br /># GET the object<br>response = requests.get(URL, headers=HEADERS)<br /><br /># Extract the JSON response as a python dict<br />response_json_dict = response.json()<br /><br /># Print the object<br />print json.dumps(response_json_dict, indent=4, separators=(',', ': '))</code></pre> <p>This script GETs the JSON representation of ENCODE biosample ENCBS000AAA. The ENCODE server&rsquo;s JSON response is extracted as a Python dict using the response.json() method. The dict is then dumped back to a string and pretty-printed with useful indentation.</p> <p>The output should look something like:</p> <pre><code>{<br />    \"system_slims\": [],<br />    \"accession\": \"ENCBS000AAA\",<br />    \"passage_number\": 5,<br />    \"alternate_accessions\": [],<br />    \"culture_harvest_date\": \"2012-04-10\",<br />    \"aliases\": [<br />        \"richard-myers:MCF7-003\"<br />    ],<br />    \"rnais\": [],<br />    \"submitted_by\": \"/users/df9f3c8e-b819-4885-8f16-08f6ef0001e8/\",<br />    \"dbxrefs\": [<br />        \"UCSC-ENCODE-cv:MCF-7\"<br />    ],<br />    \"uuid\": \"56e94f2b-25ac-4c58-9828-f63b66220999\",<br />    \"biosample_type\": \"immortalized cell line\",<br />    \"schema_version\": \"4\",<br />    \"note\": \"(PMID: 4357757)\",<br />    \"source\": \"/sources/atcc/\",<br />    \"developmental_slims\": [],<br />    \"protocol_documents\": [<br />        \"/documents/984071d4-9149-476a-b353-93592c6f48f3/\"<br />    ],<br />    \"pooled_from\": [],<br />    \"status\": \"CURRENT\",<br />    \"description\": \"mammary gland, adenocarcinoma\",<br />    \"age_units\": \"year\",<br />    \"life_stage\": \"adult\",<br />    \"constructs\": [],<br />    \"treatments\": [],<br />    \"lab\": \"/labs/richard-myers/\",<br />    \"award\": \"/awards/U54HG004576/\",<br />    \"donor\": \"/human-donors/ENCDO000AAE/\",<br />    \"@id\": \"/biosamples/ENCBS000AAA/\",<br />    \"culture_start_date\": \"2012-03-16\",<br />    \"product_id\": \"HTB-22\",<br />    \"characterizations\": [],<br />    \"url\": \"http://www.atcc.org/Products/All/HTB-22.aspx\",<br />    \"biosample_term_id\": \"EFO:0001203\",<br />    \"age\": \"69\",<br />    \"organ_slims\": [],<br />    \"biosample_term_name\": \"MCF-7\",<br />    \"health_status\": \"unknown\",<br />    \"date_created\": \"2013-12-12T05:50:02.101495+00:00\",<br />    \"organism\": \"/organisms/human/\",<br />    \"@type\": [<br />        \"biosample\",<br />        \"item\"<br />    ]<br />}</code></pre> <p>The important point is that the response object has been cast into a native Python dict datastructure. For example, protocol_documents is an array of document identifiers and so you can loop over that array.</p> <p>Adding the following code to the example script above loops through the protocol_documents array, GETs each document object, and prints its description:</p> <pre><code>biosample = response_json_dict<br /><br />for doc_URI in biosample['protocol_documents']:<br />    doc_response = requests.get('https://www.encodedcc.org/'+doc_URI, headers=HEADERS)<br />    document = doc_response.json()<br />    print document['description']</code></pre><p>Which prints:</p> <pre><code>MCF-7 Cell Culture and 4-hydroxytamoxifen treatment</code></pre> <p>In the examples above, no username or password has been provided to the GET requests. GET will work without any authentication to fetch publicly released ENCODE objects, but to fetch objects that you&rsquo;ve just posted or that have not been released under the ENCODE Release Policy, you will need a username and password available from the ENCODE DCC.</p> <p>Here&rsquo;s an example of the same code example as above, only now providing a username and password.</p> <pre><code>#!/usr/bin/env python2<br># -*- coding: latin-1 -*-<br>'''GET an object from an ENCODE server with authentication'''<br /><br />import requests, json<br /><br /># Force return from the server in JSON format<br />HEADERS = {'accept': 'application/json'}<br /><br /># This URL locates the ENCODE biosample with accession number ENCBS000AAA<br />URL = \"https://www.encodedcc.org/biosample/ENCBS000AAA/?frame=object\"<br /><br /># Authentication is only required to GET unreleased ENCODE objects<br />AUTHID = \"H7OL67B4\" #<- Replace with your keypair, available from your ENCODE wrangler<br />AUTHPW = \"lr5gz2fjowbaqox5\" #<- Replace with your keypair, available from your ENCODE wrangler<br /><br /># GET the object<br />response = requests.get(URL, auth=(AUTHID, AUTHPW), headers=HEADERS)<br /><br /># Extract the JSON response as a python dict<br />response_json_dict = response.json()<br /><br /># Print the object<br />print json.dumps(response_json_dict, indent=4, separators=(',', ': '))</code></pre> <h3>PATCH</h3> <p>To update an existing record in the ENCODE database, use the HTTP PATCH method. Consistent with the ENCODE REST architecture and our JSON serialization of ENCODE objects, you PATCH a JSON string to the object&rsquo;s URL. Patch always requires an authorization keypair and you must have submits_for privileges for the lab that owns the object.</p> <p>For example, if you had submits_for privileges for the lab /labs/barbara-wold, the following code would chage the description property of the ENCODE experiment ENCSR000AJT on the ENCODE test server:</p> <pre><code>#!/usr/bin/env python<br /># -*- coding: latin-1 -*-<br />'''PATCH an object on an ENCODE server'''<br /><br />import sys, requests, json<br /><br /># Indicate that the content sent to the server is JSON<br /># Force return from the server in JSON format<br />HEADERS = {'content-type': 'application/json', 'accept': 'application/json'}<br /><br /># Authentication is always required to PATCH ENCODE objects<br />AUTHID = \"H7OL67B4\" #<- Replace with your keypair, available from your ENCODE wrangler<br />AUTHPW = \"lr5gz2fjowbaqox5\" #<- Replace with your keypair, available from your ENCODE wrangler<br /><br /># This URL locates the ENCODE experiment with accession number ENCSR000AJT<br />URL = \"https://test.encodedcc.org/experiments/ENCSR000AJT/\"<br /><br /># Create the JSON to send to the server<br />payload_dict = {<br />    \"description\": \"ChIP-Seq mouse C2C12 Control\" #Originally Caltech ChIP-Seq mouse C2C12 EqS_2.0pct_60hr Control_36bp<br />}<br />json_payload = json.dumps(payload_dict)<br /><br /># Send the request to the server<br />response = requests.patch(URL, auth=(AUTHID, AUTHPW), headers=HEADERS, data=json_payload)<br /><br /># Process the response<br />if not response.status_code == 200:<br />    print >> sys.stderr, response.text<br /><br /># Print the JSON response<br />print json.dumps(response.json(), indent=4, separators=(',', ': '))</code></pre> <p>The JSON response you get back should look something like:</p> <pre><code>{<br />    \"status\": \"success\",<br />    \"@graph\": [<br />        {<br />            \"files\": [<br />                \"/files/ENCFF001IEM/\",<br />                \"/files/ENCFF001IEO/\",<br />                \"/files/ENCFF001IEU/\"<br />            ],<br />            \"system_slims\": [],<br />            \"possible_controls\": [],<br />            \"original_files\": [<br />                \"/files/ENCFF001IEM/\",<br />                \"/files/ENCFF001IEO/\",<br />                \"/files/ENCFF001IEU/\"<br />            ],<br />            \"accession\": \"ENCSR000AJT\",<br />            \"replicates\": [<br />                \"/replicates/d8b213ef-eb74-4f7f-9468-2a109b6000ec/\"<br />            ],<br />            \"references\": [],<br />            \"alternate_accessions\": [],<br />            \"aliases\": [],<br />            \"submitted_by\": \"/users/bc5b62f7-ce28-4a1e-b6b3-81c9c5a86d7a/\",<br />            \"dbxrefs\": [<br />                \"UCSC-ENCODE-mm9:wgEncodeEM002125\",<br />                \"GEO:GSM915184\",<br />                \"GEO:GSM915181\"<br />            ],<br />            \"uuid\": \"7d8483a4-3948-4432-951f-7174f11a5273\",<br />            \"biosample_type\": \"in vitro differentiated cells\",<br />            \"schema_version\": \"3\",<br />            \"developmental_slims\": [],<br />            \"status\": \"CURRENT\",<br />            \"description\": \"ChIP-Seq mouse C2C12 Control\",<br />            \"assay_term_name\": \"ChIP-seq\",<br />            \"lab\": \"/labs/barbara-wold/\",<br />            \"documents\": [],<br />            \"award\": \"/awards/RC2HG005573/\",<br />            \"@id\": \"/experiments/ENCSR000AJT/\",<br />            \"related_files\": [],<br />            \"target\": \"/targets/Control-mouse/\",<br />            \"assay_term_id\": \"OBI:0000716\",<br />            \"biosample_term_id\": \"NTR:0000710\",<br />            \"organ_slims\": [],<br />            \"biosample_term_name\": \"myocyte\",<br />            \"dataset_type\": \"experiment\",<br />            \"date_created\": \"2013-11-15T06:00:31.198640+00:00\",<br />            \"@type\": [<br />                \"experiment\",<br />                \"dataset\",<br />                \"item\"<br />            ]<br />        }<br />    ],<br />    \"@type\": [<br />        \"result\"<br />    ]<br />}</code></pre> <p>Note that the response is still JSON, and can still be cast into a native Python dict. The PATCHed version of the object is embedded within the @graph array. The status property of the return shows that the PATCH was successful (it would take a value of &ldquo;fail&rdquo; if not).</p> <p>In addition to printing the JSON response, this example also shows how to catch the HTTP status code using:</p><pre><code>response.status_code</code></pre> <p>The HTTP status code is not particularly informative. The JSON response usually is. Typically you would test if the status_code is different from 200, the HTTP code for &ldquo;OK,&rdquo; then dump out or otherwise process the response JSON. For example:</p> <pre><code>import sys<br />if not response.status_code == 200:<br />    print >> sys.stderr, response.text</code></pre> <h4>PATCH is surgical</h4> <p>In the example above, the JSON payload contains only one property. To avoid overwriting properties you don&rsquo;t really want to change, include in your PATCH only the properties you&rsquo;re concerned with for this PATCH.</p> <h4>Use care with PATCH and arrays (like aliases)</h4> <p>Because PATCH replaces the value of a property with a new value, PATCHing to an array can have unintended consequences if you&rsquo;re not very careful. PATCH is not &ldquo;append&rdquo;; it is &ldquo;replace.&rdquo; So you should read the contents of an array first, then add your elements to the array, and then PATCH back the entire new array. For example:</p> <pre><code>#!/usr/bin/env python2<br /># -*- coding: latin-1 -*-<br />'''PATCH an object array on an ENCODE server'''<br /><br />import sys, requests, json<br /><br /># Send and accept JSON format<br />HEADERS = {'content-type': 'application/json', 'accept': 'application/json'}<br /><br /># Authentication is always required to PATCH ENCODE objects<br />AUTHID = \"H7OL67B4\" #<- Replace this with your keypair<br />AUTHPW = \"lr5gz2fjowbaqox5\" #<- Replace this with your keypair<br /><br /># This URL locates the ENCODE experiment with accession number ENCSR000AJT<br />URL = \"https://test.encodedcc.org/experiments/ENCSR000AJT/\"<br /><br /># GET the object we'll be PATCH'ing<br /><br />response = requests.get(URL, auth=(AUTHID, AUTHPW), headers=HEADERS)<br />experiment = response.json()<br /><br /># Extract the aliases array from the JSON object<br />alias_array = experiment['aliases']<br /><br /># Append our new alias to the array<br />alias_array.append('test:some_unique_string') #<- This must be a unique string.<br /><br /># Construct the JSON payload<br />payload_dict = {<br />    \"aliases\": alias_array<br />}<br />json_payload = json.dumps(payload_dict)<br /><br /># Do the PATCH and parse the response<br />response = requests.patch(URL, auth=(AUTHID, AUTHPW), headers=HEADERS, data=json_payload)<br /><br /># Process the response<br />if not response.status_code == 200:<br />    print >> sys.stderr, response.text<br /><br /># Print the JSON response<br />print json.dumps(response.json(), indent=4, separators=(',', ': '))</code></pre> <p>You may find that running the exact code above generates an error. It certainly will if you run it twice. Aliases must be unique, so once the &ldquo;test:some_unique_string&rdquo; alias is added, it can&rsquo;t be added again. It&rsquo;s easy to remove, though. Just replace the alias_array.append with alias_array.remove:</p> <pre><code>alias_array.remove('test:some_unique_string')</code></pre> <p>This also demonstrates how useful it is to cast ENCODE objects as native Python data structures.</p> <h3>POST</h3> <p>The HTTP POST method is used to create a new object on an ENCODE server. The best way to do this is to construct a native data structure in your script (such as a Python dict) and then to serialize that data structure as a JSON string. That JSON string then forms the payload for your HTTP POST. As with PATCH, you need to supply an authorization keypair. You also have to have submits_for privileges for the lab you intend to associate your object with.</p> <p>Here is a simple example to POST an experiment object to the ENCODE test server:</p> <pre><code>#!/usr/bin/env python2<br /># -*- coding: latin-1 -*-<br />'''POST an object to an ENCODE server'''<br /><br />import sys, requests, json<br /><br /># Send and accept JSON format<br />HEADERS = {'content-type': 'application/json', 'accept': 'application/json'}<br /><br /># Authentication is always required to PATCH ENCODE objects<br />AUTHID = \"H7OL67B4\" #<- Replace this with your keypair<br />AUTHPW = \"lr5gz2fjowbaqox5\" #<- Replace this with your keypair<br /><br /># The URL is now the collection itself<br />URL = \"http://test.encodedcc.org/experiments/\"<br /><br /># Build a Python dict with the experiment metadata<br />new_experiment = {<br />    \"description\": \"POST example experiment\",<br />    \"assay_term_name\": \"ChIP-seq\",<br />    \"biosample_term_name\": \"Stromal cell of bone marrow\",<br />    \"target\": \"/targets/SMAD6-human/\",<br />    \"award\": \"/awards/U41HG006992/\",<br />    \"lab\": \"/labs/j-michael-cherry/\", #<- Replace this with a lab for which you have submits_for privileges<br />    \"references\": [<br />        \"PMID:12345\",<br />        \"PMID:67890\"<br />    ]<br />}<br /><br /># Serialize the data structure as JSON<br />json_payload = json.dumps(new_experiment)<br /><br /># POST the JSON and print the response<br />response = requests.post(URL, auth=(AUTHID, AUTHPW), headers=HEADERS, data=json_payload)<br /><br /># If the POST succeeds, the response is the new object in JSON format<br />print json.dumps(response.json(), indent=4, separators=(',', ': '))</code></pre> <p>Note that in this example, the URL we POST to is the &ldquo;experiments&rdquo; collection itself. The response JSON indicates the success of the POST and also gives us the JSON of the newly created object. You can see that the server has filled in some additional properties, such as the date_created and the submitted_by user id (a &ldquo;test user&rdquo; in the case of this code). The accession number of the object has also been assigned and stored in the accession property. On the test server, the accession numbers are in the form &ldquo;TSTSRxxxxxx.&rdquo; These test accession numbers do not persist through test server reinitializations, but actual accession numbers assigned on the production server are permanent and immutable.</p> <p>The HTTP response code for successful post is 201.</p> <p>Here is the response JSON from the POST example above:</p> <pre><code>{<br />    \"status\": \"success\",<br />    \"@graph\": [<br />        {<br />            \"files\": [],<br />            \"system_slims\": [],<br />            \"possible_controls\": [],<br />            \"original_files\": [],<br />            \"accession\": \"TSTSR172453\",<br />            \"replicates\": [],<br />            \"references\": [<br />                \"PMID:12345\",<br />                \"PMID:67890\"<br />            ],<br />            \"alternate_accessions\": [],<br />            \"aliases\": [],<br />            \"submitted_by\": \"/users/07a850bc-9fdd-45fa-920e-b3b70be08ea3/\",<br />            \"dbxrefs\": [],<br />            \"uuid\": \"815fbd18-c62c-4c3d-955b-776b07f1e8ad\",<br />            \"schema_version\": \"3\",<br />            \"developmental_slims\": [],<br />            \"status\": \"CURRENT\",<br />            \"description\": \"POST example experiment\",<br />            \"assay_term_name\": \"ChIP-seq\",<br />            \"lab\": \"/labs/j-michael-cherry/\",<br />            \"documents\": [],<br />            \"award\": \"/awards/U41HG006992/\",<br />            \"@id\": \"/experiments/TSTSR172453/\",<br />            \"related_files\": [],<br />            \"target\": \"/targets/SMAD6-human/\",<br />            \"organ_slims\": [],<br />            \"biosample_term_name\": \"Stromal cell of bone marrow\",<br />            \"dataset_type\": \"experiment\",<br />            \"date_created\": \"2014-04-10T00:32:36.011666+00:00\",<br />            \"@type\": [<br />                \"experiment\",<br />                \"dataset\",<br />                \"item\"<br />            ]<br />        }<br />    ],<br />    \"@type\": [<br />        \"result\"<br />    ]<br />}</code></pre> <p>One of the first things to do after a POST is to parse the response object for the ENCODE accession number assigned. You should store that accession because it is the unique ENCODE-sanctioned handle to the resource you have created.</p> <p>For example:</p> <pre><code># Check the status code and if good, extract the accession number of the new object<br />if not response.status_code == 201:<br />    print >> sys.stderr, response.text<br />else:<br />    response_dict = response.json()<br />    posted_experiment = response_dict['@graph'][0]<br />    new_experiment_accession = posted_experiment['accession']<br />    print \"New ENCODE accession number: %s\" %(new_experiment_accession)</code></pre> <p>The response object contains the experiment record we created as an element in the list called @graph. For a POST this list will only have one element, so we are safe to simply pull the first element and save that as our new experiment object. Once that&rsquo;s done, all the experiment metadata, like the accession number, can be accessed from a data structure native to our script.</p> <h3>Programmatic Search</h3> <p>In the GET example above, we use the ENCODE REST API to retrieve an individual object using its ENCODE accession number. You can also search for objects programmatically and get the search result back in JSON format. The ENCODE web app is a good place to start to see an example. Enter the string &ldquo;bone chip&rdquo; in the search box at the top right of the page at <a class=\"url\" href=\"https://www.encodedcc.org/\">https://www.encodedcc.org/</a>. The result are those ENCODE objects that match that string (ChIP experiments having something to do with bone, in this case).</p> <figure class=\"fig fig-align-center\"> <img src=\"/images/6e4bca66-a415-4823-9d48-d9a18b81b775/@@download/attachment/search-result-bone-chip.png\"><figcaption><span>Figure 4</span>: Search result example</figcaption></figure> <h4>Search URL format</h4> <p>The same URL that returns the search results to the web app can be used in a script. This script does the same search and returns the results in JSON format:</p> <pre><code>#!/usr/bin/env python2<br /># -*- coding: latin-1 -*-<br />'''GET the results of a search from an ENCODE server'''<br /><br />import requests, json<br /><br /># Force return from the server in JSON format<br />HEADERS = {'accept': 'application/json'}<br /><br /># This searches the ENCODE database for the phrase \"bone chip\"<br />URL = \"https://www.encodedcc.org/search/?searchTerm=bone+chip\"<br /><br /># GET the search result<br />response = requests.get(URL, headers=HEADERS)<br /><br /># Extract the JSON response as a python dict<br />response_json_dict = response.json()<br /><br /># Print the object<br />print json.dumps(response_json_dict, indent=4, separators=(',', ': '))</code></pre> <p>The output of the script should start with something like this:</p> <pre><code>{<br />    \"title\": \"Search\",<br />    \"notification\": \"Success\",<br />    \"@graph\": [<br />        {<br />            \"status\": \"CURRENT\",<br />            \"lab.title\": \"Bing Ren, UCSD\",<br />            \"description\": \"CTCF ChIP-seq on 8-week mouse bone marrow\",<br />            \"assay_term_name\": \"ChIP-seq\",<br />            \"accession\": \"ENCSR000CBL\",<br />            \"biosample_term_name\": \"bone marrow\",<br />            \"biosample_type\": \"tissue\",<br />            \"dataset_type\": \"experiment\",<br />            \"target.organism.name\": \"mouse\",<br />            \"target.label\": \"CTCF\",<br />            \"award.project\": \"ENCODE\",<br />            \"@id\": \"/experiments/ENCSR000CBL/\",<br />            \"@type\": [<br />                \"experiment\",<br />                \"dataset\",<br />                \"item\"<br />            ]<br />        },<br />        {<br />            \"status\": \"CURRENT\",<br />            \"lab.title\": \"Bing Ren, UCSD\",<br />            \"description\": \"POLR2A ChIP-seq on 8-week mouse bone marrow\",<br />            \"assay_term_name\": \"ChIP-seq\",<br />            \"accession\": \"ENCSR000CBM\",<br />            \"biosample_term_name\": \"bone marrow\",<br />            \"biosample_type\": \"tissue\",<br />            \"dataset_type\": \"experiment\",<br />            \"target.organism.name\": \"mouse\",<br />            \"target.label\": \"POLR2A\",<br />            \"award.project\": \"ENCODE\",<br />            \"@id\": \"/experiments/ENCSR000CBM/\",<br />            \"@type\": [<br />                \"experiment\",<br />                \"dataset\",<br />                \"item\"<br />            ]<br />        },<br />...</code></pre> <p>Whereas before, when we retrieved a single object, the @graph property was a list with only one element. Now @graph is a multi-element list, with each object that satisfies the search condition represented as one entry.</p> <p>Notice that the experiment objects returned contain only a subset of the properties. These are the properties that the server returns to the web app to render the search results page. To get the full objects back, add <code>&frame=object</code> to the query. The query looks like:</p> <pre><code># This searches the ENCODE database for the phrase \"bone chip\"<br />URL = \"https://www.encodedcc.org/search/?searchTerm=bone+chip&frame=object\"</code></pre> <p>This returns the full objects, with all their properties and values.</p> <pre><code>{<br />    \"title\": \"Search\",<br />    \"notification\": \"Success\",<br />    \"@graph\": [<br />        {<br />            \"files\": [<br />                \"/files/ENCFF001LFR/\",<br />                \"/files/ENCFF001LFT/\",<br />                \"/files/ENCFF001LFU/\",<br />                \"/files/ENCFF001LFX/\",<br />                \"/files/ENCFF001LGH/\",<br />                \"/files/ENCFF001LGI/\",<br />                \"/files/ENCFF001XZU/\"<br />            ],<br />            \"system_slims\": [<br />                \"skeletal system\",<br />                \"immune system\"<br />            ],<br />            \"possible_controls\": [<br />                \"/experiments/ENCSR000CAS/\"<br />            ],<br />            \"original_files\": [<br />                \"/files/ENCFF001LFR/\",<br />                \"/files/ENCFF001LFT/\",<br />                \"/files/ENCFF001LFU/\",<br />                \"/files/ENCFF001LFX/\",<br />                \"/files/ENCFF001LGH/\",<br />                \"/files/ENCFF001LGI/\",<br />                \"/files/ENCFF001XZU/\"<br />            ],<br />            \"accession\": \"ENCSR000CBL\",<br />            \"replicates\": [<br />                \"/replicates/7c570f54-519d-46b6-a418-5cff7291f920/\",<br />                \"/replicates/bd65bc6e-50e6-4a40-90e8-79b312274267/\"<br />            ],<br />            \"references\": [],<br />            \"alternate_accessions\": [],<br />            \"aliases\": [],<br />            \"submitted_by\": \"/users/4f6e1132-f893-4011-8197-848187303a10/\",<br />            \"documents\": [],<br />            \"uuid\": \"522579b3-86a3-4f04-90d8-efa87ee9f84a\",<br />            \"biosample_type\": \"tissue\",<br />...</code></pre> <p>Embedded objects can be fully expanded in the search results with <code>&frame=embedded</code> so that the query would look like:</p> <pre><code># This searches the ENCODE database for the phrase \"bone chip\"<br />URL = \"https://www.encodedcc.org/search/?searchTerm=bone+chip&frame=embedded\"</code></pre> <p>The output should start with something like:</p> <pre><code>{<br />    \"title\": \"Search\",<br />    \"notification\": \"Success\",<br />    \"@graph\": [<br />        {<br />            \"files\": [<br />                {<br />                    \"status\": \"CURRENT\",<br />                    \"submitted_file_name\": \"mm9/wgEncodeLicrTfbs/wgEncodeLicrTfbsBmarrowCtcfMAdult8wksC57bl6StdAlnRep1.bam\",<br />                    \"assembly\": \"mm9\",<br />                    \"submitted_by\": {<br />                        \"title\": \"Lee Edsall\",<br />                        \"@id\": \"/users/4f6e1132-f893-4011-8197-848187303a10/\",<br />                        \"uuid\": \"4f6e1132-f893-4011-8197-848187303a10\",<br />                        \"lab\": \"/labs/bing-ren/\",<br />                        \"@type\": [<br />                            \"user\",<br />                            \"item\"<br />                        ]<br />                    },<br />                    \"file_format\": \"bam\",<br />                    \"md5sum\": \"19a4854564b4635c461d2cc16ca10647\",<br />                    \"accession\": \"ENCFF001LFR\",<br />                    \"schema_version\": \"1\",<br />                    \"dataset\": \"/experiments/ENCSR000CBL/\",<br />                    \"download_path\": \"2013/4/18/ENCFF001LFR.bam\",<br />                    \"replicate\": {<br />                        \"status\": \"CURRENT\",<br />                        \"submitted_by\": \"/users/4f6e1132-f893-4011-8197-848187303a10/\",<br />                        \"biological_replicate_number\": 1,<br />                        \"uuid\": \"7c570f54-519d-46b6-a418-5cff7291f920\",<br />                        \"antibody\": \"/antibody-lots/ENCAB210NHK/\",<br />                        \"flowcell_details\": [],<br />                        \"technical_replicate_number\": 1,<br />...</code></pre> <h4>Additional search examples</h4> <ol><li>Every object that matches the string &ldquo;CTCF&rdquo;:<br /><a class=\"url\" href=\"https://www.encodedcc.org/search/?searchTerm=CTCF&format=json&frame=object\">https://www.encodedcc.org/search/?searchTerm=CTCF&format=json&frame=object</a></li><li>A file with a particular MD5 7b9f8ccd15fea0bda867e042db2b6f5a:<br /><a class=\"url\" href=\"https://www.encodedcc.org/search/?type=file&md5sum=7b9f8ccd15fea0bda867e042db2b6f5a&format=json\">https://www.encodedcc.org/search/?type=file&md5sum=7b9f8ccd15fea0bda867e042db2b6f5a&format=json</a></li> <li>All the file objects from a particular experiment ENCSR000AKS (with links to embedded objects):<br /><a class=\"url\" href=\"https://www.encodedcc.org/search/?type=file&dataset=/experiments/ENCSR000AKS/&format=json&frame=object&limit=all\">https://www.encodedcc.org/search/?type=file&dataset=/experiments/ENCSR000AKS/&format=json&frame=object&limit=all</a></li> <li>All the fastq files from a particular experiment ENCSR000AKS:<br /><a class=\"url\" href=\"https://www.encodedcc.org/search/?type=file&dataset=/experiments/ENCSR000AKS/&file_format=fastq&format=json&frame=object&limit=all\">https://www.encodedcc.org/search/?type=file&dataset=/experiments/ENCSR000AKS/&file_format=fastq&format=json&frame=object&limit=all</a></li> <li>All the replicates for a particular experiment ENCSR000AKS:<br /><a class=\"url\" href=\"https://www.encodedcc.org/search/?type=replicate&experiment=/experiments/ENCSR000AKS/&format=json&limit=all\">https://www.encodedcc.org/search/?type=replicate&experiment=/experiments/ENCSR000AKS/&format=json&limit=all</a></li> <li>The same query as above but with embedded objects expanded:<br /><a class=\"url\" href=\"https://www.encodedcc.org/search/?type=replicate&experiment=/experiments/ENCSR000AKS/&format=json&frame=embedded&limit=all\">https://www.encodedcc.org/search/?type=replicate&experiment=/experiments/ENCSR000AKS/&format=json&frame=embedded&limit=all</a></li> <li>All the experiments from the Bernstein lab against H3K9ac during the previous phase of the project (with embedded objects expanded):<br /><a class=\"url\" href=\"https://www.encodedcc.org/search/?type=experiment&lab.title=Bradley%20Bernstein,%20Broad&award.rfa=ENCODE2&target.label=H3K9ac&format=json&frame=embedded&limit=all\">https://www.encodedcc.org/search/?type=experiment&lab.title=Bradley%20Bernstein,%20Broad&award.rfa=ENCODE2&target.label=H3K9ac&format=json&frame=embedded&limit=all</a></li> <li>All biosamples (abbreviated metadata):<br /><a class=\"url\" href=\"https://www.encodedcc.org/search/?type=biosample&limit=all\">https://www.encodedcc.org/search/?type=biosample&limit=all</a></li> <li>All experiments (full metadata with object references):<br /><a class=\"url\" href=\"https://www.encodedcc.org/search/?type=biosample&frame=object&limit=all\">https://www.encodedcc.org/search/?type=biosample&frame=object&limit=all</a></li></ol> <h4>Summary of search features</h4> <ul><li>If you do not specify <code>frame=something</code>, you will get a subset of object properties as defined by the webapp. If what you need is in that subset (like accession, maybe), it&rsquo;s a relatively fast way of getting back a long list of objects.</li> <li>If you specify <code>frame=embedded</code> you will get all the object properties, with selected embedded objects expanded.</li> <li>If you specify <code>frame=object</code> you will get all the object properties, with embedded objects.</li> <li><code>frame=object</code> will always give you all of the properties, with embedded objects referred to by an identifier. So it&rsquo;s consistent, and it&rsquo;s faster. Which embedded objects are expanded by <code>frame=embedded</code> may change in the future as our requirements for search change. Also the depth of expansion is chosen to support search, and might change, as well. So for the most robust code you might choose to use <code>frame=object</code> and then GET only the embedded objects you need.</li> <li>You do not need to specify <code>frame=embedded</code> in order to search within embedded objects. The example above which searches inside the embedded award object works fine with <code>frame=object</code>, even though one of the search terms (&ldquo;award.rfa&rdquo;) searches within an embedded object.</li> <li>All of the results from search can be visualized within the web app by opening the URL in your browser, omitting <code>format=json</code>. Not all objects have fancy rendered collections or pages, but you will always get back a clickable list.</li> <li><code>limit=all</code> is not strictly necessary but without it your result will contain only the first 25 hits (or all if < 25 hits). We plan to implement a mechanism to return very large searches in batches, but for now <code>limit=all</code> can generate large result sets.</li> <li>Giving <code>searchTerm=somestring</code> will often return multiple object types. You can look into the @type property of each returned object for its data type.</li></ul> <h2>Submission Best Practices</h2> <p>This section is under construction.</p> <h2>Reference: The ENCODE Metadata Model</h2> <figure class=\"fig fig-align-center\"> <img src=\"/images/498ce836-3050-47b6-b4cf-b0ac911a7d38/@@download/attachment/encode-library-object-structure.jpg\"><figcaption><span>Figure 5</span>: ENCODE library object structure</figcaption></figure>",
                    "@id": "#block2",
                    "@type": [
                        "richtextblock",
                        "block"
                    ]
                }
            ]
        }
    }
]