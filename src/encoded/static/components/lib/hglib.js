(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"), require("pixi.js"), require("react-bootstrap"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom", "pixi.js", "react-bootstrap"], factory);
	else if(typeof exports === 'object')
		exports["hglib"] = factory(require("react"), require("react-dom"), require("pixi.js"), require("react-bootstrap"));
	else
		root["hglib"] = factory(root["React"], root["ReactDOM"], root["PIXI"], root["ReactBootstrap"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__, __WEBPACK_EXTERNAL_MODULE_59__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 251);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactCSS = exports.loop = exports.handleActive = exports.handleHover = exports.hover = undefined;

var _flattenNames = __webpack_require__(539);

var _flattenNames2 = _interopRequireDefault(_flattenNames);

var _mergeClasses = __webpack_require__(542);

var _mergeClasses2 = _interopRequireDefault(_mergeClasses);

var _autoprefix = __webpack_require__(566);

var _autoprefix2 = _interopRequireDefault(_autoprefix);

var _hover2 = __webpack_require__(567);

var _hover3 = _interopRequireDefault(_hover2);

var _active = __webpack_require__(568);

var _active2 = _interopRequireDefault(_active);

var _loop2 = __webpack_require__(569);

var _loop3 = _interopRequireDefault(_loop2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.hover = _hover3.default;
exports.handleHover = _hover3.default;
exports.handleActive = _active2.default;
exports.loop = _loop3.default;
var ReactCSS = exports.ReactCSS = function ReactCSS(classes) {
  for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    activations[_key - 1] = arguments[_key];
  }

  var activeNames = (0, _flattenNames2.default)(activations);
  var merged = (0, _mergeClasses2.default)(classes, activeNames);
  return (0, _autoprefix2.default)(merged);
};

exports.default = ReactCSS;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(253)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(256)();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _absToChr = __webpack_require__(515);

Object.defineProperty(exports, 'absToChr', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_absToChr)['default'];
    }

    return get;
  }()
});

var _chromInfoBisector = __webpack_require__(516);

Object.defineProperty(exports, 'chromInfoBisector', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_chromInfoBisector)['default'];
    }

    return get;
  }()
});

var _chrToAbs = __webpack_require__(517);

Object.defineProperty(exports, 'chrToAbs', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_chrToAbs)['default'];
    }

    return get;
  }()
});

var _colorDomainToRgbaArray = __webpack_require__(518);

Object.defineProperty(exports, 'colorDomainToRgbaArray', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_colorDomainToRgbaArray)['default'];
    }

    return get;
  }()
});

var _colorToHex = __webpack_require__(519);

Object.defineProperty(exports, 'colorToHex', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_colorToHex)['default'];
    }

    return get;
  }()
});

var _debounce = __webpack_require__(520);

Object.defineProperty(exports, 'debounce', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_debounce)['default'];
    }

    return get;
  }()
});

var _dictFromTuples = __webpack_require__(521);

Object.defineProperty(exports, 'dictFromTuples', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_dictFromTuples)['default'];
    }

    return get;
  }()
});

var _dictItems = __webpack_require__(522);

Object.defineProperty(exports, 'dictItems', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_dictItems)['default'];
    }

    return get;
  }()
});

var _dictKeys = __webpack_require__(523);

Object.defineProperty(exports, 'dictKeys', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_dictKeys)['default'];
    }

    return get;
  }()
});

var _dictValues = __webpack_require__(524);

Object.defineProperty(exports, 'dictValues', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_dictValues)['default'];
    }

    return get;
  }()
});

var _download = __webpack_require__(525);

Object.defineProperty(exports, 'download', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_download)['default'];
    }

    return get;
  }()
});

var _genomeLociToPixels = __webpack_require__(526);

Object.defineProperty(exports, 'genomeLociToPixels', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_genomeLociToPixels)['default'];
    }

    return get;
  }()
});

var _getTrackByUid = __webpack_require__(527);

Object.defineProperty(exports, 'getTrackByUid', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_getTrackByUid)['default'];
    }

    return get;
  }()
});

var _getTrackPositionByUid = __webpack_require__(528);

Object.defineProperty(exports, 'getTrackPositionByUid', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_getTrackPositionByUid)['default'];
    }

    return get;
  }()
});

var _loadChromInfos = __webpack_require__(529);

Object.defineProperty(exports, 'loadChromInfos', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_loadChromInfos)['default'];
    }

    return get;
  }()
});

var _map = __webpack_require__(624);

Object.defineProperty(exports, 'map', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_map)['default'];
    }

    return get;
  }()
});

var _objVals = __webpack_require__(625);

Object.defineProperty(exports, 'objVals', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_objVals)['default'];
    }

    return get;
  }()
});

var _or = __webpack_require__(626);

Object.defineProperty(exports, 'or', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_or)['default'];
    }

    return get;
  }()
});

var _pixelToGenomeLoci = __webpack_require__(238);

Object.defineProperty(exports, 'pixelToGenomeLoci', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_pixelToGenomeLoci)['default'];
    }

    return get;
  }()
});

var _pixiTextToSvg = __webpack_require__(627);

Object.defineProperty(exports, 'pixiTextToSvg', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_pixiTextToSvg)['default'];
    }

    return get;
  }()
});

var _positionedTracksToAllTracks = __webpack_require__(222);

Object.defineProperty(exports, 'positionedTracksToAllTracks', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_positionedTracksToAllTracks)['default'];
    }

    return get;
  }()
});

var _relToAbsChromPos = __webpack_require__(628);

Object.defineProperty(exports, 'relToAbsChromPos', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_relToAbsChromPos)['default'];
    }

    return get;
  }()
});

var _scalesCenterAndK = __webpack_require__(629);

Object.defineProperty(exports, 'scalesCenterAndK', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_scalesCenterAndK)['default'];
    }

    return get;
  }()
});

var _scalesToGenomeLoci = __webpack_require__(630);

Object.defineProperty(exports, 'scalesToGenomeLoci', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_scalesToGenomeLoci)['default'];
    }

    return get;
  }()
});

var _sum = __webpack_require__(631);

Object.defineProperty(exports, 'sum', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_sum)['default'];
    }

    return get;
  }()
});

var _svgLine = __webpack_require__(632);

Object.defineProperty(exports, 'svgLine', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_svgLine)['default'];
    }

    return get;
  }()
});

var _totalTrackPixelHeight = __webpack_require__(633);

Object.defineProperty(exports, 'totalTrackPixelHeight', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_totalTrackPixelHeight)['default'];
    }

    return get;
  }()
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_create__ = __webpack_require__(257);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return __WEBPACK_IMPORTED_MODULE_0__src_create__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_creator__ = __webpack_require__(64);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return __WEBPACK_IMPORTED_MODULE_1__src_creator__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_local__ = __webpack_require__(286);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "local", function() { return __WEBPACK_IMPORTED_MODULE_2__src_local__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_matcher__ = __webpack_require__(149);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return __WEBPACK_IMPORTED_MODULE_3__src_matcher__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_mouse__ = __webpack_require__(287);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "mouse", function() { return __WEBPACK_IMPORTED_MODULE_4__src_mouse__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_namespace__ = __webpack_require__(90);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return __WEBPACK_IMPORTED_MODULE_5__src_namespace__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_namespaces__ = __webpack_require__(91);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return __WEBPACK_IMPORTED_MODULE_6__src_namespaces__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_point__ = __webpack_require__(65);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "clientPoint", function() { return __WEBPACK_IMPORTED_MODULE_7__src_point__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_select__ = __webpack_require__(147);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "select", function() { return __WEBPACK_IMPORTED_MODULE_8__src_select__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_selectAll__ = __webpack_require__(288);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return __WEBPACK_IMPORTED_MODULE_9__src_selectAll__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_selection_index__ = __webpack_require__(16);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return __WEBPACK_IMPORTED_MODULE_10__src_selection_index__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_selector__ = __webpack_require__(92);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return __WEBPACK_IMPORTED_MODULE_11__src_selector__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_selectorAll__ = __webpack_require__(148);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return __WEBPACK_IMPORTED_MODULE_12__src_selectorAll__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_selection_style__ = __webpack_require__(152);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "style", function() { return __WEBPACK_IMPORTED_MODULE_13__src_selection_style__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_touch__ = __webpack_require__(289);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "touch", function() { return __WEBPACK_IMPORTED_MODULE_14__src_touch__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_touches__ = __webpack_require__(290);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "touches", function() { return __WEBPACK_IMPORTED_MODULE_15__src_touches__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_window__ = __webpack_require__(93);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return __WEBPACK_IMPORTED_MODULE_16__src_window__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__src_selection_on__ = __webpack_require__(94);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "event", function() { return __WEBPACK_IMPORTED_MODULE_17__src_selection_on__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return __WEBPACK_IMPORTED_MODULE_17__src_selection_on__["a"]; });




















/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Alpha = __webpack_require__(571);

Object.defineProperty(exports, 'Alpha', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Alpha).default;
  }
});

var _Checkboard = __webpack_require__(232);

Object.defineProperty(exports, 'Checkboard', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Checkboard).default;
  }
});

var _EditableInput = __webpack_require__(574);

Object.defineProperty(exports, 'EditableInput', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_EditableInput).default;
  }
});

var _Hue = __webpack_require__(575);

Object.defineProperty(exports, 'Hue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Hue).default;
  }
});

var _Raised = __webpack_require__(577);

Object.defineProperty(exports, 'Raised', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Raised).default;
  }
});

var _Saturation = __webpack_require__(578);

Object.defineProperty(exports, 'Saturation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Saturation).default;
  }
});

var _ColorWrap = __webpack_require__(234);

Object.defineProperty(exports, 'ColorWrap', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ColorWrap).default;
  }
});

var _Swatch = __webpack_require__(585);

Object.defineProperty(exports, 'Swatch', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Swatch).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _availableTrackTypes = __webpack_require__(533);

Object.defineProperty(exports, 'AVAILABLE_TRACK_TYPES', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_availableTrackTypes)['default'];
    }

    return get;
  }()
});

var _datatypeToTrackType = __webpack_require__(534);

Object.defineProperty(exports, 'DATATYPE_TO_TRACK_TYPE', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_datatypeToTrackType)['default'];
    }

    return get;
  }()
});

var _colormaps = __webpack_require__(535);

Object.defineProperty(exports, 'HEATED_OBJECT_MAP', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_colormaps)['default'];
    }

    return get;
  }()
});

var _isTrackRangeSelectable = __webpack_require__(536);

Object.defineProperty(exports, 'IS_TRACK_RANGE_SELECTABLE', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_isTrackRangeSelectable)['default'];
    }

    return get;
  }()
});

var _optionsInfo = __webpack_require__(537);

Object.defineProperty(exports, 'OPTIONS_INFO', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_optionsInfo)['default'];
    }

    return get;
  }()
});

var _tracksInfo = __webpack_require__(621);

Object.defineProperty(exports, 'TRACKS_INFO', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_tracksInfo)['default'];
    }

    return get;
  }()
});

var _tracksInfoByType = __webpack_require__(622);

Object.defineProperty(exports, 'TRACKS_INFO_BY_TYPE', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_tracksInfoByType)['default'];
    }

    return get;
  }()
});

var _usedServer = __webpack_require__(623);

Object.defineProperty(exports, 'USED_SERVER', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_usedServer)['default'];
    }

    return get;
  }()
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/* ------------------------------- Primitives ------------------------------- */

var MOUSE_TOOL_MOVE = exports.MOUSE_TOOL_MOVE = 'move';

var MOUSE_TOOL_SELECT = exports.MOUSE_TOOL_SELECT = 'select';

var TILE_FETCH_DEBOUNCE = exports.TILE_FETCH_DEBOUNCE = 100;

// Number of milliseconds zoom-related actions (e.g., tile loading) are debounced
var ZOOM_DEBOUNCE = exports.ZOOM_DEBOUNCE = 100;

// the length of time to keep refreshing the view after a drag event
var SHORT_DRAG_TIMEOUT = exports.SHORT_DRAG_TIMEOUT = 110;

var LONG_DRAG_TIMEOUT = exports.LONG_DRAG_TIMEOUT = 3000;

var LOCATION_LISTENER_PREFIX = exports.LOCATION_LISTENER_PREFIX = 'locationListenerPrefix';

var ZOOM_TRANSITION_DURATION = exports.ZOOM_TRANSITION_DURATION = 1000;

var DEFAULT_SERVER = exports.DEFAULT_SERVER = 'https://higlass.io/api/v1';

var VIEW_HEADER_MED_WIDTH_SEARCH_BAR = exports.VIEW_HEADER_MED_WIDTH_SEARCH_BAR = 400;

var VIEW_HEADER_MIN_WIDTH_SEARCH_BAR = exports.VIEW_HEADER_MIN_WIDTH_SEARCH_BAR = 300;

/* --------------------------------- Complex -------------------------------- */

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _chromInfo = __webpack_require__(530);

Object.defineProperty(exports, 'chromInfo', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_chromInfo)['default'];
    }

    return get;
  }()
});

var _domEvent = __webpack_require__(531);

Object.defineProperty(exports, 'domEvent', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_domEvent)['default'];
    }

    return get;
  }()
});

var _pubSub = __webpack_require__(40);

Object.defineProperty(exports, 'pubSub', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_pubSub)['default'];
    }

    return get;
  }()
});

var _tileProxy = __webpack_require__(532);

Object.defineProperty(exports, 'tileProxy', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_tileProxy)['default'];
    }

    return get;
  }()
});
Object.defineProperty(exports, 'requestsInFlight', {
  enumerable: true,
  get: function () {
    function get() {
      return _tileProxy.requestsInFlight;
    }

    return get;
  }()
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_bisect__ = __webpack_require__(153);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "bisect", function() { return __WEBPACK_IMPORTED_MODULE_0__src_bisect__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "bisectRight", function() { return __WEBPACK_IMPORTED_MODULE_0__src_bisect__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return __WEBPACK_IMPORTED_MODULE_0__src_bisect__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_ascending__ = __webpack_require__(45);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ascending", function() { return __WEBPACK_IMPORTED_MODULE_1__src_ascending__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_bisector__ = __webpack_require__(154);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "bisector", function() { return __WEBPACK_IMPORTED_MODULE_2__src_bisector__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_cross__ = __webpack_require__(292);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return __WEBPACK_IMPORTED_MODULE_3__src_cross__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_descending__ = __webpack_require__(293);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "descending", function() { return __WEBPACK_IMPORTED_MODULE_4__src_descending__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_deviation__ = __webpack_require__(156);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "deviation", function() { return __WEBPACK_IMPORTED_MODULE_5__src_deviation__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_extent__ = __webpack_require__(158);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "extent", function() { return __WEBPACK_IMPORTED_MODULE_6__src_extent__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_histogram__ = __webpack_require__(294);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return __WEBPACK_IMPORTED_MODULE_7__src_histogram__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_threshold_freedmanDiaconis__ = __webpack_require__(297);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "thresholdFreedmanDiaconis", function() { return __WEBPACK_IMPORTED_MODULE_8__src_threshold_freedmanDiaconis__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_threshold_scott__ = __webpack_require__(298);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "thresholdScott", function() { return __WEBPACK_IMPORTED_MODULE_9__src_threshold_scott__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_threshold_sturges__ = __webpack_require__(162);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "thresholdSturges", function() { return __WEBPACK_IMPORTED_MODULE_10__src_threshold_sturges__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_max__ = __webpack_require__(299);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return __WEBPACK_IMPORTED_MODULE_11__src_max__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_mean__ = __webpack_require__(300);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return __WEBPACK_IMPORTED_MODULE_12__src_mean__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_median__ = __webpack_require__(301);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "median", function() { return __WEBPACK_IMPORTED_MODULE_13__src_median__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_merge__ = __webpack_require__(302);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return __WEBPACK_IMPORTED_MODULE_14__src_merge__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_min__ = __webpack_require__(163);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return __WEBPACK_IMPORTED_MODULE_15__src_min__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_pairs__ = __webpack_require__(155);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return __WEBPACK_IMPORTED_MODULE_16__src_pairs__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__src_permute__ = __webpack_require__(303);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "permute", function() { return __WEBPACK_IMPORTED_MODULE_17__src_permute__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__src_quantile__ = __webpack_require__(96);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "quantile", function() { return __WEBPACK_IMPORTED_MODULE_18__src_quantile__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__src_range__ = __webpack_require__(160);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return __WEBPACK_IMPORTED_MODULE_19__src_range__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__src_scan__ = __webpack_require__(304);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return __WEBPACK_IMPORTED_MODULE_20__src_scan__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__src_shuffle__ = __webpack_require__(305);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return __WEBPACK_IMPORTED_MODULE_21__src_shuffle__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__src_sum__ = __webpack_require__(306);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return __WEBPACK_IMPORTED_MODULE_22__src_sum__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__src_ticks__ = __webpack_require__(161);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ticks", function() { return __WEBPACK_IMPORTED_MODULE_23__src_ticks__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return __WEBPACK_IMPORTED_MODULE_23__src_ticks__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "tickStep", function() { return __WEBPACK_IMPORTED_MODULE_23__src_ticks__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__src_transpose__ = __webpack_require__(164);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return __WEBPACK_IMPORTED_MODULE_24__src_transpose__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__src_variance__ = __webpack_require__(157);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "variance", function() { return __WEBPACK_IMPORTED_MODULE_25__src_variance__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__src_zip__ = __webpack_require__(307);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return __WEBPACK_IMPORTED_MODULE_26__src_zip__["a"]; });





























/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// The MIT License (MIT)
//
// Copyright (c) 2014 Jonas Finnemann Jensen
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

module.exports = __webpack_require__(360);


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_band__ = __webpack_require__(291);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scaleBand", function() { return __WEBPACK_IMPORTED_MODULE_0__src_band__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scalePoint", function() { return __WEBPACK_IMPORTED_MODULE_0__src_band__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_identity__ = __webpack_require__(308);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return __WEBPACK_IMPORTED_MODULE_1__src_identity__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_linear__ = __webpack_require__(52);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scaleLinear", function() { return __WEBPACK_IMPORTED_MODULE_2__src_linear__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_log__ = __webpack_require__(331);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scaleLog", function() { return __WEBPACK_IMPORTED_MODULE_3__src_log__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_ordinal__ = __webpack_require__(165);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOrdinal", function() { return __WEBPACK_IMPORTED_MODULE_4__src_ordinal__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scaleImplicit", function() { return __WEBPACK_IMPORTED_MODULE_4__src_ordinal__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_pow__ = __webpack_require__(332);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scalePow", function() { return __WEBPACK_IMPORTED_MODULE_5__src_pow__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scaleSqrt", function() { return __WEBPACK_IMPORTED_MODULE_5__src_pow__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_quantile__ = __webpack_require__(333);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scaleQuantile", function() { return __WEBPACK_IMPORTED_MODULE_6__src_quantile__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_quantize__ = __webpack_require__(334);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scaleQuantize", function() { return __WEBPACK_IMPORTED_MODULE_7__src_quantize__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_threshold__ = __webpack_require__(335);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scaleThreshold", function() { return __WEBPACK_IMPORTED_MODULE_8__src_threshold__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_time__ = __webpack_require__(180);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scaleTime", function() { return __WEBPACK_IMPORTED_MODULE_9__src_time__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_utcTime__ = __webpack_require__(351);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scaleUtc", function() { return __WEBPACK_IMPORTED_MODULE_10__src_utcTime__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_category10__ = __webpack_require__(352);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "schemeCategory10", function() { return __WEBPACK_IMPORTED_MODULE_11__src_category10__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_category20b__ = __webpack_require__(353);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "schemeCategory20b", function() { return __WEBPACK_IMPORTED_MODULE_12__src_category20b__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_category20c__ = __webpack_require__(354);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "schemeCategory20c", function() { return __WEBPACK_IMPORTED_MODULE_13__src_category20c__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_category20__ = __webpack_require__(355);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "schemeCategory20", function() { return __WEBPACK_IMPORTED_MODULE_14__src_category20__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__ = __webpack_require__(356);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixDefault", function() { return __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_rainbow__ = __webpack_require__(357);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateRainbow", function() { return __WEBPACK_IMPORTED_MODULE_16__src_rainbow__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateWarm", function() { return __WEBPACK_IMPORTED_MODULE_16__src_rainbow__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateCool", function() { return __WEBPACK_IMPORTED_MODULE_16__src_rainbow__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__src_viridis__ = __webpack_require__(358);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateViridis", function() { return __WEBPACK_IMPORTED_MODULE_17__src_viridis__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateMagma", function() { return __WEBPACK_IMPORTED_MODULE_17__src_viridis__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateInferno", function() { return __WEBPACK_IMPORTED_MODULE_17__src_viridis__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolatePlasma", function() { return __WEBPACK_IMPORTED_MODULE_17__src_viridis__["d"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__src_sequential__ = __webpack_require__(359);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "scaleSequential", function() { return __WEBPACK_IMPORTED_MODULE_18__src_sequential__["a"]; });







































/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = newInterval;
var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_color__ = __webpack_require__(103);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "color", function() { return __WEBPACK_IMPORTED_MODULE_0__src_color__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return __WEBPACK_IMPORTED_MODULE_0__src_color__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return __WEBPACK_IMPORTED_MODULE_0__src_color__["f"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_lab__ = __webpack_require__(309);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "lab", function() { return __WEBPACK_IMPORTED_MODULE_1__src_lab__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return __WEBPACK_IMPORTED_MODULE_1__src_lab__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_cubehelix__ = __webpack_require__(310);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "cubehelix", function() { return __WEBPACK_IMPORTED_MODULE_2__src_cubehelix__["a"]; });





/***/ }),
/* 15 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return root; });
/* harmony export (immutable) */ __webpack_exports__["a"] = Selection;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__select__ = __webpack_require__(258);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selectAll__ = __webpack_require__(259);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__filter__ = __webpack_require__(260);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__data__ = __webpack_require__(261);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__enter__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__exit__ = __webpack_require__(263);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__merge__ = __webpack_require__(264);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__order__ = __webpack_require__(265);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__sort__ = __webpack_require__(266);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__call__ = __webpack_require__(267);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__nodes__ = __webpack_require__(268);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__node__ = __webpack_require__(269);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__size__ = __webpack_require__(270);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__empty__ = __webpack_require__(271);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__each__ = __webpack_require__(272);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__attr__ = __webpack_require__(273);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__style__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__property__ = __webpack_require__(274);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__classed__ = __webpack_require__(275);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__text__ = __webpack_require__(276);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__html__ = __webpack_require__(277);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__raise__ = __webpack_require__(278);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__lower__ = __webpack_require__(279);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__append__ = __webpack_require__(280);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__insert__ = __webpack_require__(281);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__remove__ = __webpack_require__(282);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__clone__ = __webpack_require__(283);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__datum__ = __webpack_require__(284);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__on__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__dispatch__ = __webpack_require__(285);































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: __WEBPACK_IMPORTED_MODULE_0__select__["a" /* default */],
  selectAll: __WEBPACK_IMPORTED_MODULE_1__selectAll__["a" /* default */],
  filter: __WEBPACK_IMPORTED_MODULE_2__filter__["a" /* default */],
  data: __WEBPACK_IMPORTED_MODULE_3__data__["a" /* default */],
  enter: __WEBPACK_IMPORTED_MODULE_4__enter__["b" /* default */],
  exit: __WEBPACK_IMPORTED_MODULE_5__exit__["a" /* default */],
  merge: __WEBPACK_IMPORTED_MODULE_6__merge__["a" /* default */],
  order: __WEBPACK_IMPORTED_MODULE_7__order__["a" /* default */],
  sort: __WEBPACK_IMPORTED_MODULE_8__sort__["a" /* default */],
  call: __WEBPACK_IMPORTED_MODULE_9__call__["a" /* default */],
  nodes: __WEBPACK_IMPORTED_MODULE_10__nodes__["a" /* default */],
  node: __WEBPACK_IMPORTED_MODULE_11__node__["a" /* default */],
  size: __WEBPACK_IMPORTED_MODULE_12__size__["a" /* default */],
  empty: __WEBPACK_IMPORTED_MODULE_13__empty__["a" /* default */],
  each: __WEBPACK_IMPORTED_MODULE_14__each__["a" /* default */],
  attr: __WEBPACK_IMPORTED_MODULE_15__attr__["a" /* default */],
  style: __WEBPACK_IMPORTED_MODULE_16__style__["a" /* default */],
  property: __WEBPACK_IMPORTED_MODULE_17__property__["a" /* default */],
  classed: __WEBPACK_IMPORTED_MODULE_18__classed__["a" /* default */],
  text: __WEBPACK_IMPORTED_MODULE_19__text__["a" /* default */],
  html: __WEBPACK_IMPORTED_MODULE_20__html__["a" /* default */],
  raise: __WEBPACK_IMPORTED_MODULE_21__raise__["a" /* default */],
  lower: __WEBPACK_IMPORTED_MODULE_22__lower__["a" /* default */],
  append: __WEBPACK_IMPORTED_MODULE_23__append__["a" /* default */],
  insert: __WEBPACK_IMPORTED_MODULE_24__insert__["a" /* default */],
  remove: __WEBPACK_IMPORTED_MODULE_25__remove__["a" /* default */],
  clone: __WEBPACK_IMPORTED_MODULE_26__clone__["a" /* default */],
  datum: __WEBPACK_IMPORTED_MODULE_27__datum__["a" /* default */],
  on: __WEBPACK_IMPORTED_MODULE_28__on__["b" /* default */],
  dispatch: __WEBPACK_IMPORTED_MODULE_29__dispatch__["a" /* default */]
};

/* harmony default export */ __webpack_exports__["b"] = (selection);


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CREATED */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return SCHEDULED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return STARTING; });
/* unused harmony export STARTED */
/* unused harmony export RUNNING */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ENDED; });
/* harmony export (immutable) */ __webpack_exports__["g"] = init;
/* harmony export (immutable) */ __webpack_exports__["h"] = set;
/* harmony export (immutable) */ __webpack_exports__["f"] = get;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dispatch__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_timer__ = __webpack_require__(195);



var emptyOn = Object(__WEBPACK_IMPORTED_MODULE_0_d3_dispatch__["a" /* dispatch */])("start", "end", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ __webpack_exports__["e"] = (function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTING) throw new Error("too late; already started");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = Object(__WEBPACK_IMPORTED_MODULE_1_d3_timer__["c" /* timer */])(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return Object(__WEBPACK_IMPORTED_MODULE_1_d3_timer__["b" /* timeout */])(start);

      // Interrupt the active transition, if any.
      // Dispatch the interrupt event.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    Object(__WEBPACK_IMPORTED_MODULE_1_d3_timer__["b" /* timeout */])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(198);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.red = undefined;

var _each = __webpack_require__(582);

var _each2 = _interopRequireDefault(_each);

var _tinycolor = __webpack_require__(584);

var _tinycolor2 = _interopRequireDefault(_tinycolor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  simpleCheckForValidColor: function simpleCheckForValidColor(data) {
    var keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v'];
    var checked = 0;
    var passed = 0;
    (0, _each2.default)(keysToCheck, function (letter) {
      if (data[letter]) {
        checked += 1;
        if (!isNaN(data[letter])) {
          passed += 1;
        }
        if (letter === 's' || letter === 'l') {
          var percentPatt = /^\d+%$/;
          if (percentPatt.test(data[letter])) {
            passed += 1;
          }
        }
      }
    });
    return checked === passed ? data : false;
  },
  toState: function toState(data, oldHue) {
    var color = data.hex ? (0, _tinycolor2.default)(data.hex) : (0, _tinycolor2.default)(data);
    var hsl = color.toHsl();
    var hsv = color.toHsv();
    var rgb = color.toRgb();
    var hex = color.toHex();
    if (hsl.s === 0) {
      hsl.h = oldHue || 0;
      hsv.h = oldHue || 0;
    }
    var transparent = hex === '000000' && rgb.a === 0;

    return {
      hsl: hsl,
      hex: transparent ? 'transparent' : '#' + hex,
      rgb: rgb,
      hsv: hsv,
      oldHue: data.h || oldHue || hsl.h,
      source: data.source
    };
  },
  isValidHex: function isValidHex(hex) {
    // disable hex4 and hex8
    var lh = String(hex).charAt(0) === '#' ? 1 : 0;
    return hex.length !== 4 + lh && hex.length < 7 + lh && (0, _tinycolor2.default)(hex).isValid();
  },
  getContrastingColor: function getContrastingColor(data) {
    if (!data) {
      return '#fff';
    }
    var col = this.toState(data);
    if (col.hex === 'transparent') {
      return 'rgba(0,0,0,0.4)';
    }
    var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1000;
    return yiq >= 128 ? '#000' : '#fff';
  }
};
var red = exports.red = {
  hsl: { a: 1, h: 0, l: 0.5, s: 1 },
  hex: '#ff0000',
  rgb: { r: 255, g: 0, b: 0, a: 1 },
  hsv: { h: 0, s: 1, v: 1, a: 1 }
};

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_value__ = __webpack_require__(102);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_value__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_array__ = __webpack_require__(170);
/* unused harmony reexport interpolateArray */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_basis__ = __webpack_require__(105);
/* unused harmony reexport interpolateBasis */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_basisClosed__ = __webpack_require__(168);
/* unused harmony reexport interpolateBasisClosed */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_date__ = __webpack_require__(171);
/* unused harmony reexport interpolateDate */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_number__ = __webpack_require__(67);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_5__src_number__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_object__ = __webpack_require__(172);
/* unused harmony reexport interpolateObject */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_round__ = __webpack_require__(311);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_7__src_round__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_string__ = __webpack_require__(173);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_8__src_string__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_transform_index__ = __webpack_require__(312);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_9__src_transform_index__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_9__src_transform_index__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_zoom__ = __webpack_require__(315);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_10__src_zoom__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_rgb__ = __webpack_require__(167);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_11__src_rgb__["a"]; });
/* unused harmony reexport interpolateRgbBasis */
/* unused harmony reexport interpolateRgbBasisClosed */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_hsl__ = __webpack_require__(316);
/* unused harmony reexport interpolateHsl */
/* unused harmony reexport interpolateHslLong */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_lab__ = __webpack_require__(317);
/* unused harmony reexport interpolateLab */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_hcl__ = __webpack_require__(318);
/* unused harmony reexport interpolateHcl */
/* unused harmony reexport interpolateHclLong */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__ = __webpack_require__(319);
/* unused harmony reexport interpolateCubehelix */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_quantize__ = __webpack_require__(320);
/* unused harmony reexport quantize */



















/***/ }),
/* 21 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return durationSecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return durationMinute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return durationHour; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return durationDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return durationWeek; });
var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__request__ = __webpack_require__(31);


/* harmony default export */ __webpack_exports__["a"] = (function(defaultMimeType, response) {
  return function(url, callback) {
    var r = Object(__WEBPACK_IMPORTED_MODULE_0__request__["a" /* default */])(url).mimeType(defaultMimeType).response(response);
    if (callback != null) {
      if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
      return r.get(callback);
    }
    return r;
  };
});


/***/ }),
/* 24 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_brush__ = __webpack_require__(382);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "brush", function() { return __WEBPACK_IMPORTED_MODULE_0__src_brush__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "brushX", function() { return __WEBPACK_IMPORTED_MODULE_0__src_brush__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "brushY", function() { return __WEBPACK_IMPORTED_MODULE_0__src_brush__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "brushSelection", function() { return __WEBPACK_IMPORTED_MODULE_0__src_brush__["a"]; });



/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Transition;
/* unused harmony export default */
/* harmony export (immutable) */ __webpack_exports__["b"] = newId;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__attr__ = __webpack_require__(391);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__attrTween__ = __webpack_require__(392);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__delay__ = __webpack_require__(393);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__duration__ = __webpack_require__(394);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ease__ = __webpack_require__(395);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__filter__ = __webpack_require__(396);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__merge__ = __webpack_require__(397);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__on__ = __webpack_require__(398);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__remove__ = __webpack_require__(399);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__select__ = __webpack_require__(400);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__selectAll__ = __webpack_require__(401);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__selection__ = __webpack_require__(402);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__style__ = __webpack_require__(403);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__styleTween__ = __webpack_require__(404);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__text__ = __webpack_require__(405);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__transition__ = __webpack_require__(406);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__tween__ = __webpack_require__(71);



















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = __WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: __WEBPACK_IMPORTED_MODULE_10__select__["a" /* default */],
  selectAll: __WEBPACK_IMPORTED_MODULE_11__selectAll__["a" /* default */],
  filter: __WEBPACK_IMPORTED_MODULE_6__filter__["a" /* default */],
  merge: __WEBPACK_IMPORTED_MODULE_7__merge__["a" /* default */],
  selection: __WEBPACK_IMPORTED_MODULE_12__selection__["a" /* default */],
  transition: __WEBPACK_IMPORTED_MODULE_16__transition__["a" /* default */],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: __WEBPACK_IMPORTED_MODULE_8__on__["a" /* default */],
  attr: __WEBPACK_IMPORTED_MODULE_1__attr__["a" /* default */],
  attrTween: __WEBPACK_IMPORTED_MODULE_2__attrTween__["a" /* default */],
  style: __WEBPACK_IMPORTED_MODULE_13__style__["a" /* default */],
  styleTween: __WEBPACK_IMPORTED_MODULE_14__styleTween__["a" /* default */],
  text: __WEBPACK_IMPORTED_MODULE_15__text__["a" /* default */],
  remove: __WEBPACK_IMPORTED_MODULE_9__remove__["a" /* default */],
  tween: __WEBPACK_IMPORTED_MODULE_17__tween__["a" /* default */],
  delay: __WEBPACK_IMPORTED_MODULE_3__delay__["a" /* default */],
  duration: __WEBPACK_IMPORTED_MODULE_4__duration__["a" /* default */],
  ease: __WEBPACK_IMPORTED_MODULE_5__ease__["a" /* default */]
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(135),
    baseIteratee = __webpack_require__(73),
    baseMap = __webpack_require__(218),
    isArray = __webpack_require__(15);

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return prefix; });
var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

/* harmony default export */ __webpack_exports__["a"] = (map);


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return slice; });
var array = Array.prototype;

var map = array.map;
var slice = array.slice;


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_request__ = __webpack_require__(31);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "request", function() { return __WEBPACK_IMPORTED_MODULE_0__src_request__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_html__ = __webpack_require__(111);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "html", function() { return __WEBPACK_IMPORTED_MODULE_1__src_html__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_json__ = __webpack_require__(112);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "json", function() { return __WEBPACK_IMPORTED_MODULE_2__src_json__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_text__ = __webpack_require__(113);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "text", function() { return __WEBPACK_IMPORTED_MODULE_3__src_text__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_xml__ = __webpack_require__(114);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "xml", function() { return __WEBPACK_IMPORTED_MODULE_4__src_xml__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_csv__ = __webpack_require__(115);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "csv", function() { return __WEBPACK_IMPORTED_MODULE_5__src_csv__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_tsv__ = __webpack_require__(118);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "tsv", function() { return __WEBPACK_IMPORTED_MODULE_6__src_tsv__["a"]; });









/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_collection__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_dispatch__ = __webpack_require__(32);



/* harmony default export */ __webpack_exports__["a"] = (function(url, callback) {
  var request,
      event = Object(__WEBPACK_IMPORTED_MODULE_1_d3_dispatch__["a" /* dispatch */])("beforesend", "progress", "load", "error"),
      mimeType,
      headers = Object(__WEBPACK_IMPORTED_MODULE_0_d3_collection__["a" /* map */])(),
      xhr = new XMLHttpRequest,
      user = null,
      password = null,
      response,
      responseType,
      timeout = 0;

  // If IE does not support CORS, use XDomainRequest.
  if (typeof XDomainRequest !== "undefined"
      && !("withCredentials" in xhr)
      && /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest;

  "onload" in xhr
      ? xhr.onload = xhr.onerror = xhr.ontimeout = respond
      : xhr.onreadystatechange = function(o) { xhr.readyState > 3 && respond(o); };

  function respond(o) {
    var status = xhr.status, result;
    if (!status && hasResponse(xhr)
        || status >= 200 && status < 300
        || status === 304) {
      if (response) {
        try {
          result = response.call(request, xhr);
        } catch (e) {
          event.call("error", request, e);
          return;
        }
      } else {
        result = xhr;
      }
      event.call("load", request, result);
    } else {
      event.call("error", request, o);
    }
  }

  xhr.onprogress = function(e) {
    event.call("progress", request, e);
  };

  request = {
    header: function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers.get(name);
      if (value == null) headers.remove(name);
      else headers.set(name, value + "");
      return request;
    },

    // If mimeType is non-null and no Accept header is set, a default is used.
    mimeType: function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return request;
    },

    // Specifies what type the response value should take;
    // for instance, arraybuffer, blob, document, or text.
    responseType: function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return request;
    },

    timeout: function(value) {
      if (!arguments.length) return timeout;
      timeout = +value;
      return request;
    },

    user: function(value) {
      return arguments.length < 1 ? user : (user = value == null ? null : value + "", request);
    },

    password: function(value) {
      return arguments.length < 1 ? password : (password = value == null ? null : value + "", request);
    },

    // Specify how to convert the response content to a specific type;
    // changes the callback value on "load" events.
    response: function(value) {
      response = value;
      return request;
    },

    // Alias for send("GET", ).
    get: function(data, callback) {
      return request.send("GET", data, callback);
    },

    // Alias for send("POST", ).
    post: function(data, callback) {
      return request.send("POST", data, callback);
    },

    // If callback is non-null, it will be used for error and load events.
    send: function(method, data, callback) {
      xhr.open(method, url, true, user, password);
      if (mimeType != null && !headers.has("accept")) headers.set("accept", mimeType + ",*/*");
      if (xhr.setRequestHeader) headers.each(function(value, name) { xhr.setRequestHeader(name, value); });
      if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);
      if (responseType != null) xhr.responseType = responseType;
      if (timeout > 0) xhr.timeout = timeout;
      if (callback == null && typeof data === "function") callback = data, data = null;
      if (callback != null && callback.length === 1) callback = fixCallback(callback);
      if (callback != null) request.on("error", callback).on("load", function(xhr) { callback(null, xhr); });
      event.call("beforesend", request, xhr);
      xhr.send(data == null ? null : data);
      return request;
    },

    abort: function() {
      xhr.abort();
      return request;
    },

    on: function() {
      var value = event.on.apply(event, arguments);
      return value === event ? request : value;
    }
  };

  if (callback != null) {
    if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
    return request.get(callback);
  }

  return request;
});

function fixCallback(callback) {
  return function(error, xhr) {
    callback(error == null ? xhr : null);
  };
}

function hasResponse(xhr) {
  var type = xhr.responseType;
  return type && type !== "text"
      ? xhr.response // null on error
      : xhr.responseText; // "" on error
}


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_dispatch__ = __webpack_require__(110);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_dispatch__["a"]; });



/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_dsv__ = __webpack_require__(34);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "dsvFormat", function() { return __WEBPACK_IMPORTED_MODULE_0__src_dsv__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_csv__ = __webpack_require__(116);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "csvParse", function() { return __WEBPACK_IMPORTED_MODULE_1__src_csv__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return __WEBPACK_IMPORTED_MODULE_1__src_csv__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormat", function() { return __WEBPACK_IMPORTED_MODULE_1__src_csv__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return __WEBPACK_IMPORTED_MODULE_1__src_csv__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_tsv__ = __webpack_require__(117);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "tsvParse", function() { return __WEBPACK_IMPORTED_MODULE_2__src_tsv__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return __WEBPACK_IMPORTED_MODULE_2__src_tsv__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return __WEBPACK_IMPORTED_MODULE_2__src_tsv__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return __WEBPACK_IMPORTED_MODULE_2__src_tsv__["b"]; });





/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

/* harmony default export */ __webpack_exports__["a"] = (function(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    })).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return text == null ? ""
        : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\""
        : text;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatRows: formatRows
  };
});


/***/ }),
/* 35 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});


var DEFAULT_HANDLE_MISSING_STYLENAME_OPTION = 'throw';

var isNamespacedStyleName = function isNamespacedStyleName(styleName) {
  return styleName.indexOf('.') !== -1;
};

var getClassNameForNamespacedStyleName = function getClassNameForNamespacedStyleName(styleName, styleModuleImportMap, handleMissingStyleNameOption) {
  // Note:
  // Do not use the desctructing syntax with Babel.
  // Desctructing adds _slicedToArray helper.
  var styleNameParts = styleName.split('.');
  var importName = styleNameParts[0];
  var moduleName = styleNameParts[1];
  var handleMissingStyleName = handleMissingStyleNameOption || DEFAULT_HANDLE_MISSING_STYLENAME_OPTION;

  if (!moduleName) {
    if (handleMissingStyleName === 'throw') {
      throw new Error('Invalid style name.');
    } else if (handleMissingStyleName === 'warn') {
      // eslint-disable-next-line no-console
      console.warn('Invalid style name.');
    } else {
      return null;
    }
  }

  if (!styleModuleImportMap[importName]) {
    if (handleMissingStyleName === 'throw') {
      throw new Error('CSS module import does not exist.');
    } else if (handleMissingStyleName === 'warn') {
      // eslint-disable-next-line no-console
      console.warn('CSS module import does not exist.');
    } else {
      return null;
    }
  }

  if (!styleModuleImportMap[importName][moduleName]) {
    if (handleMissingStyleName === 'throw') {
      throw new Error('CSS module does not exist.');
    } else if (handleMissingStyleName === 'warn') {
      // eslint-disable-next-line no-console
      console.warn('CSS module does not exist.');
    } else {
      return null;
    }
  }

  return styleModuleImportMap[importName][moduleName];
};

exports.default = function (styleNameValue, styleModuleImportMap, options) {
  var styleModuleImportMapKeys = Object.keys(styleModuleImportMap);

  var handleMissingStyleName = options && options.handleMissingStyleName || DEFAULT_HANDLE_MISSING_STYLENAME_OPTION;

  return styleNameValue.split(' ').filter(function (styleName) {
    return styleName;
  }).map(function (styleName) {
    if (isNamespacedStyleName(styleName)) {
      return getClassNameForNamespacedStyleName(styleName, styleModuleImportMap, handleMissingStyleName);
    }

    if (styleModuleImportMapKeys.length === 0) {
      throw new Error('Cannot use styleName attribute without importing at least one stylesheet.');
    }

    if (styleModuleImportMapKeys.length > 1) {
      throw new Error('Cannot use anonymous style name with more than one stylesheet import.');
    }

    var styleModuleMap = styleModuleImportMap[styleModuleImportMapKeys[0]];

    if (!styleModuleMap[styleName]) {
      if (handleMissingStyleName === 'throw') {
        throw new Error('Could not resolve the styleName \'' + styleName + '\'.');
      }
      if (handleMissingStyleName === 'warn') {
        // eslint-disable-next-line no-console
        console.warn('Could not resolve the styleName \'' + styleName + '\'.');
      }
    }

    return styleModuleMap[styleName];
  }).filter(function (className) {
    // Remove any styles which could not be found (if handleMissingStyleName === 'ignore')
    return className;
  }).join(' ');
};

//# sourceMappingURL=getClassName.js.map

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(438),
    getValue = __webpack_require__(443);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(48),
    getRawTag = __webpack_require__(439),
    objectToString = __webpack_require__(440);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 39 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 40 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var stack = {};

/**
 * Publish an event.
 *
 * @param {string} event - Event type to be published.
 * @param {any} news - The news to be published.
 */
var publish = function () {
  function publish(event, news) {
    if (!stack[event]) {
      return;
    }

    stack[event].forEach(function (listener) {
      return listener(news);
    });
  }

  return publish;
}();

/**
 * Subscribe to an event.
 *
 * @param {string} event - Event name to subscribe to.
 * @param {function} callback - Function to be called when event of type `event`
 *   is published.
 * @return {object} Object with the event name and index of the callback
 *   function on the event stack. The object can be used to unsubscribe.
 */
var subscribe = function () {
  function subscribe(event, callback) {
    if (!stack[event]) {
      stack[event] = [];
    }

    return {
      event: event,
      id: stack[event].push(callback) - 1
    };
  }

  return subscribe;
}();

/**
 * Unsubscribe from event.
 *
 * @param {string|object} event - Event from which to unsubscribe or the return
 *   object provided by `subscribe()`.
 * @param {function} callback - Callback function to be unsubscribed. It is
 *   ignored if `id` is provided.
 * @param {int} id - Index of the callback function to be removed from the
 *   event stack. The index is returned by `subscribe()`.
 */
var unsubscribe = function () {
  function unsubscribe(event, callback, id) {
    var eventName = event;
    var listenerId = id;

    if ((typeof event === 'undefined' ? 'undefined' : _typeof(event)) === 'object') {
      eventName = event.event;
      listenerId = event.id;
    } else {
      listenerId = typeof id !== 'undefined' ? id : stack[eventName].indexOf(callback);
    }

    if (!stack[eventName]) {
      return;
    }
    if (listenerId === -1 || listenerId >= stack[eventName].length) {
      return;
    }

    stack[eventName].splice(listenerId, 1);
  }

  return unsubscribe;
}();

var pubSub = {
  publish: publish,
  subscribe: subscribe,
  unsubscribe: unsubscribe
};

exports['default'] = pubSub;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TiledPixiTrack = exports.getValueScale = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _d3Scale = __webpack_require__(12);

var _d3Array = __webpack_require__(10);

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _PixiTrack2 = __webpack_require__(42);

var _PixiTrack3 = _interopRequireDefault(_PixiTrack2);

var _services = __webpack_require__(7);

var _utils = __webpack_require__(3);

var _configs = __webpack_require__(6);

var _DataFetcher = __webpack_require__(640);

var _DataFetcher2 = _interopRequireDefault(_DataFetcher);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Services


// Utils


// Configs


/**
 * Get a valueScale for a heatmap.
 *
 * If the scalingType isn't specified, then default to the defaultScaling.
 *
 * @param {string} scalingType: The type of the (e.g. 'linear', or 'log')
 * @param {number} minValue: The minimum data value to which this scale will apply
 * @param {number} pseudocount: A value to add to all numbers to prevent taking the log of 0
 * @param {number} maxValue: The maximum data value to which this scale will apply
 * @param {string} defaultScaling: The default scaling type to use in case
 * 'scalingType' is null (e.g. 'linear' or 'log')
 *
 * @returns {array} An array of [string, scale] containin the scale type and a scale with an appropriately set domain and range
 */
var getValueScale = exports.getValueScale = function () {
  function getValueScale(scalingType, minValue, pseudocount, maxValue, defaultScaling) {
    var scalingTypeToUse = scalingType || defaultScaling;

    if (scalingTypeToUse == 'log' && minValue > 0) {
      return ['log', (0, _d3Scale.scaleLog)().range([254, 0]).domain([minValue + pseudocount, maxValue + pseudocount])];
    }

    if (scalingTypeToUse == 'log') {
      // warn the users that their desired scaling type couldn't be used
      console.warn('Negative values present in data. Defaulting to linear scale: ', minValue);
    }

    return ['linear', (0, _d3Scale.scaleLinear)().range([254, 0]).domain([minValue, maxValue])];
  }

  return getValueScale;
}();

var TiledPixiTrack = exports.TiledPixiTrack = function (_PixiTrack) {
  _inherits(TiledPixiTrack, _PixiTrack);

  /**
   * A track that must pull remote tiles
   *
   * @param scene: A PIXI.js scene to draw everything to.
   * @param server: The server to pull tiles from.
   * @param tilesetUid: The data set to get the tiles from the server
   */
  function TiledPixiTrack(scene, dataConfig, handleTilesetInfoReceived, options, animate, onValueScaleChanged) {
    _classCallCheck(this, TiledPixiTrack);

    // the tiles which should be visible (although they're not necessarily fetched)
    var _this = _possibleConstructorReturn(this, (TiledPixiTrack.__proto__ || Object.getPrototypeOf(TiledPixiTrack)).call(this, scene, options));

    _this.visibleTiles = new Set();
    _this.visibleTileIds = new Set();

    // the tiles we already have requests out for
    _this.fetching = new Set();
    _this.scale = {};

    // tiles we have fetched and ready to be rendered
    _this.fetchedTiles = {};

    var tilesetInfo = null;

    // the graphics that have already been drawn for this track
    _this.tileGraphics = {};

    _this.maxZoom = 0;
    _this.medianVisibleValue = null;

    _this.animate = animate;
    _this.onValueScaleChanged = onValueScaleChanged;

    // store the server and tileset uid so they can be used in draw()
    // if the tileset info is not found
    _this.prevValueScale = null;

    _this.dataFetcher = new _DataFetcher2['default'](dataConfig);

    _this.dataFetcher.tilesetInfo(function (tilesetInfo) {
      // console.log('tilesetInfo:', tilesetInfo);
      _this.tilesetInfo = tilesetInfo;
      // console.log('this.tilesetInfo:', this.tilesetInfo);

      if ('error' in _this.tilesetInfo) {
        // no tileset info for this track
        console.warn('Error retrieving tilesetInfo:', dataConfig, _this.tilesetInfo.error);

        _this.error = _this.tilesetInfo.error;
        _this.tilesetInfo = null;
        _this.draw();
        _this.animate();
        return;
      }

      _this.maxZoom = +_this.tilesetInfo.max_zoom;

      if (_this.options && _this.options.maxZoom) {
        if (_this.options.maxZoom >= 0) {
          _this.maxZoom = Math.min(_this.options.maxZoom, _this.maxZoom);
        } else {
          console.error('Invalid maxZoom on track:', _this);
        }
      }

      _this.refreshTiles();

      if (handleTilesetInfoReceived) {
        handleTilesetInfoReceived(tilesetInfo);
      }

      if (!_this.options) {
        _this.options = {};
      }

      _this.options.name = _this.options.name ? _this.options.name : tilesetInfo.name;

      _this.draw();
      _this.animate();
    });

    _this.uuid = _slugid2['default'].nice();
    _this.refreshTilesDebounced = (0, _utils.debounce)(_this.refreshTiles.bind(_this), _configs.ZOOM_DEBOUNCE);

    _this.trackNotFoundText = new PIXI.Text('', { fontSize: '12px', fontFamily: 'Arial', fill: 'black' });

    _this.pLabel.addChild(_this.trackNotFoundText);
    return _this;
  }

  _createClass(TiledPixiTrack, [{
    key: 'rerender',
    value: function () {
      function rerender(options) {
        _get(TiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(TiledPixiTrack.prototype), 'rerender', this).call(this, options);

        if (!this.tilesetInfo) {
          return;
        }

        this.maxZoom = +this.tilesetInfo.max_zoom;

        if (this.options && this.options.maxZoom) {
          if (this.options.maxZoom >= 0) {
            this.maxZoom = Math.min(this.options.maxZoom, this.maxZoom);
          } else {
            console.error('Invalid maxZoom on track:', this);
          }
        }
      }

      return rerender;
    }()
  }, {
    key: 'visibleAndFetchedIds',
    value: function () {
      function visibleAndFetchedIds() {
        var _this2 = this;

        /**
             * Return the set of ids of all tiles which are both visible and fetched.
             */

        var ret = Object.keys(this.fetchedTiles).filter(function (x) {
          return _this2.visibleTileIds.has(x);
        });
        return ret;
      }

      return visibleAndFetchedIds;
    }()
  }, {
    key: 'visibleAndFetchedTiles',
    value: function () {
      function visibleAndFetchedTiles() {
        var _this3 = this;

        var ids = this.visibleAndFetchedIds();

        return ids.map(function (x) {
          return _this3.fetchedTiles[x];
        });
      }

      return visibleAndFetchedTiles;
    }()
  }, {
    key: 'setVisibleTiles',
    value: function () {
      function setVisibleTiles(tilePositions) {
        var _this4 = this;

        /**
             * Set which tiles are visible right now.
             *
             * @param tiles: A set of tiles which will be considered the currently visible
             * tile positions.
             */
        this.visibleTiles = tilePositions.map(function (x) {
          return {
            tileId: _this4.tileToLocalId(x),
            remoteId: _this4.tileToRemoteId(x),
            mirrored: x.mirrored
          };
        });

        this.visibleTileIds = new Set(this.visibleTiles.map(function (x) {
          return x.tileId;
        }));
      }

      return setVisibleTiles;
    }()
  }, {
    key: 'refreshTiles',
    value: function () {
      function refreshTiles() {
        var _this5 = this;

        if (!this.tilesetInfo) {
          return;
        }

        this.calculateVisibleTiles();

        // tiles that are fetched
        var fetchedTileIDs = new Set(Object.keys(this.fetchedTiles));

        // fetch the tiles that should be visible but haven't been fetched
        // and aren't in the process of being fetched
        var toFetch = [].concat(_toConsumableArray(this.visibleTiles)).filter(function (x) {
          return !_this5.fetching.has(x.remoteId) && !fetchedTileIDs.has(x.tileId);
        });

        for (var i = 0; i < toFetch.length; i++) {
          // console.log('to fetch:', toFetch[i]);
          this.fetching.add(toFetch[i].remoteId);
        }

        // calculate which tiles are obsolete and remove them
        // fetchedTileID are remote ids
        var toRemove = [].concat(_toConsumableArray(fetchedTileIDs)).filter(function (x) {
          return !_this5.visibleTileIds.has(x);
        });

        this.removeTiles(toRemove);
        this.fetchNewTiles(toFetch);
      }

      return refreshTiles;
    }()
  }, {
    key: 'parentInFetched',
    value: function () {
      function parentInFetched(tile) {
        var uid = tile.tileData.tilesetUid;
        var zl = tile.tileData.zoomLevel;
        var pos = tile.tileData.tilePos;

        while (zl > 0) {
          zl -= 1;
          pos = pos.map(function (x) {
            return Math.floor(x / 2);
          });

          var parentId = uid + '.' + zl + '.' + pos.join('.');
          if (parentId in this.fetchedTiles) {
            return true;
          }
        }

        return false;
      }

      return parentInFetched;
    }()
  }, {
    key: 'parentTileId',
    value: function () {
      function parentTileId(tile) {
        var parentZoomLevel = tile.tileData.zoomLevel - 1;
        var parentPos = tile.tileData.tilePos.map(function (x) {
          return Math.floor(x / 2);
        });
        var parentUid = tile.tileData.tilesetUid;

        return parentUid + '.' + parentZoomLevel + '.' + parentPos.join('.');
      }

      return parentTileId;
    }()
  }, {
    key: 'removeTiles',
    value: function () {
      function removeTiles(toRemoveIds) {
        var _this6 = this;

        /**
             * Remove obsolete tiles
             *
             * @param toRemoveIds: An array of tile ids to remove from the list of fetched tiles.
             */

        // if there's nothing to remove, don't bother doing anything
        if (!toRemoveIds.length) {
          return;
        }

        if (!this.areAllVisibleTilesLoaded()) {
          return;
        }

        toRemoveIds.forEach(function (x) {
          var tileIdStr = x;
          _this6.destroyTile(_this6.fetchedTiles[tileIdStr]);

          if (tileIdStr in _this6.tileGraphics) {
            _this6.pMain.removeChild(_this6.tileGraphics[tileIdStr]);
            delete _this6.tileGraphics[tileIdStr];
          }

          delete _this6.fetchedTiles[tileIdStr];
        });

        this.synchronizeTilesAndGraphics();
        this.draw();
      }

      return removeTiles;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        var k = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        var tx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var ty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

        this.xScale(newXScale);
        this.yScale(newYScale);

        this.refreshTilesDebounced();

        this.pMobile.position.x = tx;
        this.pMobile.position.y = this.position[1];

        this.pMobile.scale.x = k;
        this.pMobile.scale.y = 1;
      }

      return zoomed;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(TiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(TiledPixiTrack.prototype), 'setPosition', this).call(this, newPosition);

        // this.draw();
      }

      return setPosition;
    }()
  }, {
    key: 'setDimensions',
    value: function () {
      function setDimensions(newDimensions) {
        _get(TiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(TiledPixiTrack.prototype), 'setDimensions', this).call(this, newDimensions);

        // this.draw();
      }

      return setDimensions;
    }()
  }, {
    key: 'areAllVisibleTilesLoaded',
    value: function () {
      function areAllVisibleTilesLoaded() {
        /**
             * Check to see if all the visible tiles are loaded.
             *
             * If they are, remove all other tiles.
             */
        // tiles that are visible

        // tiles that are fetched
        var fetchedTileIDs = new Set(Object.keys(this.fetchedTiles));

        // console.log('this.fetchedTiles:', this.fetchedTiles);
        var visibleTileIdsList = [].concat(_toConsumableArray(this.visibleTileIds));

        for (var i = 0; i < visibleTileIdsList.length; i++) {
          if (!fetchedTileIDs.has(visibleTileIdsList[i])) {
            return false;
          }
        }

        return true;
      }

      return areAllVisibleTilesLoaded;
    }()
  }, {
    key: 'allTilesLoaded',
    value: function () {
      function allTilesLoaded() {
        /**
             * Function is called when all tiles that should be visible have
             * been received.
             */
      }

      return allTilesLoaded;
    }()
  }, {
    key: 'minValue',
    value: function () {
      function minValue(_) {
        if (_) {
          this.scale.minValue = _;
        } else {
          return this.scale.minValue;
        }
      }

      return minValue;
    }()
  }, {
    key: 'maxValue',
    value: function () {
      function maxValue(_) {
        if (_) {
          this.scale.maxValue = _;
        } else {
          return this.scale.maxValue;
        }
      }

      return maxValue;
    }()
  }, {
    key: 'minRawValue',
    value: function () {
      function minRawValue() {
        // this is the minimum value from all the tiles that
        // hasn't been externally modified by locked scales
        return this.scale.minRawValue;
      }

      return minRawValue;
    }()
  }, {
    key: 'maxRawValue',
    value: function () {
      function maxRawValue() {
        // this is the maximum value from all the tiles that
        // hasn't been externally modified by locked scales
        return this.scale.maxRawValue;
      }

      return maxRawValue;
    }()
  }, {
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        // create the tile
        // should be overwritten by child classes
        // console.log("ERROR: unimplemented createTile:", this);
        this.scale.minRawValue = this.minVisibleValue();
        this.scale.maxRawValue = this.maxVisibleValue();

        this.scale.minValue = this.scale.minRawValue;
        this.scale.maxValue = this.scale.maxRawValue;
      }

      return initTile;
    }()
  }, {
    key: 'updateTile',
    value: function () {
      function updateTile(tile) {
        // console.log("ERROR: unimplemented updateTile:", this);
      }

      return updateTile;
    }()
  }, {
    key: 'destroyTile',
    value: function () {
      function destroyTile(tile) {
        // remove all data structures needed to draw this tile
      }

      return destroyTile;
    }()
  }, {
    key: 'addMissingGraphics',
    value: function () {
      function addMissingGraphics() {
        /**
             * Add graphics for tiles that have no graphics
             */
        var fetchedTileIDs = Object.keys(this.fetchedTiles);
        var added = false;

        for (var i = 0; i < fetchedTileIDs.length; i++) {
          if (!(fetchedTileIDs[i] in this.tileGraphics)) {
            var newGraphics = new PIXI.Graphics();
            // console.log('adding:', fetchedTileIDs[i]);
            this.pMain.addChild(newGraphics);

            this.fetchedTiles[fetchedTileIDs[i]].graphics = newGraphics;
            // console.log('fetchedTiles:', this.fetchedTiles[fetchedTileIDs[i]]);
            this.initTile(this.fetchedTiles[fetchedTileIDs[i]]);

            // console.log('adding graphics...', fetchedTileIDs[i]);
            this.tileGraphics[fetchedTileIDs[i]] = newGraphics;
            added = true;
          }
        }

        /*
            if (added)
                this.draw();
            */
      }

      return addMissingGraphics;
    }()
  }, {
    key: 'updateExistingGraphics',
    value: function () {
      function updateExistingGraphics() {
        /**
             * Change the graphics for existing tiles
             */
        var fetchedTileIDs = Object.keys(this.fetchedTiles);

        for (var i = 0; i < fetchedTileIDs.length; i++) {
          this.updateTile(this.fetchedTiles[fetchedTileIDs[i]]);
        }
      }

      return updateExistingGraphics;
    }()
  }, {
    key: 'synchronizeTilesAndGraphics',
    value: function () {
      function synchronizeTilesAndGraphics() {
        /**
         * Make sure that we have a one to one mapping between tiles
         * and graphics objects
         *
         */

        // keep track of which tiles are visible at the moment
        this.addMissingGraphics();
        this.updateExistingGraphics();
        // this.removeOldGraphics();
      }

      return synchronizeTilesAndGraphics;
    }()
  }, {
    key: 'loadTileData',
    value: function () {
      function loadTileData(tile, dataLoader) {
        /**
         * Extract drawable data from a tile loaded by a generic tile loader
         *
         * @param tile: A tile returned by a TiledArea.
         * @param dataLoader: A function for extracting drawable data from a tile. This
         *                    usually means differentiating the between dense and sparse
         *                    tiles and putting the data into an array.
         */

        // see if the data is already cached
        var loadedTileData = this.lruCache.get(tile.tileId);

        // if not, load it and put it in the cache
        if (!loadedTileData) {
          loadedTileData = dataLoader(tile.data, tile.type);
          this.lruCache.put(tile.tileId, loadedTileData);
        }

        return loadedTileData;
      }

      return loadTileData;
    }()
  }, {
    key: 'fetchNewTiles',
    value: function () {
      function fetchNewTiles(toFetch) {
        if (toFetch.length > 0) {
          var toFetchList = [].concat(_toConsumableArray(new Set(toFetch.map(function (x) {
            return x.remoteId;
          }))));
          // console.log('fetchNewTiles', toFetchList);

          // console.log('toFetchList:', toFetchList);
          this.dataFetcher.fetchTilesDebounced(this.receivedTiles.bind(this), toFetchList);
          /*
          tileProxy.fetchTilesDebounced({
            id: this.uuid,
            server: this.tilesetServer,
            done: this.receivedTiles.bind(this),
            ids: toFetchList,
          });
          */
        }
      }

      return fetchNewTiles;
    }()
  }, {
    key: 'receivedTiles',
    value: function () {
      function receivedTiles(loadedTiles) {
        /**
             * We've gotten a bunch of tiles from the server in
             * response to a request from fetchTiles.
             */
        // console.log('received:', loadedTiles);
        for (var i = 0; i < this.visibleTiles.length; i++) {
          var tileId = this.visibleTiles[i].tileId;

          if (!loadedTiles[this.visibleTiles[i].remoteId]) {
            continue;
          }

          if (this.visibleTiles[i].remoteId in loadedTiles) {
            if (!(tileId in this.fetchedTiles)) {
              // this tile may have graphics associated with it
              this.fetchedTiles[tileId] = this.visibleTiles[i];
            }

            this.fetchedTiles[tileId].tileData = loadedTiles[this.visibleTiles[i].remoteId];

            if (this.fetchedTiles[tileId].tileData.error) {
              console.warn('Error in loaded tile', tileId, this.fetchedTiles[tileId].tileData);
            }
          }
        }

        var fetchedTileIDs = new Set(Object.keys(this.fetchedTiles));
        // console.log('fetchedTileIDs:', fetchedTileIDs);
        // console.log('fetching:', this.fetching);

        for (var key in loadedTiles) {
          if (loadedTiles[key]) {
            var _tileId = loadedTiles[key].tilePositionId;
            // console.log('tileId:', tileId, 'fetching:', this.fetching);

            if (this.fetching.has(_tileId)) {
              // console.log('removing:', tileId, 'fetching:', this.fetching);
              this.fetching['delete'](_tileId);
            }
          }
        }

        this.synchronizeTilesAndGraphics();

        /*
             * Mainly called to remove old unnecessary tiles
             */
        this.refreshTiles();

        if (this.options.valueScaling) {
          this.calculateMedianVisibleValue();
        }

        // we need to draw when we receive new data
        this.draw();

        // Let HiGlass know we need to re-render
        // check if the value scale has changed
        if (this.valueScale) {
          if (!this.prevValueScale || JSON.stringify(this.valueScale.domain()) != JSON.stringify(this.prevValueScale.domain())) {
            // console.log('here', this.onValueScaleChanged);
            // if (this.prevValueScale)
            // console.log('this.prevValueScale.domain()', this.prevValueScale.domain());
            // console.log('this.valueScale.domain()', this.valueScale.domain());
            this.prevValueScale = this.valueScale.copy();

            if (this.onValueScaleChanged) {
              this.onValueScaleChanged();
            }
          }
        }

        this.animate();
      }

      return receivedTiles;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        if (this.delayDrawing) {
          return;
        }

        if (!this.tilesetInfo) {
          if (this.dataFetcher.tilesetInfoLoading) {
            this.trackNotFoundText.text = 'Loading...';
          } else {
            this.trackNotFoundText.text = 'Tileset info not found. Server: [' + this.server + '] tilesetUid: [' + this.tilesetUid + ']';
          }

          this.trackNotFoundText.x = this.position[0];
          this.trackNotFoundText.y = this.position[1];

          /*
                if (this.flipText)
                    this.trackNotFoundText.scale.x = -1;
                */

          this.trackNotFoundText.visible = true;
        } else {
          this.trackNotFoundText.visible = false;
        }

        _get(TiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(TiledPixiTrack.prototype), 'draw', this).call(this);

        for (var uid in this.fetchedTiles) {
          this.drawTile(this.fetchedTiles[uid]);
        }
      }

      return draw;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tileData, graphics) {
        /**
         * Draw a tile on some graphics
         */
      }

      return drawTile;
    }()
  }, {
    key: 'calculateMedianVisibleValue',
    value: function () {
      function calculateMedianVisibleValue() {
        var _this7 = this;

        if (this.areAllVisibleTilesLoaded()) {
          this.allTilesLoaded();
        }

        var visibleAndFetchedIds = this.visibleAndFetchedIds();

        if (visibleAndFetchedIds.length === 0) {
          visibleAndFetchedIds = Object.keys(this.fetchedTiles);
        }

        var values = [].concat.apply([], visibleAndFetchedIds.filter(function (x) {
          return _this7.fetchedTiles[x].tileData.dense;
        }).map(function (x) {
          return Array.from(_this7.fetchedTiles[x].tileData.dense);
        })).filter(function (x) {
          return x > 0;
        });

        this.medianVisibleValue = (0, _d3Array.median)(values);
        return this.medianVisibleValue;
      }

      return calculateMedianVisibleValue;
    }()
  }, {
    key: 'allVisibleValues',
    value: function () {
      function allVisibleValues() {
        var _this8 = this;

        return [].concat.apply([], this.visibleAndFetchedIds().map(function (x) {
          return Array.from(_this8.fetchedTiles[x].tileData.dense);
        }));
      }

      return allVisibleValues;
    }()
  }, {
    key: 'minVisibleValue',
    value: function () {
      function minVisibleValue() {
        var _this9 = this;

        var visibleAndFetchedIds = this.visibleAndFetchedIds();

        if (visibleAndFetchedIds.length == 0) {
          visibleAndFetchedIds = Object.keys(this.fetchedTiles);
        }

        var min = Math.min.apply(null, visibleAndFetchedIds.map(function (x) {
          return _this9.fetchedTiles[x].tileData.minNonZero;
        }).filter(function (x) {
          return x;
        }));

        // if there's no data, use null
        if (min === Number.MAX_SAFE_INTEGER) {
          min = null;
        }

        return min;
      }

      return minVisibleValue;
    }()
  }, {
    key: 'maxVisibleValue',
    value: function () {
      function maxVisibleValue() {
        var _this10 = this;

        var visibleAndFetchedIds = this.visibleAndFetchedIds();

        if (visibleAndFetchedIds.length === 0) {
          visibleAndFetchedIds = Object.keys(this.fetchedTiles);
        }

        var max = Math.max.apply(null, visibleAndFetchedIds.map(function (x) {
          return _this10.fetchedTiles[x].tileData.maxNonZero;
        }).filter(function (x) {
          return x;
        }));

        // if there's no data, use null
        if (max === Number.MIN_SAFE_INTEGER) {
          max = null;
        }

        return max;
      }

      return maxVisibleValue;
    }()
  }, {
    key: 'makeValueScale',
    value: function () {
      function makeValueScale(minValue, medianValue, maxValue, margin) {
        /*
         * Create a value scale that will be used to position values
         * along the y axis.
         *
         * Parameters
         * ----------
         *  minValue: number
         *    The minimum value of the data
         *  medianValue: number
         *    The median value of the data. Potentially used for adding
         *    a pseudocount
         *  maxValue: number
         *    The maximum value of the data
         *  margin: number
         *    A number of pixels to be left free on the top and bottom
         *    of the track. For example if the glyphs have a certain
         *    width and we want all of them to fit into the space.
         *
         * Returns
         * -------
         *  valueScale: d3.scale
         *      A d3 value scale
        */
        var valueScale = null;

        if (!margin) margin = 6; // set a default value

        // console.log('valueScaling:', this.options.valueScaling);
        if (this.options.valueScaling === 'log') {
          var offsetValue = medianValue;

          if (!offsetValue) {
            offsetValue = minValue;
          }

          valueScale = (0, _d3Scale.scaleLog)()
          // .base(Math.E)
          .domain([offsetValue, maxValue + offsetValue])
          // .domain([offsetValue, this.maxValue()])
          .range([this.dimensions[1] - margin, margin]);
          pseudocount = offsetValue;
        } else {
          // linear scale
          valueScale = (0, _d3Scale.scaleLinear)().domain([minValue, maxValue]).range([this.dimensions[1] - margin, margin]);
        }

        return valueScale;
      }

      return makeValueScale;
    }()
  }]);

  return TiledPixiTrack;
}(_PixiTrack3['default']);

exports['default'] = TiledPixiTrack;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PixiTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _d3Format = __webpack_require__(46);

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _Track2 = __webpack_require__(140);

var _utils = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Format a resolution relative to the highest possible resolution.
 *
 * The highest possible resolution determines the granularity of the
 * formatting (e.g. 20K vs 20000)
 * @param {int} resolution The resolution to format (e.g. 30000)
 * @param {int} maxResolutionSize The maximum possible resolution (e.g. 1000)
 *
 * @returns {string} A formatted resolution string (e.g. "30K")
 */
function formatResolutionText(resolution, maxResolutionSize) {
  var pp = (0, _d3Format.precisionPrefix)(maxResolutionSize, resolution);
  var f = (0, _d3Format.formatPrefix)('.' + pp, resolution);
  var formattedResolution = f(resolution);

  return formattedResolution;
}

/**
 * Get a text description of a resolution based on a zoom level
 * and a list of resolutions
 *
 * @param {list} resolutions: A list of resolutions (e.g. [1000,2000,3000])
 * @param {int} zoomLevel: The current zoom level (e.g. 4)
 *
 * @returns {string} A formatted string representation of the zoom level (e.g. "30K")
 * 
 */
function getResolutionBasedResolutionText(resolutions, zoomLevel) {
  var sortedResolutions = resolutions.map(function (x) {
    return +x;
  }).sort(function (a, b) {
    return b - a;
  });
  var resolution = sortedResolutions[zoomLevel];
  var maxResolutionSize = sortedResolutions[sortedResolutions.length - 1];

  return formatResolutionText(resolution, maxResolutionSize);
}

/**
 * Get a text description of the resolution based on the zoom level
 * max width of the dataset, the bins per dimension and the maximum
 * zoom.
 *
 * @param {int} zoomLevel The current zoomLevel (e.g. 0)
 * @param {int} max_width The max width (e.g. 2 ** maxZoom * highestResolution * binsPerDimension)
 * @param {int} bins_per_dimension The number of bins per tile dimension (e.g. 256)
 * @param {int} maxZoom The maximum zoom level for this tileset
 *
 * @returns {string} A formatted string representation of the zoom level (e.g. "30K")
 */
function getWidthBasedResolutionText(zoomLevel, maxWidth, binsPerDimension, maxZoom) {
  var resolution = maxWidth / (Math.pow(2, zoomLevel) * binsPerDimension);

  // we can't display a NaN resolution
  if (!isNaN(resolution)) {
    // what is the maximum possible resolution?
    // this will determine how we format the lower resolutions
    var maxResolutionSize = maxWidth / (Math.pow(2, maxZoom) * binsPerDimension);

    var pp = (0, _d3Format.precisionPrefix)(maxResolutionSize, resolution);
    var f = (0, _d3Format.formatPrefix)('.' + pp, resolution);
    var formattedResolution = f(resolution);

    return formattedResolution;
  } else {
    console.warn('NaN resolution, screen is probably too small. Dimensions:', this.dimensions);

    return '';
  }
}

var PixiTrack = exports.PixiTrack = function (_Track) {
  _inherits(PixiTrack, _Track);

  /**
   * @param scene: A PIXI.js scene to draw everything to.
   * @param options: A set of options that describe how this track is rendered.
   *          - labelPosition: If the label is to be drawn, where should it be drawn?
   *          - labelText: What should be drawn in the label. If either labelPosition
   *                  or labelText are false, no label will be drawn.
   */
  function PixiTrack(scene, options) {
    _classCallCheck(this, PixiTrack);

    // the PIXI drawing areas
    // pMain will have transforms applied to it as users scroll to and fro
    var _this = _possibleConstructorReturn(this, (PixiTrack.__proto__ || Object.getPrototypeOf(PixiTrack)).call(this));

    _this.scene = scene;

    // this option is used to temporarily prevent drawing so that
    // updates can be batched (e.g. zoomed and options changed)
    _this.delayDrawing = false;

    _this.pBase = new PIXI.Graphics();

    _this.pMasked = new PIXI.Graphics();
    _this.pMask = new PIXI.Graphics();
    _this.pMain = new PIXI.Graphics();

    // for drawing the track label (often its name)
    _this.pBorder = new PIXI.Graphics();
    _this.pLabel = new PIXI.Graphics();
    _this.pMobile = new PIXI.Graphics();
    _this.pAxis = new PIXI.Graphics();

    _this.scene.addChild(_this.pBase);

    _this.pBase.addChild(_this.pMasked);

    _this.pMasked.addChild(_this.pMain);
    _this.pMasked.addChild(_this.pMask);
    _this.pMasked.addChild(_this.pMobile);
    _this.pMasked.addChild(_this.pBorder);
    _this.pMasked.addChild(_this.pLabel);
    _this.pBase.addChild(_this.pAxis);

    _this.pMasked.mask = _this.pMask;

    _this.prevOptions = '';

    // pMobile will be a graphics object that is moved around
    // tracks that wish to use it will replace this.pMain with it

    _this.options = Object.assign(_this.options, options);

    var labelTextText = _this.options.name ? _this.options.name : _this.tilesetInfo ? _this.tilesetInfo.name : '';
    _this.labelTextFontFamily = 'Arial';
    _this.labelTextFontSize = 12;

    _this.labelText = new PIXI.Text(labelTextText, { fontSize: _this.labelTextFontSize + 'px',
      fontFamily: _this.labelTextFontFamily,
      fill: 'black' });

    _this.pLabel.addChild(_this.labelText);
    return _this;
  }

  _createClass(PixiTrack, [{
    key: 'setLabelText',
    value: function () {
      function setLabelText() {
        // will be drawn in draw() anyway
      }

      return setLabelText;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        this.position = newPosition;

        this.setMask(this.position, this.dimensions);
      }

      return setPosition;
    }()
  }, {
    key: 'setDimensions',
    value: function () {
      function setDimensions(newDimensions) {
        _get(PixiTrack.prototype.__proto__ || Object.getPrototypeOf(PixiTrack.prototype), 'setDimensions', this).call(this, newDimensions);

        this.setMask(this.position, this.dimensions);
      }

      return setDimensions;
    }()
  }, {
    key: 'setMask',
    value: function () {
      function setMask(position, dimensions) {
        this.pMask.clear();
        this.pMask.beginFill();
        this.pMask.drawRect(position[0], position[1], dimensions[0], dimensions[1]);
        this.pMask.endFill();
      }

      return setMask;
    }()

    /**
     * We're going to destroy this object, so we need to detach its
     * graphics from the scene
     */

  }, {
    key: 'remove',
    value: function () {
      function remove() {
        //console.trace('removing track');
        // the entire PIXI stage was probably removed
        this.pBase.clear();
        this.scene.removeChild(this.pBase);
      }

      return remove;
    }()

    /**
     * Draw a border around each track.
     */

  }, {
    key: 'drawBorder',
    value: function () {
      function drawBorder() {
        var graphics = this.pBorder;

        graphics.clear();

        // don't display the track label
        if (!this.options || !this.options.trackBorderWidth) return;

        var stroke = (0, _utils.colorToHex)(this.options.trackBorderColor ? this.options.trackBorderColor : 'white');

        graphics.lineStyle(this.options.trackBorderWidth, stroke);

        graphics.drawRect(this.position[0], this.position[1], this.dimensions[0], this.dimensions[1]);
      }

      return drawBorder;
    }()
  }, {
    key: 'drawLabel',
    value: function () {
      function drawLabel() {
        var graphics = this.pLabel;

        if (!this.options || !this.options.labelPosition) {
          // don't display the track label
          this.labelText.opacity = 0;
          return;
        }

        graphics.clear();

        if (this.options.labelBackgroundOpacity) {
          graphics.beginFill(0xFFFFFF, +this.options.labelBackgroundOpacity);
        } else {
          graphics.beginFill(0xFFFFFF, 0);
        }

        var stroke = (0, _utils.colorToHex)(this.options.labelColor ? this.options.labelColor : 'black');
        var labelBackgroundMargin = 2;

        // we can't draw a label if there's no space
        if (this.dimensions[0] < 0) {
          return;
        }

        var labelTextText = this.tilesetInfo && this.tilesetInfo.coordSystem ? this.tilesetInfo.coordSystem + ' | ' : '';

        labelTextText += this.options.name ? this.options.name : this.tilesetInfo ? this.tilesetInfo.name : '';

        if (this.tilesetInfo && this.tilesetInfo.max_width && this.tilesetInfo.bins_per_dimension) {
          var formattedResolution = getWidthBasedResolutionText(this.calculateZoomLevel(), this.tilesetInfo.max_width, this.tilesetInfo.bins_per_dimension, this.tilesetInfo.max_zoom);

          labelTextText += '\n[Current data resolution: ' + formattedResolution + ']';
        } else if (this.tilesetInfo && this.tilesetInfo.resolutions) {

          var _formattedResolution = getResolutionBasedResolutionText(this.tilesetInfo.resolutions, this.calculateZoomLevel());

          labelTextText += '\n[Current data resolution: ' + _formattedResolution + ']';
        }

        if (this.options && this.options.dataTransform) {
          var chosenTransform = null;

          if (this.tilesetInfo && this.tilesetInfo.transforms) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = this.tilesetInfo.transforms[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var transform = _step.value;

                if (transform.value === this.options.dataTransform) {
                  chosenTransform = transform;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }

          if (chosenTransform) {
            labelTextText += '\n[Transform: ' + chosenTransform.name + ']';
          } else if (this.options.dataTransform === 'None') {
            labelTextText += '\n[Transform: None ]';
          } else {
            labelTextText += '\n[Transform: Default ]';
          }
        }

        this.labelText.text = labelTextText;
        this.labelText.style = {
          fontSize: this.labelTextFontSize + 'px',
          fontFamily: this.labelTextFontFamily,
          fill: stroke
        };
        this.labelText.alpha = typeof this.options.labelTextOpacity !== 'undefined' ? this.options.labelTextOpacity : 1;

        this.labelText.visible = true;

        if (this.flipText) {
          this.labelText.scale.x = -1;
        }

        if (this.options.labelPosition === 'topLeft') {
          this.labelText.x = this.position[0];
          this.labelText.y = this.position[1];

          this.labelText.anchor.x = 0.5;
          this.labelText.anchor.y = 0;

          this.labelText.x += this.labelText.width / 2;

          graphics.drawRect(this.position[0], this.position[1], this.labelText.width + labelBackgroundMargin, this.labelText.height + labelBackgroundMargin);
        } else if (this.options.labelPosition === 'bottomLeft' && !this.flipText || this.options.labelPosition === 'topRight' && this.flipText) {
          this.labelText.x = this.position[0];
          this.labelText.y = this.position[1] + this.dimensions[1];
          this.labelText.anchor.x = 0.5;
          this.labelText.anchor.y = 1;

          this.labelText.x += this.labelText.width / 2;
          graphics.drawRect(this.position[0], this.position[1] + this.dimensions[1] - this.labelText.height - labelBackgroundMargin, this.labelText.width + labelBackgroundMargin, this.labelText.height + labelBackgroundMargin);
        } else if (this.options.labelPosition === 'topRight' && !this.flipText || this.options.labelPosition === 'bottomLeft' && this.flipText) {
          this.labelText.x = this.position[0] + this.dimensions[0];
          this.labelText.y = this.position[1];
          this.labelText.anchor.x = 0.5;
          this.labelText.anchor.y = 0;

          this.labelText.x -= this.labelText.width / 2;

          graphics.drawRect(this.position[0] + this.dimensions[0] - this.labelText.width - labelBackgroundMargin, this.position[1], this.labelText.width + labelBackgroundMargin, this.labelText.height + labelBackgroundMargin);
        } else if (this.options.labelPosition === 'bottomRight') {
          this.labelText.x = this.position[0] + this.dimensions[0];
          this.labelText.y = this.position[1] + this.dimensions[1];
          this.labelText.anchor.x = 0.5;
          this.labelText.anchor.y = 1;

          // we set the anchor to 0.5 so that we can flip the text if the track
          // is rotated but that means we have to adjust its position
          this.labelText.x -= this.labelText.width / 2;

          graphics.drawRect(this.position[0] + this.dimensions[0] - this.labelText.width - labelBackgroundMargin, this.position[1] + this.dimensions[1] - this.labelText.height - labelBackgroundMargin, this.labelText.width + labelBackgroundMargin, this.labelText.height + labelBackgroundMargin);
        } else if (this.options.labelPosition === 'outerLeft' && !this.flipText || this.options.labelPosition === 'outerTop' && this.flipText) {
          this.labelText.x = this.position[0];
          this.labelText.y = this.position[1] + this.dimensions[1] / 2;

          this.labelText.anchor.x = 0.5;
          this.labelText.anchor.y = 0.5;

          this.labelText.x -= this.labelText.width / 2 + 3;
        } else if (this.options.labelPosition === 'outerTop' && !this.flipText || this.options.labelPosition === 'outerLeft' && this.flipText) {
          this.labelText.x = this.position[0] + this.dimensions[0] / 2;
          this.labelText.y = this.position[1];

          this.labelText.anchor.x = 0.5;
          this.labelText.anchor.y = 0.5;

          this.labelText.y -= this.labelText.height / 2 + 3;
        } else if (this.options.labelPosition === 'outerBottom' && !this.flipText || this.options.labelPosition === 'outerRight' && this.flipText) {
          this.labelText.x = this.position[0] + this.dimensions[0] / 2;
          this.labelText.y = this.position[1] + this.dimensions[1];

          this.labelText.anchor.x = 0.5;
          this.labelText.anchor.y = 0.5;

          this.labelText.y += this.labelText.height / 2 + 3;
        } else if (this.options.labelPosition == 'outerRight' && !this.flipText || this.options.labelPosition == 'outerBottom' && this.flipText) {
          this.labelText.x = this.position[0] + this.dimensions[0];
          this.labelText.y = this.position[1] + this.dimensions[1] / 2;

          this.labelText.anchor.x = 0.5;
          this.labelText.anchor.y = 0.5;

          this.labelText.x += this.labelText.width / 2 + 3;
        } else {
          this.labelText.visible = false;
        }

        if (this.options.labelPosition == 'outerLeft' || this.options.labelPosition == 'outerRight' || this.options.labelPosition == 'outerTop' || this.options.labelPosition == 'outerBottom') {
          this.pLabel.setParent(this.pBase);
        } else {
          this.pLabel.setParent(this.pMasked);
        }
      }

      return drawLabel;
    }()
  }, {
    key: 'rerender',
    value: function () {
      function rerender(options) {
        this.options = options;
        this.draw();
      }

      return rerender;
    }()

    /**
     * Draw all the data associated with this track
     */

  }, {
    key: 'draw',
    value: function () {
      function draw() {
        // this rectangle is cleared by functions that override this draw method
        this.drawBorder();
        this.drawLabel();
      }

      return draw;
    }()

    /**
     * Export an SVG representation of this track
     *
     * @returns {[DOMNode,DOMNode]} The two returned DOM nodes are both SVG
     * elements [base,track]. Base is a parent which contains track as a
     * child. Track is clipped with a clipping rectangle contained in base.
     *
     */

  }, {
    key: 'exportSVG',
    value: function () {
      function exportSVG() {
        var gBase = document.createElement('g');

        var gClipped = document.createElement('g');
        gClipped.setAttribute('class', 'g-clipped');
        gBase.appendChild(gClipped);

        var gTrack = document.createElement('g');
        gClipped.setAttribute('class', 'g-track');
        gClipped.appendChild(gTrack);

        var gLabels = document.createElement('g');
        gClipped.setAttribute('class', 'g-labels');
        gClipped.appendChild(gLabels); // labels should always appear on top of the track

        // define the clipping area as a polygon defined by the track's
        // dimensions on the canvas
        var clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
        gBase.appendChild(clipPath);

        var clipPolygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        clipPath.appendChild(clipPolygon);

        clipPolygon.setAttribute('points', this.position[0] + ',' + this.position[1] + ' ' + (this.position[0] + this.dimensions[0] + ',' + this.position[1] + ' ') + (this.position[0] + this.dimensions[0] + ',' + (this.position[1] + this.dimensions[1]) + ' ') + (this.position[0] + ',' + (this.position[1] + this.dimensions[1]) + ' '));

        // the clipping area needs to be a clipPath element
        var clipPathId = _slugid2['default'].nice();
        clipPath.setAttribute('id', clipPathId);

        gClipped.setAttribute('style', 'clip-path:url(#' + clipPathId + ');');

        var lineParts = this.labelText.text.split('\n');
        var ddy = 0;

        // SVG text alignment is wonky, just adjust the dy values of the tspans
        // instead

        var paddingBottom = 3;
        var labelTextHeight = (this.labelTextFontSize + 2) * lineParts.length + paddingBottom;

        if (this.labelText.anchor.y == 0.5) {
          ddy = labelTextHeight / 2;
        } else if (this.labelText.anchor.y == 1) {
          ddy = -labelTextHeight;
        }

        for (var i = 0; i < lineParts.length; i++) {
          var text = document.createElement('text');

          text.setAttribute('font-family', this.labelTextFontFamily);
          text.setAttribute('font-size', this.labelTextFontSize + 'px');

          // break up newlines into separate tspan elements because SVG text
          // doesn't support line breaks:
          // http://stackoverflow.com/a/16701952/899470

          text.innerText = lineParts[i];
          if (this.options.labelPosition === 'topLeft' || this.options.labelPosition === 'topRight') {
            var dy = ddy + (i + 1) * (this.labelTextFontSize + 2);
            text.setAttribute('dy', dy);
          } else if (this.options.labelPosition === 'bottomLeft' || this.options.labelPosition === 'bottomRight') {
            text.setAttribute('dy', ddy + i * (this.labelTextFontSize + 2));
          }

          text.setAttribute('fill', this.options.labelColor);

          if (this.labelText.anchor.x == 0.5) {
            text.setAttribute('text-anchor', 'middle');
          } else if (this.labelText.anchor.x == 1) {
            text.setAttribute('text-anchor', 'end');
          }

          gLabels.appendChild(text);
        }

        gLabels.setAttribute('transform', 'translate(' + this.labelText.x + ',' + this.labelText.y + ')scale(' + this.labelText.scale.x + ',1)');

        // return the whole SVG and where the specific track should draw its
        // contents
        return [gBase, gTrack];
      }

      return exportSVG;
    }()
  }]);

  return PixiTrack;
}(_Track2.Track);

exports['default'] = PixiTrack;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChromosomeInfo = ChromosomeInfo;

var _d3Dsv = __webpack_require__(33);

var _services = __webpack_require__(7);

function ChromosomeInfo(filepath, success) {
  _services.tileProxy.text(filepath, function (error, chrInfoText) {
    if (error) {
      console.warn("Chromosome info not found at:", filepath);
      success(null);
    }
    var data = (0, _d3Dsv.tsvParseRows)(chrInfoText);
    var cumValues = [];
    var chromLengths = {};
    var chrPositions = {};
    var totalLength = 0;

    for (var i = 0; i < data.length; i++) {
      totalLength += +data[i][1];

      var newValue = { id: i, chr: data[i][0], pos: totalLength - +data[i][1] };

      cumValues.push(newValue);
      chrPositions[newValue.chr] = newValue;
      chromLengths[data[i][0]] = data[i][1];
    }

    var chromInfo = {
      cumPositions: cumValues,
      chrPositions: chrPositions,
      totalLength: totalLength,
      chromLengths: chromLengths
    };

    success(chromInfo);
  });
}

exports['default'] = ChromosomeInfo;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"context-menu":"ContextMenu-module_context-menu-2OwvL","context-menu-item":"ContextMenu-module_context-menu-item-1HeVv","context-menu-hr":"ContextMenu-module_context-menu-hr-3yapb","play-icon":"ContextMenu-module_play-icon-R4pIO","context-menu-span":"ContextMenu-module_context-menu-span-8EUfZ","context-menu-thumbnail":"ContextMenu-module_context-menu-thumbnail-2vHLD","context-menu-thumbnail-inline":"ContextMenu-module_context-menu-thumbnail-inline-1iOcg"};

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__ = __webpack_require__(322);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "formatDefaultLocale", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "format", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "formatPrefix", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_locale__ = __webpack_require__(175);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "formatLocale", function() { return __WEBPACK_IMPORTED_MODULE_1__src_locale__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_formatSpecifier__ = __webpack_require__(176);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "formatSpecifier", function() { return __WEBPACK_IMPORTED_MODULE_2__src_formatSpecifier__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_precisionFixed__ = __webpack_require__(328);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "precisionFixed", function() { return __WEBPACK_IMPORTED_MODULE_3__src_precisionFixed__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_precisionPrefix__ = __webpack_require__(329);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "precisionPrefix", function() { return __WEBPACK_IMPORTED_MODULE_4__src_precisionPrefix__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_precisionRound__ = __webpack_require__(330);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "precisionRound", function() { return __WEBPACK_IMPORTED_MODULE_5__src_precisionRound__["a"]; });








/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayMove = exports.sortableHandle = exports.sortableElement = exports.sortableContainer = exports.SortableHandle = exports.SortableElement = exports.SortableContainer = undefined;

var _utils = __webpack_require__(72);

Object.defineProperty(exports, 'arrayMove', {
  enumerable: true,
  get: function get() {
    return _utils.arrayMove;
  }
});

var _SortableContainer2 = __webpack_require__(422);

var _SortableContainer3 = _interopRequireDefault(_SortableContainer2);

var _SortableElement2 = __webpack_require__(512);

var _SortableElement3 = _interopRequireDefault(_SortableElement2);

var _SortableHandle2 = __webpack_require__(513);

var _SortableHandle3 = _interopRequireDefault(_SortableHandle2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.SortableContainer = _SortableContainer3.default;
exports.SortableElement = _SortableElement3.default;
exports.SortableHandle = _SortableHandle3.default;
exports.sortableContainer = _SortableContainer3.default;
exports.sortableElement = _SortableElement3.default;
exports.sortableHandle = _SortableHandle3.default;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(18);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(208),
    baseKeys = __webpack_require__(470),
    isArrayLike = __webpack_require__(50);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(197),
    isLength = __webpack_require__(132);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x === null ? NaN : +x;
});


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = linearish;
/* harmony export (immutable) */ __webpack_exports__["a"] = linear;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__continuous__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tickFormat__ = __webpack_require__(321);





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["ticks"])(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return Object(__WEBPACK_IMPORTED_MODULE_3__tickFormat__["a" /* default */])(domain(), count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["tickIncrement"])(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["tickIncrement"])(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["tickIncrement"])(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = Object(__WEBPACK_IMPORTED_MODULE_2__continuous__["b" /* default */])(__WEBPACK_IMPORTED_MODULE_2__continuous__["c" /* deinterpolateLinear */], __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["c" /* interpolateNumber */]);

  scale.copy = function() {
    return Object(__WEBPACK_IMPORTED_MODULE_2__continuous__["a" /* copy */])(scale, linear());
  };

  return linearish(scale);
}


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = hue;
/* harmony export (immutable) */ __webpack_exports__["b"] = gamma;
/* harmony export (immutable) */ __webpack_exports__["a"] = nogamma;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(169);


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(isNaN(a) ? b : a);
}


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(s) {
  return s.match(/.{6}/g).map(function(x) {
    return "#" + x;
  });
});


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__request__ = __webpack_require__(31);


/* harmony default export */ __webpack_exports__["a"] = (function(defaultMimeType, parse) {
  return function(url, row, callback) {
    if (arguments.length < 3) callback = row, row = null;
    var r = Object(__WEBPACK_IMPORTED_MODULE_0__request__["a" /* default */])(url).mimeType(defaultMimeType);
    r.row = function(_) { return arguments.length ? r.response(responseOf(parse, row = _)) : row; };
    r.row(row);
    return callback ? r.get(callback) : r;
  };
});

function responseOf(parse, row) {
  return function(request) {
    return parse(request.responseText, row);
  };
}


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

exports.__esModule = true;
exports.noop = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.bottom = bottom;
exports.cloneLayout = cloneLayout;
exports.cloneLayoutItem = cloneLayoutItem;
exports.childrenEqual = childrenEqual;
exports.collides = collides;
exports.compact = compact;
exports.compactItem = compactItem;
exports.correctBounds = correctBounds;
exports.getLayoutItem = getLayoutItem;
exports.getFirstCollision = getFirstCollision;
exports.getAllCollisions = getAllCollisions;
exports.getStatics = getStatics;
exports.moveElement = moveElement;
exports.moveElementAwayFromCollision = moveElementAwayFromCollision;
exports.perc = perc;
exports.setTransform = setTransform;
exports.setTopLeft = setTopLeft;
exports.sortLayoutItems = sortLayoutItems;
exports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;
exports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;
exports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;
exports.validateLayout = validateLayout;
exports.autoBindHandlers = autoBindHandlers;

var _lodash = __webpack_require__(119);

var _lodash2 = _interopRequireDefault(_lodash);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).
var isProduction = process.env.NODE_ENV === "production";
var DEBUG = false;

/**
 * Return the bottom coordinate of the layout.
 *
 * @param  {Array} layout Layout array.
 * @return {Number}       Bottom coordinate.
 */
function bottom(layout) {
  var max = 0,
      bottomY = void 0;
  for (var _i = 0, len = layout.length; _i < len; _i++) {
    bottomY = layout[_i].y + layout[_i].h;
    if (bottomY > max) max = bottomY;
  }
  return max;
}

function cloneLayout(layout) {
  var newLayout = Array(layout.length);
  for (var _i2 = 0, len = layout.length; _i2 < len; _i2++) {
    newLayout[_i2] = cloneLayoutItem(layout[_i2]);
  }
  return newLayout;
}

// Fast path to cloning, since this is monomorphic
function cloneLayoutItem(layoutItem) {
  return {
    w: layoutItem.w,
    h: layoutItem.h,
    x: layoutItem.x,
    y: layoutItem.y,
    i: layoutItem.i,
    minW: layoutItem.minW,
    maxW: layoutItem.maxW,
    minH: layoutItem.minH,
    maxH: layoutItem.maxH,
    moved: Boolean(layoutItem.moved),
    static: Boolean(layoutItem.static),
    // These can be null
    isDraggable: layoutItem.isDraggable,
    isResizable: layoutItem.isResizable
  };
}

/**
 * Comparing React `children` is a bit difficult. This is a good way to compare them.
 * This will catch differences in keys, order, and length.
 */
function childrenEqual(a, b) {
  return (0, _lodash2.default)(_react2.default.Children.map(a, function (c) {
    return c.key;
  }), _react2.default.Children.map(b, function (c) {
    return c.key;
  }));
}

/**
 * Given two layoutitems, check if they collide.
 */
function collides(l1, l2) {
  if (l1 === l2) return false; // same element
  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2
  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2
  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2
  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2
  return true; // boxes overlap
}

/**
 * Given a layout, compact it. This involves going down each y coordinate and removing gaps
 * between items.
 *
 * @param  {Array} layout Layout.
 * @param  {Boolean} verticalCompact Whether or not to compact the layout
 *   vertically.
 * @return {Array}       Compacted Layout.
 */
function compact(layout, compactType, cols) {
  // Statics go in the compareWith array right away so items flow around them.
  var compareWith = getStatics(layout);
  // We go through the items by row and column.
  var sorted = sortLayoutItems(layout, compactType);
  // Holding for new items.
  var out = Array(layout.length);

  for (var _i3 = 0, len = sorted.length; _i3 < len; _i3++) {
    var l = cloneLayoutItem(sorted[_i3]);

    // Don't move static elements
    if (!l.static) {
      l = compactItem(compareWith, l, compactType, cols, sorted);

      // Add to comparison array. We only collide with items before this one.
      // Statics are already in this array.
      compareWith.push(l);
    }

    // Add to output array to make sure they still come out in the right order.
    out[layout.indexOf(sorted[_i3])] = l;

    // Clear moved flag, if it exists.
    l.moved = false;
  }

  return out;
}

var heightWidth = { x: "w", y: "h" };
/**
 * Before moving item down, it will check if the movement will cause collisions and move those items down before.
 */
function resolveCompactionCollision(layout, item, moveToCoord, axis) {
  var sizeProp = heightWidth[axis];
  item[axis] += 1;
  var itemIndex = layout.indexOf(item);

  // Go through each item we collide with.
  for (var _i4 = itemIndex + 1; _i4 < layout.length; _i4++) {
    var otherItem = layout[_i4];
    // Ignore static items
    if (otherItem.static) continue;

    // Optimization: we can break early if we know we're past this el
    // We can do this b/c it's a sorted layout
    if (otherItem.y > item.y + item.h) break;

    if (collides(item, otherItem)) {
      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);
    }
  }

  item[axis] = moveToCoord;
}

/**
 * Compact an item in the layout.
 */
function compactItem(compareWith, l, compactType, cols, fullLayout) {
  var compactV = compactType === "vertical";
  var compactH = compactType === "horizontal";
  if (compactV) {
    // Bottom 'y' possible is the bottom of the layout.
    // This allows you to do nice stuff like specify {y: Infinity}
    // This is here because the layout must be sorted in order to get the correct bottom `y`.
    l.y = Math.min(bottom(compareWith), l.y);
    // Move the element up as far as it can go without colliding.
    while (l.y > 0 && !getFirstCollision(compareWith, l)) {
      l.y--;
    }
  } else if (compactH) {
    l.y = Math.min(bottom(compareWith), l.y);
    // Move the element left as far as it can go without colliding.
    while (l.x > 0 && !getFirstCollision(compareWith, l)) {
      l.x--;
    }
  }

  // Move it down, and keep moving it down if it's colliding.
  var collides = void 0;
  while (collides = getFirstCollision(compareWith, l)) {
    if (compactH) {
      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, "x");
    } else {
      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, "y");
    }
    // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.
    if (compactH && l.x + l.w > cols) {
      l.x = cols - l.w;
      l.y++;
    }
  }
  return l;
}

/**
 * Given a layout, make sure all elements fit within its bounds.
 *
 * @param  {Array} layout Layout array.
 * @param  {Number} bounds Number of columns.
 */
function correctBounds(layout, bounds) {
  var collidesWith = getStatics(layout);
  for (var _i5 = 0, len = layout.length; _i5 < len; _i5++) {
    var l = layout[_i5];
    // Overflows right
    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;
    // Overflows left
    if (l.x < 0) {
      l.x = 0;
      l.w = bounds.cols;
    }
    if (!l.static) collidesWith.push(l);else {
      // If this is static and collides with other statics, we must move it down.
      // We have to do something nicer than just letting them overlap.
      while (getFirstCollision(collidesWith, l)) {
        l.y++;
      }
    }
  }
  return layout;
}

/**
 * Get a layout item by ID. Used so we can override later on if necessary.
 *
 * @param  {Array}  layout Layout array.
 * @param  {String} id     ID
 * @return {LayoutItem}    Item at ID.
 */
function getLayoutItem(layout, id) {
  for (var _i6 = 0, len = layout.length; _i6 < len; _i6++) {
    if (layout[_i6].i === id) return layout[_i6];
  }
}

/**
 * Returns the first item this layout collides with.
 * It doesn't appear to matter which order we approach this from, although
 * perhaps that is the wrong thing to do.
 *
 * @param  {Object} layoutItem Layout item.
 * @return {Object|undefined}  A colliding layout item, or undefined.
 */
function getFirstCollision(layout, layoutItem) {
  for (var _i7 = 0, len = layout.length; _i7 < len; _i7++) {
    if (collides(layout[_i7], layoutItem)) return layout[_i7];
  }
}

function getAllCollisions(layout, layoutItem) {
  return layout.filter(function (l) {
    return collides(l, layoutItem);
  });
}

/**
 * Get all static elements.
 * @param  {Array} layout Array of layout objects.
 * @return {Array}        Array of static layout items..
 */
function getStatics(layout) {
  return layout.filter(function (l) {
    return l.static;
  });
}

/**
 * Move an element. Responsible for doing cascading movements of other elements.
 *
 * @param  {Array}      layout            Full layout to modify.
 * @param  {LayoutItem} l                 element to move.
 * @param  {Number}     [x]               X position in grid units.
 * @param  {Number}     [y]               Y position in grid units.
 */
function moveElement(layout, l, x, y, isUserAction, preventCollision, compactType, cols) {
  if (l.static) return layout;

  // Short-circuit if nothing to do.
  if (l.y === y && l.x === x) return layout;

  log("Moving element " + l.i + " to [" + String(x) + "," + String(y) + "] from [" + l.x + "," + l.y + "]");
  var oldX = l.x;
  var oldY = l.y;

  // This is quite a bit faster than extending the object
  if (typeof x === 'number') l.x = x;
  if (typeof y === 'number') l.y = y;
  l.moved = true;

  // If this collides with anything, move it.
  // When doing this comparison, we have to sort the items we compare with
  // to ensure, in the case of multiple collisions, that we're getting the
  // nearest collision.
  var sorted = sortLayoutItems(layout, compactType);
  var movingUp = compactType === "vertical" && typeof y === 'number' ? oldY >= y : compactType === "horizontal" && typeof x === 'number' ? oldX >= x : false;
  if (movingUp) sorted = sorted.reverse();
  var collisions = getAllCollisions(sorted, l);

  // There was a collision; abort
  if (preventCollision && collisions.length) {
    log("Collision prevented on " + l.i + ", reverting.");
    l.x = oldX;
    l.y = oldY;
    l.moved = false;
    return layout;
  }

  // Move each item that collides away from this element.
  for (var _i8 = 0, len = collisions.length; _i8 < len; _i8++) {
    var collision = collisions[_i8];
    log("Resolving collision between " + l.i + " at [" + l.x + "," + l.y + "] and " + collision.i + " at [" + collision.x + "," + collision.y + "]");

    // Short circuit so we can't infinite loop
    if (collision.moved) continue;

    // Don't move static items - we have to move *this* element away
    if (collision.static) {
      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);
    } else {
      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);
    }
  }

  return layout;
}

/**
 * This is where the magic needs to happen - given a collision, move an element away from the collision.
 * We attempt to move it up if there's room, otherwise it goes below.
 *
 * @param  {Array} layout            Full layout to modify.
 * @param  {LayoutItem} collidesWith Layout item we're colliding with.
 * @param  {LayoutItem} itemToMove   Layout item we're moving.
 */
function moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction, compactType, cols) {
  var compactH = compactType === "horizontal";
  var compactV = compactType === "vertical";
  var preventCollision = false; // we're already colliding

  // If there is enough space above the collision to put this element, move it there.
  // We only do this on the main collision as this can get funky in cascades and cause
  // unwanted swapping behavior.
  if (isUserAction) {
    // Reset isUserAction flag because we're not in the main collision anymore.
    isUserAction = false;

    // Make a mock item so we don't modify the item here, only modify in moveElement.
    var fakeItem = {
      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,
      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,
      w: itemToMove.w,
      h: itemToMove.h,
      i: "-1"
    };

    // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal
    if (!getFirstCollision(layout, fakeItem)) {
      log("Doing reverse collision on " + itemToMove.i + " up to [" + fakeItem.x + "," + fakeItem.y + "].");
      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);
    }
  }

  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);
}

/**
 * Helper to convert a number to a percentage string.
 *
 * @param  {Number} num Any number
 * @return {String}     That number as a percentage.
 */
function perc(num) {
  return num * 100 + "%";
}

function setTransform(_ref) {
  var top = _ref.top,
      left = _ref.left,
      width = _ref.width,
      height = _ref.height;

  // Replace unitless items with px
  var translate = "translate(" + left + "px," + top + "px)";
  return {
    transform: translate,
    WebkitTransform: translate,
    MozTransform: translate,
    msTransform: translate,
    OTransform: translate,
    width: width + "px",
    height: height + "px",
    position: "absolute"
  };
}

function setTopLeft(_ref2) {
  var top = _ref2.top,
      left = _ref2.left,
      width = _ref2.width,
      height = _ref2.height;

  return {
    top: top + "px",
    left: left + "px",
    width: width + "px",
    height: height + "px",
    position: "absolute"
  };
}

/**
 * Get layout items sorted from top left to right and down.
 *
 * @return {Array} Array of layout objects.
 * @return {Array}        Layout, sorted static items first.
 */
function sortLayoutItems(layout, compactType) {
  if (compactType === "horizontal") return sortLayoutItemsByColRow(layout);else return sortLayoutItemsByRowCol(layout);
}

function sortLayoutItemsByRowCol(layout) {
  return [].concat(layout).sort(function (a, b) {
    if (a.y > b.y || a.y === b.y && a.x > b.x) {
      return 1;
    } else if (a.y === b.y && a.x === b.x) {
      // Without this, we can get different sort results in IE vs. Chrome/FF
      return 0;
    }
    return -1;
  });
}

function sortLayoutItemsByColRow(layout) {
  return [].concat(layout).sort(function (a, b) {
    if (a.x > b.x || a.x === b.x && a.y > b.y) {
      return 1;
    }
    return -1;
  });
}

/**
 * Generate a layout using the initialLayout and children as a template.
 * Missing entries will be added, extraneous ones will be truncated.
 *
 * @param  {Array}  initialLayout Layout passed in through props.
 * @param  {String} breakpoint    Current responsive breakpoint.
 * @param  {?String} compact      Compaction option.
 * @return {Array}                Working layout.
 */
function synchronizeLayoutWithChildren(initialLayout, children, cols, compactType) {
  initialLayout = initialLayout || [];

  // Generate one layout item per child.
  var layout = [];
  _react2.default.Children.forEach(children, function (child, i) {
    // Don't overwrite if it already exists.
    var exists = getLayoutItem(initialLayout, String(child.key));
    if (exists) {
      layout[i] = cloneLayoutItem(exists);
    } else {
      if (!isProduction && child.props._grid) {
        console.warn("`_grid` properties on children have been deprecated as of React 15.2. " + // eslint-disable-line
        "Please use `data-grid` or add your properties directly to the `layout`.");
      }
      var g = child.props["data-grid"] || child.props._grid;

      // Hey, this item has a data-grid property, use it.
      if (g) {
        if (!isProduction) {
          validateLayout([g], "ReactGridLayout.children");
        }
        layout[i] = cloneLayoutItem(_extends({}, g, { i: child.key }));
      } else {
        // Nothing provided: ensure this is added to the bottom
        layout[i] = cloneLayoutItem({
          w: 1,
          h: 1,
          x: 0,
          y: bottom(layout),
          i: String(child.key)
        });
      }
    }
  });

  // Correct the layout.
  layout = correctBounds(layout, { cols: cols });
  layout = compact(layout, compactType, cols);

  return layout;
}

/**
 * Validate a layout. Throws errors.
 *
 * @param  {Array}  layout        Array of layout items.
 * @param  {String} [contextName] Context name for errors.
 * @throw  {Error}                Validation error.
 */
function validateLayout(layout) {
  var contextName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Layout";

  var subProps = ["x", "y", "w", "h"];
  if (!Array.isArray(layout)) throw new Error(contextName + " must be an array!");
  for (var _i9 = 0, len = layout.length; _i9 < len; _i9++) {
    var item = layout[_i9];
    for (var j = 0; j < subProps.length; j++) {
      if (typeof item[subProps[j]] !== "number") {
        throw new Error("ReactGridLayout: " + contextName + "[" + _i9 + "]." + subProps[j] + " must be a number!");
      }
    }
    if (item.i && typeof item.i !== "string") {
      throw new Error("ReactGridLayout: " + contextName + "[" + _i9 + "].i must be a string!");
    }
    if (item.static !== undefined && typeof item.static !== "boolean") {
      throw new Error("ReactGridLayout: " + contextName + "[" + _i9 + "].static must be a boolean!");
    }
  }
}

// Flow can't really figure this out, so we just use Object
function autoBindHandlers(el, fns) {
  fns.forEach(function (key) {
    return el[key] = el[key].bind(el);
  });
}

function log() {
  var _console;

  if (!DEBUG) return;
  // eslint-disable-next-line no-console
  (_console = console).log.apply(_console, arguments);
}

var noop = exports.noop = function noop() {};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(38),
    isObjectLike = __webpack_require__(39);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 58 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_59__;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tiled1DPixiTrack2 = __webpack_require__(241);

var _services = __webpack_require__(7);

var _AxisPixi = __webpack_require__(83);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HorizontalTiled1DPixiTrack = function (_Tiled1DPixiTrack) {
  _inherits(HorizontalTiled1DPixiTrack, _Tiled1DPixiTrack);

  function HorizontalTiled1DPixiTrack(scene, dataConfig, handleTilesetInfoReceived, option, animate, onValueScaleChanged) {
    _classCallCheck(this, HorizontalTiled1DPixiTrack);

    var _this = _possibleConstructorReturn(this, (HorizontalTiled1DPixiTrack.__proto__ || Object.getPrototypeOf(HorizontalTiled1DPixiTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, option, animate, onValueScaleChanged));

    _this.axis = new _AxisPixi.AxisPixi(_this);
    _this.pBase.addChild(_this.axis.pAxis);
    return _this;
  }

  _createClass(HorizontalTiled1DPixiTrack, [{
    key: 'calculateZoomLevel',
    value: function () {
      function calculateZoomLevel() {
        // offset by 2 because 1D tiles are more dense than 2D tiles
        // 1024 points per tile vs 256 for 2D tiles
        var xZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]) - 2;

        var zoomLevel = Math.min(xZoomLevel, this.maxZoom);
        zoomLevel = Math.max(zoomLevel, 0);

        return zoomLevel;
      }

      return calculateZoomLevel;
    }()

    /**
     * Which scale should we use for calculating tile positions?
     *
     * Horizontal tracks should use the xScale and vertical tracks
     * should use the yScale
     *
     * This function should be overwritten by HorizontalTiled1DPixiTrack.js
     * and VerticalTiled1DPixiTrack.js
     */

  }, {
    key: 'relevantScale',
    value: function () {
      function relevantScale() {
        return this._xScale;
      }

      return relevantScale;
    }()
  }, {
    key: 'drawAxis',
    value: function () {
      function drawAxis(valueScale) {
        // either no axis position is specified
        if (!this.options.axisPositionVertical && !this.options.axisPositionHorizontal) {
          this.axis.clearAxis();
          return;
        }

        if (this.options.axisPositionVertical && this.options.axisPositionVertical === 'hidden') {
          this.axis.clearAxis();
          return;
        }

        if (this.options.axisPositionHorizontal && this.options.axisPositionHorizontal === 'hidden') {
          this.axis.clearAxis();
          return;
        }

        if (this.options.axisPositionHorizontal === 'left' || this.options.axisPositionVertical === 'top') {
          // left axis are shown at the beginning of the plot

          this.axis.pAxis.position.x = this.position[0];
          this.axis.pAxis.position.y = this.position[1];

          this.axis.drawAxisRight(valueScale, this.dimensions[1]);
        } else if (this.options.axisPositionHorizontal === 'outsideLeft' || this.options.axisPositionVertical === 'outsideTop') {
          // left axis are shown at the beginning of the plot

          this.axis.pAxis.position.x = this.position[0];
          this.axis.pAxis.position.y = this.position[1];

          this.axis.drawAxisLeft(valueScale, this.dimensions[1]);
        } else if (this.options.axisPositionHorizontal === 'right' || this.options.axisPositionVertical === 'bottom') {
          this.axis.pAxis.position.x = this.position[0] + this.dimensions[0];
          this.axis.pAxis.position.y = this.position[1];
          this.axis.drawAxisLeft(valueScale, this.dimensions[1]);
        } else if (this.options.axisPositionHorizontal === 'outsideRight' || this.options.axisPositionVertical === 'outsideBottom') {
          this.axis.pAxis.position.x = this.position[0] + this.dimensions[0];
          this.axis.pAxis.position.y = this.position[1];
          this.axis.drawAxisRight(valueScale, this.dimensions[1]);
        }
      }

      return drawAxis;
    }()
  }]);

  return HorizontalTiled1DPixiTrack;
}(_Tiled1DPixiTrack2.Tiled1DPixiTrack);

exports['default'] = HorizontalTiled1DPixiTrack;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SVGTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _d3Selection = __webpack_require__(4);

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _Track2 = __webpack_require__(140);

var _Track3 = _interopRequireDefault(_Track2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SVGTrack = exports.SVGTrack = function (_Track) {
  _inherits(SVGTrack, _Track);

  function SVGTrack(svgElement) {
    _classCallCheck(this, SVGTrack);

    /**
     * Create a new SVG track. It will contain a g element
     * that maintains all of its element.
     */
    var _this = _possibleConstructorReturn(this, (SVGTrack.__proto__ || Object.getPrototypeOf(SVGTrack)).call(this));

    _this.gMain = (0, _d3Selection.select)(svgElement).append('g');
    _this.clipUid = _slugid2['default'].nice();

    _this.clipRect = _this.gMain.append('clipPath').attr('id', 'track-bounds-' + _this.clipUid).append('rect');

    _this.gMain.attr('clip-path', 'url(#track-bounds-' + _this.clipUid + ')');
    return _this;
  }

  _createClass(SVGTrack, [{
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        this.position = newPosition;

        this.gMain.attr('transform', 'translate(' + this.position[0] + ',' + this.position[1] + ')');
        this.draw();
      }

      return setPosition;
    }()
  }, {
    key: 'setDimensions',
    value: function () {
      function setDimensions(newDimensions) {
        this.dimensions = newDimensions;

        this._xScale.range([0, this.dimensions[0]]);
        this._yScale.range([0, this.dimensions[1]]);

        if (newDimensions[0] >= 0 && newDimensions[1] >= 0) {
          this.clipRect.attr('width', newDimensions[0]);
          this.clipRect.attr('height', newDimensions[1]);
        } else {
          this.clipRect.attr('width', 0);
          this.clipRect.attr('height', 0);
        }

        this.draw();
      }

      return setDimensions;
    }()
  }, {
    key: 'remove',
    value: function () {
      function remove() {
        this.gMain.remove();
        this.gMain = null;
      }

      return remove;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        return this;
      }

      return draw;
    }()
  }]);

  return SVGTrack;
}(_Track3['default']);

exports['default'] = SVGTrack;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContextMenuContainer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(8);

var _reactDom2 = _interopRequireDefault(_reactDom);

__webpack_require__(44);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Styles


// the size of the track controls
// taken from ../styles/TrackControl.module.css
var TRACK_CONTROL_HEIGHT = 20;

var ContextMenuContainer = exports.ContextMenuContainer = function (_React$Component) {
  _inherits(ContextMenuContainer, _React$Component);

  function ContextMenuContainer(props) {
    _classCallCheck(this, ContextMenuContainer);

    var _this = _possibleConstructorReturn(this, (ContextMenuContainer.__proto__ || Object.getPrototypeOf(ContextMenuContainer)).call(this, props));
    /**
     * A window that is opened when a user clicks on the track configuration icon.
     */


    _this.adjusted = false;

    _this.state = {
      orientation: _this.props.orientation ? _this.props.orientation : 'right',
      left: _this.props.position.left,
      top: _this.props.position.top,
      submenuShown: null
    };
    return _this;
  }

  /* -------------------------- Life Cycle Methods -------------------------- */

  _createClass(ContextMenuContainer, [{
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {
        this.updateOrientation();
      }

      return componentDidMount;
    }()
  }, {
    key: 'componentWillReceiveProps',
    value: function () {
      function componentWillReceiveProps(newProps) {
        this.adjusted = false;

        this.setState({
          left: newProps.position.left,
          top: newProps.position.top
        });
      }

      return componentWillReceiveProps;
    }()
  }, {
    key: 'componentDidUpdate',
    value: function () {
      function componentDidUpdate() {
        this.updateOrientation();
      }

      return componentDidUpdate;
    }()

    /* ---------------------------- Custom Methods ---------------------------- */

  }, {
    key: 'handleItemMouseEnterWithRect',
    value: function () {
      function handleItemMouseEnterWithRect(clientRect, series) {
        this.setState({
          submenuShown: series,
          submenuSourceBbox: clientRect
        });
      }

      return handleItemMouseEnterWithRect;
    }()
  }, {
    key: 'handleItemMouseEnter',
    value: function () {
      function handleItemMouseEnter(evt, series) {
        this.handleItemMouseEnterWithRect(evt.currentTarget.getBoundingClientRect(), series);
      }

      return handleItemMouseEnter;
    }()
  }, {
    key: 'handleMouseLeave',
    value: function () {
      function handleMouseLeave() {
        return;
      }

      return handleMouseLeave;
    }()
  }, {
    key: 'handleOtherMouseEnter',
    value: function () {
      function handleOtherMouseEnter() {
        this.setState({
          submenuShown: null
        });
      }

      return handleOtherMouseEnter;
    }()

    /*
    handleSeriesMouseEnter(evt, uid) {
      let domNode = evt.currentTarget;
       this.setState({
        submenuShown: uid,
        submenuSourceBbox: domNode.getBoundingClientRect()
      });
    }
     handleMouseLeave(evt) {
      return;
    }
     handleOtherMouseEnter(evt) {
      this.setState({
        submenuShown: null
      });
    }
    */

  }, {
    key: 'updateOrientation',
    value: function () {
      function updateOrientation() {
        if (this.adjusted) return;

        this.adjusted = true;
        this.divDom = _reactDom2['default'].findDOMNode(this.div);
        var bbox = this.divDom.getBoundingClientRect();

        var parentBbox = this.props.parentBbox ? this.props.parentBbox : {
          top: this.props.position.top,
          left: this.props.position.left,
          width: 0,
          height: 0
        };

        var orientation = this.state.orientation;

        var topPosition = parentBbox.top;

        if (parentBbox.top + bbox.height > window.innerHeight) {
          // goes off the bottom
          if (parentBbox.top - bbox.height > 0) {
            // will fit on top
            topPosition = parentBbox.top - bbox.height + TRACK_CONTROL_HEIGHT;
          }
        }

        if (this.state.orientation === 'left') {
          var leftPosition = parentBbox.left - bbox.width;

          if (leftPosition < 0) {
            if (parentBbox.left + parentBbox.width + bbox.width > window.innerWidth) {
              leftPosition = 0; // goes off the side either way
            } else {
              // switch to the right
              leftPosition = parentBbox.left + parentBbox.width;
              orientation = 'right';
            }
          }

          // we're fine keeping it left oriented
          this.setState({
            left: leftPosition,
            top: topPosition,
            orientation: orientation
          });
        } else {
          var _leftPosition = parentBbox.left + parentBbox.width;

          if (parentBbox.left + parentBbox.width + bbox.width > window.innerWidth) {
            if (parentBbox.left - bbox.width < 0) {
              // goes off both sides
              _leftPosition = 0;
              orientation = 'right';
            } else {
              _leftPosition = parentBbox.left - bbox.width;
              orientation = 'left';
            }
          }

          this.setState({
            left: _leftPosition,
            top: topPosition,
            orientation: orientation
          });
        }
      }

      return updateOrientation;
    }()

    /* ------------------------------ Rendering ------------------------------- */

  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        var stylePosition = this.state.left ? {
          left: this.state.left
        } : {
          right: this.state.right
        };

        var otherStyle = {
          top: this.state.top
        };

        var wholeStyle = Object.assign(stylePosition, otherStyle);

        return _react2['default'].createElement(
          'div',
          {
            className: ('context-menu-item' ? 'context-menu-item' + ' ' : '') + 'ContextMenu-module_context-menu-2OwvL',
            ref: function () {
              function ref(c) {
                return _this2.div = c;
              }

              return ref;
            }(),
            style: wholeStyle
          },
          this.props.children
        );
      }

      return render;
    }()
  }]);

  return ContextMenuContainer;
}(_react2['default'].Component);

ContextMenuContainer.propTypes = {
  children: _propTypes2['default'].node,
  orientation: _propTypes2['default'].string,
  parentBbox: _propTypes2['default'].object,
  position: _propTypes2['default'].object
};

exports['default'] = ContextMenuContainer;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContextMenuItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

__webpack_require__(44);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Styles


var ContextMenuItem = exports.ContextMenuItem = function (_React$Component) {
  _inherits(ContextMenuItem, _React$Component);

  function ContextMenuItem() {
    _classCallCheck(this, ContextMenuItem);

    return _possibleConstructorReturn(this, (ContextMenuItem.__proto__ || Object.getPrototypeOf(ContextMenuItem)).apply(this, arguments));
  }

  _createClass(ContextMenuItem, [{
    key: 'componentWillUnmount',
    value: function () {
      function componentWillUnmount() {}

      return componentWillUnmount;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        return _react2['default'].createElement(
          'div',
          {
            onClick: function () {
              function onClick(e) {
                return _this2.props.onClick(e);
              }

              return onClick;
            }(),
            onMouseEnter: function () {
              function onMouseEnter(e) {
                return _this2.props.onMouseEnter && _this2.props.onMouseEnter(e);
              }

              return onMouseEnter;
            }(),
            onMouseLeave: function () {
              function onMouseLeave(e) {
                return _this2.props.onMouseLeave && _this2.props.onMouseLeave(e);
              }

              return onMouseLeave;
            }(),
            className: 'ContextMenu-module_context-menu-item-1HeVv'
          },
          _react2['default'].createElement(
            'span',
            {
              className: 'ContextMenu-module_context-menu-span-8EUfZ'
            },
            this.props.children
          )
        );
      }

      return render;
    }()
  }]);

  return ContextMenuItem;
}(_react2['default'].Component);

ContextMenuItem.propTypes = {
  children: _propTypes2['default'].node,
  onClick: _propTypes2['default'].func,
  onMouseEnter: _propTypes2['default'].func,
  onMouseLeave: _propTypes2['default'].func
};

exports['default'] = ContextMenuItem;

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__namespace__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__namespaces__ = __webpack_require__(91);



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === __WEBPACK_IMPORTED_MODULE_1__namespaces__["b" /* xhtml */] && document.documentElement.namespaceURI === __WEBPACK_IMPORTED_MODULE_1__namespaces__["b" /* xhtml */]
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var fullname = Object(__WEBPACK_IMPORTED_MODULE_0__namespace__["a" /* default */])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
});


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
});


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_nest__ = __webpack_require__(97);
/* unused harmony reexport nest */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_set__ = __webpack_require__(98);
/* unused harmony reexport set */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_map__ = __webpack_require__(28);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_2__src_map__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_keys__ = __webpack_require__(99);
/* unused harmony reexport keys */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_values__ = __webpack_require__(100);
/* unused harmony reexport values */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_entries__ = __webpack_require__(101);
/* unused harmony reexport entries */








/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
});


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = deinterpolateLinear;
/* harmony export (immutable) */ __webpack_exports__["a"] = copy;
/* harmony export (immutable) */ __webpack_exports__["b"] = continuous;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__array__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__constant__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__number__ = __webpack_require__(174);






var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : Object(__WEBPACK_IMPORTED_MODULE_3__constant__["a" /* default */])(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap(domain, range, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["bisect"])(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range = unit,
      interpolate = __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["a" /* interpolate */],
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = __WEBPACK_IMPORTED_MODULE_2__array__["a" /* map */].call(_, __WEBPACK_IMPORTED_MODULE_4__number__["a" /* default */]), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = __WEBPACK_IMPORTED_MODULE_2__array__["b" /* slice */].call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = __WEBPACK_IMPORTED_MODULE_2__array__["b" /* slice */].call(_), interpolate = __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["e" /* interpolateRound */], rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  return rescale();
}


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDecimal__ = __webpack_require__(107);


/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x = Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(Math.abs(x)), x ? x[1] : NaN;
});


/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = tweenValue;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(17);


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["f" /* get */])(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */])(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["f" /* get */])(node, id).value[name];
  };
}


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayMove = arrayMove;
exports.omit = omit;
exports.closest = closest;
exports.limit = limit;
exports.getElementMargin = getElementMargin;
exports.provideDisplayName = provideDisplayName;
function arrayMove(arr, previousIndex, newIndex) {
  var array = arr.slice(0);
  if (newIndex >= array.length) {
    var k = newIndex - array.length;
    while (k-- + 1) {
      array.push(undefined);
    }
  }
  array.splice(newIndex, 0, array.splice(previousIndex, 1)[0]);
  return array;
}

function omit(obj) {
  for (var _len = arguments.length, keysToOmit = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keysToOmit[_key - 1] = arguments[_key];
  }

  return Object.keys(obj).reduce(function (acc, key) {
    if (keysToOmit.indexOf(key) === -1) acc[key] = obj[key];
    return acc;
  }, {});
}

var events = exports.events = {
  start: ['touchstart', 'mousedown'],
  move: ['touchmove', 'mousemove'],
  end: ['touchend', 'touchcancel', 'mouseup']
};

var vendorPrefix = exports.vendorPrefix = function () {
  if (typeof window === 'undefined' || typeof document === 'undefined') return ''; // server environment
  // fix for:
  //    https://bugzilla.mozilla.org/show_bug.cgi?id=548397
  //    window.getComputedStyle() returns null inside an iframe with display: none
  // in this case return an array with a fake mozilla style in it.
  var styles = window.getComputedStyle(document.documentElement, '') || ['-moz-hidden-iframe'];
  var pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];

  switch (pre) {
    case 'ms':
      return 'ms';
    default:
      return pre && pre.length ? pre[0].toUpperCase() + pre.substr(1) : '';
  }
}();

function closest(el, fn) {
  while (el) {
    if (fn(el)) return el;
    el = el.parentNode;
  }
}

function limit(min, max, value) {
  if (value < min) {
    return min;
  }
  if (value > max) {
    return max;
  }
  return value;
}

function getCSSPixelValue(stringValue) {
  if (stringValue.substr(-2) === 'px') {
    return parseFloat(stringValue);
  }
  return 0;
}

function getElementMargin(element) {
  var style = window.getComputedStyle(element);

  return {
    top: getCSSPixelValue(style.marginTop),
    right: getCSSPixelValue(style.marginRight),
    bottom: getCSSPixelValue(style.marginBottom),
    left: getCSSPixelValue(style.marginLeft)
  };
}

function provideDisplayName(prefix, Component) {
  var componentName = Component.displayName || Component.name;

  return componentName ? prefix + '(' + componentName + ')' : prefix;
}

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var baseMatches = __webpack_require__(426),
    baseMatchesProperty = __webpack_require__(477),
    identity = __webpack_require__(58),
    isArray = __webpack_require__(15),
    property = __webpack_require__(487);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(428),
    listCacheDelete = __webpack_require__(429),
    listCacheGet = __webpack_require__(430),
    listCacheHas = __webpack_require__(431),
    listCacheSet = __webpack_require__(432);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(76);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 76 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(37);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(452);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(57);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.minNonZero = minNonZero;
exports.maxNonZero = maxNonZero;
exports.workerSetPix = workerSetPix;
exports.workerGetTilesetInfo = workerGetTilesetInfo;
exports.workerFetchTiles = workerFetchTiles;
exports.workerFetchMultiRequestTiles = workerFetchMultiRequestTiles;

var _d3Request = __webpack_require__(30);

var _pubSub = __webpack_require__(40);

var _pubSub2 = _interopRequireDefault(_pubSub);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*
function countTransform(count) {
    return Math.sqrt(Math.sqrt(count + 1));
}

function countTransform(count) {
    return Math.log(count+0.0001);
}
*/
var epsilon = 0.0000001;

var MAX_FETCH_TILES = 20;

function minNonZero(data) {
  /**
   * Calculate the minimum non-zero value in the data
   *
   * Parameters
   * ----------
   *  data: Float32Array
   *    An array of values
   *
   * Returns
   * -------
   *  minNonZero: float
   *    The minimum non-zero value in the array
   */
  var minNonZero = Number.MAX_SAFE_INTEGER;

  for (var i = 0; i < data.length; i++) {
    var x = data[i];

    if (x < epsilon && x > -epsilon) {
      continue;
    }

    if (x < minNonZero) {
      minNonZero = x;
    }
  }

  return minNonZero;
}

function maxNonZero(data) {
  /**
   * Calculate the minimum non-zero value in the data
   *
   * Parameters
   * ----------
   *  data: Float32Array
   *    An array of values
   *
   * Returns
   * -------
   *  minNonZero: float
   *    The minimum non-zero value in the array
   */
  var maxNonZero = Number.MIN_SAFE_INTEGER;

  for (var i = 0; i < data.length; i++) {
    var x = data[i];

    if (x < epsilon && x > -epsilon) {
      continue;
    }

    if (x > maxNonZero) {
      maxNonZero = x;
    }
  }

  return maxNonZero;
}

function workerSetPix(size, data, valueScale, pseudocount, colorScale, passedCountTransform) {
  /**
   * The pseudocount is generally the minimum non-zero value and is
   * used so that our log scaling doesn't lead to NaN values.
   */
  var epsilon = 0.000001;

  var pixData = new Uint8ClampedArray(size * 4);

  var rgbIdx = 0;
  var e = 0;

  try {
    for (var i = 0; i < data.length; i++) {
      var d = data[i];
      e = d; // for debugging

      rgbIdx = 255;

      if (d > epsilon) {
        // values less than espilon are considered NaNs and made transparent (rgbIdx 255)
        rgbIdx = Math.max(0, Math.min(254, Math.floor(valueScale(d + pseudocount))));
      }
      // let rgbIdx = qScale(d); //Math.max(0, Math.min(255, Math.floor(valueScale(ct))))
      if (rgbIdx < 0 || rgbIdx > 255) {
        console.warn('out of bounds rgbIdx:', rgbIdx, ' (should be 0 <= rgbIdx <= 255)');
      }
      var rgb = colorScale[rgbIdx];

      pixData[i * 4] = rgb[0];
      pixData[i * 4 + 1] = rgb[1];
      pixData[i * 4 + 2] = rgb[2];
      pixData[i * 4 + 3] = rgb[3];
    }
  } catch (err) {
    console.warn('Odd datapoint');
    console.warn('valueScale.domain():', valueScale.domain());
    console.warn('pseudocount:', pseudocount);
    console.warn('rgbIdx:', rgbIdx, 'd:', e, 'ct:', valueScale(e));
    console.error('ERROR:', err);
    return pixData;
  }

  return pixData;
}

function workerGetTilesetInfo(url, done) {
  _pubSub2['default'].publish('requestSent', url);
  (0, _d3Request.json)(url, function (error, data) {
    _pubSub2['default'].publish('requestReceived', url);
    if (error) {
      // console.log('error:', error);
      // don't do anything
      // no tileset info just means we can't do anything with this file...
    } else {
      // console.log('got data', data);
      done(data);
    }
  });
}

function float32(inUint16) {
  /**
   * Yanked from https://gist.github.com/martinkallman/5049614
   *
   * Does not support infinities or NaN. All requests with such
   * values should be encoded as float32
   */
  var t1 = void 0;
  var t2 = void 0;
  var t3 = void 0;

  t1 = inUint16 & 0x7fff; // Non-sign bits
  t2 = inUint16 & 0x8000; // Sign bit
  t3 = inUint16 & 0x7c00; // Exponent

  t1 <<= 13; // Align mantissa on MSB
  t2 <<= 16; // Shift sign bit into position

  t1 += 0x38000000; // Adjust bias

  t1 = t3 === 0 ? 0 : t1; // Denormals-as-zero

  t1 |= t2; // Re-insert sign bit

  return t1;
}

function _base64ToArrayBuffer(base64) {
  var binary_string = window.atob(base64);
  var len = binary_string.length;

  var bytes = new Uint8Array(len);

  for (var i = 0; i < len; i++) {
    bytes[i] = binary_string.charCodeAt(i);
  }

  return bytes.buffer;
}

function _uint16ArrayToFloat32Array(uint16array) {
  var bytes = new Uint32Array(uint16array.length);

  for (var i = 0; i < uint16array.length; i++) {
    bytes[i] = float32(uint16array[i]);
  }

  var newBytes = new Float32Array(bytes.buffer);

  return newBytes;
}

function workerFetchTiles(tilesetServer, tileIds, sessionId, done) {
  var fetchPromises = [];

  // if we request too many tiles, then the URL can get too long and fail
  // so we'll break up the requests into smaller subsets

  var _loop = function () {
    function _loop(i) {
      var theseTileIds = tileIds.slice(i, i + Math.min(tileIds.length - i, MAX_FETCH_TILES));

      var renderParams = theseTileIds.map(function (x) {
        return 'd=' + x;
      }).join('&');
      var outUrl = tilesetServer + '/tiles/?' + renderParams + '&s=' + sessionId;

      var p = new Promise(function (resolve, reject) {
        _pubSub2['default'].publish('requestSent', outUrl);
        (0, _d3Request.json)(outUrl, function (error, data) {
          _pubSub2['default'].publish('requestReceived', outUrl);
          if (error) {
            resolve({});
          } else {
            // check if we have array data to convert from base64 to float32
            for (var key in data) {
              // let's hope the payload doesn't contain a tileId field
              var keyParts = key.split('.');

              data[key].tileId = key;
              data[key].zoomLevel = +keyParts[1];
              data[key].tilePos = keyParts.slice(2, keyParts.length).map(function (x) {
                return +x;
              });
              data[key].tilesetUid = keyParts[0];

              if ('dense' in data[key]) {
                // let uint16Array = new Uint16Array(
                var newShortDense = _base64ToArrayBuffer(data[key].dense);
                var newDense = _float16ArrayToFloat32Array(newShortDense);

                var a = new Float32Array(newDense);
                var _minNonZero = Number.MAX_SAFE_INTEGER;
                var _maxNonZero = Number.MIN_SAFE_INTEGER;

                data[key].dense = a;

                // find the minimum and maximum non-zero values
                for (var _i = 0; _i < a.length; _i++) {
                  var x = a[_i];

                  if (x < epsilon && x > -epsilon) {
                    continue;
                  }

                  if (x < _minNonZero) {
                    _minNonZero = x;
                  }
                  if (x > _maxNonZero) {
                    _maxNonZero = x;
                  }
                }

                data[key].minNonZero = _minNonZero;
                data[key].maxNonZero = _maxNonZero;
              }
            }

            resolve(data);
          }
        });
      });

      fetchPromises.push(p);
    }

    return _loop;
  }();

  for (var i = 0; i < tileIds.length; i += MAX_FETCH_TILES) {
    _loop(i);
  }

  Promise.all(fetchPromises).then(function (datas) {
    // merge back all the tile requests
    for (var i = 1; i < datas.length; i++) {
      for (var uid in datas[i]) {
        datas[0][uid] = datas[i][uid];
      }
    }

    done(datas[0]);
  });
}

function workerFetchMultiRequestTiles(req) {
  var sessionId = req.sessionId;
  var requests = req.requests;
  var fetchPromises = [];

  var requestsByServer = {};

  // We're converting the array of IDs into an object in order to filter out duplicated requests.
  // In case different instances request the same data it won't be loaded twice.
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = requests[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var request = _step.value;

      if (!requestsByServer[request.server]) {
        requestsByServer[request.server] = {};
      }
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = request.ids[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var id = _step7.value;

          requestsByServer[request.server][id] = true;
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7['return']) {
            _iterator7['return']();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var servers = Object.keys(requestsByServer);

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    var _loop2 = function () {
      function _loop2() {
        var server = _step2.value;

        var ids = Object.keys(requestsByServer[server]);
        // console.log('ids:', ids);

        // if we request too many tiles, then the URL can get too long and fail
        // so we'll break up the requests into smaller subsets

        var _loop3 = function () {
          function _loop3(i) {
            var theseTileIds = ids.slice(i, i + Math.min(ids.length - i, MAX_FETCH_TILES));

            var renderParams = theseTileIds.map(function (x) {
              return 'd=' + x;
            }).join('&');
            var outUrl = server + '/tiles/?' + renderParams + '&s=' + sessionId;

            var p = new Promise(function (resolve, reject) {
              _pubSub2['default'].publish('requestSent', outUrl);
              (0, _d3Request.json)(outUrl, function (error, data) {
                _pubSub2['default'].publish('requestReceived', outUrl);
                if (!data) {
                  // probably an error
                  data = {};
                }

                if (error) {
                  console.warn('Error fetching data:', error);
                }

                var _iteratorNormalCompletion8 = true;
                var _didIteratorError8 = false;
                var _iteratorError8 = undefined;

                try {
                  for (var _iterator8 = theseTileIds[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var thisId = _step8.value;

                    if (!(thisId in data)) {
                      // the server didn't return any data for this tile
                      data[thisId] = {};
                    }
                    var key = thisId;
                    // let's hope the payload doesn't contain a tileId field
                    var keyParts = key.split('.');

                    data[key].server = server;
                    data[key].tileId = key;
                    data[key].zoomLevel = +keyParts[1];
                    data[key].tilePos = keyParts.slice(2, keyParts.length).map(function (x) {
                      return +x;
                    });
                    data[key].tilesetUid = keyParts[0];

                    if (error) {
                      // if there's an error, we have no data to fill in
                      data[key].error = error;
                      continue;
                    }

                    if ('dense' in data[key]) {
                      var arrayBuffer = _base64ToArrayBuffer(data[key].dense);
                      var a = void 0;

                      if (data[key].dtype == 'float16') {
                        // data is encoded as float16s
                        /* comment out until next empty line for 32 bit arrays */
                        var uint16Array = new Uint16Array(arrayBuffer);
                        var newDense = _uint16ArrayToFloat32Array(uint16Array);
                        a = newDense;
                      } else {
                        // data is encoded as float32s
                        a = new Float32Array(arrayBuffer);
                      }

                      data[key].dense = a;

                      data[key].minNonZero = minNonZero(a);
                      data[key].maxNonZero = maxNonZero(a);

                      /*
                                      if (data[key]['minNonZero'] == Number.MAX_SAFE_INTEGER &&
                                          data[key]['maxNonZero'] == Number.MIN_SAFE_INTEGER) {
                                          // if there's no values except 0,
                                          // then do use it as the min value
                                           data[key]['minNonZero'] = 0;
                                          data[key]['maxNonZero'] = 1;
                                      }
                                      */
                    }
                  }
                } catch (err) {
                  _didIteratorError8 = true;
                  _iteratorError8 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion8 && _iterator8['return']) {
                      _iterator8['return']();
                    }
                  } finally {
                    if (_didIteratorError8) {
                      throw _iteratorError8;
                    }
                  }
                }

                resolve(data);
              });
            });

            fetchPromises.push(p);
          }

          return _loop3;
        }();

        for (var i = 0; i < ids.length; i += MAX_FETCH_TILES) {
          _loop3(i);
        }
      }

      return _loop2;
    }();

    for (var _iterator2 = servers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      _loop2();
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2['return']) {
        _iterator2['return']();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  Promise.all(fetchPromises).then(function (datas) {
    var tiles = {};

    // merge back all the tile requests
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = datas[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var data = _step3.value;

        var tileIds = Object.keys(data);

        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = tileIds[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var tileId = _step5.value;

            tiles[data[tileId].server + '/' + tileId] = data[tileId];
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5['return']) {
              _iterator5['return']();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }

      // trigger the callback for every request
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = requests[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var request = _step4.value;

        var reqDate = {};
        var server = request.server;

        // pull together the data per request
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = request.ids[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var id = _step6.value;

            reqDate[id] = tiles[server + '/' + id];
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6['return']) {
              _iterator6['return']();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }

        request.done(reqDate);
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4['return']) {
          _iterator4['return']();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }
  });
}

function workerLoadTileData(tile_value, tile_type) {
  var resolution = 256;

  var t1 = new Date().getTime();
  if (tile_type == 'dense') {
    return tile_value;
  } else if (tile_type == 'sparse') {
    var values = [];
    for (var _i2 = 0; _i2 < resolution * resolution; _i2++) {
      values.push(0);
    }

    var i = 0;
    while (i < tile_value.length) {
      var value = tile_value[i];
      var num_poss = tile_value[i + 1];
      i += 2;

      var xs = [],
          ys = [];

      for (var j = 0; j < num_poss; j++) {
        xs.push(tile_value[i + j]);
      }

      for (var _j = 0; _j < num_poss; _j++) {
        ys.push(tile_value[i + num_poss + _j]);
      }

      for (var _j2 = 0; _j2 < num_poss; _j2++) {
        values[ys[_j2] * resolution + xs[_j2]] = value;
      }

      i += num_poss *= 2;
    }

    return values;
  }
  return [];
}

/*
self.addEventListener('message', function (e) {
    //should only be called when workerSetPix needs to be called
    let passedData = e.data;
    let inputTileData = new Float32Array(passedData.tile.data, 0, passedData.tile.dataLength);

    let tileData = workerLoadTileData(inputTileData, passedData.tile.type)
    let pixOutput = workerSetPix(256 * 256, tileData, passedData.minVisibleValue,
            passedData.maxVisibleValue,
            passedData.tile.colorScale );

    let returnObj = {
        shownTileId: passedData.shownTileId,
        tile: {
            tilePos: passedData.tile.tilePos,
            maxZoom: passedData.tile.maxZoom,
            xOrigDomain: passedData.tile.xOrigDomain,
            yOrigDomain: passedData.tile.yOrigDomain,
            xOrigRange: passedData.tile.xOrigRange,
            yOrigRange: passedData.tile.yOrigRange,
            xRange: passedData.tile.xRange,
            yRange: passedData.tile.yRange,
            mirrored: passedData.tile.mirrored
        }, pixData: pixOutput
    };
    self.postMessage(returnObj, [returnObj.pixData.buffer]);
}, false);
*/

/*
module.exports = function (passedData, done) {
    let inputTileData = new Float32Array(passedData.tile.data, 0, passedData.tile.dataLength);

    let tileData = workerLoadTileData(inputTileData, passedData.tile.type);
    let pixOutput = workerSetPix(256 * 256, tileData,
            passedData.minVisibleValue,
            passedData.maxVisibleValue,
            colorScale = passedData.colorScale);

    let returnObj = {
        shownTileId: passedData.shownTileId,
        tile: {
            tilePos: passedData.tile.tilePos,
            maxZoom: passedData.tile.maxZoom,
            xOrigDomain: passedData.tile.xOrigDomain,
            yOrigDomain: passedData.tile.yOrigDomain,
            xOrigRange: passedData.tile.xOrigRange,
            yOrigRange: passedData.tile.yOrigRange,
            xRange: passedData.tile.xRange,
            yRange: passedData.tile.yRange,
            mirrored: passedData.tile.mirrored
        }, pixData: pixOutput
    };

    done(returnObj, [returnObj.pixData.buffer]);
};
*/

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(226),
    baseAssignValue = __webpack_require__(227);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HeatmapTiledPixiTrack = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _d3Brush = __webpack_require__(25);

var _d3Scale = __webpack_require__(12);

var _d3Selection = __webpack_require__(4);

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _TiledPixiTrack2 = __webpack_require__(41);

var _AxisPixi = __webpack_require__(83);

var _services = __webpack_require__(7);

var _utils = __webpack_require__(3);

var _configs = __webpack_require__(6);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var COLORBAR_MAX_HEIGHT = 200;
var COLORBAR_WIDTH = 10;
var COLORBAR_LABELS_WIDTH = 40;
var COLORBAR_MARGIN = 10;
var BRUSH_WIDTH = COLORBAR_MARGIN;
var BRUSH_HEIGHT = 4;
var BRUSH_COLORBAR_GAP = 1;
var BRUSH_MARGIN = 4;
var SCALE_LIMIT_PRECISION = 5;
var BINS_PER_TILE = 256;

var HeatmapTiledPixiTrack = exports.HeatmapTiledPixiTrack = function (_TiledPixiTrack) {
  _inherits(HeatmapTiledPixiTrack, _TiledPixiTrack);

  function HeatmapTiledPixiTrack(scene, dataConfig, handleTilesetInfoReceived, options, animate, svgElement, onValueScaleChanged, onTrackOptionsChanged) {
    _classCallCheck(this, HeatmapTiledPixiTrack);

    var _this = _possibleConstructorReturn(this, (HeatmapTiledPixiTrack.__proto__ || Object.getPrototypeOf(HeatmapTiledPixiTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, options, animate, onValueScaleChanged));
    /**
     * @param scene: A PIXI.js scene to draw everything to.
     * @param server: The server to pull tiles from.
     * @param uid: The data set to get the tiles from the server
     */


    _this.onTrackOptionsChanged = onTrackOptionsChanged;

    // Graphics for drawing the colorbar
    _this.pColorbarArea = new PIXI.Graphics();
    _this.pMasked.addChild(_this.pColorbarArea);

    _this.pColorbar = new PIXI.Graphics();
    _this.pColorbarArea.addChild(_this.pColorbar);

    _this.axis = new _AxisPixi.AxisPixi(_this);
    _this.pColorbarArea.addChild(_this.axis.pAxis);

    // [[255,255,255,0], [237,218,10,4] ...
    // a 256 element array mapping the values 0-255 to rgba values
    // not a d3 color scale for speed
    // this.colorScale = heatedObjectMap;
    _this.colorScale = _configs.heatedObjectMap;

    if (options && options.colorRange) {
      _this.colorScale = (0, _utils.colorDomainToRgbaArray)(options.colorRange);
    }

    _this.gBase = (0, _d3Selection.select)(svgElement).append('g');
    _this.gMain = _this.gBase.append('g');
    _this.gColorscaleBrush = _this.gMain.append('g');

    _this.brushing = false;
    _this.prevOptions = '';
    return _this;
  }

  /**
   * Set the position of this track. Normally this is handled by its ancestors,
   * but because we're also drawing on the SVG track, we need the function to
   * adjust the location of this.gSVG
   *
   * Arguments
   * ---------
   *      newPosition: [x,y]
   *          The new position of this track
   */


  _createClass(HeatmapTiledPixiTrack, [{
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(HeatmapTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HeatmapTiledPixiTrack.prototype), 'setPosition', this).call(this, newPosition);
      }

      return setPosition;
    }()
  }, {
    key: 'rerender',
    value: function () {
      function rerender(options, force) {
        // if force is set, then we force a rerender even if the options
        // haven't changed rerender will force a brush.move

        var strOptions = JSON.stringify(options);

        if (!force && strOptions === this.prevOptions) {
          return;
        }

        this.prevOptions = strOptions;

        _get(HeatmapTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HeatmapTiledPixiTrack.prototype), 'rerender', this).call(this, options, force);

        // the normalization method may have changed
        this.calculateVisibleTiles();

        if (options && options.colorRange) {
          this.colorScale = (0, _utils.colorDomainToRgbaArray)(options.colorRange);
        }

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.visibleAndFetchedTiles()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tile = _step.value;

            this.renderTile(tile);
          }

          // hopefully draw isn't rerendering all the tiles
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this.drawColorbar();
      }

      return rerender;
    }()
  }, {
    key: 'tileDataToCanvas',
    value: function () {
      function tileDataToCanvas(pixData) {
        var canvas = document.createElement('canvas');

        canvas.width = 256;
        canvas.height = 256;

        var ctx = canvas.getContext('2d');

        ctx.fillStyle = 'transparent';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        var pix = new ImageData(pixData, canvas.width, canvas.height);

        ctx.putImageData(pix, 0, 0);

        return canvas;
      }

      return tileDataToCanvas;
    }()
  }, {
    key: 'exportData',
    value: function () {
      function exportData() {}

      return exportData;
    }()
  }, {
    key: 'setSpriteProperties',
    value: function () {
      function setSpriteProperties(sprite, zoomLevel, tilePos, mirrored) {
        var _getTilePosAndDimensi = this.getTilePosAndDimensions(zoomLevel, tilePos),
            tileX = _getTilePosAndDimensi.tileX,
            tileY = _getTilePosAndDimensi.tileY,
            tileWidth = _getTilePosAndDimensi.tileWidth,
            tileHeight = _getTilePosAndDimensi.tileHeight;

        var tileEndX = tileX + tileWidth;
        var tileEndY = tileY + tileHeight;

        var spriteWidth = this._refXScale(tileEndX) - this._refXScale(tileX);
        var spriteHeight = this._refYScale(tileEndY) - this._refYScale(tileY);

        sprite.width = this._refXScale(tileEndX) - this._refXScale(tileX);
        sprite.height = this._refYScale(tileEndY) - this._refYScale(tileY);

        if (mirrored) {
          // this is a mirrored tile that represents the other half of a
          // triangular matrix
          sprite.x = this._refXScale(tileY);
          sprite.y = this._refYScale(tileX);

          // sprite.pivot = [this._refXScale()[1] / 2, this._refYScale()[1] / 2];

          // I think PIXIv3 used a different method to set the pivot value
          // because the code above no longer works as of v4
          sprite.rotation = -Math.PI / 2;
          sprite.scale.x = Math.abs(sprite.scale.x) * -1;

          sprite.width = spriteHeight;
          sprite.height = spriteWidth;
        } else {
          sprite.x = this._refXScale(tileX);
          sprite.y = this._refYScale(tileY);
        }
      }

      return setSpriteProperties;
    }()
  }, {
    key: 'refXScale',
    value: function () {
      function refXScale(_) {
        _get(HeatmapTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HeatmapTiledPixiTrack.prototype), 'refXScale', this).call(this, _);

        this.draw();
      }

      return refXScale;
    }()
  }, {
    key: 'refYScale',
    value: function () {
      function refYScale(_) {
        _get(HeatmapTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HeatmapTiledPixiTrack.prototype), 'refYScale', this).call(this, _);

        this.draw();
      }

      return refYScale;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        _get(HeatmapTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HeatmapTiledPixiTrack.prototype), 'draw', this).call(this);

        this.drawColorbar();
      }

      return draw;
    }()
  }, {
    key: 'newBrushOptions',
    value: function () {
      function newBrushOptions(selection) {
        var newOptions = JSON.parse(JSON.stringify(this.options));

        var axisValueScale = this.valueScale.copy().range([this.colorbarHeight, 0]);

        var endDomain = axisValueScale.invert(selection[0]);
        var startDomain = axisValueScale.invert(selection[1]);

        var startPercent = (startDomain - axisValueScale.domain()[0]) / (axisValueScale.domain()[1] - axisValueScale.domain()[0]);
        var endPercent = (endDomain - axisValueScale.domain()[0]) / (axisValueScale.domain()[1] - axisValueScale.domain()[0]);

        newOptions.scaleStartPercent = startPercent.toFixed(SCALE_LIMIT_PRECISION);
        newOptions.scaleEndPercent = endPercent.toFixed(SCALE_LIMIT_PRECISION);

        return newOptions;
      }

      return newBrushOptions;
    }()
  }, {
    key: 'brushStart',
    value: function () {
      function brushStart() {
        this.brushing = true;
      }

      return brushStart;
    }()
  }, {
    key: 'brushMoved',
    value: function () {
      function brushMoved() {
        if (!_d3Selection.event.selection) {
          return;
        }

        var newOptions = this.newBrushOptions(_d3Selection.event.selection);

        var strOptions = JSON.stringify(newOptions);

        this.gColorscaleBrush.selectAll('.handle--custom').attr('y', function (d) {
          return d.type === 'n' ? _d3Selection.event.selection[0] : _d3Selection.event.selection[1] - BRUSH_HEIGHT / 2;
        });

        if (strOptions === this.prevOptions) return;

        this.prevOptions = strOptions;

        // force a rerender because we've already set prevOptions
        // to the new options
        // this is necessary for when value scales are synced between
        // tracks
        this.rerender(newOptions, true);

        this.onTrackOptionsChanged(newOptions);
        this.onValueScaleChanged();
      }

      return brushMoved;
    }()
  }, {
    key: 'brushEnd',
    value: function () {
      function brushEnd() {
        // let newOptions = this.newBrushOptions(event.selection);

        // this.rerender(newOptions);
        // this.animate();
        this.brushing = false;
      }

      return brushEnd;
    }()
  }, {
    key: 'drawColorbar',
    value: function () {
      function drawColorbar() {
        this.pColorbar.clear();

        if (!this.options.colorbarPosition || this.options.colorbarPosition === 'hidden') {
          this.pColorbarArea.visible = false;

          if (this.scaleBrush) {
            this.gColorscaleBrush.call(this.scaleBrush.move, null);
          }

          // turn off the color scale brush
          this.gColorscaleBrush.on('.brush', null);
          this.gColorscaleBrush.selectAll('rect').remove();

          return;
        }

        this.pColorbarArea.visible = true;

        if (!this.valueScale) {
          return;
        }
        if (isNaN(this.valueScale.domain()[0]) || isNaN(this.valueScale.domain()[1])) {
          return;
        }

        var colorbarAreaHeight = Math.min(this.dimensions[1] / 2, COLORBAR_MAX_HEIGHT);
        this.colorbarHeight = colorbarAreaHeight - 2 * COLORBAR_MARGIN;

        if (this.colorbarHeight < 0)
          //  no point in drawing the colorbar if it's not going to be visible
          return;

        var colorbarAreaWidth = COLORBAR_WIDTH + COLORBAR_LABELS_WIDTH + COLORBAR_MARGIN + BRUSH_COLORBAR_GAP + BRUSH_WIDTH + BRUSH_MARGIN;

        var axisValueScale = this.valueScale.copy().range([this.colorbarHeight, 0]);

        this.scaleBrush = (0, _d3Brush.brushY)();

        // this is to make the handles of the scale brush stick out away
        // from the colorbar
        if (this.options.colorbarPosition === 'topLeft' || this.options.colorbarPosition === 'bottomLeft') {
          this.scaleBrush.extent([[BRUSH_MARGIN, 0], [BRUSH_WIDTH, this.colorbarHeight]]);
        } else {
          this.scaleBrush.extent([[0, 0], [BRUSH_WIDTH - BRUSH_MARGIN, this.colorbarHeight]]);
        }

        if (this.options.colorbarPosition === 'topLeft') {
          // draw the background for the colorbar
          this.pColorbarArea.x = this.position[0];
          this.pColorbarArea.y = this.position[1];

          this.pColorbar.y = COLORBAR_MARGIN;
          this.axis.pAxis.y = COLORBAR_MARGIN;

          this.axis.pAxis.x = BRUSH_MARGIN + BRUSH_WIDTH + BRUSH_COLORBAR_GAP + COLORBAR_WIDTH;
          this.pColorbar.x = BRUSH_MARGIN + BRUSH_WIDTH + BRUSH_COLORBAR_GAP;

          this.gColorscaleBrush.attr('transform', 'translate(' + (this.pColorbarArea.x + BRUSH_MARGIN) + ',' + (this.pColorbarArea.y + this.pColorbar.y - 1) + ')');
        }

        if (this.options.colorbarPosition === 'topRight') {
          // draw the background for the colorbar
          this.pColorbarArea.x = this.position[0] + this.dimensions[0] - colorbarAreaWidth;
          this.pColorbarArea.y = this.position[1];

          this.pColorbar.y = COLORBAR_MARGIN;
          this.axis.pAxis.y = COLORBAR_MARGIN;

          // default to 'inside'
          this.axis.pAxis.x = COLORBAR_LABELS_WIDTH + COLORBAR_MARGIN;

          this.pColorbar.x = COLORBAR_LABELS_WIDTH + COLORBAR_MARGIN;

          this.gColorscaleBrush.attr('transform', 'translate(' + (this.pColorbarArea.x + this.pColorbar.x + COLORBAR_WIDTH + 2) + ',' + (this.pColorbarArea.y + this.pColorbar.y - 1) + ')');
        }

        if (this.options.colorbarPosition === 'bottomRight') {
          this.pColorbarArea.x = this.position[0] + this.dimensions[0] - colorbarAreaWidth;
          this.pColorbarArea.y = this.position[1] + this.dimensions[1] - colorbarAreaHeight;

          this.pColorbar.y = COLORBAR_MARGIN;
          this.axis.pAxis.y = COLORBAR_MARGIN;

          // default to "inside"
          this.axis.pAxis.x = COLORBAR_LABELS_WIDTH + COLORBAR_MARGIN;
          this.pColorbar.x = COLORBAR_LABELS_WIDTH + COLORBAR_MARGIN;

          this.gColorscaleBrush.attr('transform', 'translate(' + (this.pColorbarArea.x + this.pColorbar.x + COLORBAR_WIDTH + BRUSH_COLORBAR_GAP) + ',' + (this.pColorbarArea.y + this.pColorbar.y - 1) + ')');
        }

        if (this.options.colorbarPosition === 'bottomLeft') {
          this.pColorbarArea.x = this.position[0];
          this.pColorbarArea.y = this.position[1] + this.dimensions[1] - colorbarAreaHeight;

          this.pColorbar.y = COLORBAR_MARGIN;
          this.axis.pAxis.y = COLORBAR_MARGIN;

          // default to "inside"
          this.axis.pAxis.x = BRUSH_MARGIN + BRUSH_WIDTH + BRUSH_COLORBAR_GAP + COLORBAR_WIDTH;
          this.pColorbar.x = BRUSH_MARGIN + BRUSH_WIDTH + BRUSH_COLORBAR_GAP;

          this.gColorscaleBrush.attr('transform', 'translate(' + (this.pColorbarArea.x + 2) + ',' + (this.pColorbarArea.y + this.pColorbar.y - 1) + ')');
        }

        this.pColorbarArea.clear();
        this.pColorbarArea.beginFill((0, _utils.colorToHex)('white'), 0.6);
        this.pColorbarArea.drawRect(0, 0, colorbarAreaWidth, colorbarAreaHeight);

        if (!this.options) {
          this.options = {};
        }
        if (!this.options.scaleStartPercent) {
          this.options.scaleStartPercent = 0;
        }
        if (!this.options.scaleEndPercent) {
          this.options.scaleEndPercent = 1;
        }

        var domainWidth = axisValueScale.domain()[1] - axisValueScale.domain()[0];

        var startBrush = axisValueScale(this.options.scaleStartPercent * domainWidth + axisValueScale.domain()[0]);
        var endBrush = axisValueScale(this.options.scaleEndPercent * domainWidth + axisValueScale.domain()[0]);

        // endBrush and startBrush are reversed because lower values come first
        // only set if the user isn't brushing at the moment
        if (!this.brushing) {
          this.scaleBrush.on('start', this.brushStart.bind(this)).on('brush', this.brushMoved.bind(this)).on('end', this.brushEnd.bind(this)).handleSize(0);

          this.gColorscaleBrush.on('.brush', null);
          this.gColorscaleBrush.call(this.scaleBrush);

          this.northHandle = this.gColorscaleBrush.selectAll('.handle--custom').data([{ type: 'n' }, { type: 's' }]).enter().append('rect').classed('handle--custom', true).attr('cursor', 'ns-resize').attr('width', BRUSH_WIDTH).attr('height', BRUSH_HEIGHT).style('fill', '#666').style('stroke', 'white');

          if (this.flipText) {
            this.northHandle.attr('cursor', 'ew-resize');
          }

          this.gColorscaleBrush.call(this.scaleBrush.move, [endBrush, startBrush]);
        }

        var posScale = (0, _d3Scale.scaleLinear)().domain([0, 255]).range([0, this.colorbarHeight]);

        // draw a small rectangle for each color of the colorbar
        for (var i = 0; i < this.colorbarHeight; i++) {
          var value = this.limitedValueScale(axisValueScale.invert(i));

          var rgbIdx = Math.max(0, Math.min(254, Math.floor(value)));
          this.pColorbar.beginFill((0, _utils.colorToHex)('rgb(' + this.colorScale[rgbIdx][0] + ',' + this.colorScale[rgbIdx][1] + ',' + this.colorScale[rgbIdx][2] + ')'));

          // each rectangle in the colorbar will be one pixel high
          this.pColorbar.drawRect(0, i, COLORBAR_WIDTH, 1);
        }

        // draw an axis on the right side of the colorbar
        this.pAxis.position.x = COLORBAR_WIDTH;
        this.pAxis.position.y = posScale(0);

        if (this.options.colorbarPosition === 'topLeft' || this.options.colorbarPosition === 'bottomLeft') {
          this.axis.drawAxisRight(axisValueScale, this.colorbarHeight);
        } else if (this.options.colorbarPosition === 'topRight' || this.options.colorbarPosition === 'bottomRight') {
          this.axis.drawAxisLeft(axisValueScale, this.colorbarHeight);
        }
      }

      return drawColorbar;
    }()
  }, {
    key: 'exportColorBarSVG',
    value: function () {
      function exportColorBarSVG() {
        var gColorbarArea = document.createElement('g');

        if (!this.options.colorbarPosition || this.options.colorbarPosition === 'hidden') {
          // if there's no visible colorbar, we don't need to export anything
          return gColorbarArea;
        }

        // no value scale, no colorbar
        if (!this.valueScale) return gColorbarArea;

        gColorbarArea.setAttribute('transform', 'translate(' + this.pColorbarArea.x + ', ' + this.pColorbarArea.y + ')');

        gColorbarArea.setAttribute('transform', 'translate(' + this.pColorbarArea.x + ', ' + this.pColorbarArea.y + ')');

        var rectColorbarArea = document.createElement('rect');
        gColorbarArea.appendChild(rectColorbarArea);

        var gColorbar = document.createElement('g');
        gColorbarArea.appendChild(gColorbar);

        gColorbar.setAttribute('transform', 'translate(' + this.pColorbar.x + ', ' + this.pColorbar.y + ')');

        var colorbarAreaHeight = Math.min(this.dimensions[1], COLORBAR_MAX_HEIGHT);
        this.colorbarHeight = colorbarAreaHeight - 2 * COLORBAR_MARGIN;
        var colorbarAreaWidth = COLORBAR_WIDTH + COLORBAR_LABELS_WIDTH + 2 * COLORBAR_MARGIN;

        rectColorbarArea.setAttribute('x', 0);
        rectColorbarArea.setAttribute('y', 0);
        rectColorbarArea.setAttribute('width', colorbarAreaWidth);
        rectColorbarArea.setAttribute('height', colorbarAreaHeight);
        rectColorbarArea.setAttribute('style', 'fill: white; stroke-width: 0; opacity: 0.7');

        var posScale = (0, _d3Scale.scaleLinear)().domain([0, 255]).range([0, this.colorbarHeight]);
        var colorHeight = this.colorbarHeight / 256.0;

        for (var i = 0; i < 256; i++) {
          var rectColor = document.createElement('rect');
          gColorbar.appendChild(rectColor);

          rectColor.setAttribute('x', 0);
          rectColor.setAttribute('y', posScale(i));
          rectColor.setAttribute('width', COLORBAR_WIDTH);
          rectColor.setAttribute('height', colorHeight);
          rectColor.setAttribute('class', 'color-rect');

          rectColor.setAttribute('style', 'fill: rgb(' + this.colorScale[i][0] + ', ' + this.colorScale[i][1] + ', ' + this.colorScale[i][2] + ')');
        }

        var gAxisHolder = document.createElement('g');
        gColorbarArea.appendChild(gAxisHolder);
        gAxisHolder.setAttribute('transform', 'translate(' + this.axis.pAxis.position.x + ',' + this.axis.pAxis.position.y + ')');

        var gAxis = null;
        var axisValueScale = this.valueScale.copy().range([this.colorbarHeight, 0]);

        if (this.options.colorbarPosition === 'topLeft' || this.options.colorbarPosition === 'bottomLeft') {
          gAxis = this.axis.exportAxisRightSVG(axisValueScale, this.colorbarHeight);
        } else if (this.options.colorbarPosition === 'topRight' || this.options.colorbarPosition === 'bottomRight') {
          gAxis = this.axis.exportAxisLeftSVG(axisValueScale, this.colorbarHeight);
        }

        gAxisHolder.appendChild(gAxis);

        return gColorbarArea;
      }

      return exportColorBarSVG;
    }()

    /**
     * Convert the raw tile data to a rendered array of values which can be represented as a sprite.
     *
     * @param tile: The data structure containing all the tile information. Relevant to
     *              this function are tile.tileData = {'dense': [...], ...}
     *              and tile.graphics
     */

  }, {
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        _get(HeatmapTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HeatmapTiledPixiTrack.prototype), 'initTile', this).call(this, tile);

        if (this.scale.minValue == null || this.scale.maxValue == null)
          // no data present
          return;

        this.renderTile(tile);
      }

      return initTile;
    }()
  }, {
    key: 'renderTile',
    value: function () {
      function renderTile(tile) {
        var _this2 = this;

        var _getValueScale = (0, _TiledPixiTrack2.getValueScale)(this.options.heatmapValueScaling, this.scale.minValue, this.medianVisibleValue, this.scale.maxValue, 'log'),
            _getValueScale2 = _slicedToArray(_getValueScale, 2),
            scaleType = _getValueScale2[0],
            valueScale = _getValueScale2[1];

        this.valueScale = valueScale;
        var pseudocount = 0;

        if (scaleType == 'log') pseudocount = this.valueScale.domain()[0];

        this.limitedValueScale = this.valueScale.copy();

        if (this.options && typeof this.options.scaleStartPercent !== 'undefined' && typeof this.options.scaleEndPercent !== 'undefined') {
          this.limitedValueScale.domain([this.valueScale.domain()[0] + (this.valueScale.domain()[1] - this.valueScale.domain()[0]) * this.options.scaleStartPercent, this.valueScale.domain()[0] + (this.valueScale.domain()[1] - this.valueScale.domain()[0]) * this.options.scaleEndPercent]);
        }

        _services.tileProxy.tileDataToPixData(tile, this.limitedValueScale, pseudocount, // used as a pseudocount to prevent taking the log of 0
        this.colorScale, function (pixData) {
          // the tileData has been converted to pixData by the worker script and needs to be loaded
          // as a sprite
          var graphics = tile.graphics;
          var canvas = _this2.tileDataToCanvas(pixData);

          var sprite = null;

          sprite = new PIXI.Sprite(PIXI.Texture.fromCanvas(canvas, PIXI.SCALE_MODES.NEAREST));

          tile.sprite = sprite;

          // store the pixData so that we can export it
          tile.canvas = canvas;
          _this2.setSpriteProperties(tile.sprite, tile.tileData.zoomLevel, tile.tileData.tilePos, tile.mirrored);

          graphics.removeChildren();
          graphics.addChild(tile.sprite);
        });
      }

      return renderTile;
    }()
  }, {
    key: 'remove',
    value: function () {
      function remove() {
        /**
         * Remove this track from the view
         */
        this.gMain.remove();
        this.gMain = null;

        _get(HeatmapTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HeatmapTiledPixiTrack.prototype), 'remove', this).call(this);
      }

      return remove;
    }()
  }, {
    key: 'refScalesChanged',
    value: function () {
      function refScalesChanged(refXScale, refYScale) {
        _get(HeatmapTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HeatmapTiledPixiTrack.prototype), 'refScalesChanged', this).call(this, refXScale, refYScale);

        for (var uid in this.fetchedTiles) {
          var tile = this.fetchedTiles[uid];

          if (tile.sprite) {
            this.setSpriteProperties(tile.sprite, tile.tileData.zoomLevel, tile.tileData.tilePos, tile.mirrored);
          }
        }
      }

      return refScalesChanged;
    }()
  }, {
    key: 'superSVG',
    value: function () {
      function superSVG() {
        /**
         * Bypass this track's exportSVG function
         */
        return _get(HeatmapTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HeatmapTiledPixiTrack.prototype), 'exportSVG', this).call(this);
      }

      return superSVG;
    }()
  }, {
    key: 'exportSVG',
    value: function () {
      function exportSVG() {
        var track = null;
        var base = null;

        if (_get(HeatmapTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HeatmapTiledPixiTrack.prototype), 'exportSVG', this)) {
          var _get$call = _get(HeatmapTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HeatmapTiledPixiTrack.prototype), 'exportSVG', this).call(this);

          var _get$call2 = _slicedToArray(_get$call, 2);

          base = _get$call2[0];
          track = _get$call2[1];
        } else {
          base = document.createElement('g');
          track = base;
        }

        var output = document.createElement('g');
        track.appendChild(output);

        output.setAttribute('transform', 'translate(' + this.pMain.position.x + ',' + this.pMain.position.y + ') scale(' + this.pMain.scale.x + ',' + this.pMain.scale.y + ')');

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.visibleAndFetchedTiles()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var tile = _step2.value;

            var rotation = tile.sprite.rotation * 180 / Math.PI;
            var g = document.createElement('g');
            g.setAttribute('transform', 'translate(' + tile.sprite.x + ',' + tile.sprite.y + ') rotate(' + rotation + ') scale(' + tile.sprite.scale.x + ',' + tile.sprite.scale.y + ')');

            var image = document.createElement('image');
            image.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', tile.canvas.toDataURL());
            image.setAttribute('width', 256);
            image.setAttribute('height', 256);

            g.appendChild(image);
            output.appendChild(g);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var gColorbar = this.exportColorBarSVG();
        track.appendChild(gColorbar);

        return [base, base];
      }

      return exportSVG;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale, k, tx, ty) {
        _get(HeatmapTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HeatmapTiledPixiTrack.prototype), 'zoomed', this).call(this, newXScale, newYScale);

        this.pMain.position.x = tx; // translateX;
        this.pMain.position.y = ty; // translateY;

        this.pMain.scale.x = k; // scaleX;
        this.pMain.scale.y = k; // scaleY;

        this.drawColorbar();
      }

      return zoomed;
    }()
  }, {
    key: 'calculateVisibleTiles',
    value: function () {
      function calculateVisibleTiles() {
        var mirrorTiles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        // if we don't know anything about this dataset, no point
        // in trying to get tiles
        if (!this.tilesetInfo) {
          return;
        }

        this.zoomLevel = this.calculateZoomLevel();

        // this.zoomLevel = 0;
        if (this.tilesetInfo.resolutions) {
          var sortedResolutions = this.tilesetInfo.resolutions.map(function (x) {
            return +x;
          }).sort(function (a, b) {
            return b - a;
          });

          this.xTiles = _services.tileProxy.calculateTilesFromResolution(sortedResolutions[this.zoomLevel], this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);
          this.yTiles = _services.tileProxy.calculateTilesFromResolution(sortedResolutions[this.zoomLevel], this._yScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);

          //console.log('res', sortedResolutions[this.zoomLevel]);
          //console.log('this.xTiles:', this.xTiles);
        } else {
          this.xTiles = _services.tileProxy.calculateTiles(this.zoomLevel, this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0], this.tilesetInfo.max_zoom, this.tilesetInfo.max_width);

          this.yTiles = _services.tileProxy.calculateTiles(this.zoomLevel, this._yScale, this.tilesetInfo.min_pos[1], this.tilesetInfo.max_pos[1], this.tilesetInfo.max_zoom, this.tilesetInfo.max_width);
        }

        var rows = this.xTiles;
        var cols = this.yTiles;
        var zoomLevel = this.zoomLevel;

        // if we're mirroring tiles, then we only need tiles along the diagonal
        var tiles = [];
        // console.log('this.options:', this.options);

        // calculate the ids of the tiles that should be visible
        for (var i = 0; i < rows.length; i++) {
          for (var j = 0; j < cols.length; j++) {
            if (mirrorTiles) {
              if (rows[i] >= cols[j]) {
                // if we're in the upper triangular part of the matrix, then we need to load
                // a mirrored tile
                var newTile = [zoomLevel, cols[j], rows[i]];
                newTile.mirrored = true;
                newTile.dataTransform = this.options.dataTransform ? this.options.dataTransform : 'default';
                tiles.push(newTile);
              } else {
                // otherwise, load an original tile
                var _newTile = [zoomLevel, rows[i], cols[j]];
                _newTile.mirrored = false;
                _newTile.dataTransform = this.options.dataTransform ? this.options.dataTransform : 'default';
                tiles.push(_newTile);
              }

              if (rows[i] == cols[j]) {
                // on the diagonal, load original tiles
                var _newTile2 = [zoomLevel, rows[i], cols[j]];
                _newTile2.mirrored = false;
                _newTile2.dataTransform = this.options.dataTransform ? this.options.dataTransform : 'default';
                tiles.push(_newTile2);
              }
            } else {
              var _newTile3 = [zoomLevel, rows[i], cols[j]];
              _newTile3.mirrored = false;
              _newTile3.dataTransform = this.options.dataTransform ? this.options.dataTransform : 'default';

              tiles.push(_newTile3);
            }
          }
        }

        this.setVisibleTiles(tiles);
      }

      return calculateVisibleTiles;
    }()
  }, {
    key: 'getTilePosAndDimensions',
    value: function () {
      function getTilePosAndDimensions(zoomLevel, tilePos) {
        /**
             * Get the tile's position in its coordinate system.
             */

        if (this.tilesetInfo.resolutions) {
          var sortedResolutions = this.tilesetInfo.resolutions.map(function (x) {
            return +x;
          }).sort(function (a, b) {
            return b - a;
          });

          var chosenResolution = sortedResolutions[zoomLevel];

          var _tileWidth = chosenResolution * BINS_PER_TILE;
          var _tileHeight = _tileWidth;

          var _tileX = chosenResolution * BINS_PER_TILE * tilePos[0];
          var _tileY = chosenResolution * BINS_PER_TILE * tilePos[1];

          return { tileX: _tileX,
            tileY: _tileY,
            tileWidth: _tileWidth,
            tileHeight: _tileHeight };
        }

        var xTilePos = tilePos[0],
            yTilePos = tilePos[1];

        var totalWidth = this.tilesetInfo.max_width;
        var totalHeight = this.tilesetInfo.max_width;

        var minX = 0;
        var minY = 0;

        var tileWidth = totalWidth / Math.pow(2, zoomLevel);
        var tileHeight = totalHeight / Math.pow(2, zoomLevel);

        var tileX = minX + xTilePos * tileWidth;
        var tileY = minY + yTilePos * tileHeight;

        return { tileX: tileX,
          tileY: tileY,
          tileWidth: tileWidth,
          tileHeight: tileHeight };
      }

      return getTilePosAndDimensions;
    }()
  }, {
    key: 'calculateZoomLevel',
    value: function () {
      function calculateZoomLevel() {
        var minX = this.tilesetInfo.min_pos[0];
        var maxX = this.tilesetInfo.max_pos[0];

        var minY = this.tilesetInfo.min_pos[1];
        var maxY = this.tilesetInfo.max_pos[1];

        if (this.tilesetInfo.resolutions) {
          var zoomIndexX = _services.tileProxy.calculateZoomLevelFromResolutions(this.tilesetInfo.resolutions, this._xScale, minX, maxX);
          var zoomIndexY = _services.tileProxy.calculateZoomLevelFromResolutions(this.tilesetInfo.resolutions, this._yScale, minY, maxY);

          return Math.min(zoomIndexX, zoomIndexY);
        }

        var xZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);

        var yZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.tilesetInfo.min_pos[1], this.tilesetInfo.max_pos[1]);

        var zoomLevel = Math.max(xZoomLevel, yZoomLevel);
        zoomLevel = Math.min(zoomLevel, this.maxZoom);

        if (this.options && this.options.maxZoom) {
          if (this.options.maxZoom >= 0) {
            zoomLevel = Math.min(this.options.maxZoom, zoomLevel);
          } else {
            console.error('Invalid maxZoom on track:', this);
          }
        }

        return zoomLevel;
      }

      return calculateZoomLevel;
    }()
  }, {
    key: 'tileToLocalId',
    value: function () {
      function tileToLocalId(tile) {
        /*
         * The local tile identifier
         */

        // tile contains [zoomLevel, xPos, yPos]
        if (tile.dataTransform && tile.dataTransform != 'default') {
          return tile.join('.') + '.' + tile.mirrored + '.' + tile.dataTransform;
        }
        return tile.join('.') + '.' + tile.mirrored;
      }

      return tileToLocalId;
    }()
  }, {
    key: 'tileToRemoteId',
    value: function () {
      function tileToRemoteId(tile) {
        /**
         * The tile identifier used on the server
         */

        // tile contains [zoomLevel, xPos, yPos]
        if (tile.dataTransform && tile.dataTransform != 'default') {
          return tile.join('.') + '.' + tile.dataTransform;
        }
        return '' + tile.join('.');
      }

      return tileToRemoteId;
    }()
  }, {
    key: 'localToRemoteId',
    value: function () {
      function localToRemoteId(remoteId) {
        var idParts = remoteId.split('.');
        return idParts.slice(0, idParts.length - 1).join('.');
      }

      return localToRemoteId;
    }()
  }]);

  return HeatmapTiledPixiTrack;
}(_TiledPixiTrack2.TiledPixiTrack);

exports['default'] = HeatmapTiledPixiTrack;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AxisPixi = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _d3Format = __webpack_require__(46);

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TICK_HEIGHT = 40;
var TICK_MARGIN = 0;
var TICK_LENGTH = 5;
var TICK_LABEL_MARGIN = 4;

var AxisPixi = exports.AxisPixi = function () {
  function AxisPixi(track) {
    _classCallCheck(this, AxisPixi);

    this.pAxis = new PIXI.Graphics();
    this.track = track;

    this.axisTexts = [];
    this.axisTextFontFamily = 'Arial';
    this.axisTextFontSize = 10;

    this.tickFormat = (0, _d3Format.format)('.2');
    // hi
  }

  _createClass(AxisPixi, [{
    key: 'startAxis',
    value: function () {
      function startAxis(axisHeight) {
        var graphics = this.pAxis;

        graphics.clear();
        graphics.lineStyle(1, 0x000000, 1);

        // draw the axis line
        graphics.moveTo(0, 0);
        graphics.lineTo(0, axisHeight);
      }

      return startAxis;
    }()
  }, {
    key: 'createAxisTexts',
    value: function () {
      function createAxisTexts(valueScale, axisHeight) {
        this.tickValues = this.calculateAxisTickValues(valueScale, axisHeight);
        var i = 0;

        while (i < this.tickValues.length) {
          var tick = this.tickValues[i];

          while (this.axisTexts.length <= i) {
            var newText = new PIXI.Text(tick, { fontSize: this.axisTextFontSize + 'px',
              fontFamily: this.axisTextFontFamily,
              fill: 'black' });
            this.axisTexts.push(newText);

            this.pAxis.addChild(newText);
          }

          while (this.axisTexts.length > i + 1) {
            var lastText = this.axisTexts.pop();
            this.pAxis.removeChild(lastText);
          }

          this.axisTexts[i].text = this.tickFormat(tick);
          this.axisTexts[i].anchor.y = 0.5;
          this.axisTexts[i].anchor.x = 0.5;
          i++;
        }
      }

      return createAxisTexts;
    }()
  }, {
    key: 'calculateAxisTickValues',
    value: function () {
      function calculateAxisTickValues(valueScale, axisHeight) {
        var tickCount = Math.max(Math.ceil(axisHeight / TICK_HEIGHT), 1);
        var i = 0;

        // create scale ticks but not all the way to the top
        var tickValues = valueScale.ticks(tickCount);
        // console.log('valueScale', valueScale, tickValues, valueScale.domain());

        if (axisHeight < 100) {
          // console.log('short axis');
        }

        if (axisHeight > 100) {}
        // console.log('valueScale.domain()', valueScale.domain());
        // console.log('valueScale.range()', valueScale.range());
        // console.log('tickValues[0]', tickValues[0], 'tickValues[-1]', tickValues[tickValues.length-1]);


        /*
                ticks(valueScale.invert(MARGIN_BOTTOM),
                              valueScale.invert(this.dimensions[1] - MARGIN_TOP),
                              tickCount);
            */

        if (tickValues.length < 1) {
          tickValues = valueScale.ticks(tickCount + 1);
          /*
                tickValues = ticks(valueScale.invert(MARGIN_BOTTOM),
                              valueScale.invert(axisHeight - MARGIN_TOP),
                              tickCount + 1);
                */

          if (tickValues.length > 1) {
            // sometimes the ticks function will return 0 and then 2
            // if it didn't return enough previously, we probably only want a single
            // tick
            tickValues = [tickValues[0]];
          }
        }

        return tickValues;
      }

      return calculateAxisTickValues;
    }()
  }, {
    key: 'drawAxisLeft',
    value: function () {
      function drawAxisLeft(valueScale, axisHeight) {
        // Draw a left-oriented axis (ticks pointing to the right)
        this.startAxis(this.pAxis, axisHeight);
        this.createAxisTexts(valueScale, axisHeight);

        var graphics = this.pAxis;

        // draw the top, potentially unlabelled, ticke
        graphics.moveTo(0, 0);
        graphics.lineTo(-(TICK_MARGIN + TICK_LENGTH), 0);

        graphics.moveTo(0, axisHeight);
        graphics.lineTo(-(TICK_MARGIN + TICK_LENGTH), axisHeight);

        for (var i = 0; i < this.axisTexts.length; i++) {
          var tick = this.tickValues[i];

          // draw ticks to the left of the axis
          this.axisTexts[i].x = -(TICK_MARGIN + TICK_LENGTH + TICK_LABEL_MARGIN + this.axisTexts[i].width / 2);
          this.axisTexts[i].y = valueScale(tick);

          graphics.moveTo(-TICK_MARGIN, valueScale(tick));
          graphics.lineTo(-(TICK_MARGIN + TICK_LENGTH), valueScale(tick));

          if (this.track && this.track.flipText) {
            this.axisTexts[i].scale.x = -1;
          }
        }

        this.hideOverlappingAxisLabels();
      }

      return drawAxisLeft;
    }()
  }, {
    key: 'drawAxisRight',
    value: function () {
      function drawAxisRight(valueScale, axisHeight) {
        // Draw a right-oriented axis (ticks pointint to the left)
        this.startAxis(axisHeight);
        this.createAxisTexts(valueScale, axisHeight);

        var graphics = this.pAxis;

        // draw the top, potentially unlabelled, ticke
        graphics.moveTo(0, 0);
        graphics.lineTo(TICK_MARGIN + TICK_LENGTH, 0);

        graphics.moveTo(0, axisHeight);
        graphics.lineTo(TICK_MARGIN + TICK_LENGTH, axisHeight);

        for (var i = 0; i < this.axisTexts.length; i++) {
          var tick = this.tickValues[i];

          this.axisTexts[i].x = TICK_MARGIN + TICK_LENGTH + TICK_LABEL_MARGIN + this.axisTexts[i].width / 2;
          this.axisTexts[i].y = valueScale(tick);

          graphics.moveTo(TICK_MARGIN, valueScale(tick));
          graphics.lineTo(TICK_MARGIN + TICK_LENGTH, valueScale(tick));

          if (this.track && this.track.flipText) {
            this.axisTexts[i].scale.x = -1;
          }
        }

        this.hideOverlappingAxisLabels();
      }

      return drawAxisRight;
    }()
  }, {
    key: 'hideOverlappingAxisLabels',
    value: function () {
      function hideOverlappingAxisLabels() {
        // show all tick marks initially
        for (var i = this.axisTexts.length - 1; i >= 0; i--) {
          this.axisTexts[i].visible = true;
        }

        for (var _i = this.axisTexts.length - 1; _i >= 0; _i--) {
          // if this tick mark is invisible, it's not going to
          // overlap with any others
          if (!this.axisTexts[_i].visible) {
            continue;
          }

          var j = _i - 1;

          while (j >= 0) {
            // go through and hide all overlapping tick marks
            if (this.axisTexts[_i].y + this.axisTexts[_i].height / 2 > this.axisTexts[j].y - this.axisTexts[j].height / 2) {
              this.axisTexts[j].visible = false;
            } else {
              // because the tick marks are ordered from top to bottom, if this
              // one doesn't overlap, then the ones below it won't either, so
              // we can stop looking
              break;
            }

            j -= 1;
          }
        }
      }

      return hideOverlappingAxisLabels;
    }()
  }, {
    key: 'exportVerticalAxis',
    value: function () {
      function exportVerticalAxis(axisHeight) {
        var gAxis = document.createElement('g');
        gAxis.setAttribute('class', 'axis-vertical');

        var stroke = 'black';

        if (this.track) {
          stroke = this.track.options.lineStrokeColor ? this.track.options.lineStrokeColor : 'blue';
        }

        var line = document.createElement('path');

        line.setAttribute('fill', 'transparent');
        line.setAttribute('stroke', 'black');
        line.setAttribute('id', 'axis-line');

        line.setAttribute('d', 'M0,0 L0,' + axisHeight);

        gAxis.appendChild(line);

        return gAxis;
      }

      return exportVerticalAxis;
    }()
  }, {
    key: 'createAxisSVGLine',
    value: function () {
      function createAxisSVGLine() {
        // factor out the styling for axis lines
        var stroke = 'black';

        if (this.track) {
          stroke = this.track.options.lineStrokeColor ? this.track.options.lineStrokeColor : 'blue';
        }

        var line = document.createElement('path');
        line.setAttribute('id', 'tick-mark');
        line.setAttribute('fill', 'transparent');
        line.setAttribute('stroke', stroke);

        return line;
      }

      return createAxisSVGLine;
    }()
  }, {
    key: 'createAxisSVGText',
    value: function () {
      function createAxisSVGText(text) {
        // factor out the creation of axis texts
        var t = document.createElement('text');

        t.innerHTML = text;
        t.setAttribute('id', 'axis-text');
        t.setAttribute('text-anchor', 'middle');
        t.setAttribute('font-family', this.axisTextFontFamily);
        t.setAttribute('font-size', this.axisTextFontSize);
        t.setAttribute('dy', this.axisTextFontSize / 2 - 2);

        return t;
      }

      return createAxisSVGText;
    }()
  }, {
    key: 'exportAxisLeftSVG',
    value: function () {
      function exportAxisLeftSVG(valueScale, axisHeight) {
        var gAxis = this.exportVerticalAxis(axisHeight);

        var line = this.createAxisSVGLine();
        gAxis.appendChild(line);

        line.setAttribute('d', 'M0,0 L' + -(TICK_MARGIN + TICK_LENGTH) + ',0');

        for (var i = 0; i < this.axisTexts.length; i++) {
          var tick = this.tickValues[i];
          var text = this.axisTexts[i];

          var _line = this.createAxisSVGLine();

          gAxis.appendChild(_line);

          _line.setAttribute('d', 'M' + -TICK_MARGIN + ',' + valueScale(tick) + ' L' + -(TICK_MARGIN + TICK_LENGTH) + ',' + valueScale(tick));

          var g = document.createElement('g');
          gAxis.appendChild(g);
          if (text.visible) {
            var t = this.createAxisSVGText(text.text);
            g.appendChild(t);
          }

          g.setAttribute('transform', 'translate(' + text.position.x + ',' + text.position.y + ')\n             scale(' + text.scale.x + ',' + text.scale.y + ')');
        }

        return gAxis;
      }

      return exportAxisLeftSVG;
    }()
  }, {
    key: 'exportAxisRightSVG',
    value: function () {
      function exportAxisRightSVG(valueScale, axisHeight) {
        var gAxis = this.exportVerticalAxis(axisHeight);

        var line = this.createAxisSVGLine();
        gAxis.appendChild(line);

        line.setAttribute('d', 'M0,0 L' + (TICK_MARGIN + TICK_LENGTH) + ',0');

        for (var i = 0; i < this.axisTexts.length; i++) {
          var tick = this.tickValues[i];
          var text = this.axisTexts[i];

          var _line2 = this.createAxisSVGLine();

          gAxis.appendChild(_line2);

          _line2.setAttribute('d', 'M' + TICK_MARGIN + ',' + valueScale(tick) + ' L' + (TICK_MARGIN + TICK_LENGTH) + ',' + valueScale(tick));

          var g = document.createElement('g');
          gAxis.appendChild(g);

          if (text.visible) {
            var t = this.createAxisSVGText(text.text);
            g.appendChild(t);
          }

          g.setAttribute('transform', 'translate(' + text.position.x + ',' + text.position.y + ')\n             scale(' + text.scale.x + ',' + text.scale.y + ')');
        }

        return gAxis;
      }

      return exportAxisRightSVG;
    }()
  }, {
    key: 'clearAxis',
    value: function () {
      function clearAxis() {
        var graphics = this.pAxis;
        while (this.axisTexts.length) {
          var axisText = this.axisTexts.pop();
          graphics.removeChild(axisText);
        }

        graphics.clear();
      }

      return clearAxis;
    }()
  }]);

  return AxisPixi;
}();

exports['default'] = AxisPixi;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = boxIntersectWrapper

var pool = __webpack_require__(141)
var sweep = __webpack_require__(243)
var boxIntersectIter = __webpack_require__(654)

function boxEmpty(d, box) {
  for(var j=0; j<d; ++j) {
    if(!(box[j] <= box[j+d])) {
      return true
    }
  }
  return false
}

//Unpack boxes into a flat typed array, remove empty boxes
function convertBoxes(boxes, d, data, ids) {
  var ptr = 0
  var count = 0
  for(var i=0, n=boxes.length; i<n; ++i) {
    var b = boxes[i]
    if(boxEmpty(d, b)) {
      continue
    }
    for(var j=0; j<2*d; ++j) {
      data[ptr++] = b[j]
    }
    ids[count++] = i
  }
  return count
}

//Perform type conversions, check bounds
function boxIntersect(red, blue, visit, full) {
  var n = red.length
  var m = blue.length

  //If either array is empty, then we can skip this whole thing
  if(n <= 0 || m <= 0) {
    return
  }

  //Compute dimension, if it is 0 then we skip
  var d = (red[0].length)>>>1
  if(d <= 0) {
    return
  }

  var retval

  //Convert red boxes
  var redList  = pool.mallocDouble(2*d*n)
  var redIds   = pool.mallocInt32(n)
  n = convertBoxes(red, d, redList, redIds)

  if(n > 0) {
    if(d === 1 && full) {
      //Special case: 1d complete
      sweep.init(n)
      retval = sweep.sweepComplete(
        d, visit, 
        0, n, redList, redIds,
        0, n, redList, redIds)
    } else {

      //Convert blue boxes
      var blueList = pool.mallocDouble(2*d*m)
      var blueIds  = pool.mallocInt32(m)
      m = convertBoxes(blue, d, blueList, blueIds)

      if(m > 0) {
        sweep.init(n+m)

        if(d === 1) {
          //Special case: 1d bipartite
          retval = sweep.sweepBipartite(
            d, visit, 
            0, n, redList,  redIds,
            0, m, blueList, blueIds)
        } else {
          //General case:  d>1
          retval = boxIntersectIter(
            d, visit,    full,
            n, redList,  redIds,
            m, blueList, blueIds)
        }

        pool.free(blueList)
        pool.free(blueIds)
      }
    }

    pool.free(redList)
    pool.free(redIds)
  }

  return retval
}


var RESULT

function appendItem(i,j) {
  RESULT.push([i,j])
}

function intersectFullArray(x) {
  RESULT = []
  boxIntersect(x, x, appendItem, true)
  return RESULT
}

function intersectBipartiteArray(x, y) {
  RESULT = []
  boxIntersect(x, y, appendItem, false)
  return RESULT
}

//User-friendly wrapper, handle full input and no-visitor cases
function boxIntersectWrapper(arg0, arg1, arg2) {
  var result
  switch(arguments.length) {
    case 1:
      return intersectFullArray(arg0)
    case 2:
      if(typeof arg1 === 'function') {
        return boxIntersect(arg0, arg0, arg1, true)
      } else {
        return intersectBipartiteArray(arg0, arg1)
      }
    case 3:
      return boxIntersect(arg0, arg1, arg2, false)
    default:
      throw new Error('box-intersect: Invalid arguments')
  }
}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HorizontalLine1DPixiTrack = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _d3Scale = __webpack_require__(12);

var _HorizontalTiled1DPixiTrack = __webpack_require__(60);

var _HorizontalTiled1DPixiTrack2 = _interopRequireDefault(_HorizontalTiled1DPixiTrack);

var _utils = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HorizontalLine1DPixiTrack = exports.HorizontalLine1DPixiTrack = function (_HorizontalTiled1DPix) {
  _inherits(HorizontalLine1DPixiTrack, _HorizontalTiled1DPix);

  function HorizontalLine1DPixiTrack(scene, dataConfig, handleTilesetInfoReceived, option, animate, onValueScaleChanged) {
    _classCallCheck(this, HorizontalLine1DPixiTrack);

    return _possibleConstructorReturn(this, (HorizontalLine1DPixiTrack.__proto__ || Object.getPrototypeOf(HorizontalLine1DPixiTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, option, animate, onValueScaleChanged));
  }

  _createClass(HorizontalLine1DPixiTrack, [{
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        /**
         * Create whatever is needed to draw this tile.
         */
        _get(HorizontalLine1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalLine1DPixiTrack.prototype), 'initTile', this).call(this, tile);

        tile.lineXValues = new Array(tile.tileData.dense.length);
        tile.lineYValues = new Array(tile.tileData.dense.length);

        this.drawTile(tile);
      }

      return initTile;
    }()

    // destroyTile(tile) {

    // }

  }, {
    key: 'rerender',
    value: function () {
      function rerender(options) {
        this.options = options;

        _get(HorizontalLine1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalLine1DPixiTrack.prototype), 'draw', this).call(this);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.visibleAndFetchedTiles()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tile = _step.value;

            this.renderTile(tile);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return rerender;
    }()
  }, {
    key: 'renderTile',
    value: function () {
      function renderTile(tile) {
        // this function is just so that we follow the same pattern as
        // HeatmapTiledPixiTrack.js
        this.drawTile(tile);
      }

      return renderTile;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tile) {
        _get(HorizontalLine1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalLine1DPixiTrack.prototype), 'drawTile', this).call(this, tile);

        if (!tile.graphics) {
          return;
        }

        var graphics = tile.graphics;

        var _getTilePosAndDimensi = this.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos),
            tileX = _getTilePosAndDimensi.tileX,
            tileWidth = _getTilePosAndDimensi.tileWidth;

        var tileValues = tile.tileData.dense;

        if (tileValues.length === 0) {
          return;
        }

        var pseudocount = 0; // if we use a log scale, then we'll set a pseudocount
        // equal to the smallest non-zero value
        this.valueScale = this.makeValueScale(this.minValue(), this.calculateMedianVisibleValue(), this.maxValue());

        graphics.clear();

        this.drawAxis(this.valueScale);

        if (this.options.valueScaling === 'log' && this.valueScale.domain()[1] < 0) {
          console.warn('Negative values present when using a log scale', this.valueScale.domain());
          return;
        }

        var stroke = (0, _utils.colorToHex)(this.options.lineStrokeColor ? this.options.lineStrokeColor : 'blue');
        // this scale should go from an index in the data array to
        // a position in the genome coordinates
        var tileXScale = (0, _d3Scale.scaleLinear)().domain([0, this.tilesetInfo.tile_size]).range([tileX, tileX + tileWidth]);

        var strokeWidth = this.options.lineStrokeWidth ? this.options.lineStrokeWidth : 1;
        graphics.lineStyle(strokeWidth, stroke, 1);

        var logScaling = this.options.valueScaling === 'log';

        for (var i = 0; i < tileValues.length; i++) {
          var xPos = this._xScale(tileXScale(i));
          var yPos = this.valueScale(tileValues[i] + pseudocount);

          tile.lineXValues[i] = xPos;
          tile.lineYValues[i] = yPos;

          if (i === 0) {
            graphics.moveTo(xPos, yPos);
            continue;
          }

          if (tileXScale(i) > this.tilesetInfo.max_pos[0]) {
            // this data is in the last tile and extends beyond the length
            // of the coordinate system
            break;
          }

          if (logScaling && tileValues[i] === 0)
            // if we're using log scaling and there's a 0 value, we shouldn't draw it
            // because it's invalid
            {
              graphics.moveTo(xPos, yPos);
            } else {
            graphics.lineTo(xPos, yPos);
          }
        }
      }

      return drawTile;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(HorizontalLine1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalLine1DPixiTrack.prototype), 'setPosition', this).call(this, newPosition);

        this.pMain.position.y = this.position[1];
        this.pMain.position.x = this.position[0];
      }

      return setPosition;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        this.xScale(newXScale);
        this.yScale(newYScale);

        this.refreshTiles();

        this.draw();
      }

      return zoomed;
    }()
  }, {
    key: 'superSVG',
    value: function () {
      function superSVG() {
        /*
         * Bypass this track's exportSVG and call its parent's directly.
         */
        return _get(HorizontalLine1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalLine1DPixiTrack.prototype), 'exportSVG', this).call(this);
      }

      return superSVG;
    }()

    /**
     * Export an SVG representation of this track
     *
     * @returns {[DOMNode,DOMNode]} The two returned DOM nodes are both SVG
     * elements [base,track]. Base is a parent which contains track as a
     * child. Track is clipped with a clipping rectangle contained in base.
     *
     */

  }, {
    key: 'exportSVG',
    value: function () {
      function exportSVG() {
        var track = null;
        var base = null;

        if (_get(HorizontalLine1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalLine1DPixiTrack.prototype), 'exportSVG', this)) {
          var _get$call = _get(HorizontalLine1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalLine1DPixiTrack.prototype), 'exportSVG', this).call(this);

          var _get$call2 = _slicedToArray(_get$call, 2);

          base = _get$call2[0];
          track = _get$call2[1];
        } else {
          base = document.createElement('g');
          track = base;
        }

        base.setAttribute('class', 'exported-line-track');
        var output = document.createElement('g');

        track.appendChild(output);
        output.setAttribute('transform', 'translate(' + this.position[0] + ',' + this.position[1] + ')');

        var stroke = this.options.lineStrokeColor ? this.options.lineStrokeColor : 'blue';

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.visibleAndFetchedTiles()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var tile = _step2.value;

            var g = document.createElement('path');
            g.setAttribute('fill', 'transparent');
            g.setAttribute('stroke', stroke);
            var d = 'M' + tile.lineXValues[0] + ' ' + tile.lineYValues[0];
            for (var i = 0; i < tile.lineXValues.length; i++) {
              d += 'L' + tile.lineXValues[i] + ' ' + tile.lineYValues[i];
            }
            g.setAttribute('d', d);
            output.appendChild(g);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var gAxis = document.createElement('g');
        gAxis.setAttribute('id', 'axis');

        // append the axis to base so that it's not clipped
        base.appendChild(gAxis);
        gAxis.setAttribute('transform', 'translate(' + this.axis.pAxis.position.x + ', ' + this.axis.pAxis.position.y + ')');

        // add the axis to the export
        if (this.options.axisPositionHorizontal === 'left' || this.options.axisPositionVertical === 'top') {
          // left axis are shown at the beginning of the plot
          var gDrawnAxis = this.axis.exportAxisLeftSVG(this.valueScale, this.dimensions[1]);
          gAxis.appendChild(gDrawnAxis);
        } else if (this.options.axisPositionHorizontal === 'right' || this.options.axisPositionVertical === 'bottom') {
          var _gDrawnAxis = this.axis.exportAxisRightSVG(this.valueScale, this.dimensions[1]);
          gAxis.appendChild(_gDrawnAxis);
        }

        return [base, track];
      }

      return exportSVG;
    }()
  }]);

  return HorizontalLine1DPixiTrack;
}(_HorizontalTiled1DPixiTrack2['default']);

exports['default'] = HorizontalLine1DPixiTrack;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SearchField = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _d3Array = __webpack_require__(10);

var _d3Format = __webpack_require__(46);

var _utils = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SearchField = exports.SearchField = function () {
  function SearchField(chromInfo) {
    _classCallCheck(this, SearchField);

    this.chromInfo = chromInfo;
    this.chromInfoBisector = (0, _d3Array.bisector)(function (d) {
      return d.pos;
    }).left;
  }

  _createClass(SearchField, [{
    key: 'scalesToPositionText',
    value: function () {
      function scalesToPositionText(xScale, yScale) {
        var twoD = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (this.chromInfo == null) {
          return '';
        } // chromosome info hasn't been loaded yet

        if (!xScale || !yScale) {
          return '';
        }

        var x1 = (0, _utils.absToChr)(xScale.domain()[0], this.chromInfo);
        var x2 = (0, _utils.absToChr)(xScale.domain()[1], this.chromInfo);

        var y1 = (0, _utils.absToChr)(yScale.domain()[0], this.chromInfo);
        var y2 = (0, _utils.absToChr)(yScale.domain()[1], this.chromInfo);

        var positionString = null;
        var stringFormat = (0, _d3Format.format)(',d');

        if (x1[0] != x2[0]) {
          // different chromosomes

          positionString = x1[0] + ':' + stringFormat(Math.floor(x1[1])) + '-' + x2[0] + ':' + stringFormat(Math.ceil(x2[1]));
        } else {
          // same chromosome

          positionString = x1[0] + ':' + stringFormat(Math.floor(x1[1])) + '-' + stringFormat(Math.ceil(x2[1]));
        }

        if (twoD) {
          if (y1[0] != y2[0]) {
            // different chromosomes
            positionString += ' & ' + y1[0] + ':' + stringFormat(Math.floor(y1[1])) + '-' + y2[0] + ':' + stringFormat(Math.ceil(y2[1]));
          } else {
            // same chromosome
            positionString += ' & ' + y1[0] + ':' + stringFormat(Math.floor(y1[1])) + '-' + stringFormat(Math.ceil(y2[1]));
          }
        }

        if (x1[2] <= 0 || x2[2] > 0 || twoD && (y1[2] <= 0 || y2[2] > 0)) {
          // did any of the coordinates exceed the genome boundaries
          positionString += ' [offset ' + x1[2] + ',' + x2[2];
          if (twoD) {
            positionString += ':' + y1[2] + ',' + y2[2];
          }

          positionString += ']';
        }

        return positionString;
      }

      return scalesToPositionText;
    }()
  }, {
    key: 'parsePosition',
    value: function () {
      function parsePosition(positionText) {
        var prevChr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        // Parse chr:position strings...
        // i.e. chr1:1000
        // or   chr2:20000
        var positionParts = positionText.split(':');
        var chr = null;
        var pos = 0;

        if (positionParts.length > 1) {
          chr = positionParts[0];
          pos = +positionParts[1].replace(/,/g, ''); // chromosome specified
        } else {
          if (positionParts[0] in this.chromInfo.chrPositions) {
            // is this an entire chromosome
            chr = positionParts[0];
            pos = 0;

            if (prevChr != null) {
              // this chromosome is part of a range so we actually
              // want to search to the end of it
              pos = +this.chromInfo.chromLengths[chr];
            }
          } else {
            // no it's just a position without a chromosome
            pos = +positionParts[0].replace(/,/g, ''); // no chromosome specified
            chr = null;

            if (prevChr) chr = prevChr;
          }
        }

        var retPos = null;

        if (isNaN(pos)) {
          retPos = null;
        }

        // queries like chr1:1000-2000
        if (chr == null) {
          chr = prevChr;
        }

        if (chr == null) {
          // no chromosome provided, so this is just a number
          retPos = pos;
        } else if (chr in this.chromInfo.chrPositions) {
          // chromosome provided, everything is fine
          retPos = this.chromInfo.chrPositions[chr].pos + pos;
        } else {
          // provided chromosome doesn't exit

          // console.log("Search error: No chromInfo specified or chromosome (" + chr + ") not in chromInfo");
          retPos = null;
        }

        // retPos is the genome position of this pair
        return [chr, pos, retPos];
      }

      return parsePosition;
    }()
  }, {
    key: 'matchRangesToLarger',
    value: function () {
      function matchRangesToLarger(range1, range2) {
        // if one range is wider than the other, then adjust the other
        // so that it is just as wide
        var smaller = null,
            larger = null;

        if (range1[1] - range1[0] < range2[1] - range2[0]) {
          var _toExpand = range2[1] - range2[0] - (range1[1] - range1[0]);
          return [[range1[0] - _toExpand / 2, range1[1] + _toExpand / 2], range2];
        }
        var toExpand = range1[1] - range1[0] - (range2[1] - range2[0]);
        return [range1, [range2[0] - toExpand / 2, range2[1] + toExpand / 2]];
      }

      return matchRangesToLarger;
    }()
  }, {
    key: 'getSearchRange',
    value: function () {
      function getSearchRange(term) {
        // Get the genomic regions associated with this term
        // Example terms:
        // tp53
        // tp53 (nm_000546)
        // tp53 to adh1b
        // tp53 (nm_000546) to adh1b

        if (term.length == 0) {
          return null;
        }

        // shitty ass regex to deal with negative positions 
        // (which aren't even valid genomic coordinates)
        var parts = term.split('-'); // split on a
        parts = parts.filter(function (d) {
          return d.length > 0;
        });

        var pos1 = null,
            pos2 = null;
        var range = null;

        if (parts[0].indexOf('-') == 0) {
          parts[0] = parts[0].slice(3, parts[0].length);
        }

        if (parts.length > 1) {
          // calculate the range in one direction
          var _parsePosition = this.parsePosition(parts[0]),
              _parsePosition2 = _slicedToArray(_parsePosition, 3),
              chr1 = _parsePosition2[0],
              chrPos1 = _parsePosition2[1],
              genomePos1 = _parsePosition2[2];

          var _parsePosition3 = this.parsePosition(parts[1], chr1),
              _parsePosition4 = _slicedToArray(_parsePosition3, 3),
              chr2 = _parsePosition4[0],
              chrPos2 = _parsePosition4[1],
              genomePos2 = _parsePosition4[2];

          var tempRange1 = [genomePos1, genomePos2];

          var _parsePosition5 = this.parsePosition(parts[1]);

          var _parsePosition6 = _slicedToArray(_parsePosition5, 3);

          chr1 = _parsePosition6[0];
          chrPos1 = _parsePosition6[1];
          genomePos1 = _parsePosition6[2];

          var _parsePosition7 = this.parsePosition(parts[0], chr1);

          var _parsePosition8 = _slicedToArray(_parsePosition7, 3);

          chr2 = _parsePosition8[0];
          chrPos2 = _parsePosition8[1];
          genomePos2 = _parsePosition8[2];


          if (chr1 == null && chr2 != null) {
            var _parsePosition9 = this.parsePosition(parts[1], chr2);
            // somembody entered a string like chr17:1000-2000
            // and when we try to search the rever, the first chromosome
            // is null
            // we have to pass in the previous chromosome as a prevChrom


            var _parsePosition10 = _slicedToArray(_parsePosition9, 3);

            chr1 = _parsePosition10[0];
            chrPos1 = _parsePosition10[1];
            genomePos1 = _parsePosition10[2];
          }

          var tempRange2 = [genomePos1, genomePos2];

          // return the wider of the two ranges
          // e.g. searching for chr1-chr2 vs chr2-chr1
          if (tempRange2[1] - tempRange2[0] > tempRange1[1] - tempRange1[0]) return tempRange2;else return tempRange1;
        } else {
          // only a locus specified and no range
          // is the locus an entire chromosome?

          if (parts[0] in this.chromInfo.chrPositions) {
            var chromPosition = this.chromInfo.chrPositions[parts[0]].pos;

            // if somebody has entered an entire chromosome, we return
            // it's length as the range
            range = [+chromPosition, +chromPosition + +this.chromInfo.chromLengths[parts[0]]];
          } else {
            // e.g. ("chr1:540340")
            var _parsePosition11 = this.parsePosition(parts[0]),
                _parsePosition12 = _slicedToArray(_parsePosition11, 3),
                _chr = _parsePosition12[0],
                _chrPos = _parsePosition12[1],
                _pos = _parsePosition12[2];

            range = [_pos - 8000000, _pos + 8000000];
          }
        }

        if (range[0] > range[1]) {
          return [range[1], range[0]];
        }

        return range;
      }

      return getSearchRange;
    }()
  }, {
    key: 'parseOffset',
    value: function () {
      function parseOffset(offsetText) {
        /**
             * Convert offset text to a 2D array of offsets
             *
             * @param offsetText(string): 14,17:20,22
             *
             * @return offsetArray: [[14,17],[20,22]]
             */

        var parts = offsetText.split(':');
        // console.log('parseOffset parts:', parts);

        if (parts.length == 0) {
          return [[0, 0], [0, 0]];
        }

        if (parts.length == 1) {
          var sparts = parts[0].split(',');
          return [[+sparts[0], +sparts[1]], [0, 0]];
        }
        var sparts0 = parts[0].split(',');
        var sparts1 = parts[1].split(',');
        return [[+sparts0[0], +sparts0[1]], [+sparts1[0], +sparts1[1]]];

        return [[0, 0], [0, 0]];
      }

      return parseOffset;
    }()
  }, {
    key: 'searchPosition',
    value: function () {
      function searchPosition(text) {
        var range1 = null,
            range2 = null;
        text = text.trim(); // remove whitespace from the ends of the string

        // extract offset
        var offsetRe = /\[offset\ (.+?)\]/.exec(text);

        // the offset is the distance before the first chromosome
        // or the distance after the last chromosome of the given
        var offset = [[0, 0], [0, 0]];
        if (offsetRe) {
          text = text.replace(offsetRe[0], '');

          //
          offset = this.parseOffset(offsetRe[1]);
        }

        var parts = text.split(' & ');

        if (parts.length > 1) {
          // we need to move both axes
          // although it's possible that the first axis will be empty
          // i.e. someone enters " and p53"
          // in that case, we only move the second axis and keep the first where it is
          range1 = this.getSearchRange(parts[0].split(' ')[0]);
          range2 = this.getSearchRange(parts[1].split(' ')[0]);
        } else {
          // we just need to position the first axis
          range1 = this.getSearchRange(parts[0]);
        }

        if (range1 != null && range2 != null) {
          var _matchRangesToLarger = this.matchRangesToLarger(range1, range2);

          var _matchRangesToLarger2 = _slicedToArray(_matchRangesToLarger, 2);

          range1 = _matchRangesToLarger2[0];
          range2 = _matchRangesToLarger2[1];
        }

        if (range1) {
          range1[0] += offset[0][0];
          range1[1] += offset[0][1];
        }

        if (range2) {
          range2[0] += offset[1][0];
          range2[1] += offset[1][1];
        }

        return [range1, range2];
      }

      return searchPosition;
    }()
  }]);

  return SearchField;
}();

exports['default'] = SearchField;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__namespaces__ = __webpack_require__(91);


/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return __WEBPACK_IMPORTED_MODULE_0__namespaces__["a" /* default */].hasOwnProperty(prefix) ? {space: __WEBPACK_IMPORTED_MODULE_0__namespaces__["a" /* default */][prefix], local: name} : name;
});


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ __webpack_exports__["a"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function none() {}

/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
});


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
});


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return event; });
/* harmony export (immutable) */ __webpack_exports__["a"] = customEvent;
var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["b"] = (function(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
});

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection_on__ = __webpack_require__(94);


/* harmony default export */ __webpack_exports__["a"] = (function() {
  var current = __WEBPACK_IMPORTED_MODULE_0__selection_on__["c" /* event */], source;
  while (source = current.sourceEvent) current = source;
  return current;
});


/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(51);


/* harmony default export */ __webpack_exports__["a"] = (function(values, p, valueof) {
  if (valueof == null) valueof = __WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */];
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
});


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__map__ = __webpack_require__(28);


/* unused harmony default export */ var _unused_webpack_default_export = (function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = Object(__WEBPACK_IMPORTED_MODULE_0__map__["a" /* default */])(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();
    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
});

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return Object(__WEBPACK_IMPORTED_MODULE_0__map__["a" /* default */])();
}

function setMap(map, key, value) {
  map.set(key, value);
}


/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__map__ = __webpack_require__(28);


function Set() {}

var proto = __WEBPACK_IMPORTED_MODULE_0__map__["a" /* default */].prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[__WEBPACK_IMPORTED_MODULE_0__map__["b" /* prefix */] + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume its an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

/* unused harmony default export */ var _unused_webpack_default_export = (set);


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony default export */ var _unused_webpack_default_export = (function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
});


/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony default export */ var _unused_webpack_default_export = (function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
});


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony default export */ var _unused_webpack_default_export = (function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
});


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rgb__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__array__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__date__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__number__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__object__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__string__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__constant__ = __webpack_require__(169);









/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? Object(__WEBPACK_IMPORTED_MODULE_7__constant__["a" /* default */])(b)
      : (t === "number" ? __WEBPACK_IMPORTED_MODULE_4__number__["a" /* default */]
      : t === "string" ? ((c = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["color"])(b)) ? (b = c, __WEBPACK_IMPORTED_MODULE_1__rgb__["a" /* default */]) : __WEBPACK_IMPORTED_MODULE_6__string__["a" /* default */])
      : b instanceof __WEBPACK_IMPORTED_MODULE_0_d3_color__["color"] ? __WEBPACK_IMPORTED_MODULE_1__rgb__["a" /* default */]
      : b instanceof Date ? __WEBPACK_IMPORTED_MODULE_3__date__["a" /* default */]
      : Array.isArray(b) ? __WEBPACK_IMPORTED_MODULE_2__array__["a" /* default */]
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? __WEBPACK_IMPORTED_MODULE_5__object__["a" /* default */]
      : __WEBPACK_IMPORTED_MODULE_4__number__["a" /* default */])(a, b);
});


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Color;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return darker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return brighter; });
/* harmony export (immutable) */ __webpack_exports__["e"] = color;
/* harmony export (immutable) */ __webpack_exports__["h"] = rgbConvert;
/* harmony export (immutable) */ __webpack_exports__["g"] = rgb;
/* harmony export (immutable) */ __webpack_exports__["b"] = Rgb;
/* unused harmony export hslConvert */
/* harmony export (immutable) */ __webpack_exports__["f"] = hsl;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__define__ = __webpack_require__(104);


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

Object(__WEBPACK_IMPORTED_MODULE_0__define__["a" /* default */])(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

Object(__WEBPACK_IMPORTED_MODULE_0__define__["a" /* default */])(Rgb, rgb, Object(__WEBPACK_IMPORTED_MODULE_0__define__["b" /* extend */])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(__WEBPACK_IMPORTED_MODULE_0__define__["a" /* default */])(Hsl, hsl, Object(__WEBPACK_IMPORTED_MODULE_0__define__["b" /* extend */])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = extend;
/* harmony default export */ __webpack_exports__["a"] = (function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = basis;
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ __webpack_exports__["b"] = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
});


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_interval__ = __webpack_require__(13);
/* unused harmony reexport timeInterval */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_millisecond__ = __webpack_require__(336);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__src_millisecond__["a"]; });
/* unused harmony reexport timeMilliseconds */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_1__src_millisecond__["a"]; });
/* unused harmony reexport utcMilliseconds */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_second__ = __webpack_require__(337);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_2__src_second__["a"]; });
/* unused harmony reexport timeSeconds */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __WEBPACK_IMPORTED_MODULE_2__src_second__["a"]; });
/* unused harmony reexport utcSeconds */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_minute__ = __webpack_require__(338);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_3__src_minute__["a"]; });
/* unused harmony reexport timeMinutes */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_hour__ = __webpack_require__(339);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_4__src_hour__["a"]; });
/* unused harmony reexport timeHours */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_day__ = __webpack_require__(340);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_5__src_day__["a"]; });
/* unused harmony reexport timeDays */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_week__ = __webpack_require__(341);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["b"]; });
/* unused harmony reexport timeWeeks */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["b"]; });
/* unused harmony reexport timeSundays */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["a"]; });
/* unused harmony reexport timeMondays */
/* unused harmony reexport timeTuesday */
/* unused harmony reexport timeTuesdays */
/* unused harmony reexport timeWednesday */
/* unused harmony reexport timeWednesdays */
/* unused harmony reexport timeThursday */
/* unused harmony reexport timeThursdays */
/* unused harmony reexport timeFriday */
/* unused harmony reexport timeFridays */
/* unused harmony reexport timeSaturday */
/* unused harmony reexport timeSaturdays */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_month__ = __webpack_require__(342);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_7__src_month__["a"]; });
/* unused harmony reexport timeMonths */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_year__ = __webpack_require__(343);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_8__src_year__["a"]; });
/* unused harmony reexport timeYears */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_utcMinute__ = __webpack_require__(344);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return __WEBPACK_IMPORTED_MODULE_9__src_utcMinute__["a"]; });
/* unused harmony reexport utcMinutes */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_utcHour__ = __webpack_require__(345);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_10__src_utcHour__["a"]; });
/* unused harmony reexport utcHours */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_utcDay__ = __webpack_require__(346);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_11__src_utcDay__["a"]; });
/* unused harmony reexport utcDays */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__ = __webpack_require__(347);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["b"]; });
/* unused harmony reexport utcWeeks */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["b"]; });
/* unused harmony reexport utcSundays */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["a"]; });
/* unused harmony reexport utcMondays */
/* unused harmony reexport utcTuesday */
/* unused harmony reexport utcTuesdays */
/* unused harmony reexport utcWednesday */
/* unused harmony reexport utcWednesdays */
/* unused harmony reexport utcThursday */
/* unused harmony reexport utcThursdays */
/* unused harmony reexport utcFriday */
/* unused harmony reexport utcFridays */
/* unused harmony reexport utcSaturday */
/* unused harmony reexport utcSaturdays */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_utcMonth__ = __webpack_require__(348);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return __WEBPACK_IMPORTED_MODULE_13__src_utcMonth__["a"]; });
/* unused harmony reexport utcMonths */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_utcYear__ = __webpack_require__(349);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return __WEBPACK_IMPORTED_MODULE_14__src_utcYear__["a"]; });
/* unused harmony reexport utcYears */































/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return timeFormat; });
/* unused harmony export timeParse */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return utcParse; });
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__locale__ = __webpack_require__(182);


var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = Object(__WEBPACK_IMPORTED_MODULE_0__locale__["a" /* default */])(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}


/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ __webpack_exports__["a"] = (dispatch);


/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__type__ = __webpack_require__(23);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__type__["a" /* default */])("text/html", function(xhr) {
  return document.createRange().createContextualFragment(xhr.responseText);
}));


/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__type__ = __webpack_require__(23);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__type__["a" /* default */])("application/json", function(xhr) {
  return JSON.parse(xhr.responseText);
}));


/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__type__ = __webpack_require__(23);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__type__["a" /* default */])("text/plain", function(xhr) {
  return xhr.responseText;
}));


/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__type__ = __webpack_require__(23);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__type__["a" /* default */])("application/xml", function(xhr) {
  var xml = xhr.responseXML;
  if (!xml) throw new Error("parse error");
  return xml;
}));


/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dsv__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dsv__ = __webpack_require__(55);



/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_1__dsv__["a" /* default */])("text/csv", __WEBPACK_IMPORTED_MODULE_0_d3_dsv__["csvParse"]));


/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return csvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return csvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return csvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return csvFormatRows; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dsv__ = __webpack_require__(34);


var csv = Object(__WEBPACK_IMPORTED_MODULE_0__dsv__["a" /* default */])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatRows = csv.formatRows;


/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return tsvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return tsvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return tsvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return tsvFormatRows; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dsv__ = __webpack_require__(34);


var tsv = Object(__WEBPACK_IMPORTED_MODULE_0__dsv__["a" /* default */])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatRows = tsv.formatRows;


/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dsv__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dsv__ = __webpack_require__(55);



/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_1__dsv__["a" /* default */])("text/tab-separated-values", __WEBPACK_IMPORTED_MODULE_0_d3_dsv__["tsvParse"]));


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = isEqual;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35), __webpack_require__(70)(module)))

/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_drag__ = __webpack_require__(383);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return __WEBPACK_IMPORTED_MODULE_0__src_drag__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_nodrag__ = __webpack_require__(191);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return __WEBPACK_IMPORTED_MODULE_1__src_nodrag__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return __WEBPACK_IMPORTED_MODULE_1__src_nodrag__["b"]; });




/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = now;
/* harmony export (immutable) */ __webpack_exports__["a"] = Timer;
/* harmony export (immutable) */ __webpack_exports__["c"] = timer;
/* unused harmony export timerFlush */
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, delay);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clockNow, interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TrackControl = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _getClassName2 = __webpack_require__(36);

var _getClassName3 = _interopRequireDefault(_getClassName2);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(8);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactSortableHoc = __webpack_require__(47);

__webpack_require__(514);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _styleModuleImportMap = {
  '../styles/TrackControl.module.scss': {
    'track-control': 'TrackControl-module_track-control-2zDf3',
    'track-control-vertical': 'TrackControl-module_track-control-vertical-2McB_',
    'track-control-left': 'TrackControl-module_track-control-left-zHd9W',
    'track-control-active': 'TrackControl-module_track-control-active-2JD9i TrackControl-module_track-control-2zDf3',
    'track-control-vertical-active': 'TrackControl-module_track-control-vertical-active-1QCKn',
    'track-control-padding-right': 'TrackControl-module_track-control-padding-right-2p6Lp',
    'track-control-button': 'TrackControl-module_track-control-button-2fdIb',
    'track-control-button-vertical': 'TrackControl-module_track-control-button-vertical-1s22z'
  }
};

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Styles


var TrackControl = exports.TrackControl = function (_React$Component) {
  _inherits(TrackControl, _React$Component);

  function TrackControl() {
    _classCallCheck(this, TrackControl);

    return _possibleConstructorReturn(this, (TrackControl.__proto__ || Object.getPrototypeOf(TrackControl)).apply(this, arguments));
  }

  _createClass(TrackControl, [{
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        var className = this.props.isVisible ? 'track-control-active' : 'track-control';

        className += this.props.isAlignLeft ? ' track-control-left' : '';

        className += this.props.isVertical ? ' track-control-vertical' : '';

        className += this.props.paddingRight ? ' track-control-padding-right' : '';

        var buttonClassName = 'track-control-button';

        buttonClassName += this.props.isVertical ? ' track-control-button-vertical' : '';

        var Handle = (0, _reactSortableHoc.SortableHandle)(function () {
          return _react2['default'].createElement(
            'svg',
            {
              style: _this2.props.imgStyleMove,
              className: 'no-zoom ' + (0, _getClassName3['default'])(buttonClassName, _styleModuleImportMap)
            },
            _react2['default'].createElement('use', { xlinkHref: '#move' })
          );
        });

        return _react2['default'].createElement(
          'div',
          {
            className: (0, _getClassName3['default'])(className, _styleModuleImportMap)
          },
          this.props.isMoveable && _react2['default'].createElement(Handle, null),
          _react2['default'].createElement(
            'svg',
            {
              onClick: function () {
                function onClick() {
                  var imgDom = _reactDom2['default'].findDOMNode(_this2.imgConfig);
                  var bbox = imgDom.getBoundingClientRect();
                  _this2.props.onConfigTrackMenuOpened(_this2.props.uid, bbox);
                }

                return onClick;
              }(),
              ref: function () {
                function ref(c) {
                  _this2.imgConfig = c;
                }

                return ref;
              }(),
              style: this.props.imgStyleSettings,
              className: 'no-zoom ' + (0, _getClassName3['default'])(buttonClassName, _styleModuleImportMap)
            },
            _react2['default'].createElement('use', { xlinkHref: '#cog' })
          ),
          _react2['default'].createElement(
            'svg',
            {
              onClick: function () {
                function onClick() {
                  return _this2.props.onAddSeries(_this2.props.uid);
                }

                return onClick;
              }(),
              ref: function () {
                function ref(c) {
                  _this2.imgAdd = c;
                }

                return ref;
              }(),
              style: this.props.imgStyleAdd,
              className: 'no-zoom ' + (0, _getClassName3['default'])(buttonClassName, _styleModuleImportMap)
            },
            _react2['default'].createElement('use', { xlinkHref: '#plus' })
          ),
          _react2['default'].createElement(
            'svg',
            {
              onClick: function () {
                function onClick() {
                  var imgDom = _reactDom2['default'].findDOMNode(_this2.imgClose);
                  var bbox = imgDom.getBoundingClientRect();
                  _this2.props.onCloseTrackMenuOpened(_this2.props.uid, bbox);
                }

                return onClick;
              }(),
              ref: function () {
                function ref(c) {
                  _this2.imgClose = c;
                }

                return ref;
              }(),
              style: this.props.imgStyleClose,
              className: 'no-zoom ' + (0, _getClassName3['default'])(buttonClassName, _styleModuleImportMap)
            },
            _react2['default'].createElement('use', { xlinkHref: '#cross' })
          )
        );
      }

      return render;
    }()
  }]);

  return TrackControl;
}(_react2['default'].Component);

TrackControl.propTypes = {
  imgStyleAdd: _propTypes2['default'].object,
  imgStyleClose: _propTypes2['default'].object,
  imgStyleMove: _propTypes2['default'].object,
  imgStyleSettings: _propTypes2['default'].object,
  isAlignLeft: _propTypes2['default'].bool,
  isMoveable: _propTypes2['default'].bool,
  isVertical: _propTypes2['default'].bool,
  isVisible: _propTypes2['default'].bool,
  onConfigTrackMenuOpened: _propTypes2['default'].func,
  onCloseTrackMenuOpened: _propTypes2['default'].func,
  onAddSeries: _propTypes2['default'].func,
  paddingRight: _propTypes2['default'].bool,
  uid: _propTypes2['default'].string
};

exports['default'] = TrackControl;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(74),
    stackClear = __webpack_require__(433),
    stackDelete = __webpack_require__(434),
    stackGet = __webpack_require__(435),
    stackHas = __webpack_require__(436),
    stackSet = __webpack_require__(437);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(37),
    root = __webpack_require__(18);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(444),
    mapCacheDelete = __webpack_require__(451),
    mapCacheGet = __webpack_require__(453),
    mapCacheHas = __webpack_require__(454),
    mapCacheSet = __webpack_require__(455);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 127 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(464),
    stubArray = __webpack_require__(207);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(466),
    isObjectLike = __webpack_require__(39);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(18),
    stubFalse = __webpack_require__(467);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(70)(module)))

/***/ }),
/* 131 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 132 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 133 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(15),
    isSymbol = __webpack_require__(57);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 135 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var baseForOwn = __webpack_require__(220),
    castFunction = __webpack_require__(224);

/**
 * Iterates over own enumerable string keyed properties of an object and
 * invokes `iteratee` for each property. The iteratee is invoked with three
 * arguments: (value, key, object). Iteratee functions may exit iteration
 * early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forOwnRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forOwn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forOwn(object, iteratee) {
  return object && baseForOwn(object, castFunction(iteratee));
}

module.exports = forOwn;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(211);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(202);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 139 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"track-range-selection":"Track-module_track-range-selection-1yrDf","track-range-selection-active":"Track-module_track-range-selection-active-1oljJ Track-module_track-range-selection-1yrDf","track-range-selection-active-primary":"Track-module_track-range-selection-active-primary-29M73 Track-module_track-range-selection-active-1oljJ Track-module_track-range-selection-1yrDf","track-range-selection-active-secondary":"Track-module_track-range-selection-active-secondary-1s0t5 Track-module_track-range-selection-active-1oljJ Track-module_track-range-selection-1yrDf","track-range-selection-group-inactive":"Track-module_track-range-selection-group-inactive-YNRM4"};

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Track = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _d3Scale = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Track = exports.Track = function () {
  function Track() {
    _classCallCheck(this, Track);

    this._xScale = (0, _d3Scale.scaleLinear)();
    this._yScale = (0, _d3Scale.scaleLinear)();

    // reference scales used for tracks that can translate and scale
    // their graphics
    // They will draw their graphics on the reference scales and then translate
    // and pan them as needed
    this._refXScale = (0, _d3Scale.scaleLinear)();
    this._refYScale = (0, _d3Scale.scaleLinear)();

    this.position = [0, 0];
    this.dimensions = [1, 1];
    this.options = {};
  }

  _createClass(Track, [{
    key: 'setDimensions',
    value: function () {
      function setDimensions(newDimensions) {
        this.dimensions = newDimensions;

        this._xScale.range([0, this.dimensions[0]]);
        this._yScale.range([0, this.dimensions[1]]);
      }

      return setDimensions;
    }()

    /**
     * Either get or set the reference xScale
     */

  }, {
    key: 'refXScale',
    value: function () {
      function refXScale(_) {
        if (!arguments.length) return this._refXScale;

        this._refXScale = _;

        return this;
      }

      return refXScale;
    }()

    /**
     * Either get or set the reference yScale
     */

  }, {
    key: 'refYScale',
    value: function () {
      function refYScale(_) {
        if (!arguments.length) return this._refYScale;

        this._refYScale = _;

        return this;
      }

      return refYScale;
    }()

    /**
     * Either get or set the xScale
     */

  }, {
    key: 'xScale',
    value: function () {
      function xScale(_) {
        if (!arguments.length) return this._xScale;

        this._xScale = _;

        return this;
      }

      return xScale;
    }()

    /**
     * Either get or set the yScale
     */

  }, {
    key: 'yScale',
    value: function () {
      function yScale(_) {
        if (!arguments.length) {
          return this._yScale;
        }

        this._yScale = _;

        return this;
      }

      return yScale;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        this.xScale(newXScale);
        this.yScale(newYScale);
      }

      return zoomed;
    }()
  }, {
    key: 'refScalesChanged',
    value: function () {
      function refScalesChanged(refXScale, refYScale) {
        this._refXScale = refXScale;
        this._refYScale = refYScale;
      }

      return refScalesChanged;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {}

      return draw;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        this.position = newPosition;
      }

      return setPosition;
    }()
  }, {
    key: 'remove',
    value: function () {
      function remove() {}

      return remove;
    }()
  }, {
    key: 'rerender',
    value: function () {
      function rerender() {}

      return rerender;
    }()
  }]);

  return Track;
}();

exports['default'] = Track;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, Buffer) {

var bits = __webpack_require__(142)
var dup = __webpack_require__(652)

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35), __webpack_require__(184).Buffer))

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

 "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}



/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopupMenu = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(8);

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PopupMenu = exports.PopupMenu = function (_React$Component) {
  _inherits(PopupMenu, _React$Component);

  function PopupMenu(props) {
    _classCallCheck(this, PopupMenu);

    return _possibleConstructorReturn(this, (PopupMenu.__proto__ || Object.getPrototypeOf(PopupMenu)).call(this, props));
  }

  _createClass(PopupMenu, [{
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {
        this.popup = document.createElement('div');
        document.body.appendChild(this.popup);

        this.popup.style.zIndex = 99;
        this.popup.style.position = 'absolute';
        this.popup.className = 'hg-popup';

        this.boundHandleDocumentClick = this.handleDocumentClick.bind(this);
        this.boundHandleDocumentResize = this.handleDocumentResize.bind(this);

        document.addEventListener('click', this.boundHandleDocumentClick, true);
        window.addEventListener('resize', this.boundHandleDocumentResize, true);

        this._renderLayer();
      }

      return componentDidMount;
    }()
  }, {
    key: 'componentDidUpdate',
    value: function () {
      function componentDidUpdate() {
        this._renderLayer();
      }

      return componentDidUpdate;
    }()
  }, {
    key: 'componentWillUnmount',
    value: function () {
      function componentWillUnmount() {
        document.removeEventListener('click', this.boundHandleDocumentClick, true);
        window.removeEventListener('resize', this.boundHandleDocumentResize, true);
        _reactDom2['default'].unmountComponentAtNode(this.popup);
        document.body.removeChild(this.popup);
      }

      return componentWillUnmount;
    }()
  }, {
    key: '_renderLayer',
    value: function () {
      function _renderLayer() {
        _reactDom2['default'].render(this.props.children, this.popup);
      }

      return _renderLayer;
    }()
  }, {
    key: 'handleDocumentResize',
    value: function () {
      function handleDocumentResize() {
        if (this.props.onMenuClosed) {
          this.props.onMenuClosed(null);
        }
      }

      return handleDocumentResize;
    }()
  }, {
    key: 'handleDocumentClick',
    value: function () {
      function handleDocumentClick(evt) {
        if (!this.popup.contains(evt.target)) {
          if (this.props.onMenuClosed) {
            this.props.onMenuClosed(evt);
          }
        }
      }

      return handleDocumentClick;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        // Render a placeholder
        return _react2['default'].createElement('div', {
          ref: function () {
            function ref(c) {
              return _this2.area = c;
            }

            return ref;
          }()
        });
      }

      return render;
    }()
  }]);

  return PopupMenu;
}(_react2['default'].Component);

exports['default'] = PopupMenu;

/***/ }),
/* 144 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"tiled-plot":"TiledPlot-module_tiled-plot-uFHiB","horizontalList":"TiledPlot-module_horizontalList-1c1P8","list":"TiledPlot-module_list-24zgV","stylizedList":"TiledPlot-module_stylizedList-Mt4JL","stylizedItem":"TiledPlot-module_stylizedItem-2bQBK","stylizedHelper":"TiledPlot-module_stylizedHelper-3IVEu","horizontalItem":"TiledPlot-module_horizontalItem-2-ZjU","resizable-track":"TiledPlot-module_resizable-track-2oLT9","domain":"TiledPlot-module_domain-qYw6K"};

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _d3Selection = __webpack_require__(4);

var _d3Scale = __webpack_require__(12);

var _d3Request = __webpack_require__(30);

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _reactDom = __webpack_require__(8);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactGridLayout = __webpack_require__(366);

var _reactGridLayout2 = _interopRequireDefault(_reactGridLayout);

var _cssElementQueries = __webpack_require__(189);

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _vkbeautify = __webpack_require__(376);

var _vkbeautify2 = _interopRequireDefault(_vkbeautify);

var _urlParse = __webpack_require__(377);

var _urlParse2 = _interopRequireDefault(_urlParse);

var _TiledPlot = __webpack_require__(380);

var _GenomePositionSearchBox = __webpack_require__(699);

var _GenomePositionSearchBox2 = _interopRequireDefault(_GenomePositionSearchBox);

var _ExportLinkModal = __webpack_require__(708);

var _symbol = __webpack_require__(709);

var _icons = __webpack_require__(237);

var _ViewHeader = __webpack_require__(710);

var _ViewHeader2 = _interopRequireDefault(_ViewHeader);

var _ChromosomeInfo = __webpack_require__(43);

var _api = __webpack_require__(714);

var _api2 = _interopRequireDefault(_api);

var _services = __webpack_require__(7);

var _utils = __webpack_require__(3);

var _configs = __webpack_require__(6);

var _HiGlassModule = __webpack_require__(715);

var _HiGlassModule2 = _interopRequireDefault(_HiGlassModule);

var _ViewHeaderModule = __webpack_require__(250);

var _ViewHeaderModule2 = _interopRequireDefault(_ViewHeaderModule);

var _HiGlass = __webpack_require__(716);

var _HiGlass2 = _interopRequireDefault(_HiGlass);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Services


// Utils


// Configs


// Styles
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars

// eslint-disable-line no-unused-vars

var WidthReactGridLayout = (0, _reactGridLayout.WidthProvider)(_reactGridLayout2['default']
// Reserved props
);

var NUM_GRID_COLUMNS = 12;
var DEFAULT_NEW_VIEW_HEIGHT = 12;
var VIEW_HEADER_HEIGHT = 20;

var HiGlassComponent = function (_React$Component) {
  _inherits(HiGlassComponent, _React$Component);

  function HiGlassComponent(props) {
    _classCallCheck(this, HiGlassComponent);

    var _this = _possibleConstructorReturn(this, (HiGlassComponent.__proto__ || Object.getPrototypeOf(HiGlassComponent)).call(this, props));

    console.log('heeeeyaa');

    _this.minHorizontalHeight = 20;
    _this.minVerticalWidth = 20;
    _this.resizeSensor = null;

    _this.uid = _slugid2['default'].nice();
    _this.rowHeight = 40;
    _this.tiledPlots = {};
    _this.genomePositionSearchBoxes = {};

    // keep track of the xScales of each Track Renderer
    _this.xScales = {};
    _this.yScales = {};
    _this.topDiv = null;

    // a reference of view / track combinations
    // to be used with combined to viewAndTrackUid
    _this.viewTrackUidsToCombinedUid = {};
    _this.combinedUidToViewTrack = {};

    // event listeners for when the scales of a view change
    // bypasses the React event framework because this needs
    // to be fast
    // indexed by view uid and then listener uid
    _this.scalesChangedListeners = {};
    _this.draggingChangedListeners = {};
    _this.valueScalesChangedListeners = {};

    // locks that keep the location and zoom synchronized
    // between views
    _this.zoomLocks = {};
    _this.locationLocks = {};

    // locks that keep the value scales synchronized between
    // *tracks* (which can be in different views)
    _this.valueScaleLocks = {};

    _this.setCenters = {};

    _this.plusImg = {};
    _this.configImg = {};

    _this.horizontalMargin = 5;
    _this.verticalMargin = 5;

    _this.genomePositionSearchBox = null;
    _this.viewHeaders = {};

    _this.boundRefreshView = function () {
      _this.refreshView(_configs.LONG_DRAG_TIMEOUT);
    };

    _this.viewConfig = _this.props.viewConfig;

    _this.pixiStage = new PIXI.Container();
    _this.pixiStage.interactive = true;
    _this.element = null;

    var viewsByUid = _this.processViewConfig(JSON.parse(JSON.stringify(_this.props.viewConfig)));

    var mouseTool = _configs.MOUSE_TOOL_MOVE;

    if (_this.props.options) {
      switch (_this.props.options.mouseTool) {
        case _configs.MOUSE_TOOL_SELECT:
          mouseTool = _configs.MOUSE_TOOL_SELECT;
          break;
      }
    }

    _this.mounted = false;
    _this.state = {
      bounded: _this.props.options ? _this.props.options.bounded : false,
      currentBreakpoint: 'lg',
      width: 0,
      height: 0,
      rowHeight: 30,
      svgElement: null,
      canvasElement: null,
      views: viewsByUid,
      addTrackPositionMenuPosition: null,

      // chooseViewHandler: uid2 => this.handleZoomYanked(views[0].uid, uid2),
      // chooseViewHandler: uid2 => this.handleZoomLockChosen(views[0].uid, uid2),
      // chooseViewHandler: uid2 => this.handleCenterSynced(views[0].uid, uid2),
      // chooseTrackHandler: (viewUid, trackUid) => this.handleViewportProjected(views[0].uid, viewUid, trackUid),
      mouseOverOverlayUid: null,
      exportLinkModalOpen: false,
      exportLinkLocation: null,
      mouseTool: mouseTool
    };

    (0, _utils.dictValues)(viewsByUid).map(function (view) {
      return _this.adjustLayoutToTrackSizes(view);
    });

    // monitor whether this element is attached to the DOM so that
    // we can determine whether to add the resizesensor
    _this.attachedToDOM = false;

    // Set up API
    _this.api = (0, _api2['default'])(_this);

    _this.rangeSelectionListener = [];
    _this.viewChangeListener = [];

    _this.triggerViewChangeDb = (0, _utils.debounce)(_this.triggerViewChange.bind(_this), 250);

    _this.pubSubs = [];
    _this.rangeSelection = [null, null];
    return _this;
  }

  _createClass(HiGlassComponent, [{
    key: 'componentWillMount',
    value: function () {
      function componentWillMount() {
        _services.domEvent.register('keydown', document);
        _services.domEvent.register('keyup', document);
        _services.domEvent.register('scroll', document);
        _services.domEvent.register('resize', window);
        _services.domEvent.register('orientationchange', window);

        this.pubSubs = [];
        this.pubSubs.push(_services.pubSub.subscribe('keydown', this.keyDownHandler.bind(this)));
        this.pubSubs.push(_services.pubSub.subscribe('keyup', this.keyUpHandler.bind(this)));
        this.pubSubs.push(_services.pubSub.subscribe('resize', this.resizeHandler.bind(this)));
        this.pubSubs.push(_services.pubSub.subscribe('orientationchange', this.resizeHandler.bind(this)));

        if (this.props.getApi) {
          this.props.getApi(this.api);
        }
      }

      return componentWillMount;
    }()
  }, {
    key: 'waitForDOMAttachment',
    value: function () {
      function waitForDOMAttachment(callback) {
        var _this2 = this;

        if (!this.mounted) return;

        var thisElement = _reactDom2['default'].findDOMNode(this);

        if (document.body.contains(thisElement)) {
          callback();
        } else {
          requestAnimationFrame(function () {
            return _this2.waitForDOMAttachment(callback);
          });
        }
      }

      return waitForDOMAttachment;
    }()
  }, {
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {
        var _this3 = this;

        // the addEventListener is necessary because TrackRenderer determines where to paint
        // all the elements based on their bounding boxes. If the window isn't
        // in focus, everything is drawn at the top and overlaps. When it gains
        // focus we need to redraw everything in its proper place
        this.mounted = true;
        this.element = _reactDom2['default'].findDOMNode(this);
        window.addEventListener('focus', this.boundRefreshView);

        (0, _utils.dictValues)(this.state.views).forEach(function (v) {
          if (!v.layout) {
            v.layout = _this3.generateViewLayout(v);
          } else {
            v.layout.i = v.uid;
          }
        });

        this.pixiRenderer = PIXI.autoDetectRenderer(this.state.width, this.state.height, {
          view: this.canvasElement,
          antialias: true,
          transparent: true,
          resolution: 2,
          autoResize: true
        });

        // PIXI.RESOLUTION=2;
        this.fitPixiToParentContainer();

        // keep track of the width and height of this element, because it
        // needs to be reflected in the size of our drawing surface
        this.setState({
          svgElement: this.svgElement,
          canvasElement: this.canvasElement
        });

        this.waitForDOMAttachment(function () {
          _cssElementQueries.ElementQueries.listen();
          _this3.resizeSensor = new _cssElementQueries.ResizeSensor(_this3.element.parentNode, _this3.updateAfterResize.bind(_this3));

          // this.forceUpdate();
          _this3.updateAfterResize();
        });

        this.handleDragStart();
        this.handleDragStop();

        this.animate();
        // this.handleExportViewsAsLink();

        var baseSvg = (0, _d3Selection.select)(this.element).append('svg').style('display', 'none');

        // Add SVG Icons
        _icons.all.forEach(function (icon) {
          return (0, _symbol.createSymbolIcon)(baseSvg, icon.id, icon.paths, icon.viewBox);
        });

        //loadChromInfos(this.state.views);
      }

      return componentDidMount;
    }()
  }, {
    key: 'componentWillReceiveProps',
    value: function () {
      function componentWillReceiveProps(newProps) {
        var viewsByUid = this.processViewConfig(newProps.viewConfig);

        this.setState({
          views: viewsByUid
        });
      }

      return componentWillReceiveProps;
    }()
  }, {
    key: 'componentWillUpdate',
    value: function () {
      function componentWillUpdate(nextProps, nextState) {
        // let width = this.element.clientWidth;
        // let height = this.element.clientHeight;

        /*
        this.pixiRenderer.resize(width, height);
        this.pixiRenderer.view.style.width = width + 'px';
        this.pixiRenderer.view.style.height = height + 'px';
        */

        this.pixiRenderer.render(this.pixiStage);

        /*
        if (this.state.views !== nextState.views) {
          loadChromInfos(nextState.views);
        }
        */
      }

      return componentWillUpdate;
    }()
  }, {
    key: 'componentDidUpdate',
    value: function () {
      function componentDidUpdate() {
        this.animate();

        this.triggerViewChangeDb();
      }

      return componentDidUpdate;
    }()
  }, {
    key: 'componentWillUnmount',
    value: function () {
      function componentWillUnmount() {
        // Destroy PIXI renderer, stages, and assets
        this.mounted = false;
        this.pixiStage.destroy(false);
        this.pixiStage = null;
        this.pixiRenderer.destroy(true);
        this.pixiRenderer = null;

        window.removeEventListener('focus', this.boundRefreshView);

        // if this element was never attached to the DOM
        // then the resize sensor will never have been initiated
        if (this.resizeSensor) this.resizeSensor.detach();

        _services.domEvent.unregister('keydown', document);
        _services.domEvent.unregister('keyup', document);
        _services.domEvent.unregister('scroll', document);

        this.pubSubs.forEach(function (subscription) {
          return _services.pubSub.unsubscribe(subscription);
        });
        this.pubSubs = [];
      }

      return componentWillUnmount;
    }()

    /* ---------------------------- Custom Methods ---------------------------- */

  }, {
    key: 'fitPixiToParentContainer',
    value: function () {
      function fitPixiToParentContainer() {
        if (!this.element.parentNode) {
          console.warn('No parentNode:', this.element);
          return;
        }

        var width = this.element.parentNode.clientWidth;
        var height = this.element.parentNode.clientHeight;

        this.pixiRenderer.resize(width, height);

        this.pixiRenderer.view.style.width = width + 'px';
        this.pixiRenderer.view.style.height = height + 'px';

        this.pixiRenderer.render(this.pixiStage);
      }

      return fitPixiToParentContainer;
    }()
  }, {
    key: 'addDefaultOptions',
    value: function () {
      function addDefaultOptions(track) {
        if (!_configs.TRACKS_INFO_BY_TYPE.hasOwnProperty(track.type)) {
          console.error('ERROR: track type not found:', track.type, ' (check app/scripts/config/ for a list of defined track types)');
          return;
        }

        var trackOptions = track.options ? track.options : {};

        if (_configs.TRACKS_INFO_BY_TYPE[track.type].defaultOptions) {
          if (!track.options) {
            track.options = JSON.parse(JSON.stringify(_configs.TRACKS_INFO_BY_TYPE[track.type].defaultOptions));
          } else {
            for (var optionName in _configs.TRACKS_INFO_BY_TYPE[track.type].defaultOptions) {
              track.options[optionName] = track.options[optionName] ? track.options[optionName] : JSON.parse(JSON.stringify(_configs.TRACKS_INFO_BY_TYPE[track.type].defaultOptions[optionName]));
            }
          }
        } else {
          track.options = trackOptions;
        }
      }

      return addDefaultOptions;
    }()
  }, {
    key: 'keyDownHandler',
    value: function () {
      function keyDownHandler(event) {
        if (this.props.options.rangeSelectionOnAlt && event.key === 'Alt') {
          this.setState({
            mouseTool: _configs.MOUSE_TOOL_SELECT
          });
        }
      }

      return keyDownHandler;
    }()
  }, {
    key: 'keyUpHandler',
    value: function () {
      function keyUpHandler(event) {
        if (this.props.options.rangeSelectionOnAlt && event.key === 'Alt') {
          this.setState({
            mouseTool: _configs.MOUSE_TOOL_MOVE
          });
        }
      }

      return keyUpHandler;
    }()
  }, {
    key: 'animate',
    value: function () {
      function animate() {
        var _this4 = this;

        requestAnimationFrame(function () {
          if (!_this4.pixiRenderer)
            // component was probably unmounted
            return;

          _this4.pixiRenderer.render(_this4.pixiStage);
        });
      }

      return animate;
    }()
  }, {
    key: 'measureSize',
    value: function () {
      function measureSize() {
        var heightOffset = 0;
        var height = this.element.clientHeight - heightOffset;
        var width = this.element.clientWidth;

        if (width > 0 && height > 0) {
          this.setState({
            sizeMeasured: true,
            width: width,
            height: height
          });
        }
      }

      return measureSize;
    }()
  }, {
    key: 'updateAfterResize',
    value: function () {
      function updateAfterResize() {
        this.measureSize();
        this.updateRowHeight();
        this.fitPixiToParentContainer();
        this.refreshView(_configs.LONG_DRAG_TIMEOUT);
      }

      return updateAfterResize;
    }()
  }, {
    key: 'onBreakpointChange',
    value: function () {
      function onBreakpointChange(breakpoint) {
        this.setState({
          currentBreakpoint: breakpoint
        });
      }

      return onBreakpointChange;
    }()
  }, {
    key: 'handleOverlayMouseEnter',
    value: function () {
      function handleOverlayMouseEnter(uid) {
        this.setState({
          mouseOverOverlayUid: uid
        });
      }

      return handleOverlayMouseEnter;
    }()
  }, {
    key: 'handleOverlayMouseLeave',
    value: function () {
      function handleOverlayMouseLeave(uid) {
        this.setState({
          mouseOverOverlayUid: null
        });
      }

      return handleOverlayMouseLeave;
    }()
  }, {
    key: 'handleLockLocation',
    value: function () {
      function handleLockLocation(uid) {
        var _this5 = this;

        /**
           * We want to lock the zoom of this view to the zoom of another view.
           *
           * First we pick which other view we want to lock to.
           *
           * The we calculate the current zoom offset and center offset. The differences
           * between the center of the two views will always remain the same, as will the
           * different between the zoom levels.
           */
        // create a view chooser and remove the config view menu
        this.setState({
          chooseViewHandler: function () {
            function chooseViewHandler(uid2) {
              return _this5.handleLocationLockChosen(uid, uid2);
            }

            return chooseViewHandler;
          }(),
          mouseOverOverlayUid: uid
        });
      }

      return handleLockLocation;
    }()
  }, {
    key: 'updateLockedValueScales',
    value: function () {
      function updateLockedValueScales(viewUid, trackUid) {
        var lockGroup = this.valueScaleLocks[this.combineViewAndTrackUid(viewUid, trackUid)];
      }

      return updateLockedValueScales;
    }()

    /*
     * Iteratate over all of the views in this component
     */

  }, {
    key: 'iterateOverViews',
    value: function () {
      function iterateOverViews() {
        var viewIds = [];

        for (var viewId in this.state.views) {
          viewIds.push(viewId);
        }

        return viewIds;
      }

      return iterateOverViews;
    }()
  }, {
    key: 'iterateOverTracksInView',
    value: function () {
      function iterateOverTracksInView(viewId) {
        var allTracks = [];
        var tracks = this.state.views[viewId].tracks;

        for (var trackType in tracks) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = tracks[trackType][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var track = _step.value;

              if (track.type === 'combined' && track.contents) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                  for (var _iterator2 = track.contents[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var subTrack = _step2.value;

                    allTracks.push({ viewId: viewId, trackId: subTrack.uid, track: subTrack });
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                      _iterator2['return']();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }
              } else {
                allTracks.push({ viewId: viewId, trackId: track.uid, track: track });
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator['return']) {
                _iterator['return']();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        return allTracks;
      }

      return iterateOverTracksInView;
    }()

    /**
     * Iterate over all the tracks in this component.
     */

  }, {
    key: 'iterateOverTracks',
    value: function () {
      function iterateOverTracks() {
        var allTracks = [];
        for (var viewId in this.state.views) {
          var tracks = this.state.views[viewId].tracks;

          for (var trackType in tracks) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = tracks[trackType][Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var track = _step3.value;

                if (track.type === 'combined' && track.contents) {
                  var _iteratorNormalCompletion4 = true;
                  var _didIteratorError4 = false;
                  var _iteratorError4 = undefined;

                  try {
                    for (var _iterator4 = track.contents[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                      var subTrack = _step4.value;

                      allTracks.push({ viewId: viewId, trackId: subTrack.uid, track: subTrack });
                    }
                  } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                        _iterator4['return']();
                      }
                    } finally {
                      if (_didIteratorError4) {
                        throw _iteratorError4;
                      }
                    }
                  }
                } else {
                  allTracks.push({ viewId: viewId, trackId: track.uid, track: track });
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                  _iterator3['return']();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
        }

        return allTracks;
      }

      return iterateOverTracks;
    }()
  }, {
    key: 'setMouseTool',
    value: function () {
      function setMouseTool(mouseTool) {
        this.setState({ mouseTool: mouseTool });
      }

      return setMouseTool;
    }()

    /**
     * Syncing the values of locked scales
     *
     * Arguments
     * ---------
     *  viewUid: string
     *    The id of the view containing the track whose value scale initially changed
     *  trackUid: string
     *    The id of the track that whose value scale changed
     *
     * Returns
     * -------
     *    Nothing
     */

  }, {
    key: 'syncValueScales',
    value: function () {
      function syncValueScales(viewUid, trackUid) {
        var _this6 = this;

        var uid = this.combineViewAndTrackUid(viewUid, trackUid);
        var sourceTrack = (0, _utils.getTrackByUid)(this.state.views[viewUid].tracks, trackUid);

        if (this.valueScaleLocks[uid]) {
          var lockGroupValues = (0, _utils.dictValues)(this.valueScaleLocks[uid]);

          // /let trackObj = this.tiledPlots[viewUid].trackRenderer.getTrackObject(trackUid);
          var lockedTracks = lockGroupValues.filter(function (x) {
            return _this6.tiledPlots[x.view];
          }).map(function (x) {
            return _this6.tiledPlots[x.view].trackRenderer.getTrackObject(x.track);
          });

          var minValues = lockedTracks
          // exclude tracks that don't set min and max values
          .filter(function (x) {
            return x.minRawValue && x.maxRawValue;
          }).map(function (x) {
            return x.minRawValue();
          }).filter(function (x) {
            return x;
          });

          var maxValues = lockedTracks
          // exclude tracks that don't set min and max values
          .filter(function (x) {
            return x.minRawValue && x.maxRawValue;
          }).map(function (x) {
            return x.maxRawValue();
          }).filter(function (x) {
            return x;
          });

          var allMin = Math.min.apply(Math, _toConsumableArray(minValues));
          var allMax = Math.max.apply(Math, _toConsumableArray(maxValues));

          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = lockedTracks[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var lockedTrack = _step5.value;

              // set the newly calculated minimum and maximum values
              // using d3 style setters
              if (lockedTrack.minValue) {
                lockedTrack.minValue(allMin);
              }
              if (lockedTrack.maxValue) {
                lockedTrack.maxValue(allMax);
              }

              if (!lockedTrack.valueScale) {
                // this track probably hasn't loaded the tiles to
                // create a valueScale
                continue;
              }

              lockedTrack.valueScale.domain([allMin, allMax]);

              if (sourceTrack.options && typeof sourceTrack.options.scaleStartPercent !== 'undefined' && typeof sourceTrack.options.scaleEndPercent !== 'undefined') {
                lockedTrack.options.scaleStartPercent = sourceTrack.options.scaleStartPercent;
                lockedTrack.options.scaleEndPercent = sourceTrack.options.scaleEndPercent;
              }

              // the second parameter forces a rerender even though
              // the options haven't changed
              lockedTrack.rerender(lockedTrack.options, true);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                _iterator5['return']();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }
      }

      return syncValueScales;
    }()
  }, {
    key: 'handleNewTilesLoaded',
    value: function () {
      function handleNewTilesLoaded(viewUid, trackUid) {
        // this.syncValueScales(viewUid, trackUid);
        this.animate();
      }

      return handleNewTilesLoaded;
    }()
  }, {
    key: 'notifyDragChangedListeners',
    value: function () {
      function notifyDragChangedListeners(dragging) {
        // iterate over viewId
        (0, _utils.dictValues)(this.draggingChangedListeners).forEach(function (l) {
          // iterate over listenerId
          (0, _utils.dictValues)(l).forEach(function (listener) {
            return listener(dragging);
          });
        });
      }

      return notifyDragChangedListeners;
    }()
  }, {
    key: 'addDraggingChangedListener',
    value: function () {
      function addDraggingChangedListener(viewUid, listenerUid, eventHandler) {
        /**
           * Add a listener that will be called every time the view is updated.
           *
           * @param viewUid: The uid of the view being observed
           * @param listenerUid: The uid of the listener
           * @param eventHandler: The handler to be called when the scales change
           *    Event handler is called with parameters (xScale, yScale)
           */
        if (!this.draggingChangedListeners.hasOwnProperty(viewUid)) {
          this.draggingChangedListeners[viewUid] = {};
        }

        this.draggingChangedListeners[viewUid][listenerUid] = eventHandler;

        eventHandler(true);
        eventHandler(false);
      }

      return addDraggingChangedListener;
    }()
  }, {
    key: 'removeDraggingChangedListener',
    value: function () {
      function removeDraggingChangedListener(viewUid, listenerUid) {
        /**
           * Remove a scale change event listener
           *
           * @param viewUid: The view that it's listening on.
           * @param listenerUid: The uid of the listener itself.
           */
        if (this.draggingChangedListeners.hasOwnProperty(viewUid)) {
          var listeners = this.draggingChangedListeners[viewUid];

          if (listeners.hasOwnProperty(listenerUid)) {
            // make sure the listener doesn't think we're still
            // dragging
            listeners[listenerUid](false);
            delete listeners[listenerUid];
          }
        }
      }

      return removeDraggingChangedListener;
    }()
  }, {
    key: 'addScalesChangedListener',
    value: function () {
      function addScalesChangedListener(viewUid, listenerUid, eventHandler) {
        /**
           * Add an event listener that will be called every time the scale
           * of the view with uid viewUid is changed.
           *
           * @param viewUid: The uid of the view being observed
           * @param listenerUid: The uid of the listener
           * @param eventHandler: The handler to be called when the scales change
           *    Event handler is called with parameters (xScale, yScale)
           */
        if (!this.scalesChangedListeners.hasOwnProperty(viewUid)) {
          this.scalesChangedListeners[viewUid] = {};
        }

        this.scalesChangedListeners[viewUid][listenerUid] = eventHandler;

        if (!this.xScales[viewUid] || !this.yScales[viewUid]) {
          return;
        }

        // call the handler for the first time
        eventHandler(this.xScales[viewUid], this.yScales[viewUid]);
      }

      return addScalesChangedListener;
    }()
  }, {
    key: 'removeScalesChangedListener',
    value: function () {
      function removeScalesChangedListener(viewUid, listenerUid) {
        /**
           * Remove a scale change event listener
           *
           * @param viewUid: The view that it's listening on.
           * @param listenerUid: The uid of the listener itself.
           */
        if (this.scalesChangedListeners.hasOwnProperty(viewUid)) {
          var listeners = this.scalesChangedListeners[viewUid];

          if (listeners.hasOwnProperty(listenerUid)) {
            delete listeners[listenerUid];
          }
        }
      }

      return removeScalesChangedListener;
    }()
  }, {
    key: 'createSVG',
    value: function () {
      function createSVG() {
        var outputSVG = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n';
        var svg = document.createElement('svg');
        svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
        svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = (0, _utils.dictValues)(this.tiledPlots)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var tiledPlot = _step6.value;

            if (!tiledPlot) continue; //probalby opened and closed

            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = (0, _utils.dictValues)(tiledPlot.trackRenderer.trackDefObjects)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var trackDefObject = _step7.value;

                if (trackDefObject.trackObject.exportSVG) {
                  var trackSVG = trackDefObject.trackObject.exportSVG()[0];

                  svg.appendChild(trackSVG);
                }
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7['return']) {
                  _iterator7['return']();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6['return']) {
              _iterator6['return']();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }

        return svg;
      }

      return createSVG;
    }()
  }, {
    key: 'handleExportSVG',
    value: function () {
      function handleExportSVG() {
        var svg = this.createSVG();

        var svgText = new XMLSerializer().serializeToString(svg);
        var beautyText = _vkbeautify2['default'].xml(svgText);

        (0, _utils.download)('export.svg', _vkbeautify2['default'].xml(svgText));
        return svg;
      }

      return handleExportSVG;
    }()
  }, {
    key: 'handleScalesChanged',
    value: function () {
      function handleScalesChanged(uid, xScale, yScale) {
        var _this7 = this;

        var notify = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

        /*
           * The scales of some view have changed (presumably in response to zooming).
           *
           * Mark the new scales and update any locked views.
           *
           * @param uid: The view of whom the scales have changed.
           */
        this.xScales[uid] = xScale;
        this.yScales[uid] = yScale;

        if (notify) {
          if (this.scalesChangedListeners.hasOwnProperty(uid)) {
            (0, _utils.dictValues)(this.scalesChangedListeners[uid]).forEach(function (x) {
              x(xScale, yScale);
            });
          }
        }

        if (this.zoomLocks[uid]) {
          // this view is locked to another
          var lockGroup = this.zoomLocks[uid];
          var lockGroupItems = (0, _utils.dictItems)(lockGroup);

          var _scalesCenterAndK = (0, _utils.scalesCenterAndK)(this.xScales[uid], this.yScales[uid]),
              _scalesCenterAndK2 = _slicedToArray(_scalesCenterAndK, 3),
              centerX = _scalesCenterAndK2[0],
              centerY = _scalesCenterAndK2[1],
              k = _scalesCenterAndK2[2];

          var _loop = function () {
            function _loop(i) {
              var key = lockGroupItems[i][0];
              var value = lockGroupItems[i][1];

              if (!_this7.xScales[key] || !_this7.yScales[key]) {
                return 'continue';
              }

              if (key == uid) // no need to notify oneself that the scales have changed
                {
                  return 'continue';
                }

              var _scalesCenterAndK3 = (0, _utils.scalesCenterAndK)(_this7.xScales[key], _this7.yScales[key]),
                  _scalesCenterAndK4 = _slicedToArray(_scalesCenterAndK3, 3),
                  keyCenterX = _scalesCenterAndK4[0],
                  keyCenterY = _scalesCenterAndK4[1],
                  keyK = _scalesCenterAndK4[2];

              var dx = value[0] - lockGroup[uid][0];
              var dy = value[1] - lockGroup[uid][1];
              var rk = value[2] / lockGroup[uid][2];

              // let newCenterX = centerX + dx;
              // let newCenterY = centerY + dy;
              var newK = k * rk;

              if (!_this7.setCenters[key]) {
                return 'continue';
              }

              // the key here is the target of zoom lock, so we want to keep its
              // x center and y center unchanged

              var _setCenters$key = _this7.setCenters[key](keyCenterX, keyCenterY, newK, false),
                  _setCenters$key2 = _slicedToArray(_setCenters$key, 2),
                  newXScale = _setCenters$key2[0],
                  newYScale = _setCenters$key2[1];

              // because the setCenters call above has a 'false' notify, the new scales won't
              // be propagated from there, so we have to store them here


              _this7.xScales[key] = newXScale;
              _this7.yScales[key] = newYScale;

              // notify the listeners of all locked views that the scales of
              // this view have changed
              if (_this7.scalesChangedListeners.hasOwnProperty(key)) {
                (0, _utils.dictValues)(_this7.scalesChangedListeners[key]).forEach(function (x) {
                  x(newXScale, newYScale);
                });
              }
            }

            return _loop;
          }();

          for (var i = 0; i < lockGroupItems.length; i++) {
            var _ret = _loop(i);

            if (_ret === 'continue') continue;
          }
        }

        if (this.locationLocks[uid]) {
          // this view is locked to another
          var _lockGroup = this.locationLocks[uid];
          var _lockGroupItems = (0, _utils.dictItems)(_lockGroup);

          var _scalesCenterAndK5 = (0, _utils.scalesCenterAndK)(this.xScales[uid], this.yScales[uid]),
              _scalesCenterAndK6 = _slicedToArray(_scalesCenterAndK5, 3),
              _centerX = _scalesCenterAndK6[0],
              _centerY = _scalesCenterAndK6[1],
              _k = _scalesCenterAndK6[2];

          var _loop2 = function () {
            function _loop2(i) {
              var key = _lockGroupItems[i][0];
              var value = _lockGroupItems[i][1];

              if (!_this7.xScales[key] || !_this7.yScales[key]) {
                return 'continue';
              }

              var _scalesCenterAndK7 = (0, _utils.scalesCenterAndK)(_this7.xScales[key], _this7.yScales[key]),
                  _scalesCenterAndK8 = _slicedToArray(_scalesCenterAndK7, 3),
                  keyCenterX = _scalesCenterAndK8[0],
                  keyCenterY = _scalesCenterAndK8[1],
                  keyK = _scalesCenterAndK8[2];

              if (key == uid) // no need to notify oneself that the scales have changed
                {
                  return 'continue';
                }

              var dx = value[0] - _lockGroup[uid][0];
              var dy = value[1] - _lockGroup[uid][1];

              var newCenterX = _centerX + dx;
              var newCenterY = _centerY + dy;

              if (!_this7.setCenters[key]) {
                return 'continue';
              }

              var _setCenters$key3 = _this7.setCenters[key](newCenterX, newCenterY, keyK, false),
                  _setCenters$key4 = _slicedToArray(_setCenters$key3, 2),
                  newXScale = _setCenters$key4[0],
                  newYScale = _setCenters$key4[1];

              // because the setCenters call above has a 'false' notify, the new scales won't
              // be propagated from there, so we have to store them here


              _this7.xScales[key] = newXScale;
              _this7.yScales[key] = newYScale;

              // notify the listeners of all locked views that the scales of
              // this view have changed
              if (_this7.scalesChangedListeners.hasOwnProperty(key)) {
                (0, _utils.dictValues)(_this7.scalesChangedListeners[key]).forEach(function (x) {
                  x(newXScale, newYScale);
                });
              }
            }

            return _loop2;
          }();

          for (var i = 0; i < _lockGroupItems.length; i++) {
            var _ret2 = _loop2(i);

            if (_ret2 === 'continue') continue;
          }
        }

        this.animate();

        // Call view change handler
        this.triggerViewChangeDb();
      }

      return handleScalesChanged;
    }()
  }, {
    key: 'handleProjectViewport',
    value: function () {
      function handleProjectViewport(uid) {
        var _this8 = this;

        /**
         * We want to show the extent of this viewport on another view.
         */

        this.setState({
          chooseTrackHandler: function () {
            function chooseTrackHandler(viewUid, trackUid) {
              return _this8.handleViewportProjected(uid, viewUid, trackUid);
            }

            return chooseTrackHandler;
          }()
        });
      }

      return handleProjectViewport;
    }()
  }, {
    key: 'handleZoomToData',
    value: function () {
      function handleZoomToData(viewUid) {
        /**
         * Adjust the zoom level so that all of the data is visible
         *
         * @param viewUid: The view uid for which to adjust the zoom level
         */
        if (!this.tiledPlots[viewUid]) throw 'View uid ' + viewUid + ' does not exist in the current viewConfig';

        this.tiledPlots[viewUid].handleZoomToData();
      }

      return handleZoomToData;
    }()
  }, {
    key: 'handleYankFunction',
    value: function () {
      function handleYankFunction(uid, yankFunction) {
        /**
             * We want to yank some attributes from another view.
             *
             * This will create a view selection overlay and then call the selected
             * provided function.
             */

        this.setState({
          chooseViewHandler: function () {
            function chooseViewHandler(uid2) {
              return yankFunction(uid, uid2);
            }

            return chooseViewHandler;
          }(),
          mouseOverOverlayUid: uid
        });
      }

      return handleYankFunction;
    }()
  }, {
    key: 'handleUnlock',
    value: function () {
      function handleUnlock(uid, lockGroups) {
        /**
           * We want to unlock uid from the zoom group that it's in.
           *
           * @param uid: The uid of a view.
           */

        // if this function is being called, lockGroup has to exist
        var lockGroup = lockGroups[uid];
        var lockGroupKeys = (0, _utils.dictKeys)(lockGroup);

        if (lockGroupKeys.length == 2) {
          // there's only two items in this lock group so we need to
          // remove them both (no point in having one view locked to itself)
          delete lockGroups[lockGroupKeys[0]];
          delete lockGroups[lockGroupKeys[1]];

          return;
        }
        // delete this view from the zoomLockGroup
        if (lockGroups[uid]) {
          if (lockGroups[uid][uid]) {
            delete lockGroups[uid][uid];
          }
        }

        // remove the handler
        if (lockGroups[uid]) {
          delete lockGroups[uid];
        }
      }

      return handleUnlock;
    }()
  }, {
    key: 'viewScalesLockData',
    value: function () {
      function viewScalesLockData(uid) {
        if (!this.xScales[uid] || !this.yScales[uid]) {
          console.warn("View scale lock doesn't correspond to existing uid: ", uid);
          return;
        }

        return (0, _utils.scalesCenterAndK)(this.xScales[uid], this.yScales[uid]);
      }

      return viewScalesLockData;
    }()
  }, {
    key: 'addLock',
    value: function () {
      function addLock(uid1, uid2, lockGroups, lockData) {
        /*
           * :param uid1 (string): The uid of the first element to be locked (e.g. viewUid)
           * :param uid2 (string): The uid of the second element to be locked (e.g. viewUid)
           * :param lockGroups (dict): The set of locks where to store this lock (e.g. this.locationLocks)
           * :parma lockData (function): A function that takes two uids and calculates some extra data
           *    to store with this lock data (e.g. scalesCenterAndK(this.xScales[uid1], this.yScales[uid1]))
           */
        var group1Members = [];
        var group2Members = [];

        if (!lockGroups[uid1]) {
          // view1 isn't already in a group
          group1Members = [[uid1, lockData.bind(this)(uid1)]];
        } else {
          // view1 is already in a group
          group1Members = (0, _utils.dictItems)(lockGroups[uid1]).filter(function (x) {
            return lockData(x[0]);
          }) // make sure we can create the necessary data for this lock
          // in the case of location locks, this implies that the
          // views it's locking exist
          .map(function (x) {
            return (
              // x is [uid, [centerX, centerY, k]]
              [x[0], lockData(x[0])]
            );
          });
        }

        if (!lockGroups[uid2]) {
          // view1 isn't already in a group
          group2Members = [[uid2, lockData.bind(this)(uid2)]];
        } else {
          // view2 is already in a group
          group2Members = (0, _utils.dictItems)(lockGroups[uid2]).filter(function (x) {
            return lockData(x[0]);
          }) // make sure we can create the necessary data for this lock
          // in the case of location locks, this implies that the
          // views it's locking exist
          .map(function (x) {
            return (
              // x is [uid, [centerX, centerY, k]]
              [x[0], lockData(x[0])]
            );
          });
        }

        var allMembers = group1Members.concat(group2Members);

        var groupDict = (0, _utils.dictFromTuples)(allMembers);

        allMembers.forEach(function (m) {
          lockGroups[m[0]] = groupDict;
        });
      }

      return addLock;
    }()
  }, {
    key: 'handleLocationLockChosen',
    value: function () {
      function handleLocationLockChosen(uid1, uid2) {
        /* Views uid1 and uid2 need to be locked so that they always maintain the current
             * zoom and translation difference.
             * @param uid1: The view that the lock was called from
             * @param uid2: The view that the lock was called on (the view that was selected)
             */
        if (uid1 == uid2) {
          this.setState({
            chooseViewHandler: null
          });

          return; // locking a view to itself is silly
        }

        this.addLock(uid1, uid2, this.locationLocks, this.viewScalesLockData.bind(this));

        this.setState({
          chooseViewHandler: null
        });
      }

      return handleLocationLockChosen;
    }()
  }, {
    key: 'handleZoomLockChosen',
    value: function () {
      function handleZoomLockChosen(uid1, uid2) {
        /* Views uid1 and uid2 need to be locked so that they always maintain the current
             * zoom and translation difference.
             * @param uid1: The view that the lock was called from
             * @param uid2: The view that the lock was called on (the view that was selected)
             */

        if (uid1 == uid2) {
          this.setState({
            chooseViewHandler: null
          });

          return; // locking a view to itself is silly
        }

        this.addLock(uid1, uid2, this.zoomLocks, this.viewScalesLockData.bind(this));

        this.setState({
          chooseViewHandler: null
        });
      }

      return handleZoomLockChosen;
    }()
  }, {
    key: 'handleViewportProjected',
    value: function () {
      function handleViewportProjected(fromView, toView, toTrack) {
        /**
         * We want to project the viewport of fromView onto toTrack of toView.
         *
         * @param fromView: The uid of the view that we want to project
         * @param toView: The uid of the view that we want to project to
         * @param toTrack: The track we want to project to
         *
         * Returns
         * -------
         *
         *  newTrackUid: string
         *      The uid of the newly created viewport projection track
         */
        var newTrackUid = null;

        if (fromView == toView) {
          alert('A view can not show its own viewport.');
        } else {
          var hostTrack = (0, _utils.getTrackByUid)(this.state.views[toView].tracks, toTrack);
          var position = (0, _utils.getTrackPositionByUid)(this.state.views[toView].tracks, toTrack);
          newTrackUid = _slugid2['default'].nice();

          var projectionTypes = {
            top: 'horizontal',
            bottom: 'horizontal',
            center: 'center',
            left: 'vertical',
            right: 'vertical' };

          var newTrack = {
            uid: newTrackUid,
            type: 'viewport-projection-' + projectionTypes[position],
            fromViewUid: fromView
          };

          this.addCallbacks(toView, newTrack);
          this.handleTrackAdded(toView, newTrack, position, hostTrack);
        }
        this.setState({
          chooseTrackHandler: null
        });

        return newTrackUid;
      }

      return handleViewportProjected;
    }()
  }, {
    key: 'handleLocationYanked',
    value: function () {
      function handleLocationYanked(uid1, uid2) {
        /**
             * Uid1 is copying the center of uid2
             */
        // where we're taking the zoom from
        var sourceXScale = this.xScales[uid2];
        var sourceYScale = this.yScales[uid2];

        var targetXScale = this.xScales[uid1];
        var targetYScale = this.yScales[uid1];

        var _scalesCenterAndK9 = (0, _utils.scalesCenterAndK)(targetXScale, targetYScale),
            _scalesCenterAndK10 = _slicedToArray(_scalesCenterAndK9, 3),
            targetCenterX = _scalesCenterAndK10[0],
            targetCenterY = _scalesCenterAndK10[1],
            targetK = _scalesCenterAndK10[2];

        var _scalesCenterAndK11 = (0, _utils.scalesCenterAndK)(sourceXScale, sourceYScale),
            _scalesCenterAndK12 = _slicedToArray(_scalesCenterAndK11, 3),
            sourceCenterX = _scalesCenterAndK12[0],
            sourceCenterY = _scalesCenterAndK12[1],
            sourceK = _scalesCenterAndK12[2];

        // set target center


        this.setCenters[uid1](sourceCenterX, sourceCenterY, targetK, true);

        this.setState({
          chooseViewHandler: null
        });
      }

      return handleLocationYanked;
    }()
  }, {
    key: 'handleZoomYanked',
    value: function () {
      function handleZoomYanked(uid1, uid2) {
        /**
             * Uid1 yanked the zoom of uid2, now  make sure that they're synchronized.
             */

        // where we're taking the zoom from
        var sourceXScale = this.xScales[uid2];
        var sourceYScale = this.yScales[uid2];

        var targetXScale = this.xScales[uid1];
        var targetYScale = this.yScales[uid1];

        var _scalesCenterAndK13 = (0, _utils.scalesCenterAndK)(targetXScale, targetYScale),
            _scalesCenterAndK14 = _slicedToArray(_scalesCenterAndK13, 3),
            targetCenterX = _scalesCenterAndK14[0],
            targetCenterY = _scalesCenterAndK14[1],
            targetK = _scalesCenterAndK14[2];

        var _scalesCenterAndK15 = (0, _utils.scalesCenterAndK)(sourceXScale, sourceYScale),
            _scalesCenterAndK16 = _slicedToArray(_scalesCenterAndK15, 3),
            sourceCenterX = _scalesCenterAndK16[0],
            sourceCenterY = _scalesCenterAndK16[1],
            sourceK = _scalesCenterAndK16[2];

        // set target center


        this.setCenters[uid1](targetCenterX, targetCenterY, sourceK, true);

        this.setState({
          chooseViewHandler: null
        });
      }

      return handleZoomYanked;
    }()
  }, {
    key: 'handleTrackPositionChosen',
    value: function () {
      function handleTrackPositionChosen(viewUid, position) {
        /**
           * The user has chosen a position for the new track. The actual
           * track selection will be handled by TiledPlot
           *
           * We just need to close the menu here.
           */
        this.setState({
          addTrackPosition: position,
          addTrackPositionView: viewUid
        });
      }

      return handleTrackPositionChosen;
    }()

    /**
     * Update the height of each row in the layout so that it takes up all
     * of the available space in the div.
     */

  }, {
    key: 'updateRowHeight',
    value: function () {
      function updateRowHeight() {
        if (!(this.props.options && this.props.options.bounded)) {
          // not bounded so we don't need to update the row height
          return;
        }

        // const width = this.element.parentNode.clientWidth;
        var height = this.element.parentNode.clientHeight;

        var maxHeight = 0;
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = (0, _utils.dictValues)(this.state.views)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var view = _step8.value;

            maxHeight = Math.max(maxHeight, view.layout.y + view.layout.h);
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8['return']) {
              _iterator8['return']();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }

        this.handleDragStart();
        this.handleDragStop();

        var MARGIN_HEIGHT = this.props.viewConfig.editable ? 10 : 0;

        var marginHeight = MARGIN_HEIGHT * maxHeight - 1;
        var availableHeight = height - marginHeight;

        // const currentRowHeight = this.state.rowHeight;
        var prospectiveRowHeight = availableHeight / maxHeight; // maxHeight is the number of
        // rows necessary to display this view

        var chosenRowHeight = Math.floor(prospectiveRowHeight);

        // for (const view of dictValues(this.state.views)) {
        //   const {
        //     totalWidth,
        //     totalHeight,
        //     topHeight,
        //     bottomHeight,
        //     leftWidth,
        //     rightWidth,
        //     centerWidth,
        //     centerHeight,
        //     minNecessaryHeight
        //   } = this.calculateViewDimensions(view);

        //   // If the view is bounded, then we always fit everything inside the container
        //   //
        //   // It used to be that if the viewconfig was too long, we just let it overflow,
        //   // but I think it's better that it's always contained.

        //   /*
        //         if (minNecessaryHeight > view.layout.h * (prospectiveRowHeight + MARGIN_HEIGHT)) {
        //             // we don't have space for one of the containers, so let them exceed the bounds
        //             // of the box
        //             chosenRowHeight = currentRowHeight;
        //             break;
        //         }
        //         */
        // }

        this.setState({
          rowHeight: chosenRowHeight
        });
      }

      return updateRowHeight;
    }()
  }, {
    key: 'handleLayoutChange',
    value: function () {
      function handleLayoutChange(layout, layouts) {
        /**
           * Notify the children that the layout has changed so that they
           * know to redraw themselves
           */

        if (!this.element) {
          return;
        }

        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = layout[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var l = _step9.value;

            var view = this.state.views[l.i];

            if (view) {
              view.layout = l;
            }
          }

          // some of the views have changed their height
          /*
            this.setState({
                views: this.state.views
            });
            */
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9['return']) {
              _iterator9['return']();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }

        this.updateRowHeight();

        this.refreshView(_configs.LONG_DRAG_TIMEOUT);
      }

      return handleLayoutChange;
    }()
  }, {
    key: 'clearDragTimeout',
    value: function () {
      function clearDragTimeout() {
        /**
           * Maybe somebody started dragging again before the previous drag
           * timeout fired. In that case, we need to clear this timeout so
           * that it doesn't override a previously set one.
           */
        if (this.dragTimeout) {
          clearTimeout(this.dragTimeout);
          this.dragTimeout = null;
        }
      }

      return clearDragTimeout;
    }()
  }, {
    key: 'forceRefreshView',
    value: function () {
      function forceRefreshView() {
        // force everything to rerender

        this.setState(this.state);
      }

      return forceRefreshView;
    }()
  }, {
    key: 'refreshView',
    value: function () {
      function refreshView() {
        var _this9 = this;

        var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _configs.SHORT_DRAG_TIMEOUT;

        this.clearDragTimeout();

        this.notifyDragChangedListeners(true);

        this.clearDragTimeout();
        this.dragTimeout = setTimeout(function () {
          _this9.notifyDragChangedListeners(false);
        }, timeout);
      }

      return refreshView;
    }()
  }, {
    key: 'handleDragStart',
    value: function () {
      function handleDragStart(layout, oldItem, newItem, placeholder, e, element) {
        this.clearDragTimeout();
        this.notifyDragChangedListeners(true);
      }

      return handleDragStart;
    }()
  }, {
    key: 'handleDragStop',
    value: function () {
      function handleDragStop() {
        var _this10 = this;

        // wait for the CSS transitions to end before
        // turning off the dragging state
        //
        this.clearDragTimeout();
        this.dragTimeout = setTimeout(function () {
          _this10.notifyDragChangedListeners(false);
        }, _configs.LONG_DRAG_TIMEOUT);
      }

      return handleDragStop;
    }()
  }, {
    key: 'resizeHandler',
    value: function () {
      function resizeHandler() {
        (0, _utils.objVals)(this.viewHeaders).filter(function (x) {
          return x;
        }).forEach(function (viewHeader) {
          return viewHeader.checkWidth();
        });
      }

      return resizeHandler;
    }()
  }, {
    key: 'fillInMinWidths',
    value: function () {
      function fillInMinWidths(tracksDict) {
        /**
             * If tracks don't have specified dimensions, add in the known
             * minimums
             *
             * Operates on the tracks stored for this TiledPlot.
             */
        var horizontalLocations = ['top', 'bottom'];

        // first make sure all track types are specified
        // this will make the code later on simpler
        if (!('center' in tracksDict)) {
          tracksDict.center = [];
        }
        if (!('left' in tracksDict)) {
          tracksDict.left = [];
        }
        if (!('right' in tracksDict)) {
          tracksDict.right = [];
        }
        if (!('top' in tracksDict)) {
          tracksDict.top = [];
        }
        if (!('bottom' in tracksDict)) {
          tracksDict.bottom = [];
        }

        for (var j = 0; j < horizontalLocations.length; j++) {
          var tracks = tracksDict[horizontalLocations[j]];

          // e.g. no 'top' tracks
          if (!tracks) {
            continue;
          }

          for (var i = 0; i < tracks.length; i++) {
            var trackInfo = _configs.TRACKS_INFO_BY_TYPE[tracks[i].type];

            if (!('height' in tracks[i]) || trackInfo && tracks[i].height < trackInfo.minHeight) {
              if (trackInfo && trackInfo.minHeight) {
                tracks[i].height = trackInfo.minHeight;
              } else {
                tracks[i].height = this.minHorizontalHeight;
              }
            }
          }
        }

        var verticalLocations = ['left', 'right'];

        for (var _j = 0; _j < verticalLocations.length; _j++) {
          var _tracks = tracksDict[verticalLocations[_j]];

          // e.g. no 'left' tracks
          if (!_tracks) {
            continue;
          }

          for (var _i = 0; _i < _tracks.length; _i++) {
            var _trackInfo = _configs.TRACKS_INFO_BY_TYPE[_tracks[_i].type];

            if (!('width' in _tracks[_i]) || _trackInfo && _tracks[_i].width < _trackInfo.minWidth) {
              //
              if (_trackInfo && _trackInfo.minWidth) {
                _tracks[_i].width = _trackInfo.minWidth;
              } else {
                _tracks[_i].width = this.minVerticalWidth;
              }
            }
          }
        }

        return tracksDict;
      }

      return fillInMinWidths;
    }()
  }, {
    key: 'calculateViewDimensions',
    value: function () {
      function calculateViewDimensions(view) {
        /**
           * Get the dimensions for this view, counting just the tracks
           * that are present in it
           *
           * @param view: A view containing a list of tracks as a member.
           * @return: A width and a height pair (e.g. [width, height])
           */
        var defaultHorizontalHeight = 20;
        var defaultVerticalWidth = 0;
        var defaultCenterHeight = 100;
        var defaultCenterWidth = 100;
        var currHeight = this.horizontalMargin * 2;
        var currWidth = this.verticalMargin * 2; // currWidth will generally be ignored because it will just be set to
        // the width of the enclosing container
        var minNecessaryHeight = 0;
        minNecessaryHeight += 10; // the header

        var MIN_VERTICAL_HEIGHT = 20;

        if (view.tracks.top) {
          // tally up the height of the top tracks

          for (var i = 0; i < view.tracks.top.length; i++) {
            var track = view.tracks.top[i];
            currHeight += track.height ? track.height : defaultHorizontalHeight;
            minNecessaryHeight += track.height ? track.height : defaultHorizontalHeight;
          }
        }

        if (view.tracks.bottom) {
          // tally up the height of the top tracks

          for (var _i2 = 0; _i2 < view.tracks.bottom.length; _i2++) {
            var _track = view.tracks.bottom[_i2];
            currHeight += _track.height ? _track.height : defaultHorizontalHeight;
            minNecessaryHeight += _track.height ? _track.height : defaultHorizontalHeight;
          }
        }

        if (view.tracks.left && view.tracks.left.length > 0 || view.tracks.right && view.tracks.right.length > 0 || view.tracks.center && view.tracks.center.length > 0) {
          minNecessaryHeight += MIN_VERTICAL_HEIGHT;
        }

        var leftHeight = 0;
        if (view.tracks.left) {
          // tally up the height of the top tracks

          for (var _i3 = 0; _i3 < view.tracks.left.length; _i3++) {
            var _track2 = view.tracks.left[_i3];
            var thisHeight = _track2.height ? _track2.height : defaultCenterHeight;
            currWidth += _track2.width ? _track2.width : defaultVerticalWidth;

            leftHeight = Math.max(leftHeight, thisHeight);
          }
        }

        var rightHeight = 0;

        if (view.tracks.right) {
          // tally up the height of the top tracks

          for (var _i4 = 0; _i4 < view.tracks.right.length; _i4++) {
            var _track3 = view.tracks.right[_i4];
            var _thisHeight = _track3.height ? _track3.height : defaultCenterHeight;
            currWidth += _track3.width ? _track3.width : defaultVerticalWidth;

            rightHeight = Math.max(rightHeight, _thisHeight);
          }
        }

        var sideHeight = Math.max(leftHeight, rightHeight);

        var centerHeight = 0;
        var centerWidth = 0;
        if (view.tracks.center && (0, _utils.dictValues)(view.tracks.center).length > 0) {
          if (!view.tracks.center[0].contents || view.tracks.center[0].contents.length > 0) {
            var _centerHeight = null;
            var _centerWidth = null;

            if (view.tracks.center[0].contents) {
              // combined track in the center
              var _iteratorNormalCompletion10 = true;
              var _didIteratorError10 = false;
              var _iteratorError10 = undefined;

              try {
                for (var _iterator10 = view.tracks.center[0].contents[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                  var _track4 = _step10.value;

                  _centerHeight = Math.max(_centerHeight, _track4.height ? _track4.height : defaultCenterHeight);
                  _centerWidth = Math.max(_centerWidth, _track4.width ? _track4.width : defaultCenterWidth);
                }
              } catch (err) {
                _didIteratorError10 = true;
                _iteratorError10 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion10 && _iterator10['return']) {
                    _iterator10['return']();
                  }
                } finally {
                  if (_didIteratorError10) {
                    throw _iteratorError10;
                  }
                }
              }
            } else {
              _centerHeight = view.tracks.center[0].height ? view.tracks.center[0].height : defaultCenterHeight;
              _centerWidth = view.tracks.center[0].width ? view.tracks.center[0].width : defaultCenterWidth;
            }

            currHeight += _centerHeight;
            currWidth += _centerWidth;
          }
        } else if ((view.tracks.top && (0, _utils.dictValues)(view.tracks.top).length > 1 || view.tracks.bottom && (0, _utils.dictValues)(view.tracks.bottom).length > 1) && (view.tracks.left && (0, _utils.dictValues)(view.tracks.left).length || view.tracks.right && (0, _utils.dictValues)(view.tracks.right).length)) {
          centerWidth = defaultCenterWidth;
          centerHeight = defaultCenterHeight;
        }

        // make the total height the greater of the left height
        // and the center height
        if (sideHeight > centerHeight) {
          currHeight += sideHeight;
        } else {
          currHeight += centerHeight;
        }

        var topHeight = 0;
        var bottomHeight = 0;
        var leftWidth = 0;
        var rightWidth = 0;

        if ('top' in view.tracks) {
          topHeight = view.tracks.top.map(function (x) {
            return x.height ? x.height : defaultHorizontalHeight;
          }).reduce(function (a, b) {
            return a + b;
          }, 0);
        }
        if ('bottom' in view.tracks) {
          bottomHeight = view.tracks.bottom.map(function (x) {
            return x.height ? x.height : defaultHorizontalHeight;
          }).reduce(function (a, b) {
            return a + b;
          }, 0);
        }
        if ('left' in view.tracks) {
          leftWidth = view.tracks.left.map(function (x) {
            return x.width ? x.width : defaultVerticalWidth;
          }).reduce(function (a, b) {
            return a + b;
          }, 0);
        }
        if ('right' in view.tracks) {
          rightWidth = view.tracks.right.map(function (x) {
            return x.width ? x.width : defaultVerticalWidth;
          }).reduce(function (a, b) {
            return a + b;
          }, 0);
        }

        return { totalWidth: currWidth,
          totalHeight: currHeight,
          topHeight: topHeight,
          bottomHeight: bottomHeight,
          leftWidth: leftWidth,
          rightWidth: rightWidth,
          centerWidth: centerWidth,
          centerHeight: centerHeight,
          minNecessaryHeight: minNecessaryHeight };
      }

      return calculateViewDimensions;
    }()
  }, {
    key: 'generateViewLayout',
    value: function () {
      function generateViewLayout(view) {
        var layout = null;

        if ('layout' in view) {
          layout = view.layout;
        } else {
          var minTrackHeight = 30;
          var elementWidth = this.element.clientWidth;

          var _calculateViewDimensi = this.calculateViewDimensions(view),
              totalWidth = _calculateViewDimensi.totalWidth,
              totalHeight = _calculateViewDimensi.totalHeight,
              topHeight = _calculateViewDimensi.topHeight,
              bottomHeight = _calculateViewDimensi.bottomHeight,
              leftWidth = _calculateViewDimensi.leftWidth,
              rightWidth = _calculateViewDimensi.rightWidth,
              centerWidth = _calculateViewDimensi.centerWidth,
              centerHeight = _calculateViewDimensi.centerHeight;

          if (view.searchBox) {
            totalHeight += 30;
          }

          var heightGrid = Math.ceil(totalHeight / this.rowHeight);

          layout = {
            x: 0,
            y: 0,
            w: NUM_GRID_COLUMNS,
            h: DEFAULT_NEW_VIEW_HEIGHT
          };

          // the height should be adjusted when the layout changes


          /*
            if ('center' in view.tracks || 'left' in view.tracks || 'right' in view.tracks) {
                let desiredHeight = ((elementWidth - leftWidth - rightWidth - 2 * this.horizontalMargin) );
                desiredHeight +=  topHeight + bottomHeight + 2*this.verticalMargin + 20;
                 // how much height is left in the browser?
                 // limit the height of the container to the window height
                // the number 160 is relatively arbitrary and should be
                // replaced with a concrete measure of the element below and
                // above the canvas area
                let availableHeight = window.innerHeight - 160;
                 if (desiredHeight > availableHeight )
                    desiredHeight = availableHeight;
                 // stretch the view out
                layout.h = Math.ceil(desiredHeight / this.rowHeight);
            }
            else
                layout.h = heightGrid;
             layout.minH = heightGrid;
            layout.i = slugid.nice();
            */
        }

        return layout;
      }

      return generateViewLayout;
    }()
  }, {
    key: 'handleClearView',
    value: function () {
      function handleClearView(viewUid) {
        /**
         * Remove all the tracks from a view
         *
         * @param {viewUid} Thie view's identifier
         */
        var views = this.state.views;

        views[viewUid].tracks.top = [];
        views[viewUid].tracks.bottom = [];
        views[viewUid].tracks.center = [];
        views[viewUid].tracks.left = [];
        views[viewUid].tracks.right = [];

        this.setState({
          views: views
        });
      }

      return handleClearView;
    }()
  }, {
    key: 'handleCloseView',
    value: function () {
      function handleCloseView(uid) {
        /**
           * A view needs to be closed. Remove it from from the viewConfig and then clean
           * up all of its connections (zoom links, workers, etc...)
           *
           * @param {uid} This view's identifier
           */

        // check if this is the only view
        // if it is, don't close it (display an error message)
        if ((0, _utils.dictValues)(this.state.views).length == 1) {
          return;
        }

        // if this view was zoom locked to another, we need to unlock it
        this.handleUnlock(uid, this.zoomLocks);
        delete this.state.views[uid];

        var viewsByUid = this.removeInvalidTracks(this.state.views);

        // might want to notify the views that they're beig closed
        this.setState({
          views: viewsByUid
        });
      }

      return handleCloseView;
    }()
  }, {
    key: 'handleSeriesAdded',
    value: function () {
      function handleSeriesAdded(viewId, newTrack, position, hostTrack) {
        /**
             * We're adding a new dataset to an existing track
             *
             * @param newTrack: The new track to be added.
             * @param position: Where the new series should be placed.
             *  (This could also be inferred from the hostTrack, but since
             *  we already have it, we might as well use it)
             * @param hostTrack: The track that will host the new series.
             */

        // is the host track a combined track?
        // if so, easy, just append the new track to its contents
        // if not, remove the current track from the track list
        // create a new combined track, add the current and the new
        // tracks and then update the whole track list
        var tracks = this.state.views[viewId].tracks;

        if (hostTrack.type == 'combined') {
          hostTrack.contents.push(newTrack);
        } else {
          var newHost = { type: 'combined',
            uid: _slugid2['default'].nice(),
            height: hostTrack.height,
            width: hostTrack.width,
            contents: [hostTrack, newTrack] };

          var positionTracks = tracks[position];

          for (var i = 0; i < positionTracks.length; i++) {
            if (positionTracks[i].uid == hostTrack.uid) {
              positionTracks[i] = newHost;
            }
          }
        }

        this.setState({
          views: this.state.views
        });
      }

      return handleSeriesAdded;
    }()
  }, {
    key: 'handleNoTrackAdded',
    value: function () {
      function handleNoTrackAdded() {
        if (this.state.addTrackPosition) {
          // we've already added the track, remove the add track dialog
          this.setState({
            addTrackPosition: null
          });
        }
      }

      return handleNoTrackAdded;
    }()
  }, {
    key: 'handleTracksAdded',
    value: function () {
      function handleTracksAdded(viewId, newTracks, position, host) {
        /**
             * Add multiple new tracks (likely from the AddTrackModal dialog)
             *
             * @param trackInfo: A JSON object that can be used as a track
             *                   definition
             * @param position: The position the track is being added to
             * @param host: If this track is being added to another track
             */
        this.storeTrackSizes(viewId);

        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = newTracks[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var newTrack = _step11.value;
            this.handleTrackAdded(viewId, newTrack, position, host);
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11['return']) {
              _iterator11['return']();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }
      }

      return handleTracksAdded;
    }()
  }, {
    key: 'handleChangeTrackType',
    value: function () {
      function handleChangeTrackType(viewUid, trackUid, newType) {
        /**
         * Change the type of a track. For example, convert a line to a bar track.
         *
         * Parameters
         * ----------
         *  viewUid: string
         *    The view containing the track to be changed
         *  trackUid: string
         *    The uid identifying the existin track
         *  newType: string
         *    The type to switch this track to.
         */
        var view = this.state.views[viewUid];
        var trackConfig = (0, _utils.getTrackByUid)(view.tracks, trackUid);

        // this track needs a new uid so that it will be rerendered
        trackConfig.uid = _slugid2['default'].nice();
        trackConfig.type = newType;

        this.setState({
          views: this.state.views
        });
      }

      return handleChangeTrackType;
    }()
  }, {
    key: 'handleTrackAdded',
    value: function () {
      function handleTrackAdded(viewId, newTrack, position) {
        var host = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

        /**
             * A track was added from the AddTrackModal dialog.
             *
             * @param trackInfo: A JSON object that can be used as a track
             *                   definition
             * @param position: The position the track is being added to
             * @param host: If this track is being added to another track
             *
             * Returns
             * -------
             *
             *  { uid: "", width: }:
             *      The trackConfig object describing this track.
             */
        this.addDefaultOptions(newTrack);

        if (newTrack.contents) {
          // add default options to combined tracks
          var _iteratorNormalCompletion12 = true;
          var _didIteratorError12 = false;
          var _iteratorError12 = undefined;

          try {
            for (var _iterator12 = newTrack.contents[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
              var ct = _step12.value;
              this.addDefaultOptions(ct);
            }
          } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion12 && _iterator12['return']) {
                _iterator12['return']();
              }
            } finally {
              if (_didIteratorError12) {
                throw _iteratorError12;
              }
            }
          }
        }

        this.addNameToTrack(newTrack);

        if (this.state.addTrackPosition) {
          // we've already added the track, remove the add track dialog
          this.setState({
            addTrackPosition: null
          });
        }

        if (host) {
          // we're adding a series rather than a whole new track
          this.handleSeriesAdded(viewId, newTrack, position, host);
          return;
        }

        newTrack.width = _configs.TRACKS_INFO_BY_TYPE[newTrack.type].minWidth ? _configs.TRACKS_INFO_BY_TYPE[newTrack.type].minWidth : this.minVerticalWidth;
        newTrack.height = _configs.TRACKS_INFO_BY_TYPE[newTrack.type].minHeight ? _configs.TRACKS_INFO_BY_TYPE[newTrack.type].minHeight : this.minHorizontalHeight;

        var tracks = this.state.views[viewId].tracks;
        if (position == 'left' || position == 'top') {
          // if we're adding a track on the left or the top, we want the
          // new track to appear at the begginning of the track list
          tracks[position].unshift(newTrack);
        } else if (position == 'center') {
          // we're going to have to either overlay the existing track with a new one
          // or add another one on top
          if (tracks.center.length == 0) {
            // no existing tracks
            var newCombined = {
              uid: _slugid2['default'].nice(),
              type: 'combined',
              contents: [newTrack]
            };
            tracks.center = [newCombined];
          } else {
            // center track exists
            if (tracks.center[0].type == 'combined') {
              // if it's a combined track, we just need to add this track to the
              // contents
              tracks.center[0].contents.push(newTrack);
            } else {
              // if it's not, we have to create a new combined track
              var _newCombined = {
                uid: _slugid2['default'].nice(),
                type: 'combined',
                contents: [tracks.center[0], newTrack]
              };

              tracks.center = [_newCombined];
            }
          }
        } else {
          // otherwise, we want it at the end of the track list
          tracks[position].push(newTrack);
        }

        this.adjustLayoutToTrackSizes(this.state.views[viewId]);

        return newTrack;
      }

      return handleTrackAdded;
    }()
  }, {
    key: 'storeTrackSizes',
    value: function () {
      function storeTrackSizes(viewId) {
        /**
             * Go through each track and store its size in the viewconf.
             *
             * This is so that sizes don't get lost when the view is unbounded
             * and new tracks are added.
             *
             * Parameters
             * ----------
             *
             *  viewId : string
             *      The id of the view whose tracks we're measuring
             *
             * Returns
             * -------
             *
             *  Nothing
             */
        var looseTracks = (0, _utils.positionedTracksToAllTracks)(this.state.views[viewId].tracks);

        var _iteratorNormalCompletion13 = true;
        var _didIteratorError13 = false;
        var _iteratorError13 = undefined;

        try {
          for (var _iterator13 = looseTracks[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
            var track = _step13.value;

            var trackObj = this.tiledPlots[viewId].trackRenderer.getTrackObject(track.uid);

            track.width = trackObj.dimensions[0];
            track.height = trackObj.dimensions[1];
          }
        } catch (err) {
          _didIteratorError13 = true;
          _iteratorError13 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion13 && _iterator13['return']) {
              _iterator13['return']();
            }
          } finally {
            if (_didIteratorError13) {
              throw _iteratorError13;
            }
          }
        }
      }

      return storeTrackSizes;
    }()
  }, {
    key: 'adjustLayoutToTrackSizes',
    value: function () {
      function adjustLayoutToTrackSizes(view) {
        /*
             * Adjust the layout to match the size of the contained tracks. If tracks
             * are added, the layout size needs to expand. If they're removed, it needs
             * to contract.
             *
             * This function should be called from handleTrackAdded and handleCloseTrack.
             *
             * Parameters
             * ----------
             *
             *  view : {...}
             *      The definition from the viewconf
             */
        // if the view is too short, expand the view so that it fits this track
        if (!view.layout) {
          return;
        }

        var totalTrackHeight = 0;

        // we are not checking for this.viewHeaders because this function may be
        // called before the component is mounted
        if (this.props.viewConfig.editable) {
          totalTrackHeight += VIEW_HEADER_HEIGHT;
        }

        // the tracks are larger than the height of the current view, so we need
        // to extend it

        var _calculateViewDimensi2 = this.calculateViewDimensions(view),
            totalHeight = _calculateViewDimensi2.totalHeight;

        totalTrackHeight += totalHeight;

        var MARGIN_HEIGHT = this.props.viewConfig.editable ? 10 : 0;

        if (!this.props.options.bounded) {
          view.layout.h = Math.ceil((totalTrackHeight + MARGIN_HEIGHT) / (this.state.rowHeight + MARGIN_HEIGHT));
        }
      }

      return adjustLayoutToTrackSizes;
    }()
  }, {
    key: 'handleCloseTrack',
    value: function () {
      function handleCloseTrack(viewId, uid) {
        var tracks = this.state.views[viewId].tracks;

        this.handleUnlockValueScale(viewId, uid);

        for (var trackType in tracks) {
          var theseTracks = tracks[trackType];
          var newTracks = theseTracks.filter(function (d) {
            return d.uid != uid;
          });

          if (newTracks.length == theseTracks.length) {
            // no whole tracks need to removed, see if any of the combined tracks
            // contain series which need to go
            var combinedTracks = newTracks.filter(function (x) {
              return x.type == 'combined';
            });

            combinedTracks.forEach(function (ct) {
              ct.contents = ct.contents.filter(function (x) {
                return x.uid != uid;
              });
            });
          } else {
            tracks[trackType] = newTracks;
          }
        }

        this.storeTrackSizes(viewId);
        this.adjustLayoutToTrackSizes(this.state.views[viewId]);

        this.setState({
          views: this.state.views
        });

        return this.state.views;
      }

      return handleCloseTrack;
    }()
  }, {
    key: 'handleLockValueScale',
    value: function () {
      function handleLockValueScale(fromViewUid, fromTrackUid) {
        var _this11 = this;

        this.setState({
          chooseTrackHandler: function () {
            function chooseTrackHandler(toViewUid, toTrackUid) {
              return _this11.handleValueScaleLocked(fromViewUid, fromTrackUid, toViewUid, toTrackUid);
            }

            return chooseTrackHandler;
          }()
        });
      }

      return handleLockValueScale;
    }()
  }, {
    key: 'combineViewAndTrackUid',
    value: function () {
      function combineViewAndTrackUid(viewUid, trackUid) {
        // see if we've already created a uid for this view / track combo
        var uid = viewUid + '.' + trackUid;

        this.combinedUidToViewTrack[uid] = { view: viewUid, track: trackUid };

        if (this.viewTrackUidsToCombinedUid[viewUid]) {
          if (this.viewTrackUidsToCombinedUid[trackUid]) {
            return this.viewTrackUidsToCombinedUid[viewUid][trackUid];
          }

          this.viewTrackUidsToCombinedUid[viewUid][trackUid] = uid;
        } else {
          this.viewTrackUidsToCombinedUid[viewUid] = {};
          this.viewTrackUidsToCombinedUid[viewUid][trackUid] = uid;
        }

        return uid;
      }

      return combineViewAndTrackUid;
    }()
  }, {
    key: 'handleUnlockValueScale',
    value: function () {
      function handleUnlockValueScale(viewUid, trackUid) {
        // if it's combined track, unlock each individual component
        if (this.tiledPlots[viewUid].trackRenderer.getTrackObject(trackUid).createdTracks) {
          // if the from view is a combined track, recurse and add links between its child tracks
          var childTrackUids = (0, _utils.dictKeys)(this.tiledPlots[viewUid].trackRenderer.getTrackObject(trackUid).createdTracks);
          var _iteratorNormalCompletion14 = true;
          var _didIteratorError14 = false;
          var _iteratorError14 = undefined;

          try {
            for (var _iterator14 = childTrackUids[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
              var childTrackUid = _step14.value;

              this.handleUnlock(this.combineViewAndTrackUid(viewUid, childTrackUid), this.valueScaleLocks);
            }
          } catch (err) {
            _didIteratorError14 = true;
            _iteratorError14 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion14 && _iterator14['return']) {
                _iterator14['return']();
              }
            } finally {
              if (_didIteratorError14) {
                throw _iteratorError14;
              }
            }
          }
        } else {
          this.handleUnlock(this.combineViewAndTrackUid(viewUid, trackUid), this.valueScaleLocks);
        }
      }

      return handleUnlockValueScale;
    }()
  }, {
    key: 'handleValueScaleLocked',
    value: function () {
      function handleValueScaleLocked(fromViewUid, fromTrackUid, toViewUid, toTrackUid) {
        var _this12 = this;

        if (this.tiledPlots[fromViewUid].trackRenderer.getTrackObject(fromTrackUid).createdTracks) {
          // if the from view is a combined track, recurse and add links between its child tracks
          var childTrackUids = (0, _utils.dictKeys)(this.tiledPlots[fromViewUid].trackRenderer.getTrackObject(fromTrackUid).createdTracks);
          var _iteratorNormalCompletion15 = true;
          var _didIteratorError15 = false;
          var _iteratorError15 = undefined;

          try {
            for (var _iterator15 = childTrackUids[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
              var childTrackUid = _step15.value;

              this.handleValueScaleLocked(fromViewUid, childTrackUid, toViewUid, toTrackUid);
            }
          } catch (err) {
            _didIteratorError15 = true;
            _iteratorError15 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion15 && _iterator15['return']) {
                _iterator15['return']();
              }
            } finally {
              if (_didIteratorError15) {
                throw _iteratorError15;
              }
            }
          }

          return;
        }

        if (this.tiledPlots[toViewUid].trackRenderer.getTrackObject(toTrackUid).createdTracks) {
          // if the from view is a combined track, recurse and add links between its child tracks
          var _childTrackUids = (0, _utils.dictKeys)(this.tiledPlots[toViewUid].trackRenderer.getTrackObject(toTrackUid).createdTracks);
          var _iteratorNormalCompletion16 = true;
          var _didIteratorError16 = false;
          var _iteratorError16 = undefined;

          try {
            for (var _iterator16 = _childTrackUids[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
              var _childTrackUid = _step16.value;

              this.handleValueScaleLocked(fromViewUid, fromTrackUid, toViewUid, _childTrackUid);
            }
          } catch (err) {
            _didIteratorError16 = true;
            _iteratorError16 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion16 && _iterator16['return']) {
                _iterator16['return']();
              }
            } finally {
              if (_didIteratorError16) {
                throw _iteratorError16;
              }
            }
          }

          return;
        }

        var fromUid = this.combineViewAndTrackUid(fromViewUid, fromTrackUid);
        var toUid = this.combineViewAndTrackUid(toViewUid, toTrackUid);

        this.addLock(fromUid, toUid, this.valueScaleLocks, function (uid) {
          return _this12.combinedUidToViewTrack[uid];
        });

        this.syncValueScales(fromViewUid, fromTrackUid);

        this.setState({
          chooseTrackHandler: null
        });
      }

      return handleValueScaleLocked;
    }()
  }, {
    key: 'addCallbacks',
    value: function () {
      function addCallbacks(viewUid, track) {
        var _this13 = this;

        /**
           * Add callbacks for functions that need them
           *
           * Done in place.
           *
           * @param track: A view with tracks.
           */
        if (track.type == 'viewport-projection-center' || track.type == 'viewport-projection-horizontal' || track.type == 'viewport-projection-vertical') {
          var fromView = track.fromViewUid;

          track.registerViewportChanged = function (trackId, listener) {
            return _this13.addScalesChangedListener(fromView, trackId, listener);
          }, track.removeViewportChanged = function (trackId) {
            return _this13.removeScalesChangedListener(fromView, trackId);
          }, track.setDomainsCallback = function (xDomain, yDomain) {
            var tXScale = (0, _d3Scale.scaleLinear)().domain(xDomain).range(_this13.xScales[fromView].range());
            var tYScale = (0, _d3Scale.scaleLinear)().domain(yDomain).range(_this13.yScales[fromView].range());

            var _scalesCenterAndK17 = (0, _utils.scalesCenterAndK)(tXScale, tYScale),
                _scalesCenterAndK18 = _slicedToArray(_scalesCenterAndK17, 3),
                tx = _scalesCenterAndK18[0],
                ty = _scalesCenterAndK18[1],
                k = _scalesCenterAndK18[2];

            _this13.setCenters[fromView](tx, ty, k, false);

            var zoomLocked = false;
            var locationLocked = false;

            // if we drag the brush and this view is locked to others, we don't
            // want the movement we induce in them to come back and modify this
            // view and set up a feedback loop
            if (viewUid in _this13.zoomLocks) {
              zoomLocked = fromView in _this13.zoomLocks[viewUid];
            }
            if (zoomLocked) {
              _this13.handleUnlock(viewUid, _this13.zoomLocks);
            }

            if (viewUid in _this13.locationLocks) {
              locationLocked = fromView in _this13.locationLocks[viewUid];
            }
            if (locationLocked) {
              _this13.handleUnlock(viewUid, _this13.locationLocks);
            }

            _this13.handleScalesChanged(fromView, tXScale, tYScale, true);

            if (zoomLocked) {
              _this13.addLock(viewUid, fromView, _this13.zoomLocks, _this13.viewScalesLockData);
            }
            if (locationLocked) {
              _this13.addLock(viewUid, fromView, _this13.locationLocks, _this13.viewScalesLockData);
            }
          };
        }
      }

      return addCallbacks;
    }()
  }, {
    key: 'deserializeLocationLocks',
    value: function () {
      function deserializeLocationLocks(viewConfig) {
        this.locationLocks = {};

        if (viewConfig.locationLocks) {
          var _iteratorNormalCompletion17 = true;
          var _didIteratorError17 = false;
          var _iteratorError17 = undefined;

          try {
            for (var _iterator17 = (0, _utils.dictKeys)(viewConfig.locationLocks.locksByViewUid)[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
              var viewUid = _step17.value;

              this.locationLocks[viewUid] = viewConfig.locationLocks.locksDict[viewConfig.locationLocks.locksByViewUid[viewUid]];
            }
          } catch (err) {
            _didIteratorError17 = true;
            _iteratorError17 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion17 && _iterator17['return']) {
                _iterator17['return']();
              }
            } finally {
              if (_didIteratorError17) {
                throw _iteratorError17;
              }
            }
          }
        }
      }

      return deserializeLocationLocks;
    }()
  }, {
    key: 'deserializeZoomLocks',
    value: function () {
      function deserializeZoomLocks(viewConfig) {
        this.zoomLocks = {};

        //
        if (viewConfig.zoomLocks) {
          var _iteratorNormalCompletion18 = true;
          var _didIteratorError18 = false;
          var _iteratorError18 = undefined;

          try {
            for (var _iterator18 = (0, _utils.dictKeys)(viewConfig.zoomLocks.locksByViewUid)[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
              var viewUid = _step18.value;

              this.zoomLocks[viewUid] = viewConfig.zoomLocks.locksDict[viewConfig.zoomLocks.locksByViewUid[viewUid]];
            }
          } catch (err) {
            _didIteratorError18 = true;
            _iteratorError18 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion18 && _iterator18['return']) {
                _iterator18['return']();
              }
            } finally {
              if (_didIteratorError18) {
                throw _iteratorError18;
              }
            }
          }
        }
      }

      return deserializeZoomLocks;
    }()
  }, {
    key: 'deserializeValueScaleLocks',
    value: function () {
      function deserializeValueScaleLocks(viewConfig) {
        if (viewConfig.valueScaleLocks) {
          var _iteratorNormalCompletion19 = true;
          var _didIteratorError19 = false;
          var _iteratorError19 = undefined;

          try {
            for (var _iterator19 = (0, _utils.dictKeys)(viewConfig.valueScaleLocks.locksByViewUid)[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
              var viewUid = _step19.value;

              this.valueScaleLocks[viewUid] = viewConfig.valueScaleLocks.locksDict[viewConfig.valueScaleLocks.locksByViewUid[viewUid]];
            }
          } catch (err) {
            _didIteratorError19 = true;
            _iteratorError19 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion19 && _iterator19['return']) {
                _iterator19['return']();
              }
            } finally {
              if (_didIteratorError19) {
                throw _iteratorError19;
              }
            }
          }
        }
      }

      return deserializeValueScaleLocks;
    }()
  }, {
    key: 'serializeLocks',
    value: function () {
      function serializeLocks(locks) {
        var locksDict = {};
        var locksByViewUid = {};

        var _iteratorNormalCompletion20 = true;
        var _didIteratorError20 = false;
        var _iteratorError20 = undefined;

        try {
          for (var _iterator20 = (0, _utils.dictKeys)(locks)[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
            var viewUid = _step20.value;

            var lockUid = locks[viewUid] && locks[viewUid].uid;

            if (!lockUid) {
              // otherwise, assign this locationLock its own uid
              lockUid = _slugid2['default'].nice();
            }
            locks[viewUid].uid = lockUid;

            // make a note that we've seen this lock
            locksDict[lockUid] = locks[viewUid];

            // note that this view has a reference to this lock
            locksByViewUid[viewUid] = locks[viewUid].uid;
          }

          // remove the uids we just added
          // for (let viewUid of dictKeys(locks)) {
          //   if (locks[viewUid].hasOwnProperty('uid')) {
          //     locks[viewUid].uid = undefined;
          //     delete locks[viewUid].uid;
          //   }
          // }
        } catch (err) {
          _didIteratorError20 = true;
          _iteratorError20 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion20 && _iterator20['return']) {
              _iterator20['return']();
            }
          } finally {
            if (_didIteratorError20) {
              throw _iteratorError20;
            }
          }
        }

        return { locksByViewUid: locksByViewUid, locksDict: locksDict };
      }

      return serializeLocks;
    }()
  }, {
    key: 'getViewsAsString',
    value: function () {
      function getViewsAsString() {
        var _this14 = this;

        var newJson = JSON.parse(JSON.stringify(this.props.viewConfig));
        newJson.views = (0, _utils.dictItems)(this.state.views).map(function (k) {
          var newView = JSON.parse(JSON.stringify(k[1]));
          var uid = k[0];

          var _iteratorNormalCompletion21 = true;
          var _didIteratorError21 = false;
          var _iteratorError21 = undefined;

          try {
            for (var _iterator21 = (0, _utils.positionedTracksToAllTracks)(newView.tracks)[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
              var track = _step21.value;


              if (track.server) {
                var url = (0, _urlParse2['default'])(track.server, {});

                if (!url.hostname.length) {
                  // no hostname specified in the track source servers so we'll add the
                  // current URL's
                  var hostString = window.location.host;
                  var protocol = window.location.protocol;
                  var newUrl = protocol + '//' + hostString + url.pathname;

                  track.server = newUrl;
                }
              }

              if ('serverUidKey' in track) {
                delete track.serverUidKey;
              }
              if ('uuid' in track) {
                delete track.uuid;
              }
              if ('private' in track) {
                delete track['private'];
              }
              if ('maxZoom' in track) {
                delete track.maxZoom;
              }
              if ('coordSystem' in track) {
                delete track.coordSystem;
              }
              if ('coordSystem2' in track) {
                delete track.coordSystem2;
              }
              if ('datatype' in track) {
                delete track.datatype;
              }
              if ('maxWidth' in track) {
                delete track.maxWidth;
              }
              if ('datafile' in track) {
                delete track.datafile;
              }
              if ('filetype' in track) {
                delete track.filetype;
              }
              if ('binsPerDimension' in track) {
                delete track.binsPerDimension;
              }
            }
            //
          } catch (err) {
            _didIteratorError21 = true;
            _iteratorError21 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion21 && _iterator21['return']) {
                _iterator21['return']();
              }
            } finally {
              if (_didIteratorError21) {
                throw _iteratorError21;
              }
            }
          }

          newView.uid = uid;
          newView.initialXDomain = _this14.xScales[uid].domain();
          newView.initialYDomain = _this14.yScales[uid].domain();

          return newView;
        });

        newJson.zoomLocks = this.serializeLocks(this.zoomLocks);
        newJson.locationLocks = this.serializeLocks(this.locationLocks);
        newJson.valueScaleLocks = this.serializeLocks(this.valueScaleLocks);

        var data = JSON.stringify(newJson, null, 2);
        return data;
      }

      return getViewsAsString;
    }()
  }, {
    key: 'handleExportViewAsJSON',
    value: function () {
      function handleExportViewAsJSON() {
        var data = this.getViewsAsString();
        var file = new Blob([data], { type: 'text/json' });

        (0, _utils.download)('viewconf.json', data);
      }

      return handleExportViewAsJSON;
    }()
  }, {
    key: 'handleExportViewsAsLink',
    value: function () {
      function handleExportViewsAsLink() {
        var _this15 = this;

        var wrapper = '{"viewconf":' + this.getViewsAsString() + '}';

        this.width = this.element.clientWidth;
        this.height = this.element.clientHeight;

        this.setState({
          exportLinkModalOpen: true,
          exportLinkLocation: null
        });

        (0, _d3Request.request)(this.props.viewConfig.exportViewUrl).header('X-Requested-With', 'XMLHttpRequest').header('Content-Type', 'application/json').post(wrapper, function (error, response) {
          if (response) {
            var content = JSON.parse(response.response);
            var portString = window.location.port === '' ? '' : ':' + window.location.port;
            _this15.setState({
              // exportLinkLocation: this.props.viewConfig.exportViewUrl + "?d=" + content.uid
              exportLinkLocation: 'http://' + window.location.hostname + portString + '/app/?config=' + content.uid
            });
          } else {
            console.error('error:', error);
          }
        });
      }

      return handleExportViewsAsLink;
    }()
  }, {
    key: 'handleDataDomainChanged',
    value: function () {
      function handleDataDomainChanged(viewUid, newXDomain, newYDomain) {
        /*
             * The initial[XY]Domain of a view has changed. Update its definition
             * and rerender.
             */
        var views = this.state.views;

        views[viewUid].initialXDomain = newXDomain;
        views[viewUid].initialYDomain = newYDomain;

        this.setState({ views: views });
      }

      return handleDataDomainChanged;
    }()
  }, {
    key: 'viewPositionAvailable',
    value: function () {
      function viewPositionAvailable(pX, pY, w, h) {
        /**
           * Check if we can place a view at this position
           */
        var pEndX = pX + w;
        var pEndY = pY + h;

        if (pX + w > NUM_GRID_COLUMNS) {
          // this view will go over the right edge of our grid
          return false;
        }

        var sortedViews = (0, _utils.dictValues)(this.state.views);

        // check if this position
        for (var j = 0; j < sortedViews.length; j++) {
          var svX = sortedViews[j].layout.x;
          var svY = sortedViews[j].layout.y;

          var svEndX = svX + sortedViews[j].layout.w;
          var svEndY = svY + sortedViews[j].layout.h;

          var intersects = false;

          if (pX < svEndX && pEndX > svX) {
            // x range intersects
            if (pY < svEndY && pEndY > svY) {
              // y range intersects
              return false;
            }
          }
        }

        return true;
      }

      return viewPositionAvailable;
    }()
  }, {
    key: 'handleAddView',
    value: function () {
      function handleAddView(view) {
        var _this16 = this;

        /**
           * User clicked on the "Add View" button. We'll duplicate the last
           * view.
           */

        var views = (0, _utils.dictValues)(this.state.views);
        var lastView = view;

        var potentialPositions = [];

        for (var i = 0; i < views.length; i++) {
          var pX = views[i].layout.x + views[i].layout.w;
          var pY = views[i].layout.y;

          // can we place the new view to the right of this view?
          if (this.viewPositionAvailable(pX, pY, view.layout.w, view.layout.h)) {
            potentialPositions.push([pX, pY]);
          }

          pX = views[i].layout.x;
          pY = views[i].layout.y + views[i].layout.h;
          // can we place the new view below this view
          if (this.viewPositionAvailable(pX, pY, view.layout.w, view.layout.h)) {
            potentialPositions.push([pX, pY]);
          }
        }

        potentialPositions.sort(function (a, b) {
          var n = a[1] - b[1];

          if (n == 0) {
            return a[0] - b[0];
          }

          return n;
        });

        /*
          for (let i = 0; i < views.length; i++) {
              let view = views[i];
               if ('layout' in view) {
                  if ('minH' in view.layout)
                        maxY += Math.max(maxY, view.layout.y + view.layout.minH);
                  else
                        maxY += Math.max(maxY, view.layout.y + 1);
              }
          }
          */

        var jsonString = JSON.stringify(lastView);

        var newView = JSON.parse(jsonString); // ghetto copy

        // place this new view below all the others
        newView.layout.x = potentialPositions[0][0];
        newView.layout.y = potentialPositions[0][1];

        // give it its own unique id
        newView.uid = _slugid2['default'].nice();
        newView.layout.i = newView.uid;

        (0, _utils.positionedTracksToAllTracks)(newView.tracks).forEach(function (t) {
          return _this16.addCallbacks(newView.uid, t);
        });

        this.state.views[newView.uid] = newView;

        this.setState({
          views: this.state.views
        });

        /*
          this.state
          freshViewConfig.views.push(newView);
          let newViewConfigText = JSON.stringify(freshViewConfig);
           this.props.onNewConfig(newViewConfigText);
          */
      }

      return handleAddView;
    }()
  }, {
    key: 'addNameToTrack',
    value: function () {
      function addNameToTrack(track) {
        /**
           * Add a name to this track based on its track type.
           *
           * Name is added in-place.
           *
           * The list of track information can be found in config.js:TRACKS_INFO
           */
        var typeToName = {};
        _configs.TRACKS_INFO.forEach(function (x) {
          if (x.name) {
            typeToName[x.type] = x.name;
          }
        });

        if (track.type in typeToName) {
          track.name = typeToName[track.type];
        }

        return track;
      }

      return addNameToTrack;
    }()
  }, {
    key: 'addUidsToTracks',
    value: function () {
      function addUidsToTracks(allTracks) {
        /**
             * Add track names to the ones that have known names in config.js
             */

        allTracks.forEach(function (t) {
          if (!t.uid) {
            t.uid = _slugid2['default'].nice();
          }
        });

        return allTracks;
      }

      return addUidsToTracks;
    }()
  }, {
    key: 'addNamesToTracks',
    value: function () {
      function addNamesToTracks(allTracks) {
        var _this17 = this;

        /**
             * Add track names to the ones that have known names in config.js
             */

        allTracks.forEach(function (t) {
          if (!t.name) {
            _this17.addNameToTrack(t);
          }
        });

        return allTracks;
      }

      return addNamesToTracks;
    }()
  }, {
    key: 'handleSelectedAssemblyChanged',
    value: function () {
      function handleSelectedAssemblyChanged(viewUid, newAssembly, newAutocompleteId, newServer) {
        /*
         * A new assembly was selected in the GenomePositionSearchBox. 
         * Update the corresponding
         * view's entry
         *
         * Arguments
         * ---------
         *
         * viewUid: string
         *      The uid of the view this genomepositionsearchbox belongs to
         * newAssembly: string
         *      The new assembly it should display coordinates for
         *
         * Returns
         * -------
         *
         *  Nothing
         */
        var views = this.state.views;

        views[viewUid].genomePositionSearchBox.chromInfoId = newAssembly;
        views[viewUid].genomePositionSearchBox.autocompleteId = newAutocompleteId;
        views[viewUid].genomePositionSearchBox.autocompleteServer = newServer;
      }

      return handleSelectedAssemblyChanged;
    }()
  }, {
    key: 'createGenomePostionSearchBoxEntry',
    value: function () {
      function createGenomePostionSearchBoxEntry(existingGenomePositionSearchBox, suggestedAssembly) {
        /*
             * Create genomePositionSearchBox settings. If existing settings for this view exist,
             * then use those. Otherwise use defaults.
             *
             * Arguments:
             *     existingGenomePositionSearchBox:
             *          {
             *              autocompleteServer: string (e.g. higlass.io/api/v1),
             *              autocompleteId: string (e.g. Xz1f)
             *              chromInfoServer: string (e.g. higlass.io/api/v1)
             *              chromInfoId: string (e.g. hg19)
             *              visible: boolean (e.g. true)
             *           }
             *          If there's already information about which assembly and autocomplete
             *          source to use, it should be in this format.
             *
             *      suggestedAssembly:
             *          Guess which assembly should be displayed based on the tracks visible.
             *          In all meaningful scenarios, all tracks should be of the same assembly
             *          but in case they're not, suggest the most common one
             *
             * Return:
             *      A valid genomePositionSearchBox object
             *
             */
        var newGpsb = existingGenomePositionSearchBox;
        var defaultGpsb = {
          autocompleteServer: _configs.DEFAULT_SERVER,
          // "autocompleteId": "OHJakQICQD6gTD7skx4EWA",
          chromInfoServer: _configs.DEFAULT_SERVER,
          visible: false
        };

        if (!newGpsb) {
          newGpsb = JSON.parse(JSON.stringify(defaultGpsb));
        }

        if (!newGpsb.autocompleteServer) {
          newGpsb.autocompleteServer = defaultGpsb.autocompleteServer;
        }

        /*
             * If we don't have an autocompleteId, we'll try to look it up in
             * the autocomplete server
             */
        /*
            if (!newGpsb.autocompleteId)
                newGpsb.autocompleteId = defaultGpsb.autocompleteId;
            */

        if (!newGpsb.chromInfoId) {
          newGpsb.chromInfoId = suggestedAssembly;
        }

        if (!newGpsb.chromInfoServer) {
          newGpsb.chromInfoServer = defaultGpsb.chromInfoServer;
        }

        if (!newGpsb.visible) {
          newGpsb.visible = false;
        }

        return newGpsb;
      }

      return createGenomePostionSearchBoxEntry;
    }()
  }, {
    key: 'handleTogglePositionSearchBox',
    value: function () {
      function handleTogglePositionSearchBox(viewUid) {
        /*
             * Show or hide the genome position search box for a given view
             */

        var view = this.state.views[viewUid];
        view.genomePositionSearchBoxVisible = !view.genomePositionSearchBoxVisible;

        var positionedTracks = (0, _utils.positionedTracksToAllTracks)(view.tracks);

        // count the number of tracks that are part of some assembly
        var assemblyCounts = {};
        var _iteratorNormalCompletion22 = true;
        var _didIteratorError22 = false;
        var _iteratorError22 = undefined;

        try {
          for (var _iterator22 = positionedTracks[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
            var track = _step22.value;

            if (!track.coordSystem) {
              continue;
            }

            if (!assemblyCounts[track.coordSystem]) {
              assemblyCounts[track.coordSystem] = 0;
            }

            assemblyCounts[track.coordSystem] += 1;
          }
        } catch (err) {
          _didIteratorError22 = true;
          _iteratorError22 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion22 && _iterator22['return']) {
              _iterator22['return']();
            }
          } finally {
            if (_didIteratorError22) {
              throw _iteratorError22;
            }
          }
        }

        var sortedAssemblyCounts = (0, _utils.dictItems)(assemblyCounts).sort(function (a, b) {
          return b[1] - a[1];
        });
        var selectedAssembly = 'hg19'; // always the default if nothing is otherwise selected

        if (sortedAssemblyCounts.length) {
          selectedAssembly = sortedAssemblyCounts[0][0];
        }

        view.genomePositionSearchBox = this.createGenomePostionSearchBoxEntry(view.genomePositionSearchBox, selectedAssembly);
        view.genomePositionSearchBox.visible = !view.genomePositionSearchBox.visible;

        this.refreshView();

        this.setState({
          views: this.state.views,
          configMenuUid: null
        });
      }

      return handleTogglePositionSearchBox;
    }()
  }, {
    key: 'handleTrackOptionsChanged',
    value: function () {
      function handleTrackOptionsChanged(viewUid, trackUid, newOptions) {
        // some track's options changed...
        // redraw the track  and store the changes in the config file
        var view = this.state.views[viewUid];
        var track = (0, _utils.getTrackByUid)(view.tracks, trackUid);

        if (!track) return;

        track.options = Object.assign(track.options, newOptions);

        if (this.mounted) {
          this.setState({
            views: this.state.views
          });
        }
      }

      return handleTrackOptionsChanged;
    }()
  }, {
    key: 'isTrackValid',
    value: function () {
      function isTrackValid(track, viewUidsPresent) {
        /**
             * Determine whether a track is valid and can be displayed.
             *
             * Tracks can be invalid due to inconsistent input such as
             * referral to views that don't exist
             *
             * @param track (object): A track definition
             * @param viewUidsPresent (Set): The view uids which are available
             */

        if (track.type == 'viewport-projection-center') {
          if (!viewUidsPresent.has(track.fromViewUid)) {
            return false;
          }
        }

        return true;
      }

      return isTrackValid;
    }()
  }, {
    key: 'removeInvalidTracks',
    value: function () {
      function removeInvalidTracks(viewsByUid) {
        var _this18 = this;

        /**
             * Remove tracks which can no longer be shown (possibly because the views they
             * refer to no longer exist
             */
        var viewUidsSet = new Set((0, _utils.dictKeys)(viewsByUid));

        var _iteratorNormalCompletion23 = true;
        var _didIteratorError23 = false;
        var _iteratorError23 = undefined;

        try {
          for (var _iterator23 = (0, _utils.dictValues)(viewsByUid)[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
            var v = _step23.value;
            var _arr = ['left', 'top', 'center', 'right', 'bottom'];

            for (var _i5 = 0; _i5 < _arr.length; _i5++) {
              var trackOrientation = _arr[_i5];
              if (v.tracks.hasOwnProperty(trackOrientation)) {
                // filter out invalid tracks
                v.tracks[trackOrientation] = v.tracks[trackOrientation].filter(function (t) {
                  return _this18.isTrackValid(t, viewUidsSet);
                });

                // filter out invalid tracks in combined tracks
                v.tracks[trackOrientation].forEach(function (t) {
                  if (t.type == 'combined') {
                    t.contents = t.contents.filter(function (c) {
                      return _this18.isTrackValid(c, viewUidsSet);
                    });
                  }
                });
              }
            }
          }
        } catch (err) {
          _didIteratorError23 = true;
          _iteratorError23 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion23 && _iterator23['return']) {
              _iterator23['return']();
            }
          } finally {
            if (_didIteratorError23) {
              throw _iteratorError23;
            }
          }
        }

        return viewsByUid;
      }

      return removeInvalidTracks;
    }()
  }, {
    key: 'processViewConfig',
    value: function () {
      function processViewConfig(viewConfig) {
        var _this19 = this;

        var views = viewConfig.views;
        var viewsByUid = {};

        if (!viewConfig.views || viewConfig.views.length == 0) throw 'No views provided in viewConfig';

        views.forEach(function (v) {
          _this19.fillInMinWidths(v.tracks);

          // if a view doesn't have a uid, assign it one
          if (!v.uid) {
            v.uid = _slugid2['default'].nice();
          }

          viewsByUid[v.uid] = v;

          if (!v.initialXDomain) {
            throw 'No initialXDomain in provided viewconf';
          } else {
            v.initialXDomain[0] = +v.initialXDomain[0];
            v.initialXDomain[1] = +v.initialXDomain[1];
          }

          // if there's no y domain specified just use the x domain instead
          // effectively centers the view on the diagonal
          if (!v.initialYDomain) {
            v.initialYDomain = [v.initialXDomain[0], v.initialXDomain[1]];
          } else {
            v.initialXDomain[0] = +v.initialXDomain[0];
            v.initialXDomain[1] = +v.initialXDomain[1];
          }

          if (!_this19.xScales[v.uid]) _this19.xScales[v.uid] = (0, _d3Scale.scaleLinear)().domain(v.initialXDomain);
          if (!_this19.yScales[v.uid]) _this19.yScales[v.uid] = (0, _d3Scale.scaleLinear)().domain(v.initialYDomain);

          // Add names to all the tracks
          var looseTracks = (0, _utils.positionedTracksToAllTracks)(v.tracks);

          _this19.deserializeZoomLocks(viewConfig);
          _this19.deserializeLocationLocks(viewConfig);
          _this19.deserializeValueScaleLocks(viewConfig);

          // give tracks their default names (e.g. 'type': 'top-axis'
          // will get a name of 'Top Axis'
          looseTracks = _this19.addUidsToTracks(looseTracks);
          looseTracks = _this19.addNamesToTracks(looseTracks);

          looseTracks.forEach(function (t) {
            return _this19.addCallbacks(v.uid, t);
          });

          // make sure that the layout for this view refers to this view
          if (v.layout) {
            v.layout.i = v.uid;
          }

          // add default options (as specified in config.js
          // (e.g. line color, heatmap color scales, etc...)
          looseTracks.forEach(function (t) {
            _this19.addDefaultOptions(t);

            if (t.contents) {
              // add default options to combined tracks
              var _iteratorNormalCompletion24 = true;
              var _didIteratorError24 = false;
              var _iteratorError24 = undefined;

              try {
                for (var _iterator24 = t.contents[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
                  var ct = _step24.value;
                  _this19.addDefaultOptions(ct);
                }
              } catch (err) {
                _didIteratorError24 = true;
                _iteratorError24 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion24 && _iterator24['return']) {
                    _iterator24['return']();
                  }
                } finally {
                  if (_didIteratorError24) {
                    throw _iteratorError24;
                  }
                }
              }
            }
          });
        });

        viewsByUid = this.removeInvalidTracks(viewsByUid);

        return viewsByUid;
      }

      return processViewConfig;
    }()
  }, {
    key: 'handleWindowFocused',
    value: function () {
      function handleWindowFocused() {
        /*
             * The window housing this view gained focus. That means the bounding boxes
             * may have changed so we need to redraw everything.
             *
             */

      }

      return handleWindowFocused;
    }()
  }, {
    key: 'offRangeSelection',
    value: function () {
      function offRangeSelection(listenerId) {
        this.rangeSelectionListener.splice(listenerId, 1);
      }

      return offRangeSelection;
    }()
  }, {
    key: 'onRangeSelection',
    value: function () {
      function onRangeSelection(callback) {
        return this.rangeSelectionListener.push(callback) - 1;
      }

      return onRangeSelection;
    }()
  }, {
    key: 'rangeSelectionHandler',
    value: function () {
      function rangeSelectionHandler(range) {
        this.rangeSelection = range;
        this.rangeSelectionListener.forEach(function (callback) {
          return callback(range);
        });
      }

      return rangeSelectionHandler;
    }()
  }, {
    key: 'offViewChange',
    value: function () {
      function offViewChange(listenerId) {
        this.viewChangeListener.splice(listenerId, 1);
      }

      return offViewChange;
    }()
  }, {
    key: 'onViewChange',
    value: function () {
      function onViewChange(callback) {
        return this.viewChangeListener.push(callback) - 1;
      }

      return onViewChange;
    }()
  }, {
    key: 'triggerViewChange',
    value: function () {
      function triggerViewChange() {
        var _this20 = this;

        this.viewChangeListener.forEach(function (callback) {
          return callback(_this20.getViewsAsString());
        });
      }

      return triggerViewChange;
    }()
  }, {
    key: 'getGenomeLocation',
    value: function () {
      function getGenomeLocation(viewId) {
        var _this21 = this;

        return _services.chromInfo.get(this.state.views[viewId].chromInfoPath).then(function (chromInfo) {
          return (0, _utils.scalesToGenomeLoci)(_this21.xScales[viewId], _this21.yScales[viewId], chromInfo);
        });
      }

      return getGenomeLocation;
    }()
  }, {
    key: 'offLocationChange',
    value: function () {
      function offLocationChange(viewId, listenerId) {
        this.removeScalesChangedListener(viewId, listenerId);
      }

      return offLocationChange;
    }()
  }, {
    key: 'onLocationChange',
    value: function () {
      function onLocationChange(viewId, callback, callbackId) {
        var _this22 = this;

        if (typeof viewId === 'undefined' || Object.keys(this.state.views).indexOf(viewId) === -1) {
          console.error(' listen to me: you forgot to give me a propper view ID. ' + 'I can\'t do nothing without that. ');
          return;
        }

        var view = this.state.views[viewId];

        // Set chromInfo if not available
        if (!this.chromInfo) {
          this.setChromInfo(view.chromInfoPath, function () {
            _this22.onLocationChange(viewId, callback, callbackId);
          });
          return;
        }

        // Convert scales into genomic locations
        var middleLayerListener = function () {
          function middleLayerListener(xScale, yScale) {
            callback((0, _utils.scalesToGenomeLoci)(xScale, yScale, _this22.chromInfo));
          }

          return middleLayerListener;
        }();

        var newListenerId = Object.keys(this.scalesChangedListeners[view.uid]).filter(function (listenerId) {
          return listenerId.indexOf(_configs.LOCATION_LISTENER_PREFIX) === 0;
        }).map(function (listenerId) {
          return parseInt(listenerId.slice(_configs.LOCATION_LISTENER_PREFIX.length + 1), 10);
        }).reduce(function (max, value) {
          return Math.max(max, value);
        }, 0) + 1;

        var scaleListener = this.addScalesChangedListener(view.uid, _configs.LOCATION_LISTENER_PREFIX + '.' + newListenerId, middleLayerListener);

        if (callbackId) {
          callbackId(_configs.LOCATION_LISTENER_PREFIX + '.' + newListenerId);
        }
      }

      return onLocationChange;
    }()
  }, {
    key: 'setChromInfo',
    value: function () {
      function setChromInfo(chromInfoPath, callback) {
        var _this23 = this;

        (0, _ChromosomeInfo.ChromosomeInfo)(chromInfoPath, function (chromInfo) {
          _this23.chromInfo = chromInfo;
          callback();
        });
      }

      return setChromInfo;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this24 = this;

        // console.log('rendering');
        var tiledAreas = _react2['default'].createElement('div', {
          ref: function () {
            function ref(c) {
              _this24.tiledAreaDiv = c;
            }

            return ref;
          }(),
          className: 'HiGlass-module_tiled-area-22H1L'
        });

        // The component needs to be mounted in order for the initial view to have the right
        // width
        if (this.mounted) {
          tiledAreas = (0, _utils.dictValues)(this.state.views).map(function (view) {
            var zoomFixed = typeof view.zoomFixed !== 'undefined' ? view.zoomFixed : _this24.props.zoomFixed;

            // only show the add track menu for the tiled plot it was selected
            // for
            var addTrackPositionMenuPosition = view.uid === _this24.state.addTrackPositionMenuUid ? _this24.state.addTrackPositionMenuPosition : null;

            var overlay = null;
            if (_this24.state.chooseViewHandler) {
              var background = 'transparent';

              if (_this24.state.mouseOverOverlayUid === view.uid) background = 'green';

              overlay = _react2['default'].createElement('div', {
                className: 'tiled-plot-overlay',
                onClick: function () {
                  function onClick() {
                    return _this24.state.chooseViewHandler(view.uid);
                  }

                  return onClick;
                }(),
                onMouseEnter: function () {
                  function onMouseEnter() {
                    return _this24.handleOverlayMouseEnter(view.uid);
                  }

                  return onMouseEnter;
                }(),
                onMouseLeave: function () {
                  function onMouseLeave() {
                    return _this24.handleOverlayMouseLeave(view.uid);
                  }

                  return onMouseLeave;
                }(),
                onMouseMove: function () {
                  function onMouseMove() {
                    return _this24.handleOverlayMouseEnter(view.uid);
                  }

                  return onMouseMove;
                }(),
                style: {
                  position: 'absolute',
                  width: '100%',
                  height: '100%',
                  background: background,
                  opacity: 0.3
                }
              });
            }

            var tiledPlot = _react2['default'].createElement(_TiledPlot.TiledPlot
            // Reserved props
            , { key: 'tp' + view.uid,
              ref: function () {
                function ref(c) {
                  _this24.tiledPlots[view.uid] = c;
                }

                return ref;
              }()

              // Custom props
              , addTrackPosition: _this24.state.addTrackPositionView === view.uid ? _this24.state.addTrackPosition : null,
              addTrackPositionMenuPosition: addTrackPositionMenuPosition,
              canvasElement: _this24.state.canvasElement,
              chooseTrackHandler: _this24.state.chooseTrackHandler ? function (trackId) {
                return _this24.state.chooseTrackHandler(view.uid, trackId);
              } : null,
              chromInfoPath: view.chromInfoPath,
              editable: _this24.props.viewConfig.editable,
              horizontalMargin: _this24.horizontalMargin,
              initialXDomain: view.initialXDomain,
              initialYDomain: view.initialYDomain,
              mouseTool: _this24.state.mouseTool,
              onChangeTrackType: function () {
                function onChangeTrackType(trackId, newType) {
                  return _this24.handleChangeTrackType(view.uid, trackId, newType);
                }

                return onChangeTrackType;
              }(),
              onCloseTrack: function () {
                function onCloseTrack(uid) {
                  return _this24.handleCloseTrack(view.uid, uid);
                }

                return onCloseTrack;
              }(),
              onDataDomainChanged: function () {
                function onDataDomainChanged(xDomain, yDomain) {
                  return _this24.handleDataDomainChanged(view.uid, xDomain, yDomain);
                }

                return onDataDomainChanged;
              }(),
              onLockValueScale: function () {
                function onLockValueScale(uid) {
                  return _this24.handleLockValueScale(view.uid, uid);
                }

                return onLockValueScale;
              }(),
              onNewTilesLoaded: function () {
                function onNewTilesLoaded(trackUid) {
                  return _this24.handleNewTilesLoaded(view.uid, trackUid);
                }

                return onNewTilesLoaded;
              }(),
              onNoTrackAdded: _this24.handleNoTrackAdded.bind(_this24),
              onRangeSelection: _this24.rangeSelectionHandler.bind(_this24),
              onScalesChanged: function () {
                function onScalesChanged(x, y) {
                  return _this24.handleScalesChanged(view.uid, x, y);
                }

                return onScalesChanged;
              }(),
              onTrackOptionsChanged: function () {
                function onTrackOptionsChanged(trackId, options) {
                  return _this24.handleTrackOptionsChanged(view.uid, trackId, options);
                }

                return onTrackOptionsChanged;
              }(),
              onTrackPositionChosen: _this24.handleTrackPositionChosen.bind(_this24),
              onTracksAdded: function () {
                function onTracksAdded(newTracks, position, host) {
                  return _this24.handleTracksAdded(view.uid, newTracks, position, host);
                }

                return onTracksAdded;
              }(),
              onUnlockValueScale: function () {
                function onUnlockValueScale(uid) {
                  return _this24.handleUnlockValueScale(view.uid, uid);
                }

                return onUnlockValueScale;
              }(),
              onValueScaleChanged: function () {
                function onValueScaleChanged(uid) {
                  return _this24.syncValueScales(view.uid, uid);
                }

                return onValueScaleChanged;
              }(),
              pixiStage: _this24.pixiStage,
              registerDraggingChangedListener: function () {
                function registerDraggingChangedListener(listener) {
                  _this24.addDraggingChangedListener(view.uid, view.uid, listener);
                }

                return registerDraggingChangedListener;
              }(),
              removeDraggingChangedListener: function () {
                function removeDraggingChangedListener(listener) {
                  return _this24.removeDraggingChangedListener(view.uid, view.uid, listener);
                }

                return removeDraggingChangedListener;
              }(),
              setCentersFunction: function () {
                function setCentersFunction(c) {
                  _this24.setCenters[view.uid] = c;
                }

                return setCentersFunction;
              }(),
              svgElement: _this24.state.svgElement,
              trackSourceServers: _this24.props.viewConfig.trackSourceServers,
              tracks: view.tracks,
              uid: view.uid,
              verticalMargin: _this24.verticalMargin
              // dragging={this.state.dragging}
              , zoomable: !zoomFixed
            });

            var getGenomePositionSearchBox = function () {
              function getGenomePositionSearchBox(isFocused, onFocus) {
                if (!view.genomePositionSearchBox) return null;

                return _react2['default'].createElement(_GenomePositionSearchBox2['default']
                // Reserved props
                , { key: 'gpsb' + view.uid,
                  ref: function () {
                    function ref(c) {
                      _this24.genomePositionSearchBoxes[view.uid] = c;
                    }

                    return ref;
                  }()

                  // Custom props
                  , autocompleteId: view.genomePositionSearchBox.autocompleteId,
                  autocompleteServer: view.genomePositionSearchBox.autocompleteServer,
                  chromInfoId: view.genomePositionSearchBox.chromInfoId,
                  chromInfoServer: view.genomePositionSearchBox.chromInfoServer,
                  isFocused: isFocused
                  // the chromInfoId is either specified in the viewconfig or guessed based on
                  // the visible tracks (see createGenomePositionSearchBoxEntry)
                  , onFocus: onFocus,
                  onSelectedAssemblyChanged: function () {
                    function onSelectedAssemblyChanged(x, y, server) {
                      return _this24.handleSelectedAssemblyChanged(view.uid, x, y, server);
                    }

                    return onSelectedAssemblyChanged;
                  }(),
                  registerViewportChangedListener: function () {
                    function registerViewportChangedListener(listener) {
                      return _this24.addScalesChangedListener(view.uid, view.uid, listener);
                    }

                    return registerViewportChangedListener;
                  }(),
                  removeViewportChangedListener: function () {
                    function removeViewportChangedListener() {
                      return _this24.removeScalesChangedListener(view.uid, view.uid);
                    }

                    return removeViewportChangedListener;
                  }(),
                  setCenters: function () {
                    function setCenters(centerX, centerY, k, animate, animateTime) {
                      return _this24.setCenters[view.uid](centerX, centerY, k, false, animate, animateTime);
                    }

                    return setCenters;
                  }(),
                  trackSourceServers: _this24.props.viewConfig.trackSourceServers,
                  twoD: true
                });
              }

              return getGenomePositionSearchBox;
            }();

            var multiTrackHeader = _this24.props.viewConfig.editable && !_this24.props.viewConfig.hideHeader ? _react2['default'].createElement(_ViewHeader2['default']
            // Reserved props
            , { ref: function () {
                function ref(c) {
                  _this24.viewHeaders[view.uid] = c;
                }

                return ref;
              }()

              // Custom props
              , getGenomePositionSearchBox: getGenomePositionSearchBox,
              isGenomePositionSearchBoxVisible: view.genomePositionSearchBox && view.genomePositionSearchBox.visible,
              onAddView: function () {
                function onAddView() {
                  return _this24.handleAddView(view);
                }

                return onAddView;
              }(),
              onClearView: function () {
                function onClearView() {
                  return _this24.handleClearView(view.uid);
                }

                return onClearView;
              }(),
              onCloseView: function () {
                function onCloseView() {
                  return _this24.handleCloseView(view.uid);
                }

                return onCloseView;
              }(),
              onExportSVG: _this24.handleExportSVG.bind(_this24),
              onExportViewsAsJSON: _this24.handleExportViewAsJSON.bind(_this24),
              onExportViewsAsLink: _this24.handleExportViewsAsLink.bind(_this24),
              onLockLocation: function () {
                function onLockLocation(uid) {
                  return _this24.handleYankFunction(uid, _this24.handleLocationLockChosen.bind(_this24));
                }

                return onLockLocation;
              }(),
              onLockZoom: function () {
                function onLockZoom(uid) {
                  return _this24.handleYankFunction(uid, _this24.handleZoomLockChosen.bind(_this24));
                }

                return onLockZoom;
              }(),
              onLockZoomAndLocation: function () {
                function onLockZoomAndLocation(uid) {
                  return _this24.handleYankFunction(uid, function (a, b) {
                    _this24.handleZoomLockChosen(a, b);
                    _this24.handleLocationLockChosen(a, b);
                  });
                }

                return onLockZoomAndLocation;
              }(),
              onProjectViewport: _this24.handleProjectViewport.bind(_this24),
              onTakeAndLockZoomAndLocation: function () {
                function onTakeAndLockZoomAndLocation(uid) {
                  _this24.handleYankFunction(uid, function (a, b) {
                    _this24.handleZoomYanked(a, b);
                    _this24.handleLocationYanked(a, b);
                    _this24.handleZoomLockChosen(a, b);
                    _this24.handleLocationLockChosen(a, b);
                  });
                }

                return onTakeAndLockZoomAndLocation;
              }(),
              onTogglePositionSearchBox: _this24.handleTogglePositionSearchBox.bind(_this24),
              onTrackPositionChosen: function () {
                function onTrackPositionChosen(position) {
                  return _this24.handleTrackPositionChosen(view.uid, position);
                }

                return onTrackPositionChosen;
              }(),
              onUnlockLocation: function () {
                function onUnlockLocation(uid) {
                  return _this24.handleUnlock(uid, _this24.locationLocks);
                }

                return onUnlockLocation;
              }(),
              onUnlockZoom: function () {
                function onUnlockZoom(uid) {
                  return _this24.handleUnlock(uid, _this24.zoomLocks);
                }

                return onUnlockZoom;
              }(),
              onUnlockZoomAndLocation: function () {
                function onUnlockZoomAndLocation(uid) {
                  _this24.handleUnlock(uid, _this24.zoomLocks);
                  _this24.handleUnlock(uid, _this24.locationLocks);
                }

                return onUnlockZoomAndLocation;
              }(),
              onYankLocation: function () {
                function onYankLocation(uid) {
                  return _this24.handleYankFunction(uid, _this24.handleLocationYanked.bind(_this24));
                }

                return onYankLocation;
              }(),
              onYankZoom: function () {
                function onYankZoom(uid) {
                  return _this24.handleYankFunction(uid, _this24.handleZoomYanked.bind(_this24));
                }

                return onYankZoom;
              }(),
              onYankZoomAndLocation: function () {
                function onYankZoomAndLocation(uid) {
                  return _this24.handleYankFunction(uid, function (a, b) {
                    _this24.handleZoomYanked(a, b);
                    _this24.handleLocationYanked(a, b);
                  });
                }

                return onYankZoomAndLocation;
              }(),
              onZoomToData: function () {
                function onZoomToData(uid) {
                  return _this24.handleZoomToData(uid);
                }

                return onZoomToData;
              }(),
              viewUid: view.uid
            }) : null;

            return _react2['default'].createElement(
              'div',
              {
                key: view.uid,
                ref: function () {
                  function ref(c) {
                    _this24.tiledAreaDiv = c;
                  }

                  return ref;
                }(),
                className: 'HiGlass-module_tiled-area-22H1L'
              },
              multiTrackHeader,
              tiledPlot,
              overlay
            );
          });
        }

        var exportLinkModal = this.state.exportLinkModalOpen ? _react2['default'].createElement(_ExportLinkModal.ExportLinkModal, {
          height: this.height,
          linkLocation: this.state.exportLinkLocation,
          onDone: function () {
            function onDone() {
              return _this24.setState({ exportLinkModalOpen: false });
            }

            return onDone;
          }(),
          width: this.width
        }) : null;

        var layouts = this.mounted ? (0, _utils.dictValues)(this.state.views).filter(function (x) {
          return x.layout;
        }).map(function (x) {
          return x.layout;
        }) : [];
        layouts = JSON.parse(JSON.stringify(layouts)); // make sure to copy the layouts

        var gridLayout = _react2['default'].createElement(
          _reactGridLayout2['default'],
          { ref: function () {
              function ref(c) {
                _this24.gridLayout = c;
              }

              return ref;
            }()

            // Custom props
            , cols: 12,
            width: this.state.width,
            draggableHandle: '.' + _ViewHeaderModule2['default']['multitrack-header-grabber'],
            isDraggable: this.props.viewConfig.editable,
            isResizable: this.props.viewConfig.editable,
            layout: layouts,
            margin: this.props.viewConfig.editable ? [10, 10] : [0, 0],
            measureBeforeMount: false,
            onBreakpointChange: this.onBreakpointChange.bind(this),
            onDragStart: this.handleDragStart.bind(this),
            onDragStop: this.handleDragStop.bind(this),
            onLayoutChange: this.handleLayoutChange.bind(this),
            onResize: this.resizeHandler.bind(this),
            rowHeight: this.state.rowHeight
            // for some reason, this becomes 40 within the react-grid component
            // (try resizing the component to see how much the height changes)
            // Programming by coincidence FTW :-/
            // WidthProvider option
            // I like to have it animate on mount. If you don't, delete
            // `useCSSTransforms` (it's default `true`)
            // and set `measureBeforeMount={true}`.
            , useCSSTransforms: this.mounted
          },
          tiledAreas
        );

        return _react2['default'].createElement(
          'div',
          {
            key: this.uid,
            ref: function () {
              function ref(c) {
                _this24.topDiv = c;
              }

              return ref;
            }(),
            className: 'higlass HiGlass-module_higlass-1NHR2'
          },
          _react2['default'].createElement('canvas', {
            key: this.uid,
            ref: function () {
              function ref(c) {
                _this24.canvasElement = c;
              }

              return ref;
            }(),
            className: 'HiGlass-module_higlass-canvas-_mP9r'
          }),
          _react2['default'].createElement('div', {
            ref: function () {
              function ref(c) {
                _this24.divDrawingSurface = c;
              }

              return ref;
            }(),
            className: 'HiGlass-module_higlass-drawing-surface-3aQQo'
          }),
          gridLayout,
          _react2['default'].createElement('svg', {
            ref: function () {
              function ref(c) {
                _this24.svgElement = c;
              }

              return ref;
            }(),
            className: 'HiGlass-module_higlass-svg-JJZbf'
          }),
          exportLinkModal
        );
      }

      return render;
    }()
  }]);

  return HiGlassComponent;
}(_react2['default'].Component);

HiGlassComponent.defaultProps = {
  getApi: null,
  options: {},
  zoomFixed: false
};

HiGlassComponent.propTypes = {
  getApi: _propTypes2['default'].func,
  options: _propTypes2['default'].object,
  viewConfig: _propTypes2['default'].object.isRequired,
  zoomFixed: _propTypes2['default'].bool
};

exports['default'] = HiGlassComponent;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(87);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection_index__ = __webpack_require__(16);


/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return typeof selector === "string"
      ? new __WEBPACK_IMPORTED_MODULE_0__selection_index__["a" /* Selection */]([[document.querySelector(selector)]], [document.documentElement])
      : new __WEBPACK_IMPORTED_MODULE_0__selection_index__["a" /* Selection */]([[selector]], __WEBPACK_IMPORTED_MODULE_0__selection_index__["c" /* root */]);
});


/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
});


/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var matcher = function(selector) {
  return function() {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector
        || element.msMatchesSelector
        || element.mozMatchesSelector
        || element.oMatchesSelector;
    matcher = function(selector) {
      return function() {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

/* harmony default export */ __webpack_exports__["a"] = (matcher);


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EnterNode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sparse__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(16);



/* harmony default export */ __webpack_exports__["b"] = (function() {
  return new __WEBPACK_IMPORTED_MODULE_1__index__["a" /* Selection */](this._enter || this._groups.map(__WEBPACK_IMPORTED_MODULE_0__sparse__["a" /* default */]), this._parents);
});

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(update) {
  return new Array(update.length);
});


/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = styleValue;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__window__ = __webpack_require__(93);


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
});

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || Object(__WEBPACK_IMPORTED_MODULE_0__window__["a" /* default */])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return bisectRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return bisectLeft; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ascending__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__bisector__ = __webpack_require__(154);



var ascendingBisect = Object(__WEBPACK_IMPORTED_MODULE_1__bisector__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__ascending__["a" /* default */]);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ __webpack_exports__["c"] = (bisectRight);


/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ascending__ = __webpack_require__(45);


/* harmony default export */ __webpack_exports__["a"] = (function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
});

function ascendingComparator(f) {
  return function(d, x) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__ascending__["a" /* default */])(f(d), x);
  };
}


/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = pair;
/* harmony default export */ __webpack_exports__["a"] = (function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
});

function pair(a, b) {
  return [a, b];
}


/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__variance__ = __webpack_require__(157);


/* harmony default export */ __webpack_exports__["a"] = (function(array, f) {
  var v = Object(__WEBPACK_IMPORTED_MODULE_0__variance__["a" /* default */])(array, f);
  return v ? Math.sqrt(v) : v;
});


/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(51);


/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
});


/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
});


/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return map; });
var array = Array.prototype;

var slice = array.slice;
var map = array.map;


/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
});


/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = tickIncrement;
/* harmony export (immutable) */ __webpack_exports__["c"] = tickStep;
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ __webpack_exports__["a"] = (function(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
});

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}


/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
});


/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
});


/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__min__ = __webpack_require__(163);


/* harmony default export */ __webpack_exports__["a"] = (function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = Object(__WEBPACK_IMPORTED_MODULE_0__min__["a" /* default */])(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
});

function length(d) {
  return d.length;
}


/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return implicit; });
/* harmony export (immutable) */ __webpack_exports__["a"] = ordinal;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_collection__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(29);



var implicit = {name: "implicit"};

function ordinal(range) {
  var index = Object(__WEBPACK_IMPORTED_MODULE_0_d3_collection__["a" /* map */])(),
      domain = [],
      unknown = implicit;

  range = range == null ? [] : __WEBPACK_IMPORTED_MODULE_1__array__["b" /* slice */].call(range);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = Object(__WEBPACK_IMPORTED_MODULE_0_d3_collection__["a" /* map */])();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = __WEBPACK_IMPORTED_MODULE_1__array__["b" /* slice */].call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return scale;
}


/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return deg2rad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return rad2deg; });
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;


/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export rgbBasis */
/* unused harmony export rgbBasisClosed */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__basis__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__basisClosed__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__color__ = __webpack_require__(53);





/* harmony default export */ __webpack_exports__["a"] = ((function rgbGamma(y) {
  var color = Object(__WEBPACK_IMPORTED_MODULE_3__color__["b" /* gamma */])(y);

  function rgb(start, end) {
    var r = color((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["rgb"])(start)).r, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["rgb"])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = Object(__WEBPACK_IMPORTED_MODULE_3__color__["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["rgb"])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(__WEBPACK_IMPORTED_MODULE_1__basis__["b" /* default */]);
var rgbBasisClosed = rgbSpline(__WEBPACK_IMPORTED_MODULE_2__basisClosed__["a" /* default */]);


/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basis__ = __webpack_require__(105);


/* harmony default export */ __webpack_exports__["a"] = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return Object(__WEBPACK_IMPORTED_MODULE_0__basis__["a" /* basis */])((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__value__ = __webpack_require__(102);


/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(nb),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = Object(__WEBPACK_IMPORTED_MODULE_0__value__["a" /* default */])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
});


/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
});


/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__value__ = __webpack_require__(102);


/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = Object(__WEBPACK_IMPORTED_MODULE_0__value__["a" /* default */])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
});


/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(67);


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});


/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return +x;
});


/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__formatGroup__ = __webpack_require__(323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__formatNumerals__ = __webpack_require__(324);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__formatSpecifier__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__formatTypes__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__formatPrefixAuto__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__identity__ = __webpack_require__(327);








var prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ __webpack_exports__["a"] = (function(locale) {
  var group = locale.grouping && locale.thousands ? Object(__WEBPACK_IMPORTED_MODULE_1__formatGroup__["a" /* default */])(locale.grouping, locale.thousands) : __WEBPACK_IMPORTED_MODULE_6__identity__["a" /* default */],
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? Object(__WEBPACK_IMPORTED_MODULE_2__formatNumerals__["a" /* default */])(locale.numerals) : __WEBPACK_IMPORTED_MODULE_6__identity__["a" /* default */],
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = Object(__WEBPACK_IMPORTED_MODULE_3__formatSpecifier__["a" /* default */])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        type = specifier.type;

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = __WEBPACK_IMPORTED_MODULE_4__formatTypes__["a" /* default */][type],
        maybeSuffix = !type || /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? (type ? 6 : 12)
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + __WEBPACK_IMPORTED_MODULE_5__formatPrefixAuto__["b" /* prefixExponent */] / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = Object(__WEBPACK_IMPORTED_MODULE_3__formatSpecifier__["a" /* default */])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
});


/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = formatSpecifier;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatTypes__ = __webpack_require__(177);


// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

  var match,
      fill = match[1] || " ",
      align = match[2] || ">",
      sign = match[3] || "-",
      symbol = match[4] || "",
      zero = !!match[5],
      width = match[6] && +match[6],
      comma = !!match[7],
      precision = match[8] && +match[8].slice(1),
      type = match[9] || "";

  // The "n" type is an alias for ",g".
  if (type === "n") comma = true, type = "g";

  // Map invalid types to the default format.
  else if (!__WEBPACK_IMPORTED_MODULE_0__formatTypes__["a" /* default */][type]) type = "";

  // If zero fill is specified, padding goes after sign and before digits.
  if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

  this.fill = fill;
  this.align = align;
  this.sign = sign;
  this.symbol = symbol;
  this.zero = zero;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type;
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + this.type;
};


/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDefault__ = __webpack_require__(325);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__formatPrefixAuto__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__formatRounded__ = __webpack_require__(326);




/* harmony default export */ __webpack_exports__["a"] = ({
  "": __WEBPACK_IMPORTED_MODULE_0__formatDefault__["a" /* default */],
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return Object(__WEBPACK_IMPORTED_MODULE_2__formatRounded__["a" /* default */])(x * 100, p); },
  "r": __WEBPACK_IMPORTED_MODULE_2__formatRounded__["a" /* default */],
  "s": __WEBPACK_IMPORTED_MODULE_1__formatPrefixAuto__["a" /* default */],
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
});


/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return prefixExponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDecimal__ = __webpack_require__(107);


var prefixExponent;

/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  var d = Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(x, Math.max(0, p + i - 1))[0]; // less than 1y!
});


/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
});


/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = calendar;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_time__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3_time_format__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__array__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__continuous__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__nice__ = __webpack_require__(179);








var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = Object(__WEBPACK_IMPORTED_MODULE_5__continuous__["b" /* default */])(__WEBPACK_IMPORTED_MODULE_5__continuous__["c" /* deinterpolateLinear */], __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["c" /* interpolateNumber */]),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["bisector"])(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["tickStep"])(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["tickStep"])(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(__WEBPACK_IMPORTED_MODULE_4__array__["a" /* map */].call(_, number)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(Object(__WEBPACK_IMPORTED_MODULE_6__nice__["a" /* default */])(d, interval))
        : scale;
  };

  scale.copy = function() {
    return Object(__WEBPACK_IMPORTED_MODULE_5__continuous__["a" /* copy */])(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

/* harmony default export */ __webpack_exports__["b"] = (function() {
  return calendar(__WEBPACK_IMPORTED_MODULE_2_d3_time__["j" /* timeYear */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["f" /* timeMonth */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["i" /* timeWeek */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["a" /* timeDay */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["b" /* timeHour */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["d" /* timeMinute */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["g" /* timeSecond */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["c" /* timeMillisecond */], __WEBPACK_IMPORTED_MODULE_3_d3_time_format__["a" /* timeFormat */]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
});


/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__ = __webpack_require__(109);
/* unused harmony reexport timeFormatDefaultLocale */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["a"]; });
/* unused harmony reexport timeParse */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["b"]; });
/* unused harmony reexport utcParse */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_locale__ = __webpack_require__(182);
/* unused harmony reexport timeFormatLocale */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_isoFormat__ = __webpack_require__(183);
/* unused harmony reexport isoFormat */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_isoParse__ = __webpack_require__(350);
/* unused harmony reexport isoParse */






/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = formatLocale;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_time__ = __webpack_require__(108);


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "S": formatSeconds,
    "U": formatWeekNumberSunday,
    "w": formatWeekdayNumber,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "S": formatUTCSeconds,
    "U": formatUTCWeekNumberSunday,
    "w": formatUTCWeekdayNumber,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "S": parseSeconds,
    "U": parseWeekNumberSunday,
    "w": parseWeekdayNumber,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0);
      if (i != string.length) return null;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "W" in d ? 1 : 0;
        var day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + __WEBPACK_IMPORTED_MODULE_0_d3_time__["a" /* timeDay */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["j" /* timeYear */])(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekNumberSunday(d, p) {
  return pad(__WEBPACK_IMPORTED_MODULE_0_d3_time__["h" /* timeSunday */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["j" /* timeYear */])(d), d), p, 2);
}

function formatWeekdayNumber(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(__WEBPACK_IMPORTED_MODULE_0_d3_time__["e" /* timeMonday */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["j" /* timeYear */])(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + __WEBPACK_IMPORTED_MODULE_0_d3_time__["k" /* utcDay */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["t" /* utcYear */])(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(__WEBPACK_IMPORTED_MODULE_0_d3_time__["r" /* utcSunday */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["t" /* utcYear */])(d), d), p, 2);
}

function formatUTCWeekdayNumber(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(__WEBPACK_IMPORTED_MODULE_0_d3_time__["o" /* utcMonday */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["t" /* utcYear */])(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}


/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isoSpecifier; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defaultLocale__ = __webpack_require__(109);


var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : Object(__WEBPACK_IMPORTED_MODULE_0__defaultLocale__["b" /* utcFormat */])(isoSpecifier);

/* unused harmony default export */ var _unused_webpack_default_export = (formatIso);


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(361)
var ieee754 = __webpack_require__(362)
var isArray = __webpack_require__(363)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)))

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lodash = __webpack_require__(119);

var _lodash2 = _interopRequireDefault(_lodash);

var _classnames = __webpack_require__(186);

var _classnames2 = _interopRequireDefault(_classnames);

var _utils = __webpack_require__(56);

var _GridItem = __webpack_require__(367);

var _GridItem2 = _interopRequireDefault(_GridItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// End Types

/**
 * A reactive, fluid grid layout with draggable, resizable components.
 */

// Types
var ReactGridLayout = function (_React$Component) {
  _inherits(ReactGridLayout, _React$Component);

  // TODO publish internal ReactClass displayName transform
  function ReactGridLayout(props, context) {
    _classCallCheck(this, ReactGridLayout);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

    _initialiseProps.call(_this);

    (0, _utils.autoBindHandlers)(_this, ["onDragStart", "onDrag", "onDragStop", "onResizeStart", "onResize", "onResizeStop"]);
    return _this;
  }

  ReactGridLayout.prototype.componentDidMount = function componentDidMount() {
    this.setState({ mounted: true });
    // Possibly call back with layout on mount. This should be done after correcting the layout width
    // to ensure we don't rerender with the wrong width.
    this.onLayoutMaybeChanged(this.state.layout, this.props.layout);
  };

  ReactGridLayout.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var newLayoutBase = void 0;
    // Legacy support for compactType
    // Allow parent to set layout directly.
    if (!(0, _lodash2.default)(nextProps.layout, this.props.layout) || nextProps.compactType !== this.props.compactType) {
      newLayoutBase = nextProps.layout;
    } else if (!(0, _utils.childrenEqual)(this.props.children, nextProps.children)) {
      // If children change, also regenerate the layout. Use our state
      // as the base in case because it may be more up to date than
      // what is in props.
      newLayoutBase = this.state.layout;
    }

    // We need to regenerate the layout.
    if (newLayoutBase) {
      var newLayout = (0, _utils.synchronizeLayoutWithChildren)(newLayoutBase, nextProps.children, nextProps.cols, this.compactType(nextProps));
      var _oldLayout = this.state.layout;
      this.setState({ layout: newLayout });
      this.onLayoutMaybeChanged(newLayout, _oldLayout);
    }
  };

  /**
   * Calculates a pixel value for the container.
   * @return {String} Container height in pixels.
   */


  ReactGridLayout.prototype.containerHeight = function containerHeight() {
    if (!this.props.autoSize) return;
    var nbRow = (0, _utils.bottom)(this.state.layout);
    var containerPaddingY = this.props.containerPadding ? this.props.containerPadding[1] : this.props.margin[1];
    return nbRow * this.props.rowHeight + (nbRow - 1) * this.props.margin[1] + containerPaddingY * 2 + "px";
  };

  ReactGridLayout.prototype.compactType = function compactType(props) {
    if (!props) props = this.props;
    return props.verticalCompact === false ? null : props.compactType;
  };

  /**
   * When dragging starts
   * @param {String} i Id of the child
   * @param {Number} x X position of the move
   * @param {Number} y Y position of the move
   * @param {Event} e The mousedown event
   * @param {Element} node The current dragging DOM element
   */


  ReactGridLayout.prototype.onDragStart = function onDragStart(i, x, y, _ref) {
    var e = _ref.e,
        node = _ref.node;
    var layout = this.state.layout;

    var l = (0, _utils.getLayoutItem)(layout, i);
    if (!l) return;

    this.setState({
      oldDragItem: (0, _utils.cloneLayoutItem)(l),
      oldLayout: this.state.layout
    });

    return this.props.onDragStart(layout, l, l, null, e, node);
  };

  /**
   * Each drag movement create a new dragelement and move the element to the dragged location
   * @param {String} i Id of the child
   * @param {Number} x X position of the move
   * @param {Number} y Y position of the move
   * @param {Event} e The mousedown event
   * @param {Element} node The current dragging DOM element
   */


  ReactGridLayout.prototype.onDrag = function onDrag(i, x, y, _ref2) {
    var e = _ref2.e,
        node = _ref2.node;
    var oldDragItem = this.state.oldDragItem;
    var layout = this.state.layout;
    var cols = this.props.cols;

    var l = (0, _utils.getLayoutItem)(layout, i);
    if (!l) return;

    // Create placeholder (display only)
    var placeholder = {
      w: l.w,
      h: l.h,
      x: l.x,
      y: l.y,
      placeholder: true,
      i: i
    };

    // Move the element to the dragged location.
    var isUserAction = true;
    layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, this.props.preventCollision, this.compactType(), cols);

    this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);

    this.setState({
      layout: (0, _utils.compact)(layout, this.compactType(), cols),
      activeDrag: placeholder
    });
  };

  /**
   * When dragging stops, figure out which position the element is closest to and update its x and y.
   * @param  {String} i Index of the child.
   * @param {Number} x X position of the move
   * @param {Number} y Y position of the move
   * @param {Event} e The mousedown event
   * @param {Element} node The current dragging DOM element
   */


  ReactGridLayout.prototype.onDragStop = function onDragStop(i, x, y, _ref3) {
    var e = _ref3.e,
        node = _ref3.node;
    var oldDragItem = this.state.oldDragItem;
    var layout = this.state.layout;
    var _props = this.props,
        cols = _props.cols,
        preventCollision = _props.preventCollision;

    var l = (0, _utils.getLayoutItem)(layout, i);
    if (!l) return;

    // Move the element here
    var isUserAction = true;
    layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, this.compactType(), cols);

    this.props.onDragStop(layout, oldDragItem, l, null, e, node);

    // Set state
    var newLayout = (0, _utils.compact)(layout, this.compactType(), cols);
    var oldLayout = this.state.oldLayout;

    this.setState({
      activeDrag: null,
      layout: newLayout,
      oldDragItem: null,
      oldLayout: null
    });

    this.onLayoutMaybeChanged(newLayout, oldLayout);
  };

  ReactGridLayout.prototype.onLayoutMaybeChanged = function onLayoutMaybeChanged(newLayout, oldLayout) {
    if (!oldLayout) oldLayout = this.state.layout;
    if (!(0, _lodash2.default)(oldLayout, newLayout)) {
      this.props.onLayoutChange(newLayout);
    }
  };

  ReactGridLayout.prototype.onResizeStart = function onResizeStart(i, w, h, _ref4) {
    var e = _ref4.e,
        node = _ref4.node;
    var layout = this.state.layout;

    var l = (0, _utils.getLayoutItem)(layout, i);
    if (!l) return;

    this.setState({
      oldResizeItem: (0, _utils.cloneLayoutItem)(l),
      oldLayout: this.state.layout
    });

    this.props.onResizeStart(layout, l, l, null, e, node);
  };

  ReactGridLayout.prototype.onResize = function onResize(i, w, h, _ref5) {
    var e = _ref5.e,
        node = _ref5.node;
    var _state = this.state,
        layout = _state.layout,
        oldResizeItem = _state.oldResizeItem;
    var _props2 = this.props,
        cols = _props2.cols,
        preventCollision = _props2.preventCollision;

    var l = (0, _utils.getLayoutItem)(layout, i);
    if (!l) return;

    // Something like quad tree should be used
    // to find collisions faster
    var hasCollisions = void 0;
    if (preventCollision) {
      var collisions = (0, _utils.getAllCollisions)(layout, _extends({}, l, { w: w, h: h })).filter(function (layoutItem) {
        return layoutItem.i !== l.i;
      });
      hasCollisions = collisions.length > 0;

      // If we're colliding, we need adjust the placeholder.
      if (hasCollisions) {
        // adjust w && h to maximum allowed space
        var leastX = Infinity,
            leastY = Infinity;
        collisions.forEach(function (layoutItem) {
          if (layoutItem.x > l.x) leastX = Math.min(leastX, layoutItem.x);
          if (layoutItem.y > l.y) leastY = Math.min(leastY, layoutItem.y);
        });

        if (Number.isFinite(leastX)) l.w = leastX - l.x;
        if (Number.isFinite(leastY)) l.h = leastY - l.y;
      }
    }

    if (!hasCollisions) {
      // Set new width and height.
      l.w = w;
      l.h = h;
    }

    // Create placeholder element (display only)
    var placeholder = {
      w: l.w,
      h: l.h,
      x: l.x,
      y: l.y,
      static: true,
      i: i
    };

    this.props.onResize(layout, oldResizeItem, l, placeholder, e, node);

    // Re-compact the layout and set the drag placeholder.
    this.setState({
      layout: (0, _utils.compact)(layout, this.compactType(), cols),
      activeDrag: placeholder
    });
  };

  ReactGridLayout.prototype.onResizeStop = function onResizeStop(i, w, h, _ref6) {
    var e = _ref6.e,
        node = _ref6.node;
    var _state2 = this.state,
        layout = _state2.layout,
        oldResizeItem = _state2.oldResizeItem;
    var cols = this.props.cols;

    var l = (0, _utils.getLayoutItem)(layout, i);

    this.props.onResizeStop(layout, oldResizeItem, l, null, e, node);

    // Set state
    var newLayout = (0, _utils.compact)(layout, this.compactType(), cols);
    var oldLayout = this.state.oldLayout;

    this.setState({
      activeDrag: null,
      layout: newLayout,
      oldResizeItem: null,
      oldLayout: null
    });

    this.onLayoutMaybeChanged(newLayout, oldLayout);
  };

  /**
   * Create a placeholder object.
   * @return {Element} Placeholder div.
   */


  ReactGridLayout.prototype.placeholder = function placeholder() {
    var activeDrag = this.state.activeDrag;

    if (!activeDrag) return null;
    var _props3 = this.props,
        width = _props3.width,
        cols = _props3.cols,
        margin = _props3.margin,
        containerPadding = _props3.containerPadding,
        rowHeight = _props3.rowHeight,
        maxRows = _props3.maxRows,
        useCSSTransforms = _props3.useCSSTransforms;

    // {...this.state.activeDrag} is pretty slow, actually

    return _react2.default.createElement(
      _GridItem2.default,
      {
        w: activeDrag.w,
        h: activeDrag.h,
        x: activeDrag.x,
        y: activeDrag.y,
        i: activeDrag.i,
        className: "react-grid-placeholder",
        containerWidth: width,
        cols: cols,
        margin: margin,
        containerPadding: containerPadding || margin,
        maxRows: maxRows,
        rowHeight: rowHeight,
        isDraggable: false,
        isResizable: false,
        useCSSTransforms: useCSSTransforms
      },
      _react2.default.createElement("div", null)
    );
  };

  /**
   * Given a grid item, set its style attributes & surround in a <Draggable>.
   * @param  {Element} child React element.
   * @return {Element}       Element wrapped in draggable and properly placed.
   */


  ReactGridLayout.prototype.processGridItem = function processGridItem(child) {
    if (!child || !child.key) return;
    var l = (0, _utils.getLayoutItem)(this.state.layout, String(child.key));
    if (!l) return null;
    var _props4 = this.props,
        width = _props4.width,
        cols = _props4.cols,
        margin = _props4.margin,
        containerPadding = _props4.containerPadding,
        rowHeight = _props4.rowHeight,
        maxRows = _props4.maxRows,
        isDraggable = _props4.isDraggable,
        isResizable = _props4.isResizable,
        useCSSTransforms = _props4.useCSSTransforms,
        draggableCancel = _props4.draggableCancel,
        draggableHandle = _props4.draggableHandle;
    var mounted = this.state.mounted;

    // Parse 'static'. Any properties defined directly on the grid item will take precedence.

    var draggable = Boolean(!l.static && isDraggable && (l.isDraggable || l.isDraggable == null));
    var resizable = Boolean(!l.static && isResizable && (l.isResizable || l.isResizable == null));

    return _react2.default.createElement(
      _GridItem2.default,
      {
        containerWidth: width,
        cols: cols,
        margin: margin,
        containerPadding: containerPadding || margin,
        maxRows: maxRows,
        rowHeight: rowHeight,
        cancel: draggableCancel,
        handle: draggableHandle,
        onDragStop: this.onDragStop,
        onDragStart: this.onDragStart,
        onDrag: this.onDrag,
        onResizeStart: this.onResizeStart,
        onResize: this.onResize,
        onResizeStop: this.onResizeStop,
        isDraggable: draggable,
        isResizable: resizable,
        useCSSTransforms: useCSSTransforms && mounted,
        usePercentages: !mounted,
        w: l.w,
        h: l.h,
        x: l.x,
        y: l.y,
        i: l.i,
        minH: l.minH,
        minW: l.minW,
        maxH: l.maxH,
        maxW: l.maxW,
        "static": l.static
      },
      child
    );
  };

  ReactGridLayout.prototype.render = function render() {
    var _this2 = this;

    var _props5 = this.props,
        className = _props5.className,
        style = _props5.style;


    var mergedClassName = (0, _classnames2.default)("react-grid-layout", className);
    var mergedStyle = _extends({
      height: this.containerHeight()
    }, style);

    return _react2.default.createElement(
      "div",
      { className: mergedClassName, style: mergedStyle },
      _react2.default.Children.map(this.props.children, function (child) {
        return _this2.processGridItem(child);
      }),
      this.placeholder()
    );
  };

  return ReactGridLayout;
}(_react2.default.Component);

ReactGridLayout.displayName = "ReactGridLayout";
ReactGridLayout.propTypes = {
  //
  // Basic props
  //
  className: _propTypes2.default.string,
  style: _propTypes2.default.object,

  // This can be set explicitly. If it is not set, it will automatically
  // be set to the container width. Note that resizes will *not* cause this to adjust.
  // If you need that behavior, use WidthProvider.
  width: _propTypes2.default.number,

  // If true, the container height swells and contracts to fit contents
  autoSize: _propTypes2.default.bool,
  // # of cols.
  cols: _propTypes2.default.number,

  // A selector that will not be draggable.
  draggableCancel: _propTypes2.default.string,
  // A selector for the draggable handler
  draggableHandle: _propTypes2.default.string,

  // Deprecated
  verticalCompact: function verticalCompact(props) {
    if (props.verticalCompact === false && process.env.NODE_ENV !== "production") {
      console.warn(
      // eslint-disable-line no-console
      "`verticalCompact` on <ReactGridLayout> is deprecated and will be removed soon. " + 'Use `compactType`: "horizontal" | "vertical" | null.');
    }
  },
  // Choose vertical or hotizontal compaction
  compactType: _propTypes2.default.oneOf(["vertical", "horizontal"]),

  // layout is an array of object with the format:
  // {x: Number, y: Number, w: Number, h: Number, i: String}
  layout: function layout(props) {
    var layout = props.layout;
    // I hope you're setting the data-grid property on the grid items
    if (layout === undefined) return;
    (0, _utils.validateLayout)(layout, "layout");
  },

  //
  // Grid Dimensions
  //

  // Margin between items [x, y] in px
  margin: _propTypes2.default.arrayOf(_propTypes2.default.number),
  // Padding inside the container [x, y] in px
  containerPadding: _propTypes2.default.arrayOf(_propTypes2.default.number),
  // Rows have a static height, but you can change this based on breakpoints if you like
  rowHeight: _propTypes2.default.number,
  // Default Infinity, but you can specify a max here if you like.
  // Note that this isn't fully fleshed out and won't error if you specify a layout that
  // extends beyond the row capacity. It will, however, not allow users to drag/resize
  // an item past the barrier. They can push items beyond the barrier, though.
  // Intentionally not documented for this reason.
  maxRows: _propTypes2.default.number,

  //
  // Flags
  //
  isDraggable: _propTypes2.default.bool,
  isResizable: _propTypes2.default.bool,
  // If true, grid items won't change position when being dragged over.
  preventCollision: _propTypes2.default.bool,
  // Use CSS transforms instead of top/left
  useCSSTransforms: _propTypes2.default.bool,

  //
  // Callbacks
  //

  // Callback so you can save the layout. Calls after each drag & resize stops.
  onLayoutChange: _propTypes2.default.func,

  // Calls when drag starts. Callback is of the signature (layout, oldItem, newItem, placeholder, e, ?node).
  // All callbacks below have the same signature. 'start' and 'stop' callbacks omit the 'placeholder'.
  onDragStart: _propTypes2.default.func,
  // Calls on each drag movement.
  onDrag: _propTypes2.default.func,
  // Calls when drag is complete.
  onDragStop: _propTypes2.default.func,
  //Calls when resize starts.
  onResizeStart: _propTypes2.default.func,
  // Calls when resize movement happens.
  onResize: _propTypes2.default.func,
  // Calls when resize is complete.
  onResizeStop: _propTypes2.default.func,

  //
  // Other validations
  //

  // Children must not have duplicate keys.
  children: function children(props, propName) {
    var children = props[propName];

    // Check children keys for duplicates. Throw if found.
    var keys = {};
    _react2.default.Children.forEach(children, function (child) {
      if (keys[child.key]) {
        throw new Error('Duplicate child key "' + child.key + '" found! This will cause problems in ReactGridLayout.');
      }
      keys[child.key] = true;
    });
  }
};
ReactGridLayout.defaultProps = {
  autoSize: true,
  cols: 12,
  className: "",
  style: {},
  draggableHandle: "",
  draggableCancel: "",
  containerPadding: null,
  rowHeight: 150,
  maxRows: Infinity, // infinite vertical growth
  layout: [],
  margin: [10, 10],
  isDraggable: true,
  isResizable: true,
  useCSSTransforms: true,
  verticalCompact: true,
  compactType: "vertical",
  preventCollision: false,
  onLayoutChange: _utils.noop,
  onDragStart: _utils.noop,
  onDrag: _utils.noop,
  onDragStop: _utils.noop,
  onResizeStart: _utils.noop,
  onResize: _utils.noop,
  onResizeStop: _utils.noop
};

var _initialiseProps = function _initialiseProps() {
  this.state = {
    activeDrag: null,
    layout: (0, _utils.synchronizeLayoutWithChildren)(this.props.layout, this.props.children, this.props.cols,
    // Legacy support for verticalCompact: false
    this.compactType()),
    mounted: false,
    oldDragItem: null,
    oldLayout: null,
    oldResizeItem: null
  };
};

exports.default = ReactGridLayout;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDraggable = __webpack_require__(370);

var _cloneElement = __webpack_require__(371);

var _cloneElement2 = _interopRequireDefault(_cloneElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Resizable = function (_React$Component) {
  _inherits(Resizable, _React$Component);

  function Resizable() {
    var _temp, _this, _ret;

    _classCallCheck(this, Resizable);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      resizing: false,
      width: _this.props.width, height: _this.props.height,
      slackW: 0, slackH: 0
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Resizable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    // If parent changes height/width, set that in our state.
    if (!this.state.resizing && (nextProps.width !== this.props.width || nextProps.height !== this.props.height)) {
      this.setState({
        width: nextProps.width,
        height: nextProps.height
      });
    }
  };

  Resizable.prototype.lockAspectRatio = function lockAspectRatio(width, height, aspectRatio) {
    height = width / aspectRatio;
    width = height * aspectRatio;
    return [width, height];
  };

  // If you do this, be careful of constraints


  Resizable.prototype.runConstraints = function runConstraints(width, height) {
    var _ref = [this.props.minConstraints, this.props.maxConstraints],
        min = _ref[0],
        max = _ref[1];


    if (this.props.lockAspectRatio) {
      var ratio = this.state.width / this.state.height;
      height = width / ratio;
      width = height * ratio;
    }

    if (!min && !max) return [width, height];

    var oldW = width,
        oldH = height;

    // Add slack to the values used to calculate bound position. This will ensure that if
    // we start removing slack, the element won't react to it right away until it's been
    // completely removed.

    var _state = this.state,
        slackW = _state.slackW,
        slackH = _state.slackH;

    width += slackW;
    height += slackH;

    if (min) {
      width = Math.max(min[0], width);
      height = Math.max(min[1], height);
    }
    if (max) {
      width = Math.min(max[0], width);
      height = Math.min(max[1], height);
    }

    // If the numbers changed, we must have introduced some slack. Record it for the next iteration.
    slackW += oldW - width;
    slackH += oldH - height;
    if (slackW !== this.state.slackW || slackH !== this.state.slackH) {
      this.setState({ slackW: slackW, slackH: slackH });
    }

    return [width, height];
  };

  /**
   * Wrapper around drag events to provide more useful data.
   *
   * @param  {String} handlerName Handler name to wrap.
   * @return {Function}           Handler function.
   */


  Resizable.prototype.resizeHandler = function resizeHandler(handlerName) {
    var _this2 = this;

    return function (e, _ref2) {
      var node = _ref2.node,
          deltaX = _ref2.deltaX,
          deltaY = _ref2.deltaY;


      // Axis restrictions
      var canDragX = _this2.props.axis === 'both' || _this2.props.axis === 'x';
      var canDragY = _this2.props.axis === 'both' || _this2.props.axis === 'y';

      // Update w/h
      var width = _this2.state.width + (canDragX ? deltaX : 0);
      var height = _this2.state.height + (canDragY ? deltaY : 0);

      // Early return if no change
      var widthChanged = width !== _this2.state.width,
          heightChanged = height !== _this2.state.height;
      if (handlerName === 'onResize' && !widthChanged && !heightChanged) return;

      // Set the appropriate state for this handler.
      var _runConstraints = _this2.runConstraints(width, height);

      width = _runConstraints[0];
      height = _runConstraints[1];
      var newState = {};
      if (handlerName === 'onResizeStart') {
        newState.resizing = true;
      } else if (handlerName === 'onResizeStop') {
        newState.resizing = false;
        newState.slackW = newState.slackH = 0;
      } else {
        // Early return if no change after constraints
        if (width === _this2.state.width && height === _this2.state.height) return;
        newState.width = width;
        newState.height = height;
      }

      var hasCb = typeof _this2.props[handlerName] === 'function';
      if (hasCb) {
        if (typeof e.persist === 'function') e.persist();
        _this2.setState(newState, function () {
          return _this2.props[handlerName](e, { node: node, size: { width: width, height: height } });
        });
      } else {
        _this2.setState(newState);
      }
    };
  };

  Resizable.prototype.render = function render() {
    // eslint-disable-next-line no-unused-vars
    var _props = this.props,
        children = _props.children,
        draggableOpts = _props.draggableOpts,
        width = _props.width,
        height = _props.height,
        handleSize = _props.handleSize,
        lockAspectRatio = _props.lockAspectRatio,
        axis = _props.axis,
        minConstraints = _props.minConstraints,
        maxConstraints = _props.maxConstraints,
        onResize = _props.onResize,
        onResizeStop = _props.onResizeStop,
        onResizeStart = _props.onResizeStart,
        p = _objectWithoutProperties(_props, ['children', 'draggableOpts', 'width', 'height', 'handleSize', 'lockAspectRatio', 'axis', 'minConstraints', 'maxConstraints', 'onResize', 'onResizeStop', 'onResizeStart']);

    var className = p.className ? p.className + ' react-resizable' : 'react-resizable';

    // What we're doing here is getting the child of this element, and cloning it with this element's props.
    // We are then defining its children as:
    // Its original children (resizable's child's children), and
    // A draggable handle.
    return (0, _cloneElement2.default)(children, _extends({}, p, {
      className: className,
      children: [children.props.children, _react2.default.createElement(
        _reactDraggable.DraggableCore,
        _extends({}, draggableOpts, {
          key: 'resizableHandle',
          onStop: this.resizeHandler('onResizeStop'),
          onStart: this.resizeHandler('onResizeStart'),
          onDrag: this.resizeHandler('onResize')
        }),
        _react2.default.createElement('span', { className: 'react-resizable-handle' })
      )]
    }));
  };

  return Resizable;
}(_react2.default.Component);

Resizable.propTypes = {
  //
  // Required Props
  //

  // Require that one and only one child be present.
  children: _propTypes2.default.element.isRequired,

  // Initial w/h
  width: _propTypes2.default.number.isRequired,
  height: _propTypes2.default.number.isRequired,

  //
  // Optional props
  //

  // If you change this, be sure to update your css
  handleSize: _propTypes2.default.array,

  // If true, will only allow width/height to move in lockstep
  lockAspectRatio: _propTypes2.default.bool,

  // Restricts resizing to a particular axis (default: 'both')
  // 'both' - allows resizing by width or height
  // 'x' - only allows the width to be changed
  // 'y' - only allows the height to be changed
  // 'none' - disables resizing altogether
  axis: _propTypes2.default.oneOf(['both', 'x', 'y', 'none']),

  // Min/max size
  minConstraints: _propTypes2.default.arrayOf(_propTypes2.default.number),
  maxConstraints: _propTypes2.default.arrayOf(_propTypes2.default.number),

  // Callbacks
  onResizeStop: _propTypes2.default.func,
  onResizeStart: _propTypes2.default.func,
  onResize: _propTypes2.default.func,

  // These will be passed wholesale to react-draggable's DraggableCore
  draggableOpts: _propTypes2.default.object
};
Resizable.defaultProps = {
  handleSize: [20, 20],
  lockAspectRatio: false,
  axis: 'both',
  minConstraints: [20, 20],
  maxConstraints: [Infinity, Infinity]
};
exports.default = Resizable;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getBreakpointFromWidth = getBreakpointFromWidth;
exports.getColsFromBreakpoint = getColsFromBreakpoint;
exports.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;
exports.sortBreakpoints = sortBreakpoints;

var _utils = __webpack_require__(56);

/**
 * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).
 *
 * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})
 * @param  {Number} width Screen width.
 * @return {String}       Highest breakpoint that is less than width.
 */
function getBreakpointFromWidth(breakpoints, width) {
  var sorted = sortBreakpoints(breakpoints);
  var matching = sorted[0];
  for (var i = 1, len = sorted.length; i < len; i++) {
    var breakpointName = sorted[i];
    if (width > breakpoints[breakpointName]) matching = breakpointName;
  }
  return matching;
}

/**
 * Given a breakpoint, get the # of cols set for it.
 * @param  {String} breakpoint Breakpoint name.
 * @param  {Object} cols       Map of breakpoints to cols.
 * @return {Number}            Number of cols.
 */


function getColsFromBreakpoint(breakpoint, cols) {
  if (!cols[breakpoint]) {
    throw new Error("ResponsiveReactGridLayout: `cols` entry for breakpoint " + breakpoint + " is missing!");
  }
  return cols[breakpoint];
}

/**
 * Given existing layouts and a new breakpoint, find or generate a new layout.
 *
 * This finds the layout above the new one and generates from it, if it exists.
 *
 * @param  {Object} layouts     Existing layouts.
 * @param  {Array} breakpoints All breakpoints.
 * @param  {String} breakpoint New breakpoint.
 * @param  {String} breakpoint Last breakpoint (for fallback).
 * @param  {Number} cols       Column count at new breakpoint.
 * @param  {Boolean} verticalCompact Whether or not to compact the layout
 *   vertically.
 * @return {Array}             New layout.
 */
function findOrGenerateResponsiveLayout(layouts, breakpoints, breakpoint, lastBreakpoint, cols, compactType) {
  // If it already exists, just return it.
  if (layouts[breakpoint]) return (0, _utils.cloneLayout)(layouts[breakpoint]);
  // Find or generate the next layout
  var layout = layouts[lastBreakpoint];
  var breakpointsSorted = sortBreakpoints(breakpoints);
  var breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));
  for (var i = 0, len = breakpointsAbove.length; i < len; i++) {
    var b = breakpointsAbove[i];
    if (layouts[b]) {
      layout = layouts[b];
      break;
    }
  }
  layout = (0, _utils.cloneLayout)(layout || []); // clone layout so we don't modify existing items
  return (0, _utils.compact)((0, _utils.correctBounds)(layout, { cols: cols }), compactType, cols);
}

/**
 * Given breakpoints, return an array of breakpoints sorted by width. This is usually
 * e.g. ['xxs', 'xs', 'sm', ...]
 *
 * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.
 * @return {Array}              Sorted breakpoints.
 */
function sortBreakpoints(breakpoints) {
  var keys = Object.keys(breakpoints);
  return keys.sort(function (a, b) {
    return breakpoints[a] - breakpoints[b];
  });
}

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    ResizeSensor: __webpack_require__(190),
    ElementQueries: __webpack_require__(375)
};


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

/**
 * Copyright Marc J. Schmidt. See the LICENSE file at the top-level
 * directory of this distribution and at
 * https://github.com/marcj/css-element-queries/blob/master/LICENSE.
 */
(function (root, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
        root.ResizeSensor = factory();
    }
}(typeof window !== 'undefined' ? window : this, function () {

    // Make sure it does not throw in a SSR (Server Side Rendering) situation
    if (typeof window === "undefined") {
        return null;
    }
    // Only used for the dirty checking, so the event callback count is limited to max 1 call per fps per sensor.
    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and
    // would generate too many unnecessary events.
    var requestAnimationFrame = window.requestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        function (fn) {
            return window.setTimeout(fn, 20);
        };

    /**
     * Iterate over each of the provided element(s).
     *
     * @param {HTMLElement|HTMLElement[]} elements
     * @param {Function}                  callback
     */
    function forEachElement(elements, callback){
        var elementsType = Object.prototype.toString.call(elements);
        var isCollectionTyped = ('[object Array]' === elementsType
            || ('[object NodeList]' === elementsType)
            || ('[object HTMLCollection]' === elementsType)
            || ('[object Object]' === elementsType)
            || ('undefined' !== typeof jQuery && elements instanceof jQuery) //jquery
            || ('undefined' !== typeof Elements && elements instanceof Elements) //mootools
        );
        var i = 0, j = elements.length;
        if (isCollectionTyped) {
            for (; i < j; i++) {
                callback(elements[i]);
            }
        } else {
            callback(elements);
        }
    }

    /**
    * Get element size
    * @param {HTMLElement} element
    * @returns {Object} {width, height}
    */
    function getElementSize(element) {
        if (!element.getBoundingClientRect) {
            return {
                width: element.offsetWidth,
                height: element.offsetHeight
            }
        }

        var rect = element.getBoundingClientRect();
        return {
            width: Math.round(rect.width),
            height: Math.round(rect.height)
        }
    }

    /**
     * Class for dimension change detection.
     *
     * @param {Element|Element[]|Elements|jQuery} element
     * @param {Function} callback
     *
     * @constructor
     */
    var ResizeSensor = function(element, callback) {
       
        var observer;
       
        /**
         *
         * @constructor
         */
        function EventQueue() {
            var q = [];
            this.add = function(ev) {
                q.push(ev);
            };

            var i, j;
            this.call = function(sizeInfo) {
                for (i = 0, j = q.length; i < j; i++) {
                    q[i].call(this, sizeInfo);
                }
            };

            this.remove = function(ev) {
                var newQueue = [];
                for(i = 0, j = q.length; i < j; i++) {
                    if(q[i] !== ev) newQueue.push(q[i]);
                }
                q = newQueue;
            };

            this.length = function() {
                return q.length;
            }
        }

        /**
         *
         * @param {HTMLElement} element
         * @param {Function}    resized
         */
        function attachResizeEvent(element, resized) {
            if (!element) return;
            if (element.resizedAttached) {
                element.resizedAttached.add(resized);
                return;
            }

            element.resizedAttached = new EventQueue();
            element.resizedAttached.add(resized);

            element.resizeSensor = document.createElement('div');
            element.resizeSensor.dir = 'ltr';
            element.resizeSensor.className = 'resize-sensor';
            var style = 'position: absolute; left: -10px; top: -10px; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';
            var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';

            element.resizeSensor.style.cssText = style;
            element.resizeSensor.innerHTML =
                '<div class="resize-sensor-expand" style="' + style + '">' +
                    '<div style="' + styleChild + '"></div>' +
                '</div>' +
                '<div class="resize-sensor-shrink" style="' + style + '">' +
                    '<div style="' + styleChild + ' width: 200%; height: 200%"></div>' +
                '</div>';
            element.appendChild(element.resizeSensor);

            var position = window.getComputedStyle(element).getPropertyValue('position');
            if ('absolute' !== position && 'relative' !== position && 'fixed' !== position) {
                element.style.position = 'relative';
            }

            var expand = element.resizeSensor.childNodes[0];
            var expandChild = expand.childNodes[0];
            var shrink = element.resizeSensor.childNodes[1];

            var dirty, rafId;
            var size = getElementSize(element);
            var lastWidth = size.width;
            var lastHeight = size.height;
            var initialHiddenCheck = true, resetRAF_id;
            
            
            var resetExpandShrink = function () {
                expandChild.style.width = '100000px';
                expandChild.style.height = '100000px';
        
                expand.scrollLeft = 100000;
                expand.scrollTop = 100000;
        
                shrink.scrollLeft = 100000;
                shrink.scrollTop = 100000;
            };

            var reset = function() {
                // Check if element is hidden
                if (initialHiddenCheck) {
                    if (!expand.scrollTop && !expand.scrollLeft) {

                        // reset
                        resetExpandShrink();

                        // Check in next frame
                        if (!resetRAF_id){
                            resetRAF_id = requestAnimationFrame(function(){
                                resetRAF_id = 0;
                                
                                reset();
                            });
                        }
                        
                        return;
                    } else {
                        // Stop checking
                        initialHiddenCheck = false;
                    }
                }

                resetExpandShrink();
            };
            element.resizeSensor.resetSensor = reset;

            var onResized = function() {
                rafId = 0;

                if (!dirty) return;

                lastWidth = size.width;
                lastHeight = size.height;

                if (element.resizedAttached) {
                    element.resizedAttached.call(size);
                }
            };

            var onScroll = function() {
                size = getElementSize(element);
                dirty = size.width !== lastWidth || size.height !== lastHeight;

                if (dirty && !rafId) {
                    rafId = requestAnimationFrame(onResized);
                }

                reset();
            };

            var addEvent = function(el, name, cb) {
                if (el.attachEvent) {
                    el.attachEvent('on' + name, cb);
                } else {
                    el.addEventListener(name, cb);
                }
            };

            addEvent(expand, 'scroll', onScroll);
            addEvent(shrink, 'scroll', onScroll);
            
            // Fix for custom Elements
            requestAnimationFrame(reset);
        }
         
        if (typeof ResizeObserver !== "undefined") {
            observer = new ResizeObserver(function(element){
                forEachElement(element, function (elem) {
                    callback.call(
                        this,
                        {
                            width: elem.contentRect.width,
                            height: elem.contentRect.height
                        }
                   );
                });
            });
            if (element !== undefined) {
                forEachElement(element, function(elem){
                   observer.observe(elem);
                });
            }
        }
        else {
            forEachElement(element, function(elem){
                attachResizeEvent(elem, callback);
            });
        }

        this.detach = function(ev) {
            if (typeof ResizeObserver != "undefined") {
                forEachElement(element, function(elem){
                    observer.unobserve(elem);
                });
            }
            else {
                ResizeSensor.detach(element, ev);
            }
        };

        this.reset = function() {
            element.resizeSensor.resetSensor();
        };
    };

    ResizeSensor.reset = function(element, ev) {
        forEachElement(element, function(elem){
            elem.resizeSensor.resetSensor();
        });
    };

    ResizeSensor.detach = function(element, ev) {
        forEachElement(element, function(elem){
            if (!elem) return;
            if(elem.resizedAttached && typeof ev === "function"){
                elem.resizedAttached.remove(ev);
                if(elem.resizedAttached.length()) return;
            }
            if (elem.resizeSensor) {
                if (elem.contains(elem.resizeSensor)) {
                    elem.removeChild(elem.resizeSensor);
                }
                delete elem.resizeSensor;
                delete elem.resizedAttached;
            }
        });
    };

    return ResizeSensor;

}));


/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = yesdrag;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__noevent__ = __webpack_require__(192);



/* harmony default export */ __webpack_exports__["a"] = (function(view) {
  var root = view.document.documentElement,
      selection = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["select"])(view).on("dragstart.drag", __WEBPACK_IMPORTED_MODULE_1__noevent__["a" /* default */], true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", __WEBPACK_IMPORTED_MODULE_1__noevent__["a" /* default */], true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["select"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", __WEBPACK_IMPORTED_MODULE_1__noevent__["a" /* default */], true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),
/* 192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = nopropagation;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(4);


function nopropagation() {
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["event"].stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["event"].preventDefault();
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["event"].stopImmediatePropagation();
});


/***/ }),
/* 193 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_selection_index__ = __webpack_require__(386);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_transition_index__ = __webpack_require__(26);
/* unused harmony reexport transition */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_active__ = __webpack_require__(418);
/* unused harmony reexport active */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_interrupt__ = __webpack_require__(194);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_3__src_interrupt__["a"]; });






/***/ }),
/* 194 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transition_schedule__ = __webpack_require__(17);


/* harmony default export */ __webpack_exports__["a"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > __WEBPACK_IMPORTED_MODULE_0__transition_schedule__["d" /* STARTING */] && schedule.state < __WEBPACK_IMPORTED_MODULE_0__transition_schedule__["b" /* ENDING */];
    schedule.state = __WEBPACK_IMPORTED_MODULE_0__transition_schedule__["a" /* ENDED */];
    schedule.timer.stop();
    if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});


/***/ }),
/* 195 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_timer__ = __webpack_require__(121);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_timer__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_0__src_timer__["c"]; });
/* unused harmony reexport timerFlush */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_timeout__ = __webpack_require__(388);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__src_timeout__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_interval__ = __webpack_require__(389);
/* unused harmony reexport interval */







/***/ }),
/* 196 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(20);



/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var c;
  return (typeof b === "number" ? __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["c" /* interpolateNumber */]
      : b instanceof __WEBPACK_IMPORTED_MODULE_0_d3_color__["color"] ? __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["d" /* interpolateRgb */]
      : (c = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["color"])(b)) ? (b = c, __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["d" /* interpolateRgb */])
      : __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["f" /* interpolateString */])(a, b);
});


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(38),
    isObject = __webpack_require__(21);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)))

/***/ }),
/* 199 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(456),
    isObjectLike = __webpack_require__(39);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(457),
    arraySome = __webpack_require__(460),
    cacheHas = __webpack_require__(461);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(18);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 203 */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),
/* 204 */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(206),
    getSymbols = __webpack_require__(128),
    keys = __webpack_require__(49);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(127),
    isArray = __webpack_require__(15);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 207 */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(465),
    isArguments = __webpack_require__(129),
    isArray = __webpack_require__(15),
    isBuffer = __webpack_require__(130),
    isIndex = __webpack_require__(131),
    isTypedArray = __webpack_require__(209);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(468),
    baseUnary = __webpack_require__(210),
    nodeUtil = __webpack_require__(469);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 210 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 211 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(472),
    Map = __webpack_require__(125),
    Promise = __webpack_require__(473),
    Set = __webpack_require__(474),
    WeakMap = __webpack_require__(475),
    baseGetTag = __webpack_require__(38),
    toSource = __webpack_require__(199);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(21);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),
/* 214 */
/***/ (function(module, exports) {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(216),
    toKey = __webpack_require__(79);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(15),
    isKey = __webpack_require__(134),
    stringToPath = __webpack_require__(479),
    toString = __webpack_require__(482);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(21),
    isSymbol = __webpack_require__(57);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(219),
    isArrayLike = __webpack_require__(50);

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

var baseForOwn = __webpack_require__(220),
    createBaseEach = __webpack_require__(500);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

var baseFor = __webpack_require__(498),
    keys = __webpack_require__(49);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(37);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 222 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Convert the position indexed list of tracks:
 *
 * { 'top': [{line}, {bar}],
 *   'center': [{combined, contents: {heatmap, 2d-tiles}]
 *   ...
 *  }
 *
 *  To a flat list of tracks:
 *  { line, position: 'top'
 *   bar, position: 'top'
 *   ...
 *   }
 */
var positionedTracksToAllTracks = function () {
  function positionedTracksToAllTracks(positionedTracks) {
    var includeCombinedContents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    var tracks = positionedTracks;
    var allTracks = [];

    var _loop = function () {
      function _loop(trackType) {
        var theseTracks = tracks[trackType];

        theseTracks.forEach(function (x) {
          if (x.type == 'combined') {
            // we don't really deal with nested combined tracks here,
            // but those shouldn't really be used anyway
            if (includeCombinedContents) {
              x.contents.forEach(function (y) {
                allTracks.push(Object.assign(y, { position: trackType }));
              });
            }
          }

          allTracks.push(Object.assign(x, { position: trackType }));
        });
      }

      return _loop;
    }();

    for (var trackType in tracks) {
      _loop(trackType);
    }

    return allTracks;
  }

  return positionedTracksToAllTracks;
}();

exports['default'] = positionedTracksToAllTracks;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _d3Color = __webpack_require__(14);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _reactColor = __webpack_require__(231);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SketchInlinePicker = function (_React$Component) {
  _inherits(SketchInlinePicker, _React$Component);

  function SketchInlinePicker(props) {
    _classCallCheck(this, SketchInlinePicker);

    var _this = _possibleConstructorReturn(this, (SketchInlinePicker.__proto__ || Object.getPrototypeOf(SketchInlinePicker)).call(this, props));

    var startColor = (0, _d3Color.rgb)(props.color);

    _this.state = {
      displayColorPicker: false,
      color: {
        r: startColor.r,
        g: startColor.g,
        b: startColor.b,
        a: startColor.opacity
      }
    };
    return _this;
  }

  _createClass(SketchInlinePicker, [{
    key: 'handleClick',
    value: function () {
      function handleClick() {
        this.setState({ displayColorPicker: !this.state.displayColorPicker });
      }

      return handleClick;
    }()
  }, {
    key: 'handleClose',
    value: function () {
      function handleClose() {
        this.setState({ displayColorPicker: false });
      }

      return handleClose;
    }()
  }, {
    key: 'handleChange',
    value: function () {
      function handleChange(color) {
        var rgb = color.rgb;
        var colorString = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + rgb.a + ')';

        this.props.onChange(colorString);
        this.setState({ color: color.rgb });
      }

      return handleChange;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var styles = (0, _reactcss2['default'])({
          'default': {
            color: {
              width: '36px',
              height: '14px',
              borderRadius: '2px',
              background: 'rgba(' + this.state.color.r + ', ' + this.state.color.g + ', ' + this.state.color.b + ', ' + this.state.color.a + ')'
            },
            swatch: {
              padding: '5px',
              background: '#fff',
              borderRadius: '1px',
              boxShadow: '0 0 0 1px rgba(0,0,0,.1)',
              display: 'inline-block',
              cursor: 'pointer'
            },
            popover: {
              position: 'absolute',
              zIndex: '2'
            },
            cover: {
              position: 'fixed',
              top: '0px',
              right: '0px',
              bottom: '0px',
              left: '0px'
            }
          }
        });

        return _react2['default'].createElement(
          'div',
          null,
          _react2['default'].createElement(
            'div',
            { style: styles.swatch, onClick: this.handleClick.bind(this) },
            _react2['default'].createElement('div', { style: styles.color })
          ),
          this.state.displayColorPicker ? _react2['default'].createElement(
            'div',
            { style: styles.popover },
            _react2['default'].createElement('div', { style: styles.cover, onClick: this.handleClose.bind(this) }),
            _react2['default'].createElement(_reactColor.SketchPicker, { color: this.state.color, onChange: this.handleChange.bind(this) })
          ) : null
        );
      }

      return render;
    }()
  }]);

  return SketchInlinePicker;
}(_react2['default'].Component);

exports['default'] = SketchInlinePicker;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(58);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),
/* 225 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(227),
    eq = __webpack_require__(76);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(221);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(208),
    baseKeysIn = __webpack_require__(547),
    isArrayLike = __webpack_require__(50);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(127),
    getPrototype = __webpack_require__(137),
    getSymbols = __webpack_require__(128),
    stubArray = __webpack_require__(207);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),
/* 230 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomPicker = exports.TwitterPicker = exports.SwatchesPicker = exports.SliderPicker = exports.SketchPicker = exports.PhotoshopPicker = exports.MaterialPicker = exports.HuePicker = exports.GithubPicker = exports.CompactPicker = exports.ChromePicker = exports.default = exports.CirclePicker = exports.BlockPicker = exports.AlphaPicker = undefined;

var _Alpha = __webpack_require__(570);

Object.defineProperty(exports, 'AlphaPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Alpha).default;
  }
});

var _Block = __webpack_require__(588);

Object.defineProperty(exports, 'BlockPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Block).default;
  }
});

var _Circle = __webpack_require__(590);

Object.defineProperty(exports, 'CirclePicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Circle).default;
  }
});

var _Chrome = __webpack_require__(592);

Object.defineProperty(exports, 'ChromePicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Chrome).default;
  }
});

var _Compact = __webpack_require__(596);

Object.defineProperty(exports, 'CompactPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Compact).default;
  }
});

var _Github = __webpack_require__(599);

Object.defineProperty(exports, 'GithubPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Github).default;
  }
});

var _Hue = __webpack_require__(601);

Object.defineProperty(exports, 'HuePicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Hue).default;
  }
});

var _Material = __webpack_require__(603);

Object.defineProperty(exports, 'MaterialPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Material).default;
  }
});

var _Photoshop = __webpack_require__(604);

Object.defineProperty(exports, 'PhotoshopPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Photoshop).default;
  }
});

var _Sketch = __webpack_require__(610);

Object.defineProperty(exports, 'SketchPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Sketch).default;
  }
});

var _Slider = __webpack_require__(613);

Object.defineProperty(exports, 'SliderPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Slider).default;
  }
});

var _Swatches = __webpack_require__(617);

Object.defineProperty(exports, 'SwatchesPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Swatches).default;
  }
});

var _Twitter = __webpack_require__(620);

Object.defineProperty(exports, 'TwitterPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Twitter).default;
  }
});

var _ColorWrap = __webpack_require__(234);

Object.defineProperty(exports, 'CustomPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ColorWrap).default;
  }
});

var _Chrome2 = _interopRequireDefault(_Chrome);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Chrome2.default;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Checkboard = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _checkboard = __webpack_require__(573);

var checkboard = _interopRequireWildcard(_checkboard);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Checkboard = exports.Checkboard = function Checkboard(_ref) {
  var white = _ref.white,
      grey = _ref.grey,
      size = _ref.size,
      renderers = _ref.renderers,
      borderRadius = _ref.borderRadius,
      boxShadow = _ref.boxShadow;

  var styles = (0, _reactcss2.default)({
    'default': {
      grid: {
        borderRadius: borderRadius,
        boxShadow: boxShadow,
        absolute: '0px 0px 0px 0px',
        background: 'url(' + checkboard.get(white, grey, size, renderers.canvas) + ') center left'
      }
    }
  });

  return _react2.default.createElement('div', { style: styles.grid });
};

Checkboard.defaultProps = {
  size: 8,
  white: 'transparent',
  grey: 'rgba(0,0,0,.08)',
  renderers: {}
};

exports.default = Checkboard;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(21),
    now = __webpack_require__(580),
    toNumber = __webpack_require__(217);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorWrap = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _debounce = __webpack_require__(233);

var _debounce2 = _interopRequireDefault(_debounce);

var _color = __webpack_require__(19);

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ColorWrap = exports.ColorWrap = function ColorWrap(Picker) {
  var ColorPicker = function (_ref) {
    _inherits(ColorPicker, _ref);

    function ColorPicker(props) {
      _classCallCheck(this, ColorPicker);

      var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this));

      _this.handleChange = function (data, event) {
        var isValidColor = _color2.default.simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = _color2.default.toState(data, data.h || _this.state.oldHue);
          _this.setState(colors);
          _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors, event);
          _this.props.onChange && _this.props.onChange(colors, event);
        }
      };

      _this.handleSwatchHover = function (data, event) {
        var isValidColor = _color2.default.simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = _color2.default.toState(data, data.h || _this.state.oldHue);
          _this.setState(colors);
          _this.props.onSwatchHover && _this.props.onSwatchHover(colors, event);
        }
      };

      _this.state = _extends({}, _color2.default.toState(props.color, 0));

      _this.debounce = (0, _debounce2.default)(function (fn, data, event) {
        fn(data, event);
      }, 100);
      return _this;
    }

    _createClass(ColorPicker, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        this.setState(_extends({}, _color2.default.toState(nextProps.color, this.state.oldHue)));
      }
    }, {
      key: 'render',
      value: function render() {
        var optionalEvents = {};
        if (this.props.onSwatchHover) {
          optionalEvents.onSwatchHover = this.handleSwatchHover;
        }

        return _react2.default.createElement(Picker, _extends({}, this.props, this.state, {
          onChange: this.handleChange
        }, optionalEvents));
      }
    }]);

    return ColorPicker;
  }(_react.PureComponent || _react.Component);

  ColorPicker.propTypes = _extends({}, Picker.propTypes);

  ColorPicker.defaultProps = _extends({}, Picker.defaultProps, {
    color: {
      h: 250,
      s: 0.50,
      l: 0.20,
      a: 1
    }
  });

  return ColorPicker;
};

exports.default = ColorWrap;

/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "red", function() { return red; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pink", function() { return pink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "purple", function() { return purple; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepPurple", function() { return deepPurple; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indigo", function() { return indigo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blue", function() { return blue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lightBlue", function() { return lightBlue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cyan", function() { return cyan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "teal", function() { return teal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "green", function() { return green; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lightGreen", function() { return lightGreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lime", function() { return lime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yellow", function() { return yellow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "amber", function() { return amber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orange", function() { return orange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepOrange", function() { return deepOrange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brown", function() { return brown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grey", function() { return grey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blueGrey", function() { return blueGrey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darkText", function() { return darkText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lightText", function() { return lightText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darkIcons", function() { return darkIcons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lightIcons", function() { return lightIcons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "white", function() { return white; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "black", function() { return black; });
var red = {"50":"#ffebee","100":"#ffcdd2","200":"#ef9a9a","300":"#e57373","400":"#ef5350","500":"#f44336","600":"#e53935","700":"#d32f2f","800":"#c62828","900":"#b71c1c","a100":"#ff8a80","a200":"#ff5252","a400":"#ff1744","a700":"#d50000"};
var pink = {"50":"#fce4ec","100":"#f8bbd0","200":"#f48fb1","300":"#f06292","400":"#ec407a","500":"#e91e63","600":"#d81b60","700":"#c2185b","800":"#ad1457","900":"#880e4f","a100":"#ff80ab","a200":"#ff4081","a400":"#f50057","a700":"#c51162"};
var purple = {"50":"#f3e5f5","100":"#e1bee7","200":"#ce93d8","300":"#ba68c8","400":"#ab47bc","500":"#9c27b0","600":"#8e24aa","700":"#7b1fa2","800":"#6a1b9a","900":"#4a148c","a100":"#ea80fc","a200":"#e040fb","a400":"#d500f9","a700":"#aa00ff"};
var deepPurple = {"50":"#ede7f6","100":"#d1c4e9","200":"#b39ddb","300":"#9575cd","400":"#7e57c2","500":"#673ab7","600":"#5e35b1","700":"#512da8","800":"#4527a0","900":"#311b92","a100":"#b388ff","a200":"#7c4dff","a400":"#651fff","a700":"#6200ea"};
var indigo = {"50":"#e8eaf6","100":"#c5cae9","200":"#9fa8da","300":"#7986cb","400":"#5c6bc0","500":"#3f51b5","600":"#3949ab","700":"#303f9f","800":"#283593","900":"#1a237e","a100":"#8c9eff","a200":"#536dfe","a400":"#3d5afe","a700":"#304ffe"};
var blue = {"50":"#e3f2fd","100":"#bbdefb","200":"#90caf9","300":"#64b5f6","400":"#42a5f5","500":"#2196f3","600":"#1e88e5","700":"#1976d2","800":"#1565c0","900":"#0d47a1","a100":"#82b1ff","a200":"#448aff","a400":"#2979ff","a700":"#2962ff"};
var lightBlue = {"50":"#e1f5fe","100":"#b3e5fc","200":"#81d4fa","300":"#4fc3f7","400":"#29b6f6","500":"#03a9f4","600":"#039be5","700":"#0288d1","800":"#0277bd","900":"#01579b","a100":"#80d8ff","a200":"#40c4ff","a400":"#00b0ff","a700":"#0091ea"};
var cyan = {"50":"#e0f7fa","100":"#b2ebf2","200":"#80deea","300":"#4dd0e1","400":"#26c6da","500":"#00bcd4","600":"#00acc1","700":"#0097a7","800":"#00838f","900":"#006064","a100":"#84ffff","a200":"#18ffff","a400":"#00e5ff","a700":"#00b8d4"};
var teal = {"50":"#e0f2f1","100":"#b2dfdb","200":"#80cbc4","300":"#4db6ac","400":"#26a69a","500":"#009688","600":"#00897b","700":"#00796b","800":"#00695c","900":"#004d40","a100":"#a7ffeb","a200":"#64ffda","a400":"#1de9b6","a700":"#00bfa5"};
var green = {"50":"#e8f5e9","100":"#c8e6c9","200":"#a5d6a7","300":"#81c784","400":"#66bb6a","500":"#4caf50","600":"#43a047","700":"#388e3c","800":"#2e7d32","900":"#1b5e20","a100":"#b9f6ca","a200":"#69f0ae","a400":"#00e676","a700":"#00c853"};
var lightGreen = {"50":"#f1f8e9","100":"#dcedc8","200":"#c5e1a5","300":"#aed581","400":"#9ccc65","500":"#8bc34a","600":"#7cb342","700":"#689f38","800":"#558b2f","900":"#33691e","a100":"#ccff90","a200":"#b2ff59","a400":"#76ff03","a700":"#64dd17"};
var lime = {"50":"#f9fbe7","100":"#f0f4c3","200":"#e6ee9c","300":"#dce775","400":"#d4e157","500":"#cddc39","600":"#c0ca33","700":"#afb42b","800":"#9e9d24","900":"#827717","a100":"#f4ff81","a200":"#eeff41","a400":"#c6ff00","a700":"#aeea00"};
var yellow = {"50":"#fffde7","100":"#fff9c4","200":"#fff59d","300":"#fff176","400":"#ffee58","500":"#ffeb3b","600":"#fdd835","700":"#fbc02d","800":"#f9a825","900":"#f57f17","a100":"#ffff8d","a200":"#ffff00","a400":"#ffea00","a700":"#ffd600"};
var amber = {"50":"#fff8e1","100":"#ffecb3","200":"#ffe082","300":"#ffd54f","400":"#ffca28","500":"#ffc107","600":"#ffb300","700":"#ffa000","800":"#ff8f00","900":"#ff6f00","a100":"#ffe57f","a200":"#ffd740","a400":"#ffc400","a700":"#ffab00"};
var orange = {"50":"#fff3e0","100":"#ffe0b2","200":"#ffcc80","300":"#ffb74d","400":"#ffa726","500":"#ff9800","600":"#fb8c00","700":"#f57c00","800":"#ef6c00","900":"#e65100","a100":"#ffd180","a200":"#ffab40","a400":"#ff9100","a700":"#ff6d00"};
var deepOrange = {"50":"#fbe9e7","100":"#ffccbc","200":"#ffab91","300":"#ff8a65","400":"#ff7043","500":"#ff5722","600":"#f4511e","700":"#e64a19","800":"#d84315","900":"#bf360c","a100":"#ff9e80","a200":"#ff6e40","a400":"#ff3d00","a700":"#dd2c00"};
var brown = {"50":"#efebe9","100":"#d7ccc8","200":"#bcaaa4","300":"#a1887f","400":"#8d6e63","500":"#795548","600":"#6d4c41","700":"#5d4037","800":"#4e342e","900":"#3e2723"};
var grey = {"50":"#fafafa","100":"#f5f5f5","200":"#eeeeee","300":"#e0e0e0","400":"#bdbdbd","500":"#9e9e9e","600":"#757575","700":"#616161","800":"#424242","900":"#212121"};
var blueGrey = {"50":"#eceff1","100":"#cfd8dc","200":"#b0bec5","300":"#90a4ae","400":"#78909c","500":"#607d8b","600":"#546e7a","700":"#455a64","800":"#37474f","900":"#263238"};
var darkText = {"primary":"rgba(0, 0, 0, 0.87)","secondary":"rgba(0, 0, 0, 0.54)","disabled":"rgba(0, 0, 0, 0.38)","dividers":"rgba(0, 0, 0, 0.12)"};
var lightText = {"primary":"rgba(255, 255, 255, 1)","secondary":"rgba(255, 255, 255, 0.7)","disabled":"rgba(255, 255, 255, 0.5)","dividers":"rgba(255, 255, 255, 0.12)"};
var darkIcons = {"active":"rgba(0, 0, 0, 0.54)","inactive":"rgba(0, 0, 0, 0.38)"};
var lightIcons = {"active":"rgba(255, 255, 255, 1)","inactive":"rgba(255, 255, 255, 0.5)"};
var white = "#ffffff";
var black = "#000000";

/* harmony default export */ __webpack_exports__["default"] = ({
  red: red,
  pink: pink,
  purple: purple,
  deepPurple: deepPurple,
  indigo: indigo,
  blue: blue,
  lightBlue: lightBlue,
  cyan: cyan,
  teal: teal,
  green: green,
  lightGreen: lightGreen,
  lime: lime,
  yellow: yellow,
  amber: amber,
  orange: orange,
  deepOrange: deepOrange,
  brown: brown,
  grey: grey,
  blueGrey: blueGrey,
  darkText: darkText,
  lightText: lightText,
  darkIcons: darkIcons,
  lightIcons: lightIcons,
  white: white,
  black: black
});


/***/ }),
/* 236 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.svgArrowheadDomainsIcon = exports.svgVertical1DTilesIcon = exports.svg1DTilesIcon = exports.svgVerticalGeneAnnotationsIcon = exports.svgGeneAnnotationsIcon = exports.svgVertical1DAxisIcon = exports.svg1DAxisIcon = exports.svg2DHeatmapIcon = exports.svg2DTilesIcon = exports.svgVerticalLineIcon = exports.svgHorizontalLineIcon = exports.all = exports.TRACK_LINE = exports.CONTENT_COPY = exports.PLUS = exports.PLAY = exports.MOVE = exports.MINUS = exports.ENLARGE = exports.CROSS = exports.COG = undefined;

var _d3Selection = __webpack_require__(4);

var COG = exports.COG = {
    id: 'cog',
    paths: ['M466.895 305.125c-26.863-46.527-10.708-106.152 36.076-133.244l-50.313-87.146c-14.375 8.427-31.088 13.259-48.923 13.259-53.768 0-97.354-43.873-97.354-97.995h-100.629c0.133 16.705-4.037 33.641-12.979 49.126-26.862 46.528-86.578 62.351-133.431 35.379l-50.312 87.146c14.485 8.236 27.025 20.294 35.943 35.739 26.819 46.454 10.756 105.96-35.854 133.112l50.313 87.146c14.325-8.348 30.958-13.127 48.7-13.127 53.598 0 97.072 43.596 97.35 97.479h100.627c-0.043-16.537 4.136-33.285 12.983-48.609 26.818-46.453 86.388-62.297 133.207-35.506l50.313-87.145c-14.39-8.233-26.846-20.249-35.717-35.614zM256 359.666c-57.254 0-103.668-46.412-103.668-103.667 0-57.254 46.413-103.667 103.668-103.667s103.666 46.413 103.666 103.667c-0.001 57.255-46.412 103.667-103.666 103.667z'],
    viewBox: '0 0 512 512'
};

var CROSS = exports.CROSS = {
    id: 'cross',
    paths: ['M507.331 411.33c-0.002-0.002-0.004-0.004-0.006-0.005l-155.322-155.325 155.322-155.325c0.002-0.002 0.004-0.003 0.006-0.005 1.672-1.673 2.881-3.627 3.656-5.708 2.123-5.688 0.912-12.341-3.662-16.915l-73.373-73.373c-4.574-4.573-11.225-5.783-16.914-3.66-2.080 0.775-4.035 1.984-5.709 3.655 0 0.002-0.002 0.003-0.004 0.005l-155.324 155.326-155.324-155.325c-0.002-0.002-0.003-0.003-0.005-0.005-1.673-1.671-3.627-2.88-5.707-3.655-5.69-2.124-12.341-0.913-16.915 3.66l-73.374 73.374c-4.574 4.574-5.784 11.226-3.661 16.914 0.776 2.080 1.985 4.036 3.656 5.708 0.002 0.001 0.003 0.003 0.005 0.005l155.325 155.324-155.325 155.326c-0.001 0.002-0.003 0.003-0.004 0.005-1.671 1.673-2.88 3.627-3.657 5.707-2.124 5.688-0.913 12.341 3.661 16.915l73.374 73.373c4.575 4.574 11.226 5.784 16.915 3.661 2.080-0.776 4.035-1.985 5.708-3.656 0.001-0.002 0.003-0.003 0.005-0.005l155.324-155.325 155.324 155.325c0.002 0.001 0.004 0.003 0.006 0.004 1.674 1.672 3.627 2.881 5.707 3.657 5.689 2.123 12.342 0.913 16.914-3.661l73.373-73.374c4.574-4.574 5.785-11.227 3.662-16.915-0.776-2.080-1.985-4.034-3.657-5.707z'],
    viewBox: '0 0 512 512'
};

var ENLARGE = exports.ENLARGE = {
    id: 'enlarge',
    paths: ['M512 0h-208l80 80-96 96 48 48 96-96 80 80z', 'M512 512v-208l-80 80-96-96-48 48 96 96-80 80z', 'M0 512h208l-80-80 96-96-48-48-96 96-80-80z', 'M0 0v208l80-80 96 96 48-48-96-96 80-80z'],
    viewBox: '0 0 512 512'
};

var MINUS = exports.MINUS = {
    id: 'minus',
    paths: ['M0 208v96c0 8.836 7.164 16 16 16h480c8.836 0 16-7.164 16-16v-96c0-8.836-7.164-16-16-16h-480c-8.836 0-16 7.164-16 16z'],
    viewBox: '0 0 512 512'
};

var MOVE = exports.MOVE = {
    id: 'move',
    paths: ['M512,260.096L405.5,161.79v49.155H301.061v-104.45h49.149L251.904,0L160.77,106.495h49.15v104.45H106.495V161.79L0,260.096l106.495,91.135v-49.149h104.45v104.45H161.79L251.904,512l98.306-106.5h-49.149V301.061H405.5v49.149L512,260.096z'],
    viewBox: '0 0 512 512'
};

var PLAY = exports.PLAY = {
    id: 'play',
    paths: ['M96 64l320 192-320 192z'],
    viewBox: '0 0 512 512'
};

var PLUS = exports.PLUS = {
    id: 'plus',
    paths: ['M496 192h-176v-176c0-8.836-7.164-16-16-16h-96c-8.836 0-16 7.164-16 16v176h-176c-8.836 0-16 7.164-16 16v96c0 8.836 7.164 16 16 16h176v176c0 8.836 7.164 16 16 16h96c8.836 0 16-7.164 16-16v-176h176c8.836 0 16-7.164 16-16v-96c0-8.836-7.164-16-16-16z'],
    viewBox: '0 0 512 512'
};

var CONTENT_COPY = exports.CONTENT_COPY = {
    id: 'copy',
    paths: ['M607.5 672v-448.5h-351v448.5h351zM607.5 160.5c34.5 0 64.5 28.5 64.5 63v448.5c0 34.5-30 64.5-64.5 64.5h-351c-34.5 0-64.5-30-64.5-64.5v-448.5c0-34.5 30-63 64.5-63h351zM511.5 31.5v64.5h-384v448.5h-63v-448.5c0-34.5 28.5-64.5 63-64.5h384z'],
    viewBox: '0 0 712 712'
};

var TRACK_LINE = exports.TRACK_LINE = {
    id: 'trackLine',
    paths: ['M60 20 L50 52 L40 26 L34 46 L24 30 L14 50 L4 12'],
    viewBox: '0 0 60 60'
};

var all = exports.all = [COG, CROSS, ENLARGE, MINUS, MOVE, PLAY, PLUS, CONTENT_COPY];

var parser = new DOMParser();

var horizontalLineStr = '\n<svg width="20px" height="20px" viewBox="0 0 135 85" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <title>line</title>\n    <defs></defs>\n    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <polyline id="Path" stroke="#4990E2" stroke-width="8" points="2 45.5625 20.7460938 6.3359375 36.828125 86.6484375 59.8945312 17.5742188 79.0390625 70.703125 99.9335938 27 112.769531 81.1601562 132.078125 3"></polyline>\n    </g>\n</svg>\n';

var svgHorizontalLineIcon = exports.svgHorizontalLineIcon = parser.parseFromString(horizontalLineStr, 'text/xml').documentElement;
var svgVerticalLineIcon = exports.svgVerticalLineIcon = (0, _d3Selection.select)(parser.parseFromString(horizontalLineStr, 'text/xml').documentElement).style('transform', 'rotate(90deg)').node();

var tiles2DIconStr = '\n<svg width="20px" height="20px" viewBox="0 0 60 60" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <!-- Generator: Sketch 41 (35326) - http://www.bohemiancoding.com/sketch -->\n    <title>2d-tiles-icon</title>\n    <desc>Created with Sketch.</desc>\n    <defs>\n        <rect id="tiles2DIconStr-path-1" x="0" y="0" width="30" height="30"></rect>\n        <mask id="tiles2DIconStr-mask-2" maskContentUnits="userSpaceOnUse" maskUnits="objectBoundingBox" x="0" y="0" width="30" height="30" fill="white">\n            <use xlink:href="#tiles2DIconStr-path-1"></use>\n        </mask>\n        <rect id="tiles2DIconStr-path-3" x="0" y="30" width="30" height="30"></rect>\n        <mask id="tiles2DIconStr-mask-4" maskContentUnits="userSpaceOnUse" maskUnits="objectBoundingBox" x="0" y="0" width="30" height="30" fill="white">\n            <use xlink:href="#tiles2DIconStr-path-3"></use>\n        </mask>\n        <rect id="tiles2DIconStr-path-5" x="30" y="0" width="30" height="30"></rect>\n        <mask id="tiles2DIconStr-mask-6" maskContentUnits="userSpaceOnUse" maskUnits="objectBoundingBox" x="0" y="0" width="30" height="30" fill="white">\n            <use xlink:href="#tiles2DIconStr-path-5"></use>\n        </mask>\n        <rect id="tiles2DIconStr-path-7" x="30" y="30" width="30" height="30"></rect>\n        <mask id="tiles2DIconStr-mask-8" maskContentUnits="userSpaceOnUse" maskUnits="objectBoundingBox" x="0" y="0" width="30" height="30" fill="white">\n            <use xlink:href="#tiles2DIconStr-path-7"></use>\n        </mask>\n    </defs>\n    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <use id="Rectangle" stroke="#979797" mask="url(#tiles2DIconStr-mask-2)" stroke-width="6" fill="#EEE0E0" xlink:href="#tiles2DIconStr-path-1"></use>\n        <use id="Rectangle" stroke="#979797" mask="url(#tiles2DIconStr-mask-4)" stroke-width="6" fill="#EEE0E0" xlink:href="#tiles2DIconStr-path-3"></use>\n        <use id="Rectangle" stroke="#979797" mask="url(#tiles2DIconStr-mask-6)" stroke-width="6" fill="#EEE0E0" xlink:href="#tiles2DIconStr-path-5"></use>\n        <use id="Rectangle" stroke="#979797" mask="url(#tiles2DIconStr-mask-8)" stroke-width="6" fill="#EEE0E0" xlink:href="#tiles2DIconStr-path-7"></use>\n    </g>\n</svg>\n';

var svg2DTilesIcon = exports.svg2DTilesIcon = parser.parseFromString(tiles2DIconStr, 'text/xml').documentElement;

var heatmap2DStr = '\n<svg width="20px" height="20px" viewBox="0 0 90 90" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <!-- Generator: Sketch 41 (35326) - http://www.bohemiancoding.com/sketch -->\n    <title>2d-heatmap</title>\n    <desc>Created with Sketch.</desc>\n    <defs>\n        <rect id="heatmap2DStr-path-1" x="0" y="0" width="30" height="30"></rect>\n        <rect id="heatmap2DStr-path-2" x="30" y="0" width="30" height="30"></rect>\n        <rect id="heatmap2DStr-path-3" x="60" y="0" width="30" height="30"></rect>\n        <rect id="heatmap2DStr-path-4" x="0" y="30" width="30" height="30"></rect>\n        <rect id="heatmap2DStr-path-5" x="30" y="30" width="30" height="30"></rect>\n        <rect id="heatmap2DStr-path-6" x="60" y="30" width="30" height="30"></rect>\n        <rect id="heatmap2DStr-path-7" x="0" y="60" width="30" height="30"></rect>\n        <rect id="heatmap2DStr-path-8" x="30" y="60" width="30" height="30"></rect>\n        <rect id="heatmap2DStr-path-9" x="60" y="60" width="30" height="30"></rect>\n    </defs>\n    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <use id="Rectangle" fill="#858372" xlink:href="#heatmap2DStr-path-1"></use>\n        <use id="Rectangle" fill="#BBBAA4" xlink:href="#heatmap2DStr-path-2"></use>\n        <use id="Rectangle" fill="#ECECD5" xlink:href="#heatmap2DStr-path-3"></use>\n        <use id="Rectangle" fill="#BCBD9E" xlink:href="#heatmap2DStr-path-4"></use>\n        <use id="Rectangle" fill="#817C7C" xlink:href="#heatmap2DStr-path-5"></use>\n        <use id="Rectangle" fill="#BBBAA4" xlink:href="#heatmap2DStr-path-6"></use>\n        <use id="Rectangle" fill="#ECECD5" xlink:href="#heatmap2DStr-path-7"></use>\n        <use id="Rectangle" fill="#BBBAA4" xlink:href="#heatmap2DStr-path-8"></use>\n        <use id="Rectangle" fill="#7B7777" xlink:href="#heatmap2DStr-path-9"></use>\n    </g>\n</svg>\n';

var svg2DHeatmapIcon = exports.svg2DHeatmapIcon = parser.parseFromString(heatmap2DStr, 'text/xml').documentElement;

var axis1D = '\n<svg width="20px" height="20px" viewBox="0 0 77 33" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <!-- Generator: Sketch 41 (35326) - http://www.bohemiancoding.com/sketch -->\n    <title>axis-1d</title>\n    <desc>Created with Sketch.</desc>\n    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <polyline id="Path" stroke="#979797" stroke-width="8" transform="translate(38.258485, 27.557860) scale(1, -1) translate(-38.258485, -27.557860) " points="4 27.05786 36.7512307 27.05786 72.5169695 27.05786"></polyline>\n        <path d="M38,24.484375 L38,3" id="Path-2" stroke="#979797" stroke-width="4"></path>\n    </g>\n</svg>\n';

var svg1DAxisIcon = exports.svg1DAxisIcon = parser.parseFromString(axis1D, 'text/xml').documentElement;
var svgVertical1DAxisIcon = exports.svgVertical1DAxisIcon = (0, _d3Selection.select)(parser.parseFromString(axis1D, 'text/xml').documentElement).style('transform', 'rotate(90deg)').node();

var geneAnnotations = '\n<svg width="20px" height="20px" viewBox="0 0 171 116" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <!-- Generator: Sketch 41 (35326) - http://www.bohemiancoding.com/sketch -->\n    <title>gene-annotations</title>\n    <desc>Created with Sketch.</desc>\n    <defs>\n        <rect id="geneAnnotations-path-1" x="34" y="0" width="24" height="116"></rect>\n        <mask id="geneAnnotations-mask-2" maskContentUnits="userSpaceOnUse" maskUnits="objectBoundingBox" x="0" y="0" width="24" height="116" fill="white">\n            <use xlink:href="#geneAnnotations-path-1"></use>\n        </mask>\n        <rect id="geneAnnotations-path-3" x="80" y="0" width="56" height="116"></rect>\n        <mask id="geneAnnotations-mask-4" maskContentUnits="userSpaceOnUse" maskUnits="objectBoundingBox" x="0" y="0" width="56" height="116" fill="white">\n            <use xlink:href="#geneAnnotations-path-3"></use>\n        </mask>\n        <rect id="geneAnnotations-path-5" x="147" y="40" width="24" height="35"></rect>\n        <mask id="geneAnnotations-mask-6" maskContentUnits="userSpaceOnUse" maskUnits="objectBoundingBox" x="0" y="0" width="24" height="35" fill="white">\n            <use xlink:href="#geneAnnotations-path-5"></use>\n        </mask>\n    </defs>\n    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <path d="M12.71875,58 L147.10172,58" id="Path" stroke="#979797" stroke-width="8"></path>\n        <use id="Rectangle" stroke="#979797" mask="url(#geneAnnotations-mask-2)" stroke-width="4" fill="#DDDD66" xlink:href="#geneAnnotations-path-1"></use>\n        <use id="Rectangle" stroke="#979797" mask="url(#geneAnnotations-mask-4)" stroke-width="4" fill="#DDDD66" xlink:href="#geneAnnotations-path-3"></use>\n        <use id="Rectangle" stroke="#979797" mask="url(#geneAnnotations-mask-6)" stroke-width="4" fill="#DDDD66" xlink:href="#geneAnnotations-path-5"></use>\n        <polygon id="Triangle" stroke="#979797" fill="#D8D8D8" points="25 57.5 1 75 1 40"></polygon>\n    </g>\n</svg>\n';

var svgGeneAnnotationsIcon = exports.svgGeneAnnotationsIcon = parser.parseFromString(geneAnnotations, 'text/xml').documentElement;
var svgVerticalGeneAnnotationsIcon = exports.svgVerticalGeneAnnotationsIcon = (0, _d3Selection.select)(parser.parseFromString(geneAnnotations, 'text/xml').documentElement).style('transform', 'rotate(90deg)').node();

var tiles1DIconStr = '\n<svg width="20px" height="20px" viewBox="0 0 180 90" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <!-- Generator: Sketch 42 (36781) - http://www.bohemiancoding.com/sketch -->\n    <title>1d-tiles-icon</title>\n    <desc>Created with Sketch.</desc>\n    <defs>\n        <rect id="tiles1DIconStr-path-1" x="0" y="0" width="90" height="90"></rect>\n        <mask id="tiles1DIconStr-mask-2" maskContentUnits="userSpaceOnUse" maskUnits="objectBoundingBox" x="0" y="0" width="90" height="90" fill="white">\n            <use xlink:href="#tiles1DIconStr-path-1"></use>\n        </mask>\n        <rect id="tiles1DIconStr-path-3" x="90" y="0" width="90" height="90"></rect>\n        <mask id="tiles1DIconStr-mask-4" maskContentUnits="userSpaceOnUse" maskUnits="objectBoundingBox" x="0" y="0" width="90" height="90" fill="white">\n            <use xlink:href="#tiles1DIconStr-path-3"></use>\n        </mask>\n    </defs>\n    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <use id="Rectangle" stroke="#979797" mask="url(#tiles1DIconStr-mask-2)" stroke-width="12" fill="#E6D5D5" xlink:href="#tiles1DIconStr-path-1"></use>\n        <use id="Rectangle" stroke="#979797" mask="url(#tiles1DIconStr-mask-4)" stroke-width="12" fill="#E6D5D5" xlink:href="#tiles1DIconStr-path-3"></use>\n    </g>\n</svg>\n';

var svg1DTilesIcon = exports.svg1DTilesIcon = parser.parseFromString(tiles1DIconStr, 'text/xml').documentElement;
var svgVertical1DTilesIcon = exports.svgVertical1DTilesIcon = (0, _d3Selection.select)(parser.parseFromString(tiles1DIconStr, 'text/xml').documentElement).style('transform', 'rotate(90deg)').node();

var arrowHeadDomainsStr = '\n<svg width="20px" height="20px" viewBox="0 0 111 111" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <!-- Generator: Sketch 42 (36781) - http://www.bohemiancoding.com/sketch -->\n    <title>arrowhead-domains</title>\n    <desc>Created with Sketch.</desc>\n    <defs>\n        <rect id="arrowHeadDomainsStr-path-1" x="0" y="0" width="90" height="90"></rect>\n        <mask id="arrowHeadDomainsStr-mask-2" maskContentUnits="userSpaceOnUse" maskUnits="objectBoundingBox" x="0" y="0" width="90" height="90" fill="white">\n            <use xlink:href="#arrowHeadDomainsStr-path-1"></use>\n        </mask>\n        <rect id="arrowHeadDomainsStr-path-3" x="52" y="52" width="59" height="59"></rect>\n        <mask id="arrowHeadDomainsStr-mask-4" maskContentUnits="userSpaceOnUse" maskUnits="objectBoundingBox" x="0" y="0" width="59" height="59" fill="white">\n            <use xlink:href="#arrowHeadDomainsStr-path-3"></use>\n        </mask>\n    </defs>\n    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" fill-opacity="0">\n        <use id="Rectangle" stroke="#979797" mask="url(#arrowHeadDomainsStr-mask-2)" stroke-width="22" fill="#D8D8D8" xlink:href="#arrowHeadDomainsStr-path-1"></use>\n        <use id="Rectangle" stroke="#979797" mask="url(#arrowHeadDomainsStr-mask-4)" stroke-width="22" fill="#D8D8D8" xlink:href="#arrowHeadDomainsStr-path-3"></use>\n    </g>\n</svg>\n';

var svgArrowheadDomainsIcon = exports.svgArrowheadDomainsIcon = parser.parseFromString(arrowHeadDomainsStr, 'text/xml').documentElement;

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ = __webpack_require__(3);

var pixelToGenomeLoci = function () {
  function pixelToGenomeLoci(x0, x1, chromInfo) {
    var gX0 = (0, _.absToChr)(x0, chromInfo);
    var gX1 = (0, _.absToChr)(x1, chromInfo);

    return [gX0[0], Math.round(gX0[1]), gX1[0], Math.round(gX1[1])];
  }

  return pixelToGenomeLoci;
}();

exports['default'] = pixelToGenomeLoci;

/***/ }),
/* 239 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"center-track":"CenterTrack-module_center-track-3ptRW","center-track-container":"CenterTrack-module_center-track-container-2ELhp"};

/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Transform;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return identity; });
/* harmony export (immutable) */ __webpack_exports__["b"] = transform;
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  return node.__zoom || identity;
}


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tiled1DPixiTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _TiledPixiTrack2 = __webpack_require__(41);

var _TiledPixiTrack3 = _interopRequireDefault(_TiledPixiTrack2);

var _services = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tiled1DPixiTrack = exports.Tiled1DPixiTrack = function (_TiledPixiTrack) {
  _inherits(Tiled1DPixiTrack, _TiledPixiTrack);

  function Tiled1DPixiTrack() {
    _classCallCheck(this, Tiled1DPixiTrack);

    return _possibleConstructorReturn(this, (Tiled1DPixiTrack.__proto__ || Object.getPrototypeOf(Tiled1DPixiTrack)).apply(this, arguments));
  }

  _createClass(Tiled1DPixiTrack, [{
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        /**
             * We don't need to do anything but draw the tile.
             *
             * Child classes that rely on transforming tiles when zooming
             * and panning can override this function to draw all the elements
             * that will later be transformed.
             */
        // this.drawTile(tile);
        _get(Tiled1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(Tiled1DPixiTrack.prototype), 'initTile', this).call(this, tile);
      }

      return initTile;
    }()
  }, {
    key: 'tileToLocalId',
    value: function () {
      function tileToLocalId(tile) {
        /*
             * The local tile identifier
             */

        // tile contains [zoomLevel, xPos]
        return '' + tile.join('.');
      }

      return tileToLocalId;
    }()
  }, {
    key: 'tileToRemoteId',
    value: function () {
      function tileToRemoteId(tile) {
        /**
             * The tile identifier used on the server
             */

        // tile contains [zoomLevel, xPos]
        return '' + tile.join('.');
      }

      return tileToRemoteId;
    }()
  }, {
    key: 'relevantScale',
    value: function () {
      function relevantScale() {
        /**
             * Which scale should we use for calculating tile positions?
             *
             * Horizontal tracks should use the xScale and vertical tracks
             * should use the yScale
             *
             * This function should be overwritten by HorizontalTiled1DPixiTrack.js
             * and VerticalTiled1DPixiTrack.js
             */
        return null;
      }

      return relevantScale;
    }()
  }, {
    key: 'setVisibleTiles',
    value: function () {
      function setVisibleTiles(tilePositions) {
        var _this2 = this;

        /**
             * Set which tiles are visible right now.
             *
             * @param tiles: A set of tiles which will be considered the currently visible
             * tile positions.
             */
        this.visibleTiles = tilePositions.map(function (x) {
          return {
            tileId: _this2.tileToLocalId(x),
            remoteId: _this2.tileToRemoteId(x)
          };
        });

        this.visibleTileIds = new Set(this.visibleTiles.map(function (x) {
          return x.tileId;
        }));
      }

      return setVisibleTiles;
    }()
  }, {
    key: 'calculateVisibleTiles',
    value: function () {
      function calculateVisibleTiles() {
        var _this3 = this;

        // if we don't know anything about this dataset, no point
        // in trying to get tiles
        if (!this.tilesetInfo) {
          return;
        }

        // calculate the zoom level given the scales and the data bounds
        this.zoomLevel = this.calculateZoomLevel();

        // console.log('zoomLevel:', this.zoomLevel);

        // x doesn't necessary mean 'x' axis, it just refers to the relevant axis
        // (x if horizontal, y if vertical)
        var xTiles = _services.tileProxy.calculateTiles(this.zoomLevel, this.relevantScale(), this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0], this.tilesetInfo.max_zoom, this.tilesetInfo.max_width);

        var tiles = xTiles.map(function (x) {
          return [_this3.zoomLevel, x];
        });

        this.setVisibleTiles(tiles);
      }

      return calculateVisibleTiles;
    }()
  }, {
    key: 'getTilePosAndDimensions',
    value: function () {
      function getTilePosAndDimensions(zoomLevel, tilePos) {
        /**
             * Get the tile's position in its coordinate system.
             */
        var xTilePos = tilePos[0];
        var yTilePos = tilePos[0];

        // max_width should be substitutable with 2 ** tilesetInfo.max_zoom
        var totalWidth = this.tilesetInfo.max_width;
        var totalHeight = this.tilesetInfo.max_width;

        var minX = this.tilesetInfo.min_pos[0];
        var minY = this.tilesetInfo.min_pos[1];

        var tileWidth = totalWidth / Math.pow(2, zoomLevel);
        var tileHeight = totalHeight / Math.pow(2, zoomLevel);

        var tileX = minX + xTilePos * tileWidth;
        var tileY = minY + yTilePos * tileHeight;

        return { tileX: tileX,
          tileY: tileY,
          tileWidth: tileWidth,
          tileHeight: tileHeight };
      }

      return getTilePosAndDimensions;
    }()
  }, {
    key: 'updateTile',
    value: function () {
      function updateTile(tile) {
        // no need to redraw this tile, usually
        // unless the data scale changes or something like that


      }

      return updateTile;
    }()
  }]);

  return Tiled1DPixiTrack;
}(_TiledPixiTrack3['default']);

exports['default'] = Tiled1DPixiTrack;

/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_axis__ = __webpack_require__(646);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "axisTop", function() { return __WEBPACK_IMPORTED_MODULE_0__src_axis__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "axisRight", function() { return __WEBPACK_IMPORTED_MODULE_0__src_axis__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "axisBottom", function() { return __WEBPACK_IMPORTED_MODULE_0__src_axis__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "axisLeft", function() { return __WEBPACK_IMPORTED_MODULE_0__src_axis__["b"]; });



/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  init:           sqInit,
  sweepBipartite: sweepBipartite,
  sweepComplete:  sweepComplete,
  scanBipartite:  scanBipartite,
  scanComplete:   scanComplete
}

var pool  = __webpack_require__(141)
var bits  = __webpack_require__(142)
var isort = __webpack_require__(653)

//Flag for blue
var BLUE_FLAG = (1<<28)

//1D sweep event queue stuff (use pool to save space)
var INIT_CAPACITY      = 1024
var RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)
var RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)
var SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)

//Reserves memory for the 1D sweep data structures
function sqInit(count) {
  var rcount = bits.nextPow2(count)
  if(RED_SWEEP_QUEUE.length < rcount) {
    pool.free(RED_SWEEP_QUEUE)
    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(RED_SWEEP_INDEX.length < rcount) {
    pool.free(RED_SWEEP_INDEX)
    RED_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_QUEUE.length < rcount) {
    pool.free(BLUE_SWEEP_QUEUE)
    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_INDEX.length < rcount) {
    pool.free(BLUE_SWEEP_INDEX)
    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_QUEUE.length < rcount) {
    pool.free(COMMON_SWEEP_QUEUE)
    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_INDEX.length < rcount) {
    pool.free(COMMON_SWEEP_INDEX)
    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  var eventLength = 8 * rcount
  if(SWEEP_EVENTS.length < eventLength) {
    pool.free(SWEEP_EVENTS)
    SWEEP_EVENTS = pool.mallocDouble(eventLength)
  }
}

//Remove an item from the active queue in O(1)
function sqPop(queue, index, count, item) {
  var idx = index[item]
  var top = queue[count-1]
  queue[idx] = top
  index[top] = idx
}

//Insert an item into the active queue in O(1)
function sqPush(queue, index, count, item) {
  queue[count] = item
  index[item]  = count
}

//Recursion base case: use 1D sweep algorithm
function sweepBipartite(
    d, visit,
    redStart,  redEnd, red, redIndex,
    blueStart, blueEnd, blue, blueIndex) {

  //store events as pairs [coordinate, idx]
  //
  //  red create:  -(idx+1)
  //  red destroy: idx
  //  blue create: -(idx+BLUE_FLAG)
  //  blue destroy: idx+BLUE_FLAG
  //
  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = redIndex[i]
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -(idx+1)
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = blueIndex[i]+BLUE_FLAG
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive  = 0
  var blueActive = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e >= BLUE_FLAG) {
      //blue destroy event
      e = (e-BLUE_FLAG)|0
      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)
    } else if(e >= 0) {
      //red destroy event
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)
    } else if(e <= -BLUE_FLAG) {
      //blue create event
      e = (-e-BLUE_FLAG)|0
      for(var j=0; j<redActive; ++j) {
        var retval = visit(RED_SWEEP_QUEUE[j], e)
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)
    } else {
      //red create event
      e = (-e-1)|0
      for(var j=0; j<blueActive; ++j) {
        var retval = visit(e, BLUE_SWEEP_QUEUE[j])
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)
    }
  }
}

//Complete sweep
function sweepComplete(d, visit, 
  redStart, redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = (redIndex[i]+1)<<1
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = (blueIndex[i]+1)<<1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = (-idx)|1
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx|1
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  var blueActive   = 0
  var commonActive = 0
  for(var i=0; i<n; ++i) {
    var e     = SWEEP_EVENTS[2*i+1]|0
    var color = e&1
    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {
      color = 2
      i += 1
    }
    
    if(e < 0) {
      //Create event
      var id = -(e>>1) - 1

      //Intersect with common
      for(var j=0; j<commonActive; ++j) {
        var retval = visit(COMMON_SWEEP_QUEUE[j], id)
        if(retval !== void 0) {
          return retval
        }
      }

      if(color !== 0) {
        //Intersect with red
        for(var j=0; j<redActive; ++j) {
          var retval = visit(RED_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color !== 1) {
        //Intersect with blue
        for(var j=0; j<blueActive; ++j) {
          var retval = visit(BLUE_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color === 0) {
        //Red
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)
      } else if(color === 1) {
        //Blue
        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)
      } else if(color === 2) {
        //Both
        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)
      }
    } else {
      //Destroy event
      var id = (e>>1) - 1
      if(color === 0) {
        //Red
        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)
      } else if(color === 1) {
        //Blue
        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)
      } else if(color === 2) {
        //Both
        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)
      }
    }
  }
}

//Sweep and prune/scanline algorithm:
//  Scan along axis, detect intersections
//  Brute force all boxes along axis
function scanBipartite(
  d, axis, visit, flip,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {
  
  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  var redShift  = 1
  var blueShift = 1
  if(flip) {
    blueShift = BLUE_FLAG
  } else {
    redShift  = BLUE_FLAG
  }

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + redShift
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + blueShift
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      var isRed = false
      if(idx >= BLUE_FLAG) {
        isRed = !flip
        idx -= BLUE_FLAG 
      } else {
        isRed = !!flip
        idx -= 1
      }
      if(isRed) {
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)
      } else {
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx
        
        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redPtr = elemSize * oidx

          if(b1 < red[redPtr+axis+1] || 
             red[redPtr+axis+1+d] < b0) {
            continue
          }

          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d] < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var redId  = redIndex[oidx]
          var retval
          if(flip) {
            retval = visit(blueId, redId)
          } else {
            retval = visit(redId, blueId)
          }
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)
    }
  }
}

function scanComplete(
  d, axis, visit,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + BLUE_FLAG
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + 1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      if(idx >= BLUE_FLAG) {
        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG
      } else {
        idx -= 1
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx

        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redId  = redIndex[oidx]

          if(redId === blueId) {
            break
          }

          var redPtr = elemSize * oidx
          if(b1 < red[redPtr+axis+1] || 
            red[redPtr+axis+1+d] < b0) {
            continue
          }
          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d]   < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var retval = visit(redId, blueId)
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      var idx = e - BLUE_FLAG
      for(var j=redActive-1; j>=0; --j) {
        if(RED_SWEEP_QUEUE[j] === idx) {
          for(var k=j+1; k<redActive; ++k) {
            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]
          }
          break
        }
      }
      --redActive
    }
  }
}

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = genPartition

var code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'

function genPartition(predicate, args) {
  var fargs ='abcdef'.split('').concat(args)
  var reads = []
  if(predicate.indexOf('lo') >= 0) {
    reads.push('lo=e[k+n]')
  }
  if(predicate.indexOf('hi') >= 0) {
    reads.push('hi=e[k+o]')
  }
  fargs.push(
    code.replace('_', reads.join())
        .replace('$', predicate))
  return Function.apply(void 0, fargs)
}

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BarTrack = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _d3Scale = __webpack_require__(12);

var _HorizontalLine1DPixiTrack = __webpack_require__(85);

var _utils = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Utils


var BarTrack = exports.BarTrack = function (_HorizontalLine1DPixi) {
  _inherits(BarTrack, _HorizontalLine1DPixi);

  function BarTrack(scene, dataConfig, handleTilesetInfoReceived, option, animate, onValueScaleChanged) {
    _classCallCheck(this, BarTrack);

    return _possibleConstructorReturn(this, (BarTrack.__proto__ || Object.getPrototypeOf(BarTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, option, animate, onValueScaleChanged));
  }

  _createClass(BarTrack, [{
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        /**
             * Create whatever is needed to draw this tile.
             */
        _get(BarTrack.prototype.__proto__ || Object.getPrototypeOf(BarTrack.prototype), 'initTile', this).call(this, tile);

        // console.log('initializing tile');
        tile.barXValues = new Array(tile.tileData.dense.length);
        tile.barYValues = new Array(tile.tileData.dense.length);
        tile.barWidths = new Array(tile.tileData.dense.length);
        tile.barHeights = new Array(tile.tileData.dense.length);
        tile.barColors = new Array(tile.tileData.dense.length);

        // this.drawTile(tile);
        this.renderTile(tile);
      }

      return initTile;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tile) {
        // empty function so that the superclass's drawTile
        // doesn't do anything
      }

      return drawTile;
    }()
  }, {
    key: 'renderTile',
    value: function () {
      function renderTile(tile) {
        //super.drawTile(tile);

        if (!tile.graphics) {
          return;
        }

        var graphics = tile.graphics;

        var _getTilePosAndDimensi = this.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos),
            tileX = _getTilePosAndDimensi.tileX,
            tileWidth = _getTilePosAndDimensi.tileWidth;

        var tileValues = tile.tileData.dense;

        if (tileValues.length == 0) {
          return;
        }

        var pseudocount = 0; // if we use a log scale, then we'll set a pseudocount
        // equal to the smallest non-zero value
        this.valueScale = null;

        // console.log('valueScaling:', this.options.valueScaling);
        if (this.options.valueScaling == 'log') {
          var offsetValue = this.medianVisibleValue;

          if (!this.medianVisibleValue) {
            offsetValue = this.minVisibleValue();
          }

          this.valueScale = (0, _d3Scale.scaleLog)()
          // .base(Math.E)
          .domain([offsetValue, this.maxValue() + offsetValue]).range([this.dimensions[1], 0]);
          pseudocount = offsetValue;
        } else {
          // linear scale
          this.valueScale = (0, _d3Scale.scaleLinear)().domain([this.minValue(), this.maxValue()]).range([this.dimensions[1], 0]);
        }

        graphics.clear();

        this.drawAxis(this.valueScale);

        if (this.options.valueScaling == 'log' && this.valueScale.domain()[1] < 0) {
          console.warn('Negative values present when using a log scale', this.valueScale.domain());
          return;
        }

        var stroke = (0, _utils.colorToHex)(this.options.lineStrokeColor ? this.options.lineStrokeColor : 'blue');
        // this scale should go from an index in the data array to
        // a position in the genome coordinates
        var tileXScale = (0, _d3Scale.scaleLinear)().domain([0, this.tilesetInfo.tile_size]).range([tileX, tileX + tileWidth]);

        // let strokeWidth = this.options.lineStrokeWidth ? this.options.lineStrokeWidth : 1;

        var strokeWidth = 0;
        graphics.lineStyle(strokeWidth, stroke, 1);

        var color = this.options.barFillColor ? this.options.barFillColor : 'grey';
        var colorHex = (0, _utils.colorToHex)(color);

        var opacity = 'barOpacity' in this.options ? this.options.barOpacity : 1;

        graphics.beginFill(colorHex, opacity);

        var j = 0;
        tile.drawnAtScale = this._xScale.copy();

        for (var i = 0; i < tileValues.length; i++) {
          var xPos = this._xScale(tileXScale(i));
          var yPos = this.valueScale(tileValues[i] + pseudocount);

          var width = this._xScale(tileXScale(i + 1)) - xPos;
          var height = this.dimensions[1] - yPos;

          tile.barColors[i] = color;
          tile.barXValues[i] = xPos;
          tile.barYValues[i] = yPos;
          tile.barWidths[i] = width;
          tile.barHeights[i] = height;

          if (tileXScale(i) > this.tilesetInfo.max_pos[0])
            // this data is in the last tile and extends beyond the length
            // of the coordinate system
            {
              break;
            }

          graphics.drawRect(xPos, yPos, width, height);
        }
      }

      return renderTile;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        // we don't want to call HorizontalLine1DPixiTrack's draw function
        // but rather its parent's
        _get(BarTrack.prototype.__proto__ || Object.getPrototypeOf(BarTrack.prototype), 'draw', this).call(this);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _utils.dictValues)(this.fetchedTiles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tile = _step.value;

            // scaling between tiles
            var tileK = (tile.drawnAtScale.domain()[1] - tile.drawnAtScale.domain()[0]) / (this._xScale.domain()[1] - this._xScale.domain()[0]);

            // let posOffset = newRange[0];

            var newRange = this._xScale.domain().map(tile.drawnAtScale);

            var posOffset = newRange[0];
            tile.graphics.scale.x = tileK;
            tile.graphics.position.x = -posOffset * tileK;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return draw;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale, k, tx, ty) {
        _get(BarTrack.prototype.__proto__ || Object.getPrototypeOf(BarTrack.prototype), 'zoomed', this).call(this, newXScale, newYScale);
      }

      return zoomed;
    }()

    /**
     * Export an SVG representation of this track
     *
     * @returns {[DOMNode,DOMNode]} The two returned DOM nodes are both SVG
     * elements [base,track]. Base is a parent which contains track as a
     * child. Track is clipped with a clipping rectangle contained in base.
     *
     */

  }, {
    key: 'exportSVG',
    value: function () {
      function exportSVG() {
        var track = null;
        var base = null;

        var _get$call = _get(BarTrack.prototype.__proto__ || Object.getPrototypeOf(BarTrack.prototype), 'superSVG', this).call(this);

        var _get$call2 = _slicedToArray(_get$call, 2);

        base = _get$call2[0];
        track = _get$call2[1];


        base.setAttribute('class', 'exported-line-track');
        var output = document.createElement('g');

        track.appendChild(output);
        output.setAttribute('transform', 'translate(' + this.position[0] + ',' + this.position[1] + ')');

        var stroke = this.options.lineStrokeColor ? this.options.lineStrokeColor : 'blue';

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.visibleAndFetchedTiles()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var tile = _step2.value;

            for (var i = 0; i < tile.barXValues.length; i++) {
              var rect = document.createElement('rect');
              var color = this.options.barFillColor ? this.options.barFillColor : 'grey';
              rect.setAttribute('fill', tile.barColors[i]);
              rect.setAttribute('stroke', tile.barColors[i]);

              rect.setAttribute('x', tile.barXValues[i]);
              rect.setAttribute('y', tile.barYValues[i]);
              rect.setAttribute('height', tile.barHeights[i]);
              rect.setAttribute('width', tile.barWidths[i]);

              output.appendChild(rect);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var gAxis = document.createElement('g');
        gAxis.setAttribute('id', 'axis');

        // append the axis to base so that it's not clipped
        base.appendChild(gAxis);
        gAxis.setAttribute('transform', 'translate(' + this.axis.pAxis.position.x + ', ' + this.axis.pAxis.position.y + ')');

        // add the axis to the export
        if (this.options.axisPositionHorizontal === 'left' || this.options.axisPositionVertical === 'top') {
          // left axis are shown at the beginning of the plot
          var gDrawnAxis = this.axis.exportAxisLeftSVG(this.valueScale, this.dimensions[1]);
          gAxis.appendChild(gDrawnAxis);
        } else if (this.options.axisPositionHorizontal === 'right' || this.options.axisPositionVertical === 'bottom') {
          var _gDrawnAxis = this.axis.exportAxisRightSVG(this.valueScale, this.dimensions[1]);
          gAxis.appendChild(_gDrawnAxis);
        }

        return [base, track];
      }

      return exportSVG;
    }()
  }]);

  return BarTrack;
}(_HorizontalLine1DPixiTrack.HorizontalLine1DPixiTrack);

exports['default'] = BarTrack;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OSMTilesTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _PixiTrack2 = __webpack_require__(42);

var _services = __webpack_require__(7);

var _utils = __webpack_require__(3);

var _configs = __webpack_require__(6);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Services


// Utils


// Configs


var OSMTilesTrack = exports.OSMTilesTrack = function (_PixiTrack) {
  _inherits(OSMTilesTrack, _PixiTrack);

  /**
   * A track that must pull remote tiles
   *
   * @param scene: A PIXI.js scene to draw everything to.
   * @param server: The server to pull tiles from.
   * @param tilesetUid: The data set to get the tiles from the server
   */
  function OSMTilesTrack(scene, options, animate) {
    _classCallCheck(this, OSMTilesTrack);

    // the tiles which should be visible (although they're not necessarily fetched)
    var _this = _possibleConstructorReturn(this, (OSMTilesTrack.__proto__ || Object.getPrototypeOf(OSMTilesTrack)).call(this, scene, options));

    _this.visibleTiles = new Set();
    _this.visibleTileIds = new Set();

    // the tiles we already have requests out for
    _this.fetching = new Set();

    // tiles we have fetched and ready to be rendered
    _this.fetchedTiles = {};

    // the graphics that have already been drawn for this track
    _this.tileGraphics = {};

    var minPos = 0;
    var maxPos = 3120000000;

    if (_this.options && _this.options.minPos) {
      minPos = +_this.options.minPos;
    }
    if (_this.options && _this.options.maxPos) {
      maxPos = +_this.options.maxPos;
    }

    _this.minPos = [minPos, minPos];
    _this.maxPos = [maxPos, maxPos];
    _this.maxZoom = 19;
    _this.maxWidth = maxPos;
    _this.animate = animate;

    _this.uuid = _slugid2['default'].nice();
    _this.refreshTilesDebounced = (0, _utils.debounce)(_this.refreshTiles.bind(_this), _configs.ZOOM_DEBOUNCE);
    return _this;
  }

  _createClass(OSMTilesTrack, [{
    key: 'rerender',
    value: function () {
      function rerender(options) {
        _get(OSMTilesTrack.prototype.__proto__ || Object.getPrototypeOf(OSMTilesTrack.prototype), 'rerender', this).call(this, options);

        if (!this.tilesetInfo) {}
      }

      return rerender;
    }()
  }, {
    key: 'visibleAndFetchedIds',
    value: function () {
      function visibleAndFetchedIds() {
        var _this2 = this;

        /**
             * Return the set of ids of all tiles which are both visible and fetched.
             */

        var ret = Object.keys(this.fetchedTiles).filter(function (x) {
          return _this2.visibleTileIds.has(x);
        });
        return ret;
      }

      return visibleAndFetchedIds;
    }()
  }, {
    key: 'visibleAndFetchedTiles',
    value: function () {
      function visibleAndFetchedTiles() {
        var _this3 = this;

        var ids = this.visibleAndFetchedIds();

        return ids.map(function (x) {
          return _this3.fetchedTiles[x];
        });
      }

      return visibleAndFetchedTiles;
    }()
  }, {
    key: 'setVisibleTiles',
    value: function () {
      function setVisibleTiles(tilePositions) {
        var _this4 = this;

        /**
             * Set which tiles are visible right now.
             *
             * @param tiles: A set of tiles which will be considered the currently visible
             * tile positions.
             */
        this.visibleTiles = tilePositions.map(function (x) {
          return {
            tileId: _this4.tileToLocalId(x),
            remoteId: _this4.tileToRemoteId(x),
            mirrored: x.mirrored
          };
        });

        this.visibleTileIds = new Set(this.visibleTiles.map(function (x) {
          return x.tileId;
        }));
      }

      return setVisibleTiles;
    }()
  }, {
    key: 'removeAllTiles',
    value: function () {
      function removeAllTiles() {
        var fetchedTileIDs = new Set(Object.keys(this.fetchedTiles));

        this.removeTiles([].concat(_toConsumableArray(fetchedTileIDs)));
      }

      return removeAllTiles;
    }()
  }, {
    key: 'refreshTiles',
    value: function () {
      function refreshTiles() {
        var _this5 = this;

        this.calculateVisibleTiles();

        // tiles that are fetched
        var fetchedTileIDs = new Set(Object.keys(this.fetchedTiles));

        // fetch the tiles that should be visible but haven't been fetched
        // and aren't in the process of being fetched
        var toFetch = [].concat(_toConsumableArray(this.visibleTiles)).filter(function (x) {
          return !_this5.fetching.has(x.remoteId) && !fetchedTileIDs.has(x.tileId);
        });

        for (var i = 0; i < toFetch.length; i++) {
          this.fetching.add(toFetch[i].remoteId);
        }

        // calculate which tiles are obsolete and remove them
        // fetchedTileID are remote ids
        var toRemove = [].concat(_toConsumableArray(fetchedTileIDs)).filter(function (x) {
          return !_this5.visibleTileIds.has(x);
        });

        this.removeTiles(toRemove);
        this.fetchNewTiles(toFetch);
      }

      return refreshTiles;
    }()
  }, {
    key: 'removeTiles',
    value: function () {
      function removeTiles(toRemoveIds) {
        var _this6 = this;

        /**
             * Remove obsolete tiles
             *
             * @param toRemoveIds: An array of tile ids to remove from the list of fetched tiles.
             */

        // if there's nothing to remove, don't bother doing anything
        if (!toRemoveIds.length) {
          return;
        }

        if (!this.areAllVisibleTilesLoaded()) {
          return;
        }

        toRemoveIds.forEach(function (x) {
          var tileIdStr = x;
          _this6.destroyTile(_this6.fetchedTiles[tileIdStr]);

          if (tileIdStr in _this6.tileGraphics) {
            _this6.pMain.removeChild(_this6.tileGraphics[tileIdStr]);
            delete _this6.tileGraphics[tileIdStr];
          }

          delete _this6.fetchedTiles[tileIdStr];
        });

        this.synchronizeTilesAndGraphics();
        this.draw();
      }

      return removeTiles;
    }()
  }, {
    key: 'tileToLocalId',
    value: function () {
      function tileToLocalId(tile) {
        /*
             * The local tile identifier
             */

        // tile contains [zoomLevel, xPos, yPos]
        return tile.join('.');
      }

      return tileToLocalId;
    }()
  }, {
    key: 'tileToRemoteId',
    value: function () {
      function tileToRemoteId(tile) {
        /**
             * The tile identifier used on the server
             */

        // tile contains [zoomLevel, xPos, yPos]
        return tile.join('.');
      }

      return tileToRemoteId;
    }()
  }, {
    key: 'localToRemoteId',
    value: function () {
      function localToRemoteId(remoteId) {
        var idParts = remoteId.split('.');
        return idParts.slice(0, idParts.length - 1).join('.');
      }

      return localToRemoteId;
    }()
  }, {
    key: 'calculateZoomLevel',
    value: function () {
      function calculateZoomLevel() {
        var xZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.minPos[0], this.maxPos[0]);
        var yZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.minPos[1], this.maxPos[1]);

        var zoomLevel = Math.max(xZoomLevel, yZoomLevel);
        zoomLevel = Math.min(zoomLevel, this.maxZoom);

        if (this.options && this.options.maxZoom) {
          if (this.options.maxZoom >= 0) {
            zoomLevel = Math.min(this.options.maxZoom, zoomLevel);
          } else {
            console.error('Invalid maxZoom on track:', this);
          }
        }

        return zoomLevel;
      }

      return calculateZoomLevel;
    }()
  }, {
    key: 'calculateVisibleTiles',
    value: function () {
      function calculateVisibleTiles() {
        var mirrorTiles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        // if we don't know anything about this dataset, no point
        // in trying to get tiles

        this.zoomLevel = this.calculateZoomLevel();

        // this.zoomLevel = 0;

        this.xTiles = _services.tileProxy.calculateTiles(this.zoomLevel, this._xScale, this.minPos[0], this.maxPos[0], this.maxZoom, this.maxWidth);

        this.yTiles = _services.tileProxy.calculateTiles(this.zoomLevel, this._yScale, this.minPos[1], this.maxPos[1], this.maxZoom, this.maxWidth);

        var rows = this.xTiles;
        var cols = this.yTiles;
        var zoomLevel = this.zoomLevel;

        // if we're mirroring tiles, then we only need tiles along the diagonal
        var tiles = [];
        // console.log('this.options:', this.options);

        // calculate the ids of the tiles that should be visible
        for (var i = 0; i < rows.length; i++) {
          for (var j = 0; j < cols.length; j++) {
            var newTile = [zoomLevel, rows[i], cols[j]];

            tiles.push(newTile);
          }
        }

        this.setVisibleTiles(tiles);
      }

      return calculateVisibleTiles;
    }()

    /*
      zoomed(newXScale, newYScale, k=1, tx=0, ty=0) {
          this.xScale(newXScale);
          this.yScale(newYScale);
           this.refreshTilesDebounced();
           this.pMobile.position.x = tx;
          this.pMobile.position.y = this.position[1];
           this.pMobile.scale.x = k;
          this.pMobile.scale.y = 1;
      }
      */

  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale, k, tx, ty) {
        _get(OSMTilesTrack.prototype.__proto__ || Object.getPrototypeOf(OSMTilesTrack.prototype), 'zoomed', this).call(this, newXScale, newYScale);

        this.xScale(newXScale);
        this.yScale(newYScale);

        this.pMain.position.x = tx; // translateX;
        this.pMain.position.y = ty; // translateY;

        this.pMain.scale.x = k; // scaleX;
        this.pMain.scale.y = k; // scaleY;

        this.refreshTilesDebounced();
      }

      return zoomed;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(OSMTilesTrack.prototype.__proto__ || Object.getPrototypeOf(OSMTilesTrack.prototype), 'setPosition', this).call(this, newPosition);

        // this.draw();
      }

      return setPosition;
    }()
  }, {
    key: 'setDimensions',
    value: function () {
      function setDimensions(newDimensions) {
        _get(OSMTilesTrack.prototype.__proto__ || Object.getPrototypeOf(OSMTilesTrack.prototype), 'setDimensions', this).call(this, newDimensions);

        // this.draw();
      }

      return setDimensions;
    }()
  }, {
    key: 'areAllVisibleTilesLoaded',
    value: function () {
      function areAllVisibleTilesLoaded() {
        /**
             * Check to see if all the visible tiles are loaded.
             *
             * If they are, remove all other tiles.
             */
        // tiles that are visible

        // tiles that are fetched
        var fetchedTileIDs = new Set(Object.keys(this.fetchedTiles));

        // console.log('this.fetchedTiles:', this.fetchedTiles);
        var visibleTileIdsList = [].concat(_toConsumableArray(this.visibleTileIds));

        // console.log('fetchedTileIDs:', fetchedTileIDs);
        // console.log('visibleTileIdsList:', visibleTileIdsList);

        for (var i = 0; i < visibleTileIdsList.length; i++) {
          if (!fetchedTileIDs.has(visibleTileIdsList[i])) {
            return false;
          }
        }

        return true;
      }

      return areAllVisibleTilesLoaded;
    }()
  }, {
    key: 'allTilesLoaded',
    value: function () {
      function allTilesLoaded() {
        /**
             * Function is called when all tiles that should be visible have
             * been received.
             */
      }

      return allTilesLoaded;
    }()
  }, {
    key: 'minValue',
    value: function () {
      function minValue(_) {
        if (_) {
          this.scale.minValue = _;
        } else {
          return this.scale.minValue;
        }
      }

      return minValue;
    }()
  }, {
    key: 'maxValue',
    value: function () {
      function maxValue(_) {
        if (_) {
          this.scale.maxValue = _;
        } else {
          return this.scale.maxValue;
        }
      }

      return maxValue;
    }()
  }, {
    key: 'minRawValue',
    value: function () {
      function minRawValue() {
        // this is the minimum value from all the tiles that
        // hasn't been externally modified by locked scales
        return this.scale.minRawValue;
      }

      return minRawValue;
    }()
  }, {
    key: 'maxRawValue',
    value: function () {
      function maxRawValue() {
        // this is the maximum value from all the tiles that
        // hasn't been externally modified by locked scales
        return this.scale.maxRawValue;
      }

      return maxRawValue;
    }()
  }, {
    key: 'getTilePosAndDimensions',
    value: function () {
      function getTilePosAndDimensions(zoomLevel, tilePos) {
        /**
             * Get the tile's position in its coordinate system.
             */
        var xTilePos = tilePos[0],
            yTilePos = tilePos[1];

        var totalWidth = this.maxPos[0] - this.minPos[0];
        var totalHeight = this.maxPos[0] - this.minPos[0];

        var minX = 0;
        var minY = 0;

        var tileWidth = totalWidth / Math.pow(2, zoomLevel);
        var tileHeight = totalHeight / Math.pow(2, zoomLevel);

        var tileX = minX + xTilePos * tileWidth;
        var tileY = minY + yTilePos * tileHeight;

        return { tileX: tileX,
          tileY: tileY,
          tileWidth: tileWidth,
          tileHeight: tileHeight };
      }

      return getTilePosAndDimensions;
    }()
  }, {
    key: 'setSpriteProperties',
    value: function () {
      function setSpriteProperties(sprite, zoomLevel, tilePos) {
        var _getTilePosAndDimensi = this.getTilePosAndDimensions(zoomLevel, tilePos),
            tileX = _getTilePosAndDimensi.tileX,
            tileY = _getTilePosAndDimensi.tileY,
            tileWidth = _getTilePosAndDimensi.tileWidth,
            tileHeight = _getTilePosAndDimensi.tileHeight;

        sprite.x = this._refXScale(tileX);
        sprite.y = this._refYScale(tileY);

        var tileEndX = tileX + tileWidth;
        var tileEndY = tileY + tileHeight;

        var spriteWidth = this._refXScale(tileEndX) - this._refXScale(tileX);
        var spriteHeight = this._refYScale(tileEndY) - this._refYScale(tileY);

        sprite.width = this._refXScale(tileEndX) - this._refXScale(tileX);
        sprite.height = this._refYScale(tileEndY) - this._refYScale(tileY);
      }

      return setSpriteProperties;
    }()
  }, {
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        // create the tile
        // should be overwritten by child classes
        // console.log("ERROR: unimplemented createTile:", this);
        var texture = new PIXI.Texture(new PIXI.BaseTexture(tile.tileData.img));
        var sprite = new PIXI.Sprite(texture);
        // console.log('tile.tileSrc:', tile);
        // let sprite = new PIXI.Sprite.fromImage(tile.tileSrc);

        var graphics = tile.graphics;

        var pos = tile.tileId.split('.').map(function (x) {
          return +x;
        });

        tile.sprite = sprite;

        this.setSpriteProperties(tile.sprite, tile.tileData.zoomLevel, tile.tileData.tilePos);

        graphics.removeChildren();
        graphics.addChild(tile.sprite);
      }

      return initTile;
    }()
  }, {
    key: 'updateTile',
    value: function () {
      function updateTile(tile) {
        // console.log("ERROR: unimplemented updateTile:", this);
      }

      return updateTile;
    }()
  }, {
    key: 'destroyTile',
    value: function () {
      function destroyTile(tile) {
        // remove all data structures needed to draw this tile
      }

      return destroyTile;
    }()
  }, {
    key: 'addMissingGraphics',
    value: function () {
      function addMissingGraphics() {
        /**
             * Add graphics for tiles that have no graphics
             */
        var fetchedTileIDs = Object.keys(this.fetchedTiles);
        var added = false;

        for (var i = 0; i < fetchedTileIDs.length; i++) {
          if (!(fetchedTileIDs[i] in this.tileGraphics)) {
            var newGraphics = new PIXI.Graphics();
            // console.log('adding:', fetchedTileIDs[i]);
            this.pMain.addChild(newGraphics);

            this.fetchedTiles[fetchedTileIDs[i]].graphics = newGraphics;
            // console.log('fetchedTiles:', this.fetchedTiles[fetchedTileIDs[i]]);
            this.initTile(this.fetchedTiles[fetchedTileIDs[i]]);

            // console.log('adding graphics...', fetchedTileIDs[i]);
            this.tileGraphics[fetchedTileIDs[i]] = newGraphics;
            added = true;
          }
        }

        /*
            if (added)
                this.draw();
            */
      }

      return addMissingGraphics;
    }()
  }, {
    key: 'updateExistingGraphics',
    value: function () {
      function updateExistingGraphics() {
        /**
             * Change the graphics for existing tiles
             */
        var fetchedTileIDs = Object.keys(this.fetchedTiles);

        for (var i = 0; i < fetchedTileIDs.length; i++) {
          this.updateTile(this.fetchedTiles[fetchedTileIDs[i]]);
        }
      }

      return updateExistingGraphics;
    }()
  }, {
    key: 'synchronizeTilesAndGraphics',
    value: function () {
      function synchronizeTilesAndGraphics() {
        /**
             * Make sure that we have a one to one mapping between tiles
             * and graphics objects
             *
             */

        // keep track of which tiles are visible at the moment
        this.addMissingGraphics();
        this.updateExistingGraphics();
        // this.removeOldGraphics();
      }

      return synchronizeTilesAndGraphics;
    }()
  }, {
    key: 'loadTileData',
    value: function () {
      function loadTileData(tile, dataLoader) {
        /**
             * Extract drawable data from a tile loaded by a generic tile loader
             *
             * @param tile: A tile returned by a TiledArea.
             * @param dataLoader: A function for extracting drawable data from a tile. This
             *                    usually means differentiating the between dense and sparse
             *                    tiles and putting the data into an array.
             */

        // see if the data is already cached
        var loadedTileData = this.lruCache.get(tile.tileId);

        // if not, load it and put it in the cache
        if (!loadedTileData) {
          loadedTileData = dataLoader(tile.data, tile.type);
          this.lruCache.put(tile.tileId, loadedTileData);
        }

        return loadedTileData;
      }

      return loadTileData;
    }()
  }, {
    key: 'getTileUrl',
    value: function () {
      function getTileUrl(tileZxy) {
        /**
             * Get the url used to fetch the tile data
             */
        var serverPrefixes = ['a', 'b', 'c'];
        var serverPrefixIndex = Math.floor(Math.random() * serverPrefixes.length);
        var src = 'http://' + serverPrefixes[serverPrefixIndex] + '.tile.openstreetmap.org/' + tileZxy[0] + '/' + tileZxy[1] + '/' + tileZxy[2] + '.png';

        return src;
      }

      return getTileUrl;
    }()
  }, {
    key: 'fetchNewTiles',
    value: function () {
      function fetchNewTiles(toFetch) {
        var _this7 = this;

        if (toFetch.length > 0) {
          var toFetchList = [].concat(_toConsumableArray(new Set(toFetch.map(function (x) {
            return x.remoteId;
          }))));
          // console.log('xs:', toFetch);
          // console.log('fetching:', toFetchList.join(' '));

          // http://a.tile.openstreetmap.org/z/x/y.png
          //
          // tileProxy.fetchTiles(this.tilesetServer, toFetchList, this.receivedTiles.bind(this));

          /*
                tileProxy.fetchTilesDebounced({
                    id: this.uuid,
                    server: this.tilesetServer,
                    done: this.receivedTiles.bind(this),
                    ids: toFetchList
                });
                */

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            var _loop = function () {
              function _loop() {
                var tileId = _step.value;

                var parts = tileId.split('.');
                var src = _this7.getTileUrl(parts);

                var img = new Image();
                img.crossOrigin = 'Anonymous';
                img.src = src;

                img.onload = function () {
                  var loadedTiles = {};
                  loadedTiles[tileId] = { tileId: tileId,
                    img: img,
                    zoomLevel: +parts[0],
                    tilePos: [+parts[1], +parts[2]],
                    tileSrc: src };

                  _this7.receivedTiles(loadedTiles);
                };
              }

              return _loop;
            }();

            for (var _iterator = toFetchList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              _loop();
            }
            // for (let tileId
            // let img = new Image();
            // img.src = "http://a.tile.openstreetmap.org/
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator['return']) {
                _iterator['return']();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }

      return fetchNewTiles;
    }()
  }, {
    key: 'receivedTiles',
    value: function () {
      function receivedTiles(loadedTiles) {
        /**
             * We've gotten a bunch of tiles from the server in
             * response to a request from fetchTiles.
             */
        // console.log('received:', loadedTiles);
        for (var i = 0; i < this.visibleTiles.length; i++) {
          var _tileId = this.visibleTiles[i].tileId;

          if (!loadedTiles[this.visibleTiles[i].remoteId]) {
            continue;
          }

          if (this.visibleTiles[i].remoteId in loadedTiles) {
            if (!(_tileId in this.fetchedTiles)) {
              // this tile may have graphics associated with it
              this.fetchedTiles[_tileId] = this.visibleTiles[i];
            }

            this.fetchedTiles[_tileId].tileData = loadedTiles[this.visibleTiles[i].remoteId];
          }
        }

        for (var key in loadedTiles) {
          if (loadedTiles[key]) {
            if (this.fetching.has(key)) {
              this.fetching['delete'](key);
            }
          }
        }

        this.synchronizeTilesAndGraphics();

        /*
             * Mainly called to remove old unnecessary tiles
             */
        this.refreshTiles();

        // we need to draw when we receive new data
        this.draw();

        // Let HiGlass know we need to re-render
        this.animate();
      }

      return receivedTiles;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        if (this.delayDrawing) {
          return;
        }

        _get(OSMTilesTrack.prototype.__proto__ || Object.getPrototypeOf(OSMTilesTrack.prototype), 'draw', this).call(this);

        for (var uid in this.fetchedTiles) {
          this.drawTile(this.fetchedTiles[uid]);
        }

        // this.animate();
      }

      return draw;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tileData, graphics) {
        /**
             * Draw a tile on some graphics
             */

      }

      return drawTile;
    }()
  }, {
    key: 'refScalesChanged',
    value: function () {
      function refScalesChanged(refXScale, refYScale) {
        _get(OSMTilesTrack.prototype.__proto__ || Object.getPrototypeOf(OSMTilesTrack.prototype), 'refScalesChanged', this).call(this, refXScale, refYScale);

        for (var uid in this.fetchedTiles) {
          var tile = this.fetchedTiles[uid];

          if (tile.sprite) {
            this.setSpriteProperties(tile.sprite, tile.tileData.zoomLevel, tile.tileData.tilePos);
          } else {
            // console.log('skipping...', tile.tileId);
          }
        }
      }

      return refScalesChanged;
    }()
  }]);

  return OSMTilesTrack;
}(_PixiTrack2.PixiTrack);

exports['default'] = OSMTilesTrack;

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ListWrapper = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactSortableHoc = __webpack_require__(47);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ListWrapper = exports.ListWrapper = function (_React$Component) {
  _inherits(ListWrapper, _React$Component);

  function ListWrapper(_ref) {
    var items = _ref.items;

    _classCallCheck(this, ListWrapper);

    var _this = _possibleConstructorReturn(this, (ListWrapper.__proto__ || Object.getPrototypeOf(ListWrapper)).call(this));

    _this.state = {
      items: items, isSorting: false
    };
    return _this;
  }

  _createClass(ListWrapper, [{
    key: 'componentWillReceiveProps',
    value: function () {
      function componentWillReceiveProps(nextProps) {
        this.setState({
          items: nextProps.items
        });
      }

      return componentWillReceiveProps;
    }()
  }, {
    key: 'onSortStart',
    value: function () {
      function onSortStart(_ref2, e) {
        var node = _ref2.node,
            index = _ref2.index,
            collection = _ref2.collection;

        e.stopImmediatePropagation();
        var onSortStart = this.props.onSortStart;

        this.setState({ isSorting: true });

        if (onSortStart) {
          onSortStart(this.ref);
        }

        this.sortingIndex = index;

        this.sortStartTop = e.offsetTop;
        this.sortStartLeft = e.offsetLeft;
      }

      return onSortStart;
    }()
  }, {
    key: 'onSortMove',
    value: function () {
      function onSortMove() {}

      return onSortMove;
    }()
  }, {
    key: 'onSortEnd',
    value: function () {
      function onSortEnd(_ref3) {
        var oldIndex = _ref3.oldIndex,
            newIndex = _ref3.newIndex;
        var onSortEnd = this.props.onSortEnd;
        var items = this.state.items;


        this.setState({
          items: (0, _reactSortableHoc.arrayMove)(items, oldIndex, newIndex),
          isSorting: false
        });

        if (onSortEnd) {
          onSortEnd(this.state.items);
        }

        this.sortingIndex = null;
      }

      return onSortEnd;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        var Component = this.props.component;
        var _state = this.state,
            items = _state.items,
            isSorting = _state.isSorting;

        var props = {
          isSorting: isSorting,
          items: items,
          onSortEnd: this.onSortEnd.bind(this),
          onSortStart: this.onSortStart.bind(this),
          onSortMove: this.onSortMove.bind(this)
        };

        return _react2['default'].createElement(Component, _extends({}, this.props, props, {
          ref: function () {
            function ref(element) {
              return _this2.ref = element;
            }

            return ref;
          }()
        }));
      }

      return render;
    }()
  }]);

  return ListWrapper;
}(_react2['default'].Component);

ListWrapper.propTypes = {
  axis: _propTypes2['default'].string,
  className: _propTypes2['default'].string,
  component: _propTypes2['default'].func,
  editable: _propTypes2['default'].bool,
  handleConfigTrack: _propTypes2['default'].func,
  handleResizeTrack: _propTypes2['default'].func,
  height: _propTypes2['default'].number,
  helperClass: _propTypes2['default'].string,
  itemClass: _propTypes2['default'].string,
  itemControlAlignLeft: _propTypes2['default'].bool,
  itemReactClass: _propTypes2['default'].func,
  items: _propTypes2['default'].array,
  onAddSeries: _propTypes2['default'].func,
  onCloseTrack: _propTypes2['default'].func,
  onCloseTrackMenuOpened: _propTypes2['default'].func,
  onConfigTrackMenuOpened: _propTypes2['default'].func,
  onSortEnd: _propTypes2['default'].func,
  onSortStart: _propTypes2['default'].func,
  referenceAncestor: _propTypes2['default'].string,
  resizeHandles: _propTypes2['default'].object,
  useDragHandle: _propTypes2['default'].bool,
  width: _propTypes2['default'].number
};

ListWrapper.defaultProps = {
  className: 'list stylizedList',
  itemClass: 'item stylizedItem',
  width: 400,
  height: 600
};

exports['default'] = ListWrapper;

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MoveableTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _DraggableDiv = __webpack_require__(691);

var _DraggableDiv2 = _interopRequireDefault(_DraggableDiv);

var _TrackArea2 = __webpack_require__(693);

var _TrackArea3 = _interopRequireDefault(_TrackArea2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MoveableTrack = exports.MoveableTrack = function (_TrackArea) {
  _inherits(MoveableTrack, _TrackArea);

  function MoveableTrack(props) {
    _classCallCheck(this, MoveableTrack);

    var _this = _possibleConstructorReturn(this, (MoveableTrack.__proto__ || Object.getPrototypeOf(MoveableTrack)).call(this, props));

    _this.moveable = true;
    return _this;
  }

  _createClass(MoveableTrack, [{
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        return _react2['default'].createElement(
          'div',
          {
            className: this.props.className,
            onMouseEnter: this.handleMouseEnter.bind(this),
            onMouseLeave: this.handleMouseLeave.bind(this),
            style: {
              height: this.props.height,
              width: this.props.width
            }
          },
          _react2['default'].createElement(_DraggableDiv2['default'], {
            height: this.props.height,
            key: this.props.uid,
            resizeHandles: this.props.editable ? this.props.resizeHandles : new Set(),
            sizeChanged: function () {
              function sizeChanged(stuff) {
                return _this2.props.handleResizeTrack(_this2.props.uid, stuff.width, stuff.height);
              }

              return sizeChanged;
            }(),
            style: { background: 'transparent' },
            uid: this.props.uid,
            width: this.props.width
          }),
          this.props.editable && _react2['default'].createElement(
            'div',
            null,
            this.getControls(this.state.controlsVisible || this.props.item.configMenuVisible)
          )
        );
      }

      return render;
    }()
  }]);

  return MoveableTrack;
}(_TrackArea3['default']);

MoveableTrack.propTypes = {
  className: _propTypes2['default'].string,
  uid: _propTypes2['default'].string,
  item: _propTypes2['default'].object,
  height: _propTypes2['default'].number,
  width: _propTypes2['default'].number
};

exports['default'] = MoveableTrack;

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SortableList = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactSortableHoc = __webpack_require__(47);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var SortableList = exports.SortableList = (0, _reactSortableHoc.SortableContainer)(function (_ref) {
  var className = _ref.className,
      items = _ref.items,
      itemClass = _ref.itemClass,
      itemControlAlignLeft = _ref.itemControlAlignLeft,
      sortingIndex = _ref.sortingIndex,
      useDragHandle = _ref.useDragHandle,
      sortableHandlers = _ref.sortableHandlers,
      height = _ref.height,
      width = _ref.width,
      onCloseTrack = _ref.onCloseTrack,
      onCloseTrackMenuOpened = _ref.onCloseTrackMenuOpened,
      onConfigTrackMenuOpened = _ref.onConfigTrackMenuOpened,
      onAddSeries = _ref.onAddSeries,
      handleConfigTrack = _ref.handleConfigTrack,
      editable = _ref.editable,
      itemReactClass = _ref.itemReactClass,
      handleResizeTrack = _ref.handleResizeTrack,
      resizeHandles = _ref.resizeHandles;

  var itemElements = items.map(function (item, index) {
    return _react2['default'].createElement(itemReactClass, {
      key: 'sci-' + item.uid,
      className: itemClass,
      controlAlignLeft: itemControlAlignLeft,
      sortingIndex: sortingIndex,
      index: index,
      uid: item.uid,
      height: item.height,
      width: item.width,
      item: item,
      useDragHandle: useDragHandle,
      onCloseTrack: onCloseTrack,
      onCloseTrackMenuOpened: onCloseTrackMenuOpened,
      onConfigTrackMenuOpened: onConfigTrackMenuOpened,
      onAddSeries: onAddSeries,
      handleConfigTrack: handleConfigTrack,
      editable: editable,
      handleResizeTrack: handleResizeTrack,
      resizeHandles: resizeHandles
    });
  });

  return _react2['default'].createElement(
    'div',
    _extends({
      className: className,
      style: {
        height: height,
        width: width,
        background: 'transparent'
      }
    }, sortableHandlers),
    itemElements
  );
});

exports['default'] = SortableList;

/***/ }),
/* 250 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"multitrack-header":"ViewHeader-module_multitrack-header-3XnZx","multitrack-header-focus":"ViewHeader-module_multitrack-header-focus-3akkN","multitrack-header-squeazed":"ViewHeader-module_multitrack-header-squeazed-GHIVd","multitrack-header-id":"ViewHeader-module_multitrack-header-id-3YURk","multitrack-header-left":"ViewHeader-module_multitrack-header-left-Qj9Sm","multitrack-header-grabber":"ViewHeader-module_multitrack-header-grabber-3jrIz","multitrack-header-grabber-squeazed":"ViewHeader-module_multitrack-header-grabber-squeazed-dU45Z","multitrack-header-search":"ViewHeader-module_multitrack-header-search-1X_3_","multitrack-header-nav-list":"ViewHeader-module_multitrack-header-nav-list-2nvcu","multitrack-header-icon":"ViewHeader-module_multitrack-header-icon-16QKZ","multitrack-header-icon-squeazed":"ViewHeader-module_multitrack-header-icon-squeazed-25lkF"};

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(252);


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChromosomeInfo = exports.HiGlassComponent = undefined;

var _HiGlassComponent = __webpack_require__(145);

Object.defineProperty(exports, 'HiGlassComponent', {
  enumerable: true,
  get: function () {
    function get() {
      return _interopRequireDefault(_HiGlassComponent)['default'];
    }

    return get;
  }()
});

var _ChromosomeInfo = __webpack_require__(43);

Object.defineProperty(exports, 'ChromosomeInfo', {
  enumerable: true,
  get: function () {
    function get() {
      return _ChromosomeInfo.ChromosomeInfo;
    }

    return get;
  }()
});
exports.createHgComponent = createHgComponent;

var _d3Request = __webpack_require__(30);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(8);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _HiGlassComponent2 = _interopRequireDefault(_HiGlassComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function launch(element, config, options, callback) {
  /**
   * The instance's public API will be passed into the callback
   *
   * @param   {Object} higlass - HiGlass instance
   * @return  {Object} The instance's public API
   */
  callback(function (higlass) {
    return higlass.api;
  }(_reactDom2['default'].render(_react2['default'].createElement(_HiGlassComponent2['default'], {
    options: options || {},
    viewConfig: config
  }), element)));
}

function createHgComponent(element, config, options, callback) {
  /**
   * Available options:
   *
   *  bounded: [true/false]
   *      Fit the container to the bounds of the element
   */
  if (typeof config === 'string') {
    // Load external config
    (0, _d3Request.json)(config, function (error, data) {
      if (error) throw error;

      launch(element, data, options, callback);
    });
  } else {
    launch(element, config, options, callback);
  }
}

exports['default'] = createHgComponent;

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(87);
var invariant = __webpack_require__(88);
var warning = __webpack_require__(146);
var assign = __webpack_require__(254);

var ReactPropTypesSecret = __webpack_require__(89);
var checkPropTypes = __webpack_require__(255);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(88);
  var warning = __webpack_require__(146);
  var ReactPropTypesSecret = __webpack_require__(89);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(87);
var invariant = __webpack_require__(88);
var ReactPropTypesSecret = __webpack_require__(89);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 257 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__select__ = __webpack_require__(147);



/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__select__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_0__creator__["a" /* default */])(name).call(document.documentElement));
});


/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selector__ = __webpack_require__(92);



/* harmony default export */ __webpack_exports__["a"] = (function(select) {
  if (typeof select !== "function") select = Object(__WEBPACK_IMPORTED_MODULE_1__selector__["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Selection */](subgroups, this._parents);
});


/***/ }),
/* 259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selectorAll__ = __webpack_require__(148);



/* harmony default export */ __webpack_exports__["a"] = (function(select) {
  if (typeof select !== "function") select = Object(__WEBPACK_IMPORTED_MODULE_1__selectorAll__["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Selection */](subgroups, parents);
});


/***/ }),
/* 260 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__matcher__ = __webpack_require__(149);



/* harmony default export */ __webpack_exports__["a"] = (function(match) {
  if (typeof match !== "function") match = Object(__WEBPACK_IMPORTED_MODULE_1__matcher__["a" /* default */])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Selection */](subgroups, this._parents);
});


/***/ }),
/* 261 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__enter__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constant__ = __webpack_require__(262);




var keyPrefix = "$"; // Protect against keys like __proto__.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new __WEBPACK_IMPORTED_MODULE_1__enter__["a" /* EnterNode */](parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new __WEBPACK_IMPORTED_MODULE_1__enter__["a" /* EnterNode */](parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ __webpack_exports__["a"] = (function(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Selection */](update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});


/***/ }),
/* 262 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sparse__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(16);



/* harmony default export */ __webpack_exports__["a"] = (function() {
  return new __WEBPACK_IMPORTED_MODULE_1__index__["a" /* Selection */](this._exit || this._groups.map(__WEBPACK_IMPORTED_MODULE_0__sparse__["a" /* default */]), this._parents);
});


/***/ }),
/* 264 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(16);


/* harmony default export */ __webpack_exports__["a"] = (function(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Selection */](merges, this._parents);
});


/***/ }),
/* 265 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});


/***/ }),
/* 266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(16);


/* harmony default export */ __webpack_exports__["a"] = (function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Selection */](sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});


/***/ }),
/* 268 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
});


/***/ }),
/* 269 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});


/***/ }),
/* 270 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
});


/***/ }),
/* 271 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  return !this.node();
});


/***/ }),
/* 272 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});


/***/ }),
/* 273 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__namespace__ = __webpack_require__(90);


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var fullname = Object(__WEBPACK_IMPORTED_MODULE_0__namespace__["a" /* default */])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});


/***/ }),
/* 274 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
});


/***/ }),
/* 275 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
});


/***/ }),
/* 276 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
});


/***/ }),
/* 277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
});


/***/ }),
/* 278 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this.each(raise);
});


/***/ }),
/* 279 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this.each(lower);
});


/***/ }),
/* 280 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(64);


/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var create = typeof name === "function" ? name : Object(__WEBPACK_IMPORTED_MODULE_0__creator__["a" /* default */])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
});


/***/ }),
/* 281 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selector__ = __webpack_require__(92);



function constantNull() {
  return null;
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, before) {
  var create = typeof name === "function" ? name : Object(__WEBPACK_IMPORTED_MODULE_0__creator__["a" /* default */])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : Object(__WEBPACK_IMPORTED_MODULE_1__selector__["a" /* default */])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});


/***/ }),
/* 282 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this.each(remove);
});


/***/ }),
/* 283 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

/* harmony default export */ __webpack_exports__["a"] = (function(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});


/***/ }),
/* 284 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
});


/***/ }),
/* 285 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__window__ = __webpack_require__(93);


function dispatchEvent(node, type, params) {
  var window = Object(__WEBPACK_IMPORTED_MODULE_0__window__["a" /* default */])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
});


/***/ }),
/* 286 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = local;
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),
/* 287 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(65);



/* harmony default export */ __webpack_exports__["a"] = (function(node) {
  var event = Object(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__["a" /* default */])();
  if (event.changedTouches) event = event.changedTouches[0];
  return Object(__WEBPACK_IMPORTED_MODULE_1__point__["a" /* default */])(node, event);
});


/***/ }),
/* 288 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection_index__ = __webpack_require__(16);


/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return typeof selector === "string"
      ? new __WEBPACK_IMPORTED_MODULE_0__selection_index__["a" /* Selection */]([document.querySelectorAll(selector)], [document.documentElement])
      : new __WEBPACK_IMPORTED_MODULE_0__selection_index__["a" /* Selection */]([selector == null ? [] : selector], __WEBPACK_IMPORTED_MODULE_0__selection_index__["c" /* root */]);
});


/***/ }),
/* 289 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(65);



/* harmony default export */ __webpack_exports__["a"] = (function(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = Object(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__["a" /* default */])().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return Object(__WEBPACK_IMPORTED_MODULE_1__point__["a" /* default */])(node, touch);
    }
  }

  return null;
});


/***/ }),
/* 290 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(65);



/* harmony default export */ __webpack_exports__["a"] = (function(node, touches) {
  if (touches == null) touches = Object(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__["a" /* default */])().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = Object(__WEBPACK_IMPORTED_MODULE_1__point__["a" /* default */])(node, touches[i]);
  }

  return points;
});


/***/ }),
/* 291 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = band;
/* harmony export (immutable) */ __webpack_exports__["b"] = point;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ordinal__ = __webpack_require__(165);



function band() {
  var scale = Object(__WEBPACK_IMPORTED_MODULE_1__ordinal__["a" /* default */])().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["range"])(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band()
        .domain(domain())
        .range(range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}


/***/ }),
/* 292 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pairs__ = __webpack_require__(155);


/* harmony default export */ __webpack_exports__["a"] = (function(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = __WEBPACK_IMPORTED_MODULE_0__pairs__["b" /* pair */];

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
});


/***/ }),
/* 293 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});


/***/ }),
/* 294 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__bisect__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constant__ = __webpack_require__(295);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extent__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__identity__ = __webpack_require__(296);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__range__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ticks__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__threshold_sturges__ = __webpack_require__(162);









/* harmony default export */ __webpack_exports__["a"] = (function() {
  var value = __WEBPACK_IMPORTED_MODULE_4__identity__["a" /* default */],
      domain = __WEBPACK_IMPORTED_MODULE_3__extent__["a" /* default */],
      threshold = __WEBPACK_IMPORTED_MODULE_7__threshold_sturges__["a" /* default */];

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = Object(__WEBPACK_IMPORTED_MODULE_6__ticks__["c" /* tickStep */])(x0, x1, tz);
      tz = Object(__WEBPACK_IMPORTED_MODULE_5__range__["a" /* default */])(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[Object(__WEBPACK_IMPORTED_MODULE_1__bisect__["c" /* default */])(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__array__["b" /* slice */].call(_)) : Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])(_), histogram) : threshold;
  };

  return histogram;
});


/***/ }),
/* 295 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 296 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x;
});


/***/ }),
/* 297 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ascending__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__number__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__quantile__ = __webpack_require__(96);





/* harmony default export */ __webpack_exports__["a"] = (function(values, min, max) {
  values = __WEBPACK_IMPORTED_MODULE_0__array__["a" /* map */].call(values, __WEBPACK_IMPORTED_MODULE_2__number__["a" /* default */]).sort(__WEBPACK_IMPORTED_MODULE_1__ascending__["a" /* default */]);
  return Math.ceil((max - min) / (2 * (Object(__WEBPACK_IMPORTED_MODULE_3__quantile__["a" /* default */])(values, 0.75) - Object(__WEBPACK_IMPORTED_MODULE_3__quantile__["a" /* default */])(values, 0.25)) * Math.pow(values.length, -1 / 3)));
});


/***/ }),
/* 298 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__deviation__ = __webpack_require__(156);


/* harmony default export */ __webpack_exports__["a"] = (function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * Object(__WEBPACK_IMPORTED_MODULE_0__deviation__["a" /* default */])(values) * Math.pow(values.length, -1 / 3)));
});


/***/ }),
/* 299 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
});


/***/ }),
/* 300 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(51);


/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
});


/***/ }),
/* 301 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ascending__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__number__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__quantile__ = __webpack_require__(96);




/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(__WEBPACK_IMPORTED_MODULE_1__number__["a" /* default */])(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(__WEBPACK_IMPORTED_MODULE_1__number__["a" /* default */])(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return Object(__WEBPACK_IMPORTED_MODULE_2__quantile__["a" /* default */])(numbers.sort(__WEBPACK_IMPORTED_MODULE_0__ascending__["a" /* default */]), 0.5);
});


/***/ }),
/* 302 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
});


/***/ }),
/* 303 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
});


/***/ }),
/* 304 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ascending__ = __webpack_require__(45);


/* harmony default export */ __webpack_exports__["a"] = (function(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = __WEBPACK_IMPORTED_MODULE_0__ascending__["a" /* default */];

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
});


/***/ }),
/* 305 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
});


/***/ }),
/* 306 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
});


/***/ }),
/* 307 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transpose__ = __webpack_require__(164);


/* harmony default export */ __webpack_exports__["a"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_0__transpose__["a" /* default */])(arguments);
});


/***/ }),
/* 308 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = identity;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__linear__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__number__ = __webpack_require__(174);




function identity() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = __WEBPACK_IMPORTED_MODULE_0__array__["a" /* map */].call(_, __WEBPACK_IMPORTED_MODULE_2__number__["a" /* default */]), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity().domain(domain);
  };

  return Object(__WEBPACK_IMPORTED_MODULE_1__linear__["b" /* linearish */])(scale);
}


/***/ }),
/* 309 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = lab;
/* unused harmony export Lab */
/* harmony export (immutable) */ __webpack_exports__["b"] = hcl;
/* unused harmony export Hcl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__define__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math__ = __webpack_require__(166);




var Kn = 18,
    Xn = 0.950470, // D65 standard referent
    Yn = 1,
    Zn = 1.088830,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    var h = o.h * __WEBPACK_IMPORTED_MODULE_2__math__["a" /* deg2rad */];
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof __WEBPACK_IMPORTED_MODULE_1__color__["b" /* Rgb */])) o = Object(__WEBPACK_IMPORTED_MODULE_1__color__["h" /* rgbConvert */])(o);
  var b = rgb2xyz(o.r),
      a = rgb2xyz(o.g),
      l = rgb2xyz(o.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

Object(__WEBPACK_IMPORTED_MODULE_0__define__["a" /* default */])(Lab, lab, Object(__WEBPACK_IMPORTED_MODULE_0__define__["b" /* extend */])(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* Color */], {
  brighter: function(k) {
    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new __WEBPACK_IMPORTED_MODULE_1__color__["b" /* Rgb */](
      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  var h = Math.atan2(o.b, o.a) * __WEBPACK_IMPORTED_MODULE_2__math__["b" /* rad2deg */];
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

Object(__WEBPACK_IMPORTED_MODULE_0__define__["a" /* default */])(Hcl, hcl, Object(__WEBPACK_IMPORTED_MODULE_0__define__["b" /* extend */])(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* Color */], {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));


/***/ }),
/* 310 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = cubehelix;
/* unused harmony export Cubehelix */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__define__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math__ = __webpack_require__(166);




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof __WEBPACK_IMPORTED_MODULE_1__color__["b" /* Rgb */])) o = Object(__WEBPACK_IMPORTED_MODULE_1__color__["h" /* rgbConvert */])(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * __WEBPACK_IMPORTED_MODULE_2__math__["b" /* rad2deg */] - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(__WEBPACK_IMPORTED_MODULE_0__define__["a" /* default */])(Cubehelix, cubehelix, Object(__WEBPACK_IMPORTED_MODULE_0__define__["b" /* extend */])(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* Color */], {
  brighter: function(k) {
    k = k == null ? __WEBPACK_IMPORTED_MODULE_1__color__["c" /* brighter */] : Math.pow(__WEBPACK_IMPORTED_MODULE_1__color__["c" /* brighter */], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? __WEBPACK_IMPORTED_MODULE_1__color__["d" /* darker */] : Math.pow(__WEBPACK_IMPORTED_MODULE_1__color__["d" /* darker */], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * __WEBPACK_IMPORTED_MODULE_2__math__["a" /* deg2rad */],
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new __WEBPACK_IMPORTED_MODULE_1__color__["b" /* Rgb */](
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),
/* 311 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
});


/***/ }),
/* 312 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return interpolateTransformCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return interpolateTransformSvg; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(313);



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(xa, xb)}, {i: i - 2, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(xa, xb)}, {i: i - 2, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse__["a" /* parseCss */], "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse__["b" /* parseSvg */], ", ", ")", ")");


/***/ }),
/* 313 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseCss;
/* harmony export (immutable) */ __webpack_exports__["b"] = parseSvg;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__decompose__ = __webpack_require__(314);


var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return __WEBPACK_IMPORTED_MODULE_0__decompose__["b" /* identity */];
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return Object(__WEBPACK_IMPORTED_MODULE_0__decompose__["a" /* default */])(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return __WEBPACK_IMPORTED_MODULE_0__decompose__["b" /* identity */];
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return __WEBPACK_IMPORTED_MODULE_0__decompose__["b" /* identity */];
  value = value.matrix;
  return Object(__WEBPACK_IMPORTED_MODULE_0__decompose__["a" /* default */])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),
/* 314 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return identity; });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ __webpack_exports__["a"] = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});


/***/ }),
/* 315 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
/* harmony default export */ __webpack_exports__["a"] = (function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0  u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    }
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    }
  }

  i.duration = S * 1000;

  return i;
});


/***/ }),
/* 316 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export hslLong */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(53);



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["hsl"])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["hsl"])(end)).h),
        s = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.s, end.s),
        l = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.l, end.l),
        opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* unused harmony default export */ var _unused_webpack_default_export = (hsl(__WEBPACK_IMPORTED_MODULE_1__color__["c" /* hue */]));
var hslLong = hsl(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */]);


/***/ }),
/* 317 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(53);



function lab(start, end) {
  var l = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["lab"])(start)).l, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["lab"])(end)).l),
      a = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.a, end.a),
      b = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.b, end.b),
      opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),
/* 318 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export hclLong */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(53);



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["hcl"])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["hcl"])(end)).h),
        c = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.c, end.c),
        l = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.l, end.l),
        opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* unused harmony default export */ var _unused_webpack_default_export = (hcl(__WEBPACK_IMPORTED_MODULE_1__color__["c" /* hue */]));
var hclLong = hcl(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */]);


/***/ }),
/* 319 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cubehelixLong; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(53);



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["cubehelix"])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["cubehelix"])(end)).h),
          s = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.s, end.s),
          l = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.l, end.l),
          opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* unused harmony default export */ var _unused_webpack_default_export = (cubehelix(__WEBPACK_IMPORTED_MODULE_1__color__["c" /* hue */]));
var cubehelixLong = cubehelix(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */]);


/***/ }),
/* 320 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony default export */ var _unused_webpack_default_export = (function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
});


/***/ }),
/* 321 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_format__ = __webpack_require__(46);



/* harmony default export */ __webpack_exports__["a"] = (function(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["tickStep"])(start, stop, count == null ? 10 : count),
      precision;
  specifier = Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["formatSpecifier"])(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["precisionPrefix"])(step, value))) specifier.precision = precision;
      return Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["formatPrefix"])(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["precisionRound"])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["precisionFixed"])(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["format"])(specifier);
});


/***/ }),
/* 322 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return formatPrefix; });
/* harmony export (immutable) */ __webpack_exports__["a"] = defaultLocale;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__locale__ = __webpack_require__(175);


var locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = Object(__WEBPACK_IMPORTED_MODULE_0__locale__["a" /* default */])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),
/* 323 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
});


/***/ }),
/* 324 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
});


/***/ }),
/* 325 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  x = x.toPrecision(p);

  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (x[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      case "e": break out;
      default: if (i0 > 0) i0 = 0; break;
    }
  }

  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
});


/***/ }),
/* 326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDecimal__ = __webpack_require__(107);


/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  var d = Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
});


/***/ }),
/* 327 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x;
});


/***/ }),
/* 328 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(69);


/* harmony default export */ __webpack_exports__["a"] = (function(step) {
  return Math.max(0, -Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(Math.abs(step)));
});


/***/ }),
/* 329 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(69);


/* harmony default export */ __webpack_exports__["a"] = (function(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(value) / 3))) * 3 - Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(Math.abs(step)));
});


/***/ }),
/* 330 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(69);


/* harmony default export */ __webpack_exports__["a"] = (function(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(max) - Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(step)) + 1;
});


/***/ }),
/* 331 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = log;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_format__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constant__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__nice__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__continuous__ = __webpack_require__(68);






function deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])(b);
}

function reinterpolate(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log() {
  var scale = Object(__WEBPACK_IMPORTED_MODULE_4__continuous__["b" /* default */])(deinterpolate, reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["ticks"])(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["format"])(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(Object(__WEBPACK_IMPORTED_MODULE_3__nice__["a" /* default */])(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return Object(__WEBPACK_IMPORTED_MODULE_4__continuous__["a" /* copy */])(scale, log().base(base));
  };

  return scale;
}


/***/ }),
/* 332 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = pow;
/* harmony export (immutable) */ __webpack_exports__["b"] = sqrt;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__linear__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__continuous__ = __webpack_require__(68);




function raise(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = Object(__WEBPACK_IMPORTED_MODULE_2__continuous__["b" /* default */])(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise(b, exponent) - (a = raise(a, exponent)))
        ? function(x) { return (raise(x, exponent) - a) / b; }
        : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(b);
  }

  function reinterpolate(a, b) {
    b = raise(b, exponent) - (a = raise(a, exponent));
    return function(t) { return raise(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return Object(__WEBPACK_IMPORTED_MODULE_2__continuous__["a" /* copy */])(scale, pow().exponent(exponent));
  };

  return Object(__WEBPACK_IMPORTED_MODULE_1__linear__["b" /* linearish */])(scale);
}

function sqrt() {
  return pow().exponent(0.5);
}


/***/ }),
/* 333 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = quantile;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(29);



function quantile() {
  var domain = [],
      range = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["quantile"])(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range[Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["bisect"])(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(__WEBPACK_IMPORTED_MODULE_0_d3_array__["ascending"]);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = __WEBPACK_IMPORTED_MODULE_1__array__["b" /* slice */].call(_), rescale()) : range.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range);
  };

  return scale;
}


/***/ }),
/* 334 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = quantize;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__linear__ = __webpack_require__(52);




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1];

  function scale(x) {
    if (x <= x) return range[Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["bisect"])(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = __WEBPACK_IMPORTED_MODULE_1__array__["b" /* slice */].call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range);
  };

  return Object(__WEBPACK_IMPORTED_MODULE_2__linear__["b" /* linearish */])(scale);
}


/***/ }),
/* 335 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = threshold;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(29);



function threshold() {
  var domain = [0.5],
      range = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range[Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["bisect"])(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = __WEBPACK_IMPORTED_MODULE_1__array__["b" /* slice */].call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = __WEBPACK_IMPORTED_MODULE_1__array__["b" /* slice */].call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range);
  };

  return scale;
}


/***/ }),
/* 336 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export milliseconds */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);


var millisecond = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

/* harmony default export */ __webpack_exports__["a"] = (millisecond);
var milliseconds = millisecond.range;


/***/ }),
/* 337 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export seconds */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(22);



var second = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setTime(Math.floor(date / __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationSecond */]) * __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationSecond */]);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationSecond */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationSecond */];
}, function(date) {
  return date.getUTCSeconds();
});

/* harmony default export */ __webpack_exports__["a"] = (second);
var seconds = second.range;


/***/ }),
/* 338 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export minutes */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(22);



var minute = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setTime(Math.floor(date / __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */]) * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */]);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */];
}, function(date) {
  return date.getMinutes();
});

/* harmony default export */ __webpack_exports__["a"] = (minute);
var minutes = minute.range;


/***/ }),
/* 339 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export hours */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(22);



var hour = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  var offset = date.getTimezoneOffset() * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */] % __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */];
  if (offset < 0) offset += __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */];
  date.setTime(Math.floor((+date - offset) / __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */]) * __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */] + offset);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */];
}, function(date) {
  return date.getHours();
});

/* harmony default export */ __webpack_exports__["a"] = (hour);
var hours = hour.range;


/***/ }),
/* 340 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export days */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(22);



var day = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */]) / __WEBPACK_IMPORTED_MODULE_1__duration__["a" /* durationDay */];
}, function(date) {
  return date.getDate() - 1;
});

/* harmony default export */ __webpack_exports__["a"] = (day);
var days = day.range;


/***/ }),
/* 341 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return sunday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return monday; });
/* unused harmony export tuesday */
/* unused harmony export wednesday */
/* unused harmony export thursday */
/* unused harmony export friday */
/* unused harmony export saturday */
/* unused harmony export sundays */
/* unused harmony export mondays */
/* unused harmony export tuesdays */
/* unused harmony export wednesdays */
/* unused harmony export thursdays */
/* unused harmony export fridays */
/* unused harmony export saturdays */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(22);



function weekday(i) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */]) / __WEBPACK_IMPORTED_MODULE_1__duration__["e" /* durationWeek */];
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;


/***/ }),
/* 342 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export months */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);


var month = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

/* harmony default export */ __webpack_exports__["a"] = (month);
var months = month.range;


/***/ }),
/* 343 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export years */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);


var year = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["a"] = (year);
var years = year.range;


/***/ }),
/* 344 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export utcMinutes */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(22);



var utcMinute = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */];
}, function(date) {
  return date.getUTCMinutes();
});

/* harmony default export */ __webpack_exports__["a"] = (utcMinute);
var utcMinutes = utcMinute.range;


/***/ }),
/* 345 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export utcHours */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(22);



var utcHour = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */];
}, function(date) {
  return date.getUTCHours();
});

/* harmony default export */ __webpack_exports__["a"] = (utcHour);
var utcHours = utcHour.range;


/***/ }),
/* 346 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export utcDays */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(22);



var utcDay = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["a" /* durationDay */];
}, function(date) {
  return date.getUTCDate() - 1;
});

/* harmony default export */ __webpack_exports__["a"] = (utcDay);
var utcDays = utcDay.range;


/***/ }),
/* 347 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcSunday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return utcMonday; });
/* unused harmony export utcTuesday */
/* unused harmony export utcWednesday */
/* unused harmony export utcThursday */
/* unused harmony export utcFriday */
/* unused harmony export utcSaturday */
/* unused harmony export utcSundays */
/* unused harmony export utcMondays */
/* unused harmony export utcTuesdays */
/* unused harmony export utcWednesdays */
/* unused harmony export utcThursdays */
/* unused harmony export utcFridays */
/* unused harmony export utcSaturdays */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(22);



function utcWeekday(i) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["e" /* durationWeek */];
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;


/***/ }),
/* 348 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export utcMonths */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);


var utcMonth = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

/* harmony default export */ __webpack_exports__["a"] = (utcMonth);
var utcMonths = utcMonth.range;


/***/ }),
/* 349 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export utcYears */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(13);


var utcYear = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["a"] = (utcYear);
var utcYears = utcYear.range;


/***/ }),
/* 350 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isoFormat__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__defaultLocale__ = __webpack_require__(109);



function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : Object(__WEBPACK_IMPORTED_MODULE_1__defaultLocale__["c" /* utcParse */])(__WEBPACK_IMPORTED_MODULE_0__isoFormat__["a" /* isoSpecifier */]);

/* unused harmony default export */ var _unused_webpack_default_export = (parseIso);


/***/ }),
/* 351 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__time__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_time_format__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_time__ = __webpack_require__(108);




/* harmony default export */ __webpack_exports__["a"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_0__time__["a" /* calendar */])(__WEBPACK_IMPORTED_MODULE_2_d3_time__["t" /* utcYear */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["p" /* utcMonth */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["s" /* utcWeek */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["k" /* utcDay */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["l" /* utcHour */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["n" /* utcMinute */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["q" /* utcSecond */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["m" /* utcMillisecond */], __WEBPACK_IMPORTED_MODULE_1_d3_time_format__["b" /* utcFormat */]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
});


/***/ }),
/* 352 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__colors__ = __webpack_require__(54);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));


/***/ }),
/* 353 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__colors__ = __webpack_require__(54);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6"));


/***/ }),
/* 354 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__colors__ = __webpack_require__(54);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9"));


/***/ }),
/* 355 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__colors__ = __webpack_require__(54);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5"));


/***/ }),
/* 356 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(20);



/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["b" /* interpolateCubehelixLong */])(Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["cubehelix"])(300, 0.5, 0.0), Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["cubehelix"])(-240, 0.5, 1.0)));


/***/ }),
/* 357 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return warm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cool; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(20);



var warm = Object(__WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["b" /* interpolateCubehelixLong */])(Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["cubehelix"])(-100, 0.75, 0.35), Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["cubehelix"])(80, 1.50, 0.8));

var cool = Object(__WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["b" /* interpolateCubehelixLong */])(Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["cubehelix"])(260, 0.75, 0.35), Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["cubehelix"])(80, 1.50, 0.8));

var rainbow = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["cubehelix"])();

/* harmony default export */ __webpack_exports__["b"] = (function(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
});


/***/ }),
/* 358 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return magma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return inferno; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return plasma; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__colors__ = __webpack_require__(54);


function ramp(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

/* harmony default export */ __webpack_exports__["a"] = (ramp(Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")));

var magma = ramp(Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));


/***/ }),
/* 359 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = sequential;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__linear__ = __webpack_require__(52);


function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return Object(__WEBPACK_IMPORTED_MODULE_0__linear__["b" /* linearish */])(scale);
}


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// The MIT License (MIT)
//
// Copyright (c) 2014 Jonas Finnemann Jensen
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var uuid = __webpack_require__(364);

/**
 * Returns the given uuid as a 22 character slug. This can be a regular v4
 * slug or a "nice" slug.
 */
exports.encode = function(uuid_) {
  var bytes   = uuid.parse(uuid_);
  var base64  = (new Buffer(bytes)).toString('base64');
  var slug = base64
              .replace(/\+/g, '-')  // Replace + with - (see RFC 4648, sec. 5)
              .replace(/\//g, '_')  // Replace / with _ (see RFC 4648, sec. 5)
              .substring(0, 22);    // Drop '==' padding
  return slug;
};

/**
 * Returns the uuid represented by the given v4 or "nice" slug
 */
exports.decode = function(slug) {
  var base64 = slug
                  .replace(/-/g, '+')
                  .replace(/_/g, '/')
                  + '==';
  return uuid.unparse(new Buffer(base64, 'base64'));
};

/**
 * Returns a randomly generated uuid v4 compliant slug
 */
exports.v4 = function() {
  var bytes   = uuid.v4(null, new Buffer(16));
  var base64  = bytes.toString('base64');
  var slug = base64
              .replace(/\+/g, '-')  // Replace + with - (see RFC 4648, sec. 5)
              .replace(/\//g, '_')  // Replace / with _ (see RFC 4648, sec. 5)
              .substring(0, 22);    // Drop '==' padding
  return slug;
};

/** 
 * Returns a randomly generated uuid v4 compliant slug which conforms to a set
 * of "nice" properties, at the cost of some entropy. Currently this means one
 * extra fixed bit (the first bit of the uuid is set to 0) which guarantees the
 * slug will begin with [A-Za-f]. For example such slugs don't require special
 * handling when used as command line parameters (whereas non-nice slugs may
 * start with `-` which can confuse command line tools).
 *
 * Potentially other "nice" properties may be added in future to further
 * restrict the range of potential uuids that may be generated.
 */
exports.nice = function() {
  var bytes   = uuid.v4(null, new Buffer(16));
  bytes[0] = bytes[0] & 0x7f;  // unset first bit to ensure [A-Za-f] first char
  var base64  = bytes.toString('base64');
  var slug = base64
              .replace(/\+/g, '-')  // Replace + with - (see RFC 4648, sec. 5)
              .replace(/\//g, '_')  // Replace / with _ (see RFC 4648, sec. 5)
              .substring(0, 22);    // Drop '==' padding
  return slug;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(184).Buffer))

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 362 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 363 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required
var _rng = __webpack_require__(365);

// Maps for number <-> hex string conversion
var _byteToHex = [];
var _hexToByte = {};
for (var i = 0; i < 256; i++) {
  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
  _hexToByte[_byteToHex[i]] = i;
}

// **`parse()` - Parse a UUID into it's component bytes**
function parse(s, buf, offset) {
  var i = (buf && offset) || 0, ii = 0;

  buf = buf || [];
  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
    if (ii < 16) { // Don't overflow!
      buf[i + ii++] = _hexToByte[oct];
    }
  });

  // Zero out remaining bytes if string was short
  while (ii < 16) {
    buf[i + ii++] = 0;
  }

  return buf;
}

// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
function unparse(buf, offset) {
  var i = offset || 0, bth = _byteToHex;
  return  bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = _rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; n++) {
    b[i + n] = node[n];
  }

  return buf ? buf : unparse(b);
}

// **`v4()` - Generate random UUID**

// See https://github.com/broofa/node-uuid for API details
function v4(options, buf, offset) {
  // Deprecated - 'format' argument, as supported in v1.2
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || _rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || unparse(rnds);
}

// Export public API
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
uuid.parse = parse;
uuid.unparse = unparse;

module.exports = uuid;


/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
  // Moderately fast, high quality
  var _rnds8 = new Uint8Array(16);
  rng = function whatwgRNG() {
    crypto.getRandomValues(_rnds8);
    return _rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var  _rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  };
}

module.exports = rng;


/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)))

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(185).default;
module.exports.utils = __webpack_require__(56);
module.exports.Responsive = __webpack_require__(373).default;
module.exports.Responsive.utils = __webpack_require__(188);
module.exports.WidthProvider = __webpack_require__(374).default;


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDraggable = __webpack_require__(368);

var _reactResizable = __webpack_require__(369);

var _utils = __webpack_require__(56);

var _classnames = __webpack_require__(186);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An individual item within a ReactGridLayout.
 */
var GridItem = function (_React$Component) {
  _inherits(GridItem, _React$Component);

  function GridItem() {
    var _temp, _this, _ret;

    _classCallCheck(this, GridItem);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      resizing: null,
      dragging: null,
      className: ""
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  // Helper for generating column width
  GridItem.prototype.calcColWidth = function calcColWidth() {
    var _props = this.props,
        margin = _props.margin,
        containerPadding = _props.containerPadding,
        containerWidth = _props.containerWidth,
        cols = _props.cols;

    return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;
  };

  /**
   * Return position on the page given an x, y, w, h.
   * left, top, width, height are all in pixels.
   * @param  {Number}  x             X coordinate in grid units.
   * @param  {Number}  y             Y coordinate in grid units.
   * @param  {Number}  w             W coordinate in grid units.
   * @param  {Number}  h             H coordinate in grid units.
   * @return {Object}                Object containing coords.
   */


  GridItem.prototype.calcPosition = function calcPosition(x, y, w, h, state) {
    var _props2 = this.props,
        margin = _props2.margin,
        containerPadding = _props2.containerPadding,
        rowHeight = _props2.rowHeight;

    var colWidth = this.calcColWidth();

    var out = {
      left: Math.round((colWidth + margin[0]) * x + containerPadding[0]),
      top: Math.round((rowHeight + margin[1]) * y + containerPadding[1]),
      // 0 * Infinity === NaN, which causes problems with resize constraints;
      // Fix this if it occurs.
      // Note we do it here rather than later because Math.round(Infinity) causes deopt
      width: w === Infinity ? w : Math.round(colWidth * w + Math.max(0, w - 1) * margin[0]),
      height: h === Infinity ? h : Math.round(rowHeight * h + Math.max(0, h - 1) * margin[1])
    };

    if (state && state.resizing) {
      out.width = Math.round(state.resizing.width);
      out.height = Math.round(state.resizing.height);
    }

    if (state && state.dragging) {
      out.top = Math.round(state.dragging.top);
      out.left = Math.round(state.dragging.left);
    }

    return out;
  };

  /**
   * Translate x and y coordinates from pixels to grid units.
   * @param  {Number} top  Top position (relative to parent) in pixels.
   * @param  {Number} left Left position (relative to parent) in pixels.
   * @return {Object} x and y in grid units.
   */


  GridItem.prototype.calcXY = function calcXY(top, left) {
    var _props3 = this.props,
        margin = _props3.margin,
        cols = _props3.cols,
        rowHeight = _props3.rowHeight,
        w = _props3.w,
        h = _props3.h,
        maxRows = _props3.maxRows;

    var colWidth = this.calcColWidth();

    // left = colWidth * x + margin * (x + 1)
    // l = cx + m(x+1)
    // l = cx + mx + m
    // l - m = cx + mx
    // l - m = x(c + m)
    // (l - m) / (c + m) = x
    // x = (left - margin) / (coldWidth + margin)
    var x = Math.round((left - margin[0]) / (colWidth + margin[0]));
    var y = Math.round((top - margin[1]) / (rowHeight + margin[1]));

    // Capping
    x = Math.max(Math.min(x, cols - w), 0);
    y = Math.max(Math.min(y, maxRows - h), 0);

    return { x: x, y: y };
  };

  /**
   * Given a height and width in pixel values, calculate grid units.
   * @param  {Number} height Height in pixels.
   * @param  {Number} width  Width in pixels.
   * @return {Object} w, h as grid units.
   */


  GridItem.prototype.calcWH = function calcWH(_ref) {
    var height = _ref.height,
        width = _ref.width;
    var _props4 = this.props,
        margin = _props4.margin,
        maxRows = _props4.maxRows,
        cols = _props4.cols,
        rowHeight = _props4.rowHeight,
        x = _props4.x,
        y = _props4.y;

    var colWidth = this.calcColWidth();

    // width = colWidth * w - (margin * (w - 1))
    // ...
    // w = (width + margin) / (colWidth + margin)
    var w = Math.round((width + margin[0]) / (colWidth + margin[0]));
    var h = Math.round((height + margin[1]) / (rowHeight + margin[1]));

    // Capping
    w = Math.max(Math.min(w, cols - x), 0);
    h = Math.max(Math.min(h, maxRows - y), 0);
    return { w: w, h: h };
  };

  /**
   * This is where we set the grid item's absolute placement. It gets a little tricky because we want to do it
   * well when server rendering, and the only way to do that properly is to use percentage width/left because
   * we don't know exactly what the browser viewport is.
   * Unfortunately, CSS Transforms, which are great for performance, break in this instance because a percentage
   * left is relative to the item itself, not its container! So we cannot use them on the server rendering pass.
   *
   * @param  {Object} pos Position object with width, height, left, top.
   * @return {Object}     Style object.
   */


  GridItem.prototype.createStyle = function createStyle(pos) {
    var _props5 = this.props,
        usePercentages = _props5.usePercentages,
        containerWidth = _props5.containerWidth,
        useCSSTransforms = _props5.useCSSTransforms;


    var style = void 0;
    // CSS Transforms support (default)
    if (useCSSTransforms) {
      style = (0, _utils.setTransform)(pos);
    } else {
      // top,left (slow)
      style = (0, _utils.setTopLeft)(pos);

      // This is used for server rendering.
      if (usePercentages) {
        style.left = (0, _utils.perc)(pos.left / containerWidth);
        style.width = (0, _utils.perc)(pos.width / containerWidth);
      }
    }

    return style;
  };

  /**
   * Mix a Draggable instance into a child.
   * @param  {Element} child    Child element.
   * @return {Element}          Child wrapped in Draggable.
   */


  GridItem.prototype.mixinDraggable = function mixinDraggable(child) {
    return _react2.default.createElement(
      _reactDraggable.DraggableCore,
      {
        onStart: this.onDragHandler("onDragStart"),
        onDrag: this.onDragHandler("onDrag"),
        onStop: this.onDragHandler("onDragStop"),
        handle: this.props.handle,
        cancel: ".react-resizable-handle" + (this.props.cancel ? "," + this.props.cancel : "")
      },
      child
    );
  };

  /**
   * Mix a Resizable instance into a child.
   * @param  {Element} child    Child element.
   * @param  {Object} position  Position object (pixel values)
   * @return {Element}          Child wrapped in Resizable.
   */


  GridItem.prototype.mixinResizable = function mixinResizable(child, position) {
    var _props6 = this.props,
        cols = _props6.cols,
        x = _props6.x,
        minW = _props6.minW,
        minH = _props6.minH,
        maxW = _props6.maxW,
        maxH = _props6.maxH;

    // This is the max possible width - doesn't go to infinity because of the width of the window

    var maxWidth = this.calcPosition(0, 0, cols - x, 0).width;

    // Calculate min/max constraints using our min & maxes
    var mins = this.calcPosition(0, 0, minW, minH);
    var maxes = this.calcPosition(0, 0, maxW, maxH);
    var minConstraints = [mins.width, mins.height];
    var maxConstraints = [Math.min(maxes.width, maxWidth), Math.min(maxes.height, Infinity)];
    return _react2.default.createElement(
      _reactResizable.Resizable,
      {
        width: position.width,
        height: position.height,
        minConstraints: minConstraints,
        maxConstraints: maxConstraints,
        onResizeStop: this.onResizeHandler("onResizeStop"),
        onResizeStart: this.onResizeHandler("onResizeStart"),
        onResize: this.onResizeHandler("onResize")
      },
      child
    );
  };

  /**
   * Wrapper around drag events to provide more useful data.
   * All drag events call the function with the given handler name,
   * with the signature (index, x, y).
   *
   * @param  {String} handlerName Handler name to wrap.
   * @return {Function}           Handler function.
   */


  GridItem.prototype.onDragHandler = function onDragHandler(handlerName) {
    var _this2 = this;

    return function (e, _ref2) {
      var node = _ref2.node,
          deltaX = _ref2.deltaX,
          deltaY = _ref2.deltaY;

      var handler = _this2.props[handlerName];
      if (!handler) return;

      var newPosition = { top: 0, left: 0 };

      // Get new XY
      switch (handlerName) {
        case "onDragStart":
          {
            // TODO: this wont work on nested parents
            var offsetParent = node.offsetParent;

            if (!offsetParent) return;
            var parentRect = offsetParent.getBoundingClientRect();
            var clientRect = node.getBoundingClientRect();
            newPosition.left = clientRect.left - parentRect.left + offsetParent.scrollLeft;
            newPosition.top = clientRect.top - parentRect.top + offsetParent.scrollTop;
            _this2.setState({ dragging: newPosition });
            break;
          }
        case "onDrag":
          if (!_this2.state.dragging) throw new Error("onDrag called before onDragStart.");
          newPosition.left = _this2.state.dragging.left + deltaX;
          newPosition.top = _this2.state.dragging.top + deltaY;
          _this2.setState({ dragging: newPosition });
          break;
        case "onDragStop":
          if (!_this2.state.dragging) throw new Error("onDragEnd called before onDragStart.");
          newPosition.left = _this2.state.dragging.left;
          newPosition.top = _this2.state.dragging.top;
          _this2.setState({ dragging: null });
          break;
        default:
          throw new Error("onDragHandler called with unrecognized handlerName: " + handlerName);
      }

      var _calcXY = _this2.calcXY(newPosition.top, newPosition.left),
          x = _calcXY.x,
          y = _calcXY.y;

      return handler.call(_this2, _this2.props.i, x, y, { e: e, node: node, newPosition: newPosition });
    };
  };

  /**
   * Wrapper around drag events to provide more useful data.
   * All drag events call the function with the given handler name,
   * with the signature (index, x, y).
   *
   * @param  {String} handlerName Handler name to wrap.
   * @return {Function}           Handler function.
   */


  GridItem.prototype.onResizeHandler = function onResizeHandler(handlerName) {
    var _this3 = this;

    return function (e, _ref3) {
      var node = _ref3.node,
          size = _ref3.size;

      var handler = _this3.props[handlerName];
      if (!handler) return;
      var _props7 = _this3.props,
          cols = _props7.cols,
          x = _props7.x,
          i = _props7.i,
          maxW = _props7.maxW,
          minW = _props7.minW,
          maxH = _props7.maxH,
          minH = _props7.minH;

      // Get new XY

      var _calcWH = _this3.calcWH(size),
          w = _calcWH.w,
          h = _calcWH.h;

      // Cap w at numCols


      w = Math.min(w, cols - x);
      // Ensure w is at least 1
      w = Math.max(w, 1);

      // Min/max capping
      w = Math.max(Math.min(w, maxW), minW);
      h = Math.max(Math.min(h, maxH), minH);

      _this3.setState({ resizing: handlerName === "onResizeStop" ? null : size });

      handler.call(_this3, i, w, h, { e: e, node: node, size: size });
    };
  };

  GridItem.prototype.render = function render() {
    var _props8 = this.props,
        x = _props8.x,
        y = _props8.y,
        w = _props8.w,
        h = _props8.h,
        isDraggable = _props8.isDraggable,
        isResizable = _props8.isResizable,
        useCSSTransforms = _props8.useCSSTransforms;


    var pos = this.calcPosition(x, y, w, h, this.state);
    var child = _react2.default.Children.only(this.props.children);

    // Create the child element. We clone the existing element but modify its className and style.
    var newChild = _react2.default.cloneElement(child, {
      className: (0, _classnames2.default)("react-grid-item", child.props.className, this.props.className, {
        static: this.props.static,
        resizing: Boolean(this.state.resizing),
        "react-draggable": isDraggable,
        "react-draggable-dragging": Boolean(this.state.dragging),
        cssTransforms: useCSSTransforms
      }),
      // We can set the width and height on the child, but unfortunately we can't set the position.
      style: _extends({}, this.props.style, child.props.style, this.createStyle(pos))
    });

    // Resizable support. This is usually on but the user can toggle it off.
    if (isResizable) newChild = this.mixinResizable(newChild, pos);

    // Draggable support. This is always on, except for with placeholders.
    if (isDraggable) newChild = this.mixinDraggable(newChild);

    return newChild;
  };

  return GridItem;
}(_react2.default.Component);

GridItem.propTypes = {
  // Children must be only a single element
  children: _propTypes2.default.element,

  // General grid attributes
  cols: _propTypes2.default.number.isRequired,
  containerWidth: _propTypes2.default.number.isRequired,
  rowHeight: _propTypes2.default.number.isRequired,
  margin: _propTypes2.default.array.isRequired,
  maxRows: _propTypes2.default.number.isRequired,
  containerPadding: _propTypes2.default.array.isRequired,

  // These are all in grid units
  x: _propTypes2.default.number.isRequired,
  y: _propTypes2.default.number.isRequired,
  w: _propTypes2.default.number.isRequired,
  h: _propTypes2.default.number.isRequired,

  // All optional
  minW: function minW(props, propName) {
    var value = props[propName];
    if (typeof value !== "number") return new Error("minWidth not Number");
    if (value > props.w || value > props.maxW) return new Error("minWidth larger than item width/maxWidth");
  },

  maxW: function maxW(props, propName) {
    var value = props[propName];
    if (typeof value !== "number") return new Error("maxWidth not Number");
    if (value < props.w || value < props.minW) return new Error("maxWidth smaller than item width/minWidth");
  },

  minH: function minH(props, propName) {
    var value = props[propName];
    if (typeof value !== "number") return new Error("minHeight not Number");
    if (value > props.h || value > props.maxH) return new Error("minHeight larger than item height/maxHeight");
  },

  maxH: function maxH(props, propName) {
    var value = props[propName];
    if (typeof value !== "number") return new Error("maxHeight not Number");
    if (value < props.h || value < props.minH) return new Error("maxHeight smaller than item height/minHeight");
  },

  // ID is nice to have for callbacks
  i: _propTypes2.default.string.isRequired,

  // Functions
  onDragStop: _propTypes2.default.func,
  onDragStart: _propTypes2.default.func,
  onDrag: _propTypes2.default.func,
  onResizeStop: _propTypes2.default.func,
  onResizeStart: _propTypes2.default.func,
  onResize: _propTypes2.default.func,

  // Flags
  isDraggable: _propTypes2.default.bool.isRequired,
  isResizable: _propTypes2.default.bool.isRequired,
  static: _propTypes2.default.bool,

  // Use CSS transforms instead of top/left
  useCSSTransforms: _propTypes2.default.bool.isRequired,

  // Others
  className: _propTypes2.default.string,
  // Selector for draggable handle
  handle: _propTypes2.default.string,
  // Selector for draggable cancel (see react-draggable)
  cancel: _propTypes2.default.string
};
GridItem.defaultProps = {
  className: "",
  cancel: "",
  handle: "",
  minH: 1,
  minW: 1,
  maxH: Infinity,
  maxW: Infinity
};
exports.default = GridItem;

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(8), __webpack_require__(0));
	else if(typeof define === 'function' && define.amd)
		define(["react-dom", "react"], factory);
	else if(typeof exports === 'object')
		exports["ReactDraggable"] = factory(require("react-dom"), require("react"));
	else
		root["ReactDraggable"] = factory(root["ReactDOM"], root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_6__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 12);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findInArray = findInArray;
exports.isFunction = isFunction;
exports.isNum = isNum;
exports.int = int;
exports.dontSetMe = dontSetMe;

// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
function findInArray(array /*: Array<any> | TouchList*/, callback /*: Function*/) /*: any*/ {
  for (var i = 0, length = array.length; i < length; i++) {
    if (callback.apply(callback, [array[i], i, array])) return array[i];
  }
}

function isFunction(func /*: any*/) /*: boolean*/ {
  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
}

function isNum(num /*: any*/) /*: boolean*/ {
  return typeof num === 'number' && !isNaN(num);
}

function int(a /*: string*/) /*: number*/ {
  return parseInt(a, 10);
}

function dontSetMe(props /*: Object*/, propName /*: string*/, componentName /*: string*/) {
  if (props[propName]) {
    return new Error('Invalid prop ' + propName + ' passed to ' + componentName + ' - do not set this, set it on the child.');
  }
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (Object({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.matchesSelector = matchesSelector;
exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
exports.addEvent = addEvent;
exports.removeEvent = removeEvent;
exports.outerHeight = outerHeight;
exports.outerWidth = outerWidth;
exports.innerHeight = innerHeight;
exports.innerWidth = innerWidth;
exports.offsetXYFromParent = offsetXYFromParent;
exports.createCSSTransform = createCSSTransform;
exports.createSVGTransform = createSVGTransform;
exports.getTouch = getTouch;
exports.getTouchIdentifier = getTouchIdentifier;
exports.addUserSelectStyles = addUserSelectStyles;
exports.removeUserSelectStyles = removeUserSelectStyles;
exports.styleHacks = styleHacks;
exports.addClassName = addClassName;
exports.removeClassName = removeClassName;

var _shims = __webpack_require__(0);

var _getPrefix = __webpack_require__(19);

var _getPrefix2 = _interopRequireDefault(_getPrefix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*:: import type {ControlPosition, MouseTouchEvent} from './types';*/


var matchesSelectorFunc = '';
function matchesSelector(el /*: Node*/, selector /*: string*/) /*: boolean*/ {
  if (!matchesSelectorFunc) {
    matchesSelectorFunc = (0, _shims.findInArray)(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {
      // $FlowIgnore: Doesn't think elements are indexable
      return (0, _shims.isFunction)(el[method]);
    });
  }

  // Might not be found entirely (not an Element?) - in that case, bail
  // $FlowIgnore: Doesn't think elements are indexable
  if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;

  // $FlowIgnore: Doesn't think elements are indexable
  return el[matchesSelectorFunc](selector);
}

// Works up the tree to the draggable itself attempting to match selector.
function matchesSelectorAndParentsTo(el /*: Node*/, selector /*: string*/, baseNode /*: Node*/) /*: boolean*/ {
  var node = el;
  do {
    if (matchesSelector(node, selector)) return true;
    if (node === baseNode) return false;
    node = node.parentNode;
  } while (node);

  return false;
}

function addEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/ {
  if (!el) {
    return;
  }
  if (el.attachEvent) {
    el.attachEvent('on' + event, handler);
  } else if (el.addEventListener) {
    el.addEventListener(event, handler, true);
  } else {
    // $FlowIgnore: Doesn't think elements are indexable
    el['on' + event] = handler;
  }
}

function removeEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/ {
  if (!el) {
    return;
  }
  if (el.detachEvent) {
    el.detachEvent('on' + event, handler);
  } else if (el.removeEventListener) {
    el.removeEventListener(event, handler, true);
  } else {
    // $FlowIgnore: Doesn't think elements are indexable
    el['on' + event] = null;
  }
}

function outerHeight(node /*: HTMLElement*/) /*: number*/ {
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetTop which is including margin. See getBoundPosition
  var height = node.clientHeight;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  height += (0, _shims.int)(computedStyle.borderTopWidth);
  height += (0, _shims.int)(computedStyle.borderBottomWidth);
  return height;
}

function outerWidth(node /*: HTMLElement*/) /*: number*/ {
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetLeft which is including margin. See getBoundPosition
  var width = node.clientWidth;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  width += (0, _shims.int)(computedStyle.borderLeftWidth);
  width += (0, _shims.int)(computedStyle.borderRightWidth);
  return width;
}
function innerHeight(node /*: HTMLElement*/) /*: number*/ {
  var height = node.clientHeight;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  height -= (0, _shims.int)(computedStyle.paddingTop);
  height -= (0, _shims.int)(computedStyle.paddingBottom);
  return height;
}

function innerWidth(node /*: HTMLElement*/) /*: number*/ {
  var width = node.clientWidth;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  width -= (0, _shims.int)(computedStyle.paddingLeft);
  width -= (0, _shims.int)(computedStyle.paddingRight);
  return width;
}

// Get from offsetParent
function offsetXYFromParent(evt /*: {clientX: number, clientY: number}*/, offsetParent /*: HTMLElement*/) /*: ControlPosition*/ {
  var isBody = offsetParent === offsetParent.ownerDocument.body;
  var offsetParentRect = isBody ? { left: 0, top: 0 } : offsetParent.getBoundingClientRect();

  var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;
  var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;

  return { x: x, y: y };
}

function createCSSTransform(_ref) /*: Object*/ {
  var x = _ref.x,
      y = _ref.y;

  // Replace unitless items with px
  return _defineProperty({}, (0, _getPrefix.browserPrefixToKey)('transform', _getPrefix2.default), 'translate(' + x + 'px,' + y + 'px)');
}

function createSVGTransform(_ref3) /*: string*/ {
  var x = _ref3.x,
      y = _ref3.y;

  return 'translate(' + x + ',' + y + ')';
}

function getTouch(e /*: MouseTouchEvent*/, identifier /*: number*/) /*: ?{clientX: number, clientY: number}*/ {
  return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, function (t) {
    return identifier === t.identifier;
  }) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, function (t) {
    return identifier === t.identifier;
  });
}

function getTouchIdentifier(e /*: MouseTouchEvent*/) /*: ?number*/ {
  if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
  if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
}

// User-select Hacks:
//
// Useful for preventing blue highlights all over everything when dragging.

// Note we're passing `document` b/c we could be iframed
function addUserSelectStyles(doc /*: ?Document*/) {
  if (!doc) return;
  var styleEl = doc.getElementById('react-draggable-style-el');
  if (!styleEl) {
    styleEl = doc.createElement('style');
    styleEl.type = 'text/css';
    styleEl.id = 'react-draggable-style-el';
    styleEl.innerHTML = '.react-draggable-transparent-selection *::-moz-selection {background: transparent;}\n';
    styleEl.innerHTML += '.react-draggable-transparent-selection *::selection {background: transparent;}\n';
    doc.getElementsByTagName('head')[0].appendChild(styleEl);
  }
  if (doc.body) addClassName(doc.body, 'react-draggable-transparent-selection');
}

function removeUserSelectStyles(doc /*: ?Document*/) {
  try {
    if (doc && doc.body) removeClassName(doc.body, 'react-draggable-transparent-selection');
    window.getSelection().removeAllRanges(); // remove selection caused by scroll
  } catch (e) {
    // probably IE
  }
}

function styleHacks() /*: Object*/ {
  var childStyle /*: Object*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // Workaround IE pointer events; see #51
  // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278
  return _extends({
    touchAction: 'none'
  }, childStyle);
}

function addClassName(el /*: HTMLElement*/, className /*: string*/) {
  if (el.classList) {
    el.classList.add(className);
  } else {
    if (!el.className.match(new RegExp('(?:^|\\s)' + className + '(?!\\S)'))) {
      el.className += ' ' + className;
    }
  }
}

function removeClassName(el /*: HTMLElement*/, className /*: string*/) {
  if (el.classList) {
    el.classList.remove(className);
  } else {
    el.className = el.className.replace(new RegExp('(?:^|\\s)' + className + '(?!\\S)', 'g'), '');
  }
}

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (Object({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(14)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(17)();
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(1);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (Object({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBoundPosition = getBoundPosition;
exports.snapToGrid = snapToGrid;
exports.canDragX = canDragX;
exports.canDragY = canDragY;
exports.getControlPosition = getControlPosition;
exports.createCoreData = createCoreData;
exports.createDraggableData = createDraggableData;

var _shims = __webpack_require__(0);

var _reactDom = __webpack_require__(4);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _domFns = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*:: import type Draggable from '../Draggable';*/
/*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/
/*:: import type DraggableCore from '../DraggableCore';*/
function getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/ {
  // If no bounds, short-circuit and move on
  if (!draggable.props.bounds) return [x, y];

  // Clone new bounds
  var bounds = draggable.props.bounds;

  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);
  var node = findDOMNode(draggable);

  if (typeof bounds === 'string') {
    var ownerDocument = node.ownerDocument;

    var ownerWindow = ownerDocument.defaultView;
    var boundNode = void 0;
    if (bounds === 'parent') {
      boundNode = node.parentNode;
    } else {
      boundNode = ownerDocument.querySelector(bounds);
    }
    if (!(boundNode instanceof HTMLElement)) {
      throw new Error('Bounds selector "' + bounds + '" could not find an element.');
    }
    var nodeStyle = ownerWindow.getComputedStyle(node);
    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode);
    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
    bounds = {
      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),
      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),
      right: (0, _domFns.innerWidth)(boundNode) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),
      bottom: (0, _domFns.innerHeight)(boundNode) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)
    };
  }

  // Keep x and y below right and bottom limits...
  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);

  // But above left and top limits.
  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);

  return [x, y];
}

function snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/ {
  var x = Math.round(pendingX / grid[0]) * grid[0];
  var y = Math.round(pendingY / grid[1]) * grid[1];
  return [x, y];
}

function canDragX(draggable /*: Draggable*/) /*: boolean*/ {
  return draggable.props.axis === 'both' || draggable.props.axis === 'x';
}

function canDragY(draggable /*: Draggable*/) /*: boolean*/ {
  return draggable.props.axis === 'both' || draggable.props.axis === 'y';
}

// Get {x, y} positions from event.
function getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/ {
  var touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch
  var node = findDOMNode(draggableCore);
  // User can provide an offsetParent if desired.
  var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent);
}

// Create an data object exposed by <DraggableCore>'s events
function createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/ {
  var state = draggable.state;
  var isStart = !(0, _shims.isNum)(state.lastX);
  var node = findDOMNode(draggable);

  if (isStart) {
    // If this is our first move, use the x and y as last coords.
    return {
      node: node,
      deltaX: 0, deltaY: 0,
      lastX: x, lastY: y,
      x: x, y: y
    };
  } else {
    // Otherwise calculate proper values.
    return {
      node: node,
      deltaX: x - state.lastX, deltaY: y - state.lastY,
      lastX: state.lastX, lastY: state.lastY,
      x: x, y: y
    };
  }
}

// Create an data exposed by <Draggable>'s events
function createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/ {
  return {
    node: coreData.node,
    x: draggable.state.x + coreData.deltaX,
    y: draggable.state.y + coreData.deltaY,
    deltaX: coreData.deltaX,
    deltaY: coreData.deltaY,
    lastX: draggable.state.x,
    lastY: draggable.state.y
  };
}

// A lot faster than stringify/parse
function cloneBounds(bounds /*: Bounds*/) /*: Bounds*/ {
  return {
    left: bounds.left,
    top: bounds.top,
    right: bounds.right,
    bottom: bounds.bottom
  };
}

function findDOMNode(draggable /*: Draggable | DraggableCore*/) /*: HTMLElement*/ {
  var node = _reactDom2.default.findDOMNode(draggable);
  if (!node) {
    throw new Error('<DraggableCore>: Unmounted during event!');
  }
  // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME
  return node;
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(7);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__(4);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _domFns = __webpack_require__(5);

var _positionFns = __webpack_require__(9);

var _shims = __webpack_require__(0);

var _log = __webpack_require__(11);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/


// Simple abstraction for dragging events names.
/*:: import type {Element as ReactElement} from 'react';*/
var eventsFor = {
  touch: {
    start: 'touchstart',
    move: 'touchmove',
    stop: 'touchend'
  },
  mouse: {
    start: 'mousedown',
    move: 'mousemove',
    stop: 'mouseup'
  }
};

// Default to mouse events.
var dragEventFor = eventsFor.mouse;

/*:: type DraggableCoreState = {
  dragging: boolean,
  lastX: number,
  lastY: number,
  touchIdentifier: ?number
};*/
/*:: export type DraggableBounds = {
  left: number,
  right: number,
  top: number,
  bottom: number,
};*/
/*:: export type DraggableData = {
  node: HTMLElement,
  x: number, y: number,
  deltaX: number, deltaY: number,
  lastX: number, lastY: number,
};*/
/*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void;*/
/*:: export type ControlPosition = {x: number, y: number};*/


//
// Define <DraggableCore>.
//
// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can
// work well with libraries that require more control over the element.
//

/*:: export type DraggableCoreProps = {
  allowAnyClick: boolean,
  cancel: string,
  children: ReactElement<any>,
  disabled: boolean,
  enableUserSelectHack: boolean,
  offsetParent: HTMLElement,
  grid: [number, number],
  handle: string,
  onStart: DraggableEventHandler,
  onDrag: DraggableEventHandler,
  onStop: DraggableEventHandler,
  onMouseDown: (e: MouseEvent) => void,
};*/

var DraggableCore = function (_React$Component) {
  _inherits(DraggableCore, _React$Component);

  function DraggableCore() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, DraggableCore);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DraggableCore.__proto__ || Object.getPrototypeOf(DraggableCore)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      dragging: false,
      // Used while dragging to determine deltas.
      lastX: NaN, lastY: NaN,
      touchIdentifier: null
    }, _this.handleDragStart = function (e) {
      // Make it possible to attach event handlers on top of this one.
      _this.props.onMouseDown(e);

      // Only accept left-clicks.
      if (!_this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;

      // Get nodes. Be sure to grab relative document (could be iframed)
      var thisNode = _reactDom2.default.findDOMNode(_this);
      if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
        throw new Error('<DraggableCore> not mounted on DragStart!');
      }
      var ownerDocument = thisNode.ownerDocument;

      // Short circuit if handle or cancel prop was provided and selector doesn't match.

      if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.handle, thisNode) || _this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.cancel, thisNode)) {
        return;
      }

      // Set touch identifier in component state if this is a touch event. This allows us to
      // distinguish between individual touches on multitouch screens by identifying which
      // touchpoint was set to this element.
      var touchIdentifier = (0, _domFns.getTouchIdentifier)(e);
      _this.setState({ touchIdentifier: touchIdentifier });

      // Get the current drag point from the event. This is used as the offset.
      var position = (0, _positionFns.getControlPosition)(e, touchIdentifier, _this);
      if (position == null) return; // not possible but satisfies flow
      var x = position.x,
          y = position.y;

      // Create an event object with all the data parents need to make a decision here.

      var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);

      (0, _log2.default)('DraggableCore: handleDragStart: %j', coreEvent);

      // Call event handler. If it returns explicit false, cancel.
      (0, _log2.default)('calling', _this.props.onStart);
      var shouldUpdate = _this.props.onStart(e, coreEvent);
      if (shouldUpdate === false) return;

      // Add a style to the body to disable user-select. This prevents text from
      // being selected all over the page.
      if (_this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);

      // Initiate dragging. Set the current x and y as offsets
      // so we know how much we've moved during the drag. This allows us
      // to drag elements around even if they have been moved, without issue.
      _this.setState({
        dragging: true,

        lastX: x,
        lastY: y
      });

      // Add events to the document directly so we catch when the user's mouse/touch moves outside of
      // this element. We use different events depending on whether or not we have detected that this
      // is a touch-capable device.
      (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
      (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
    }, _this.handleDrag = function (e) {

      // Prevent scrolling on mobile devices, like ipad/iphone.
      if (e.type === 'touchmove') e.preventDefault();

      // Get the current drag point from the event. This is used as the offset.
      var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
      if (position == null) return;
      var x = position.x,
          y = position.y;

      // Snap to grid if prop has been provided

      if (Array.isArray(_this.props.grid)) {
        var _deltaX = x - _this.state.lastX,
            _deltaY = y - _this.state.lastY;

        var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, _deltaX, _deltaY);

        var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);

        _deltaX = _snapToGrid2[0];
        _deltaY = _snapToGrid2[1];

        if (!_deltaX && !_deltaY) return; // skip useless drag
        x = _this.state.lastX + _deltaX, y = _this.state.lastY + _deltaY;
      }

      var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);

      (0, _log2.default)('DraggableCore: handleDrag: %j', coreEvent);

      // Call event handler. If it returns explicit false, trigger end.
      var shouldUpdate = _this.props.onDrag(e, coreEvent);
      if (shouldUpdate === false) {
        try {
          // $FlowIgnore
          _this.handleDragStop(new MouseEvent('mouseup'));
        } catch (err) {
          // Old browsers
          var event = ((document.createEvent('MouseEvents') /*: any*/) /*: MouseTouchEvent*/);
          // I see why this insanity was deprecated
          // $FlowIgnore
          event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
          _this.handleDragStop(event);
        }
        return;
      }

      _this.setState({
        lastX: x,
        lastY: y
      });
    }, _this.handleDragStop = function (e) {
      if (!_this.state.dragging) return;

      var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
      if (position == null) return;
      var x = position.x,
          y = position.y;

      var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);

      var thisNode = _reactDom2.default.findDOMNode(_this);
      if (thisNode) {
        // Remove user-select hack
        if (_this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);
      }

      (0, _log2.default)('DraggableCore: handleDragStop: %j', coreEvent);

      // Reset the el.
      _this.setState({
        dragging: false,
        lastX: NaN,
        lastY: NaN
      });

      // Call event handler
      _this.props.onStop(e, coreEvent);

      if (thisNode) {
        // Remove event handlers
        (0, _log2.default)('DraggableCore: Removing handlers');
        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, _this.handleDrag);
        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, _this.handleDragStop);
      }
    }, _this.onMouseDown = function (e) {
      dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse

      return _this.handleDragStart(e);
    }, _this.onMouseUp = function (e) {
      dragEventFor = eventsFor.mouse;

      return _this.handleDragStop(e);
    }, _this.onTouchStart = function (e) {
      // We're on a touch device now, so change the event handlers
      dragEventFor = eventsFor.touch;

      return _this.handleDragStart(e);
    }, _this.onTouchEnd = function (e) {
      // We're on a touch device now, so change the event handlers
      dragEventFor = eventsFor.touch;

      return _this.handleDragStop(e);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(DraggableCore, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      // Remove any leftover event handlers. Remove both touch and mouse handlers in case
      // some browser quirk caused a touch event to fire during a mouse move, or vice versa.
      var thisNode = _reactDom2.default.findDOMNode(this);
      if (thisNode) {
        var ownerDocument = thisNode.ownerDocument;

        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
        if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);
      }
    }

    // Same as onMouseDown (start drag), but now consider this a touch device.

  }, {
    key: 'render',
    value: function render() {
      // Reuse the child provided
      // This makes it flexible to use whatever element is wanted (div, ul, etc)
      return _react2.default.cloneElement(_react2.default.Children.only(this.props.children), {
        style: (0, _domFns.styleHacks)(this.props.children.props.style),

        // Note: mouseMove handler is attached to document so it will still function
        // when the user drags quickly and leaves the bounds of the element.
        onMouseDown: this.onMouseDown,
        onTouchStart: this.onTouchStart,
        onMouseUp: this.onMouseUp,
        onTouchEnd: this.onTouchEnd
      });
    }
  }]);

  return DraggableCore;
}(_react2.default.Component);

DraggableCore.displayName = 'DraggableCore';
DraggableCore.propTypes = {
  /**
   * `allowAnyClick` allows dragging using any mouse button.
   * By default, we only accept the left button.
   *
   * Defaults to `false`.
   */
  allowAnyClick: _propTypes2.default.bool,

  /**
   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
   * with the exception of `onMouseDown`, will not fire.
   */
  disabled: _propTypes2.default.bool,

  /**
   * By default, we add 'user-select:none' attributes to the document body
   * to prevent ugly text selection during drag. If this is causing problems
   * for your app, set this to `false`.
   */
  enableUserSelectHack: _propTypes2.default.bool,

  /**
   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
   * instead of using the parent node.
   */
  offsetParent: function offsetParent(props /*: DraggableCoreProps*/, propName /*: $Keys<DraggableCoreProps>*/) {
    if (process.browser === true && props[propName] && props[propName].nodeType !== 1) {
      throw new Error('Draggable\'s offsetParent must be a DOM Node.');
    }
  },

  /**
   * `grid` specifies the x and y that dragging should snap to.
   */
  grid: _propTypes2.default.arrayOf(_propTypes2.default.number),

  /**
   * `handle` specifies a selector to be used as the handle that initiates drag.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable handle=".handle">
   *              <div>
   *                  <div className="handle">Click me to drag</div>
   *                  <div>This is some other content</div>
   *              </div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  handle: _propTypes2.default.string,

  /**
   * `cancel` specifies a selector to be used to prevent drag initialization.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *           return(
   *               <Draggable cancel=".cancel">
   *                   <div>
   *                     <div className="cancel">You can't drag from here</div>
   *                     <div>Dragging here works fine</div>
   *                   </div>
   *               </Draggable>
   *           );
   *       }
   *   });
   * ```
   */
  cancel: _propTypes2.default.string,

  /**
   * Called when dragging starts.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onStart: _propTypes2.default.func,

  /**
   * Called while dragging.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onDrag: _propTypes2.default.func,

  /**
   * Called when dragging stops.
   * If this function returns the boolean false, the drag will remain active.
   */
  onStop: _propTypes2.default.func,

  /**
   * A workaround option which can be passed if onMouseDown needs to be accessed,
   * since it'll always be blocked (as there is internal use of onMouseDown)
   */
  onMouseDown: _propTypes2.default.func,

  /**
   * These properties should be defined on the child, not here.
   */
  className: _shims.dontSetMe,
  style: _shims.dontSetMe,
  transform: _shims.dontSetMe
};
DraggableCore.defaultProps = {
  allowAnyClick: false, // by default only accept left click
  cancel: null,
  disabled: false,
  enableUserSelectHack: true,
  offsetParent: null,
  handle: null,
  grid: null,
  transform: null,
  onStart: function onStart() {},
  onDrag: function onDrag() {},
  onStop: function onStop() {},
  onMouseDown: function onMouseDown() {}
};
exports.default = DraggableCore;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = log;

/*eslint no-console:0*/
function log() {
  var _console;

  if (undefined) (_console = console).log.apply(_console, arguments);
}

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Draggable = __webpack_require__(13).default;

// Previous versions of this lib exported <Draggable> as the root export. As to not break
// them, or TypeScript, we export *both* as the root and as 'default'.
// See https://github.com/mzabriskie/react-draggable/pull/254
// and https://github.com/mzabriskie/react-draggable/issues/266
module.exports = Draggable;
module.exports.default = Draggable;
module.exports.DraggableCore = __webpack_require__(10).default;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(7);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__(4);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _classnames = __webpack_require__(18);

var _classnames2 = _interopRequireDefault(_classnames);

var _domFns = __webpack_require__(5);

var _positionFns = __webpack_require__(9);

var _shims = __webpack_require__(0);

var _DraggableCore = __webpack_require__(10);

var _DraggableCore2 = _interopRequireDefault(_DraggableCore);

var _log = __webpack_require__(11);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*:: import type {ControlPosition, DraggableBounds, DraggableCoreProps} from './DraggableCore';*/
/*:: import type {DraggableEventHandler} from './utils/types';*/
/*:: import type {Element as ReactElement} from 'react';*/
/*:: type DraggableState = {
  dragging: boolean,
  dragged: boolean,
  x: number, y: number,
  slackX: number, slackY: number,
  isElementSVG: boolean
};*/


//
// Define <Draggable>
//

/*:: export type DraggableProps = {
  ...$Exact<DraggableCoreProps>,
  axis: 'both' | 'x' | 'y' | 'none',
  bounds: DraggableBounds | string | false,
  defaultClassName: string,
  defaultClassNameDragging: string,
  defaultClassNameDragged: string,
  defaultPosition: ControlPosition,
  position: ControlPosition,
};*/

var Draggable = function (_React$Component) {
  _inherits(Draggable, _React$Component);

  function Draggable(props /*: DraggableProps*/) {
    _classCallCheck(this, Draggable);

    var _this = _possibleConstructorReturn(this, (Draggable.__proto__ || Object.getPrototypeOf(Draggable)).call(this, props));

    _this.onDragStart = function (e, coreData) {
      (0, _log2.default)('Draggable: onDragStart: %j', coreData);

      // Short-circuit if user's callback killed it.
      var shouldStart = _this.props.onStart(e, (0, _positionFns.createDraggableData)(_this, coreData));
      // Kills start event on core as well, so move handlers are never bound.
      if (shouldStart === false) return false;

      _this.setState({ dragging: true, dragged: true });
    };

    _this.onDrag = function (e, coreData) {
      if (!_this.state.dragging) return false;
      (0, _log2.default)('Draggable: onDrag: %j', coreData);

      var uiData = (0, _positionFns.createDraggableData)(_this, coreData);

      var newState /*: $Shape<DraggableState>*/ = {
        x: uiData.x,
        y: uiData.y
      };

      // Keep within bounds.
      if (_this.props.bounds) {
        // Save original x and y.
        var _x = newState.x,
            _y = newState.y;

        // Add slack to the values used to calculate bound position. This will ensure that if
        // we start removing slack, the element won't react to it right away until it's been
        // completely removed.

        newState.x += _this.state.slackX;
        newState.y += _this.state.slackY;

        // Get bound position. This will ceil/floor the x and y within the boundaries.

        var _getBoundPosition = (0, _positionFns.getBoundPosition)(_this, newState.x, newState.y),
            _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2),
            newStateX = _getBoundPosition2[0],
            newStateY = _getBoundPosition2[1];

        newState.x = newStateX;
        newState.y = newStateY;

        // Recalculate slack by noting how much was shaved by the boundPosition handler.
        newState.slackX = _this.state.slackX + (_x - newState.x);
        newState.slackY = _this.state.slackY + (_y - newState.y);

        // Update the event we fire to reflect what really happened after bounds took effect.
        uiData.x = newState.x;
        uiData.y = newState.y;
        uiData.deltaX = newState.x - _this.state.x;
        uiData.deltaY = newState.y - _this.state.y;
      }

      // Short-circuit if user's callback killed it.
      var shouldUpdate = _this.props.onDrag(e, uiData);
      if (shouldUpdate === false) return false;

      _this.setState(newState);
    };

    _this.onDragStop = function (e, coreData) {
      if (!_this.state.dragging) return false;

      // Short-circuit if user's callback killed it.
      var shouldStop = _this.props.onStop(e, (0, _positionFns.createDraggableData)(_this, coreData));
      if (shouldStop === false) return false;

      (0, _log2.default)('Draggable: onDragStop: %j', coreData);

      var newState /*: $Shape<DraggableState>*/ = {
        dragging: false,
        slackX: 0,
        slackY: 0
      };

      // If this is a controlled component, the result of this operation will be to
      // revert back to the old position. We expect a handler on `onDragStop`, at the least.
      var controlled = Boolean(_this.props.position);
      if (controlled) {
        var _this$props$position = _this.props.position,
            _x2 = _this$props$position.x,
            _y2 = _this$props$position.y;

        newState.x = _x2;
        newState.y = _y2;
      }

      _this.setState(newState);
    };

    _this.state = {
      // Whether or not we are currently dragging.
      dragging: false,

      // Whether or not we have been dragged before.
      dragged: false,

      // Current transform x and y.
      x: props.position ? props.position.x : props.defaultPosition.x,
      y: props.position ? props.position.y : props.defaultPosition.y,

      // Used for compensating for out-of-bounds drags
      slackX: 0, slackY: 0,

      // Can only determine if SVG after mounting
      isElementSVG: false
    };
    return _this;
  }

  _createClass(Draggable, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      if (this.props.position && !(this.props.onDrag || this.props.onStop)) {
        // eslint-disable-next-line
        console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      // Check to see if the element passed is an instanceof SVGElement
      if (typeof window.SVGElement !== 'undefined' && _reactDom2.default.findDOMNode(this) instanceof window.SVGElement) {
        this.setState({ isElementSVG: true });
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps /*: Object*/) {
      // Set x/y if position has changed
      if (nextProps.position && (!this.props.position || nextProps.position.x !== this.props.position.x || nextProps.position.y !== this.props.position.y)) {
        this.setState({ x: nextProps.position.x, y: nextProps.position.y });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.setState({ dragging: false }); // prevents invariant if unmounted while dragging
    }
  }, {
    key: 'render',
    value: function render() /*: ReactElement<any>*/ {
      var _classNames;

      var style = {},
          svgTransform = null;

      // If this is controlled, we don't want to move it - unless it's dragging.
      var controlled = Boolean(this.props.position);
      var draggable = !controlled || this.state.dragging;

      var position = this.props.position || this.props.defaultPosition;
      var transformOpts = {
        // Set left if horizontal drag is enabled
        x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : position.x,

        // Set top if vertical drag is enabled
        y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : position.y
      };

      // If this element was SVG, we use the `transform` attribute.
      if (this.state.isElementSVG) {
        svgTransform = (0, _domFns.createSVGTransform)(transformOpts);
      } else {
        // Add a CSS transform to move the element around. This allows us to move the element around
        // without worrying about whether or not it is relatively or absolutely positioned.
        // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
        // has a clean slate.
        style = (0, _domFns.createCSSTransform)(transformOpts);
      }

      var _props = this.props,
          defaultClassName = _props.defaultClassName,
          defaultClassNameDragging = _props.defaultClassNameDragging,
          defaultClassNameDragged = _props.defaultClassNameDragged;


      var children = _react2.default.Children.only(this.props.children);

      // Mark with class while dragging
      var className = (0, _classnames2.default)(children.props.className || '', defaultClassName, (_classNames = {}, _defineProperty(_classNames, defaultClassNameDragging, this.state.dragging), _defineProperty(_classNames, defaultClassNameDragged, this.state.dragged), _classNames));

      // Reuse the child provided
      // This makes it flexible to use whatever element is wanted (div, ul, etc)
      return _react2.default.createElement(
        _DraggableCore2.default,
        _extends({}, this.props, { onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop }),
        _react2.default.cloneElement(children, {
          className: className,
          style: _extends({}, children.props.style, style),
          transform: svgTransform
        })
      );
    }
  }]);

  return Draggable;
}(_react2.default.Component);

Draggable.displayName = 'Draggable';
Draggable.propTypes = _extends({}, _DraggableCore2.default.propTypes, {

  /**
   * `axis` determines which axis the draggable can move.
   *
   *  Note that all callbacks will still return data as normal. This only
   *  controls flushing to the DOM.
   *
   * 'both' allows movement horizontally and vertically.
   * 'x' limits movement to horizontal axis.
   * 'y' limits movement to vertical axis.
   * 'none' limits all movement.
   *
   * Defaults to 'both'.
   */
  axis: _propTypes2.default.oneOf(['both', 'x', 'y', 'none']),

  /**
   * `bounds` determines the range of movement available to the element.
   * Available values are:
   *
   * 'parent' restricts movement within the Draggable's parent node.
   *
   * Alternatively, pass an object with the following properties, all of which are optional:
   *
   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
   *
   * All values are in px.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable bounds={{right: 300, bottom: 300}}>
   *              <div>Content</div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  bounds: _propTypes2.default.oneOfType([_propTypes2.default.shape({
    left: _propTypes2.default.number,
    right: _propTypes2.default.number,
    top: _propTypes2.default.number,
    bottom: _propTypes2.default.number
  }), _propTypes2.default.string, _propTypes2.default.oneOf([false])]),

  defaultClassName: _propTypes2.default.string,
  defaultClassNameDragging: _propTypes2.default.string,
  defaultClassNameDragged: _propTypes2.default.string,

  /**
   * `defaultPosition` specifies the x and y that the dragged item should start at
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable defaultPosition={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */
  defaultPosition: _propTypes2.default.shape({
    x: _propTypes2.default.number,
    y: _propTypes2.default.number
  }),

  /**
   * `position`, if present, defines the current position of the element.
   *
   *  This is similar to how form elements in React work - if no `position` is supplied, the component
   *  is uncontrolled.
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable position={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */
  position: _propTypes2.default.shape({
    x: _propTypes2.default.number,
    y: _propTypes2.default.number
  }),

  /**
   * These properties should be defined on the child, not here.
   */
  className: _shims.dontSetMe,
  style: _shims.dontSetMe,
  transform: _shims.dontSetMe
});
Draggable.defaultProps = _extends({}, _DraggableCore2.default.defaultProps, {
  axis: 'both',
  bounds: false,
  defaultClassName: 'react-draggable',
  defaultClassNameDragging: 'react-draggable-dragging',
  defaultClassNameDragged: 'react-draggable-dragged',
  defaultPosition: { x: 0, y: 0 },
  position: null
});
exports.default = Draggable;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(1);
var invariant = __webpack_require__(2);
var warning = __webpack_require__(8);
var assign = __webpack_require__(15);

var ReactPropTypesSecret = __webpack_require__(3);
var checkPropTypes = __webpack_require__(16);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (Object({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if (Object({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      Object({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      Object({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (Object({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production') {
  var invariant = __webpack_require__(2);
  var warning = __webpack_require__(8);
  var ReactPropTypesSecret = __webpack_require__(3);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (Object({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(1);
var invariant = __webpack_require__(2);
var ReactPropTypesSecret = __webpack_require__(3);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPrefix = getPrefix;
exports.browserPrefixToKey = browserPrefixToKey;
exports.browserPrefixToStyle = browserPrefixToStyle;
var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
function getPrefix() /*: string*/ {
  var prop /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';

  // Checking specifically for 'window.document' is for pseudo-browser server-side
  // environments that define 'window' as the global context.
  // E.g. React-rails (see https://github.com/reactjs/react-rails/pull/84)
  if (typeof window === 'undefined' || typeof window.document === 'undefined') return '';

  var style = window.document.documentElement.style;

  if (prop in style) return '';

  for (var i = 0; i < prefixes.length; i++) {
    if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
  }

  return '';
}

function browserPrefixToKey(prop /*: string*/, prefix /*: string*/) /*: string*/ {
  return prefix ? '' + prefix + kebabToTitleCase(prop) : prop;
}

function browserPrefixToStyle(prop /*: string*/, prefix /*: string*/) /*: string*/ {
  return prefix ? '-' + prefix.toLowerCase() + '-' + prop : prop;
}

function kebabToTitleCase(str /*: string*/) /*: string*/ {
  var out = '';
  var shouldCapitalize = true;
  for (var i = 0; i < str.length; i++) {
    if (shouldCapitalize) {
      out += str[i].toUpperCase();
      shouldCapitalize = false;
    } else if (str[i] === '-') {
      shouldCapitalize = true;
    } else {
      out += str[i];
    }
  }
  return out;
}

// Default export is the prefix itself, like 'Moz', 'Webkit', etc
// Note that you may have to re-test for certain things; for instance, Chrome 50
// can handle unprefixed `transform`, but not unprefixed `user-select`
exports.default = getPrefix();

/***/ }),
/* 20 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ })
/******/ ]);
});
//# sourceMappingURL=react-draggable.js.map

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function() {
  throw new Error("Don't instantiate Resizable directly! Use require('react-resizable').Resizable");
};

module.exports.Resizable = __webpack_require__(187).default;
module.exports.ResizableBox = __webpack_require__(372).default;


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(0), __webpack_require__(8));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["ReactDraggable"] = factory(require("react"), require("react-dom"));
	else
		root["ReactDraggable"] = factory(root["React"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_11__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(1).default;
	module.exports.DraggableCore = __webpack_require__(17).default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(3);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _reactDom = __webpack_require__(11);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _classnames = __webpack_require__(12);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _domFns = __webpack_require__(13);
	
	var _positionFns = __webpack_require__(16);
	
	var _shims = __webpack_require__(14);
	
	var _DraggableCore = __webpack_require__(17);
	
	var _DraggableCore2 = _interopRequireDefault(_DraggableCore);
	
	var _log = __webpack_require__(19);
	
	var _log2 = _interopRequireDefault(_log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	// $FlowIgnore
	
	
	/*:: import type {DraggableEventHandler} from './utils/types';*/
	/*:: type DraggableState = {
	  dragging: boolean,
	  dragged: boolean,
	  x: number, y: number,
	  slackX: number, slackY: number,
	  isElementSVG: boolean
	};*/
	
	
	//
	// Define <Draggable>
	//
	
	/*:: type ConstructorProps = {
	  position: { x: number, y: number },
	  defaultPosition: { x: number, y: number }
	};*/
	
	var Draggable = function (_React$Component) {
	  _inherits(Draggable, _React$Component);
	
	  function Draggable(props /*: ConstructorProps*/) {
	    _classCallCheck(this, Draggable);
	
	    var _this = _possibleConstructorReturn(this, (Draggable.__proto__ || Object.getPrototypeOf(Draggable)).call(this, props));
	
	    _this.onDragStart = function (e, coreData) {
	      (0, _log2.default)('Draggable: onDragStart: %j', coreData);
	
	      // Short-circuit if user's callback killed it.
	      var shouldStart = _this.props.onStart(e, (0, _positionFns.createDraggableData)(_this, coreData));
	      // Kills start event on core as well, so move handlers are never bound.
	      if (shouldStart === false) return false;
	
	      _this.setState({ dragging: true, dragged: true });
	    };
	
	    _this.onDrag = function (e, coreData) {
	      if (!_this.state.dragging) return false;
	      (0, _log2.default)('Draggable: onDrag: %j', coreData);
	
	      var uiData = (0, _positionFns.createDraggableData)(_this, coreData);
	
	      var newState /*: $Shape<DraggableState>*/ = {
	        x: uiData.x,
	        y: uiData.y
	      };
	
	      // Keep within bounds.
	      if (_this.props.bounds) {
	        // Save original x and y.
	        var _x = newState.x,
	            _y = newState.y;
	
	        // Add slack to the values used to calculate bound position. This will ensure that if
	        // we start removing slack, the element won't react to it right away until it's been
	        // completely removed.
	
	        newState.x += _this.state.slackX;
	        newState.y += _this.state.slackY;
	
	        // Get bound position. This will ceil/floor the x and y within the boundaries.
	        // $FlowBug
	
	        // Recalculate slack by noting how much was shaved by the boundPosition handler.
	        var _getBoundPosition = (0, _positionFns.getBoundPosition)(_this, newState.x, newState.y);
	
	        var _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2);
	
	        newState.x = _getBoundPosition2[0];
	        newState.y = _getBoundPosition2[1];
	        newState.slackX = _this.state.slackX + (_x - newState.x);
	        newState.slackY = _this.state.slackY + (_y - newState.y);
	
	        // Update the event we fire to reflect what really happened after bounds took effect.
	        uiData.x = _x;
	        uiData.y = _y;
	        uiData.deltaX = newState.x - _this.state.x;
	        uiData.deltaY = newState.y - _this.state.y;
	      }
	
	      // Short-circuit if user's callback killed it.
	      var shouldUpdate = _this.props.onDrag(e, uiData);
	      if (shouldUpdate === false) return false;
	
	      _this.setState(newState);
	    };
	
	    _this.onDragStop = function (e, coreData) {
	      if (!_this.state.dragging) return false;
	
	      // Short-circuit if user's callback killed it.
	      var shouldStop = _this.props.onStop(e, (0, _positionFns.createDraggableData)(_this, coreData));
	      if (shouldStop === false) return false;
	
	      (0, _log2.default)('Draggable: onDragStop: %j', coreData);
	
	      var newState /*: $Shape<DraggableState>*/ = {
	        dragging: false,
	        slackX: 0,
	        slackY: 0
	      };
	
	      // If this is a controlled component, the result of this operation will be to
	      // revert back to the old position. We expect a handler on `onDragStop`, at the least.
	      var controlled = Boolean(_this.props.position);
	      if (controlled) {
	        var _this$props$position = _this.props.position,
	            _x2 = _this$props$position.x,
	            _y2 = _this$props$position.y;
	
	        newState.x = _x2;
	        newState.y = _y2;
	      }
	
	      _this.setState(newState);
	    };
	
	    _this.state = {
	      // Whether or not we are currently dragging.
	      dragging: false,
	
	      // Whether or not we have been dragged before.
	      dragged: false,
	
	      // Current transform x and y.
	      x: props.position ? props.position.x : props.defaultPosition.x,
	      y: props.position ? props.position.y : props.defaultPosition.y,
	
	      // Used for compensating for out-of-bounds drags
	      slackX: 0, slackY: 0,
	
	      // Can only determine if SVG after mounting
	      isElementSVG: false
	    };
	    return _this;
	  }
	
	  _createClass(Draggable, [{
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      if (this.props.position && !(this.props.onDrag || this.props.onStop)) {
	        // eslint-disable-next-line
	        console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');
	      }
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      // Check to see if the element passed is an instanceof SVGElement
	      if (typeof SVGElement !== 'undefined' && _reactDom2.default.findDOMNode(this) instanceof SVGElement) {
	        this.setState({ isElementSVG: true });
	      }
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps /*: Object*/) {
	      // Set x/y if position has changed
	      if (nextProps.position && (!this.props.position || nextProps.position.x !== this.props.position.x || nextProps.position.y !== this.props.position.y)) {
	        this.setState({ x: nextProps.position.x, y: nextProps.position.y });
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.setState({ dragging: false }); // prevents invariant if unmounted while dragging
	    }
	  }, {
	    key: 'render',
	    value: function render() /*: React.Element<any>*/ {
	      var _classNames;
	
	      var style = {},
	          svgTransform = null;
	
	      // If this is controlled, we don't want to move it - unless it's dragging.
	      var controlled = Boolean(this.props.position);
	      var draggable = !controlled || this.state.dragging;
	
	      var position = this.props.position || this.props.defaultPosition;
	      var transformOpts = {
	        // Set left if horizontal drag is enabled
	        x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : position.x,
	
	        // Set top if vertical drag is enabled
	        y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : position.y
	      };
	
	      // If this element was SVG, we use the `transform` attribute.
	      if (this.state.isElementSVG) {
	        svgTransform = (0, _domFns.createSVGTransform)(transformOpts);
	      } else {
	        // Add a CSS transform to move the element around. This allows us to move the element around
	        // without worrying about whether or not it is relatively or absolutely positioned.
	        // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
	        // has a clean slate.
	        style = (0, _domFns.createCSSTransform)(transformOpts);
	      }
	
	      var _props = this.props,
	          defaultClassName = _props.defaultClassName,
	          defaultClassNameDragging = _props.defaultClassNameDragging,
	          defaultClassNameDragged = _props.defaultClassNameDragged;
	
	      // Mark with class while dragging
	
	      var className = (0, _classnames2.default)(this.props.children.props.className || '', defaultClassName, (_classNames = {}, _defineProperty(_classNames, defaultClassNameDragging, this.state.dragging), _defineProperty(_classNames, defaultClassNameDragged, this.state.dragged), _classNames));
	
	      // Reuse the child provided
	      // This makes it flexible to use whatever element is wanted (div, ul, etc)
	      return _react2.default.createElement(
	        _DraggableCore2.default,
	        _extends({}, this.props, { onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop }),
	        _react2.default.cloneElement(_react2.default.Children.only(this.props.children), {
	          className: className,
	          style: _extends({}, this.props.children.props.style, style),
	          transform: svgTransform
	        })
	      );
	    }
	  }]);
	
	  return Draggable;
	}(_react2.default.Component);
	
	Draggable.displayName = 'Draggable';
	Draggable.propTypes = _extends({}, _DraggableCore2.default.propTypes, {
	
	  /**
	   * `axis` determines which axis the draggable can move.
	   *
	   *  Note that all callbacks will still return data as normal. This only
	   *  controls flushing to the DOM.
	   *
	   * 'both' allows movement horizontally and vertically.
	   * 'x' limits movement to horizontal axis.
	   * 'y' limits movement to vertical axis.
	   * 'none' limits all movement.
	   *
	   * Defaults to 'both'.
	   */
	  axis: _propTypes2.default.oneOf(['both', 'x', 'y', 'none']),
	
	  /**
	   * `bounds` determines the range of movement available to the element.
	   * Available values are:
	   *
	   * 'parent' restricts movement within the Draggable's parent node.
	   *
	   * Alternatively, pass an object with the following properties, all of which are optional:
	   *
	   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
	   *
	   * All values are in px.
	   *
	   * Example:
	   *
	   * ```jsx
	   *   let App = React.createClass({
	   *       render: function () {
	   *         return (
	   *            <Draggable bounds={{right: 300, bottom: 300}}>
	   *              <div>Content</div>
	   *           </Draggable>
	   *         );
	   *       }
	   *   });
	   * ```
	   */
	  bounds: _propTypes2.default.oneOfType([_propTypes2.default.shape({
	    left: _propTypes2.default.number,
	    right: _propTypes2.default.number,
	    top: _propTypes2.default.number,
	    bottom: _propTypes2.default.number
	  }), _propTypes2.default.string, _propTypes2.default.oneOf([false])]),
	
	  defaultClassName: _propTypes2.default.string,
	  defaultClassNameDragging: _propTypes2.default.string,
	  defaultClassNameDragged: _propTypes2.default.string,
	
	  /**
	   * `defaultPosition` specifies the x and y that the dragged item should start at
	   *
	   * Example:
	   *
	   * ```jsx
	   *      let App = React.createClass({
	   *          render: function () {
	   *              return (
	   *                  <Draggable defaultPosition={{x: 25, y: 25}}>
	   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
	   *                  </Draggable>
	   *              );
	   *          }
	   *      });
	   * ```
	   */
	  defaultPosition: _propTypes2.default.shape({
	    x: _propTypes2.default.number,
	    y: _propTypes2.default.number
	  }),
	
	  /**
	   * `position`, if present, defines the current position of the element.
	   *
	   *  This is similar to how form elements in React work - if no `position` is supplied, the component
	   *  is uncontrolled.
	   *
	   * Example:
	   *
	   * ```jsx
	   *      let App = React.createClass({
	   *          render: function () {
	   *              return (
	   *                  <Draggable position={{x: 25, y: 25}}>
	   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
	   *                  </Draggable>
	   *              );
	   *          }
	   *      });
	   * ```
	   */
	  position: _propTypes2.default.shape({
	    x: _propTypes2.default.number,
	    y: _propTypes2.default.number
	  }),
	
	  /**
	   * These properties should be defined on the child, not here.
	   */
	  className: _shims.dontSetMe,
	  style: _shims.dontSetMe,
	  transform: _shims.dontSetMe
	});
	Draggable.defaultProps = _extends({}, _DraggableCore2.default.defaultProps, {
	  axis: 'both',
	  bounds: false,
	  defaultClassName: 'react-draggable',
	  defaultClassNameDragging: 'react-draggable-dragging',
	  defaultClassNameDragged: 'react-draggable-dragged',
	  defaultPosition: { x: 0, y: 0 },
	  position: null
	});
	exports.default = Draggable;

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	if (({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production') {
	  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
	    Symbol.for &&
	    Symbol.for('react.element')) ||
	    0xeac7;
	
	  var isValidElement = function(object) {
	    return typeof object === 'object' &&
	      object !== null &&
	      object.$$typeof === REACT_ELEMENT_TYPE;
	  };
	
	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = __webpack_require__(4)(isValidElement, throwOnDirectAccess);
	} else {
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = __webpack_require__(10)();
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(5);
	var invariant = __webpack_require__(6);
	var warning = __webpack_require__(7);
	
	var ReactPropTypesSecret = __webpack_require__(8);
	var checkPropTypes = __webpack_require__(9);
	
	module.exports = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }
	
	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */
	
	  var ANONYMOUS = '<<anonymous>>';
	
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),
	
	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker
	  };
	
	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/
	
	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;
	
	  function createChainableTypeChecker(validate) {
	    if (({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production') {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;
	
	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          invariant(
	            false,
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	        } else if (({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            warning(
	              false,
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `%s` prop on `%s`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
	              propFullName,
	              componentName
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }
	
	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);
	
	    return chainedCheckType;
	  }
	
	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);
	
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
	  }
	
	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      ({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }
	
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }
	
	      var valuesString = JSON.stringify(expectedValues);
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (propValue.hasOwnProperty(key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      ({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }
	
	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	          return null;
	        }
	      }
	
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          continue;
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }
	
	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }
	
	        return true;
	      default:
	        return false;
	    }
	  }
	
	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }
	
	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }
	
	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }
	
	    return false;
	  }
	
	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }
	
	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }
	
	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }
	
	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.PropTypes = ReactPropTypes;
	
	  return ReactPropTypes;
	};


/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var validateFormat = function validateFormat(format) {};
	
	if (({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production') {
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(5);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;

/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	if (({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production') {
	  var invariant = __webpack_require__(6);
	  var warning = __webpack_require__(7);
	  var ReactPropTypesSecret = __webpack_require__(8);
	  var loggedTypeFailures = {};
	}
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (({"DRAGGABLE_DEBUG":undefined}).NODE_ENV !== 'production') {
	    for (var typeSpecName in typeSpecs) {
	      if (typeSpecs.hasOwnProperty(typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;
	
	          var stack = getStack ? getStack() : '';
	
	          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
	        }
	      }
	    }
	  }
	}
	
	module.exports = checkPropTypes;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(5);
	var invariant = __webpack_require__(6);
	
	module.exports = function() {
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  function shim() {
	    invariant(
	      false,
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	  };
	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  };
	  var ReactPropTypes = {
	    array: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,
	
	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim
	  };
	
	  ReactPropTypes.checkPropTypes = emptyFunction;
	  ReactPropTypes.PropTypes = ReactPropTypes;
	
	  return ReactPropTypes;
	};


/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_11__;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var hasOwn = {}.hasOwnProperty;
	
		function classNames () {
			var classes = [];
	
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;
	
				var argType = typeof arg;
	
				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}
	
			return classes.join(' ');
		}
	
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.matchesSelector = matchesSelector;
	exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
	exports.addEvent = addEvent;
	exports.removeEvent = removeEvent;
	exports.outerHeight = outerHeight;
	exports.outerWidth = outerWidth;
	exports.innerHeight = innerHeight;
	exports.innerWidth = innerWidth;
	exports.offsetXYFromParent = offsetXYFromParent;
	exports.createCSSTransform = createCSSTransform;
	exports.createSVGTransform = createSVGTransform;
	exports.getTouch = getTouch;
	exports.getTouchIdentifier = getTouchIdentifier;
	exports.addUserSelectStyles = addUserSelectStyles;
	exports.removeUserSelectStyles = removeUserSelectStyles;
	exports.styleHacks = styleHacks;
	
	var _shims = __webpack_require__(14);
	
	var _getPrefix = __webpack_require__(15);
	
	var _getPrefix2 = _interopRequireDefault(_getPrefix);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	/*:: import type {ControlPosition} from './types';*/
	
	
	var matchesSelectorFunc = '';
	function matchesSelector(el /*: Node*/, selector /*: string*/) /*: boolean*/ {
	  if (!matchesSelectorFunc) {
	    matchesSelectorFunc = (0, _shims.findInArray)(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {
	      // $FlowIgnore: Doesn't think elements are indexable
	      return (0, _shims.isFunction)(el[method]);
	    });
	  }
	
	  // $FlowIgnore: Doesn't think elements are indexable
	  return el[matchesSelectorFunc].call(el, selector);
	}
	
	// Works up the tree to the draggable itself attempting to match selector.
	function matchesSelectorAndParentsTo(el /*: Node*/, selector /*: string*/, baseNode /*: Node*/) /*: boolean*/ {
	  var node = el;
	  do {
	    if (matchesSelector(node, selector)) return true;
	    if (node === baseNode) return false;
	    node = node.parentNode;
	  } while (node);
	
	  return false;
	}
	
	function addEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/ {
	  if (!el) {
	    return;
	  }
	  if (el.attachEvent) {
	    el.attachEvent('on' + event, handler);
	  } else if (el.addEventListener) {
	    el.addEventListener(event, handler, true);
	  } else {
	    // $FlowIgnore: Doesn't think elements are indexable
	    el['on' + event] = handler;
	  }
	}
	
	function removeEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/ {
	  if (!el) {
	    return;
	  }
	  if (el.detachEvent) {
	    el.detachEvent('on' + event, handler);
	  } else if (el.removeEventListener) {
	    el.removeEventListener(event, handler, true);
	  } else {
	    // $FlowIgnore: Doesn't think elements are indexable
	    el['on' + event] = null;
	  }
	}
	
	function outerHeight(node /*: HTMLElement*/) /*: number*/ {
	  // This is deliberately excluding margin for our calculations, since we are using
	  // offsetTop which is including margin. See getBoundPosition
	  var height = node.clientHeight;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  height += (0, _shims.int)(computedStyle.borderTopWidth);
	  height += (0, _shims.int)(computedStyle.borderBottomWidth);
	  return height;
	}
	
	function outerWidth(node /*: HTMLElement*/) /*: number*/ {
	  // This is deliberately excluding margin for our calculations, since we are using
	  // offsetLeft which is including margin. See getBoundPosition
	  var width = node.clientWidth;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  width += (0, _shims.int)(computedStyle.borderLeftWidth);
	  width += (0, _shims.int)(computedStyle.borderRightWidth);
	  return width;
	}
	function innerHeight(node /*: HTMLElement*/) /*: number*/ {
	  var height = node.clientHeight;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  height -= (0, _shims.int)(computedStyle.paddingTop);
	  height -= (0, _shims.int)(computedStyle.paddingBottom);
	  return height;
	}
	
	function innerWidth(node /*: HTMLElement*/) /*: number*/ {
	  var width = node.clientWidth;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  width -= (0, _shims.int)(computedStyle.paddingLeft);
	  width -= (0, _shims.int)(computedStyle.paddingRight);
	  return width;
	}
	
	// Get from offsetParent
	function offsetXYFromParent(evt /*: {clientX: number, clientY: number}*/, offsetParent /*: HTMLElement*/) /*: ControlPosition*/ {
	  var isBody = offsetParent === offsetParent.ownerDocument.body;
	  var offsetParentRect = isBody ? { left: 0, top: 0 } : offsetParent.getBoundingClientRect();
	
	  var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;
	  var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;
	
	  return { x: x, y: y };
	}
	
	function createCSSTransform(_ref) /*: Object*/ {
	  var x = _ref.x,
	      y = _ref.y;
	
	  // Replace unitless items with px
	  return _defineProperty({}, (0, _getPrefix.browserPrefixToKey)('transform', _getPrefix2.default), 'translate(' + x + 'px,' + y + 'px)');
	}
	
	function createSVGTransform(_ref3) /*: string*/ {
	  var x = _ref3.x,
	      y = _ref3.y;
	
	  return 'translate(' + x + ',' + y + ')';
	}
	
	function getTouch(e /*: MouseTouchEvent*/, identifier /*: number*/) /*: ?{clientX: number, clientY: number}*/ {
	  return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, function (t) {
	    return identifier === t.identifier;
	  }) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, function (t) {
	    return identifier === t.identifier;
	  });
	}
	
	function getTouchIdentifier(e /*: MouseTouchEvent*/) /*: ?number*/ {
	  if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
	  if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
	}
	
	// User-select Hacks:
	//
	// Useful for preventing blue highlights all over everything when dragging.
	var userSelectPrefix = (0, _getPrefix.getPrefix)('user-select');
	var userSelect = (0, _getPrefix.browserPrefixToStyle)('user-select', userSelectPrefix);
	var userSelectStyle = ';' + userSelect + ': none;';
	var userSelectReplaceRegExp = new RegExp(';?' + userSelect + ': none;'); // leading ; not present on IE
	
	// Note we're passing `document` b/c we could be iframed
	function addUserSelectStyles(body /*: HTMLElement*/) {
	  var style = body.getAttribute('style') || '';
	  if (userSelectReplaceRegExp.test(style)) return; // don't add twice
	  body.setAttribute('style', style + userSelectStyle);
	}
	
	function removeUserSelectStyles(body /*: HTMLElement*/) {
	  var style = body.getAttribute('style') || '';
	  body.setAttribute('style', style.replace(userSelectReplaceRegExp, ''));
	}
	
	function styleHacks() /*: Object*/ {
	  var childStyle /*: Object*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	  // Workaround IE pointer events; see #51
	  // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278
	  return _extends({
	    touchAction: 'none'
	  }, childStyle);
	}

/***/ },
/* 14 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.findInArray = findInArray;
	exports.isFunction = isFunction;
	exports.isNum = isNum;
	exports.int = int;
	exports.dontSetMe = dontSetMe;
	
	// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
	function findInArray(array /*: Array<any> | TouchList*/, callback /*: Function*/) /*: any*/ {
	  for (var i = 0, length = array.length; i < length; i++) {
	    if (callback.apply(callback, [array[i], i, array])) return array[i];
	  }
	}
	
	function isFunction(func /*: any*/) /*: boolean*/ {
	  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
	}
	
	function isNum(num /*: any*/) /*: boolean*/ {
	  return typeof num === 'number' && !isNaN(num);
	}
	
	function int(a /*: string*/) /*: number*/ {
	  return parseInt(a, 10);
	}
	
	function dontSetMe(props /*: Object*/, propName /*: string*/, componentName /*: string*/) {
	  if (props[propName]) {
	    return new Error('Invalid prop ' + propName + ' passed to ' + componentName + ' - do not set this, set it on the child.');
	  }
	}

/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getPrefix = getPrefix;
	exports.browserPrefixToKey = browserPrefixToKey;
	exports.browserPrefixToStyle = browserPrefixToStyle;
	var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
	function getPrefix() /*: string*/ {
	  var prop /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';
	
	  // Checking specifically for 'window.document' is for pseudo-browser server-side
	  // environments that define 'window' as the global context.
	  // E.g. React-rails (see https://github.com/reactjs/react-rails/pull/84)
	  if (typeof window === 'undefined' || typeof window.document === 'undefined') return '';
	
	  var style = window.document.documentElement.style;
	
	  if (prop in style) return '';
	
	  for (var i = 0; i < prefixes.length; i++) {
	    if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
	  }
	
	  return '';
	}
	
	function browserPrefixToKey(prop /*: string*/, prefix /*: string*/) /*: string*/ {
	  return prefix ? '' + prefix + kebabToTitleCase(prop) : prop;
	}
	
	function browserPrefixToStyle(prop /*: string*/, prefix /*: string*/) /*: string*/ {
	  return prefix ? '-' + prefix.toLowerCase() + '-' + prop : prop;
	}
	
	function kebabToTitleCase(str /*: string*/) /*: string*/ {
	  var out = '';
	  var shouldCapitalize = true;
	  for (var i = 0; i < str.length; i++) {
	    if (shouldCapitalize) {
	      out += str[i].toUpperCase();
	      shouldCapitalize = false;
	    } else if (str[i] === '-') {
	      shouldCapitalize = true;
	    } else {
	      out += str[i];
	    }
	  }
	  return out;
	}
	
	// Default export is the prefix itself, like 'Moz', 'Webkit', etc
	// Note that you may have to re-test for certain things; for instance, Chrome 50
	// can handle unprefixed `transform`, but not unprefixed `user-select`
	exports.default = getPrefix();

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getBoundPosition = getBoundPosition;
	exports.snapToGrid = snapToGrid;
	exports.canDragX = canDragX;
	exports.canDragY = canDragY;
	exports.getControlPosition = getControlPosition;
	exports.createCoreData = createCoreData;
	exports.createDraggableData = createDraggableData;
	
	var _shims = __webpack_require__(14);
	
	var _reactDom = __webpack_require__(11);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _domFns = __webpack_require__(13);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*:: import type Draggable from '../Draggable';*/
	/*:: import type {Bounds, ControlPosition, DraggableData} from './types';*/
	/*:: import type DraggableCore from '../DraggableCore';*/
	function getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/ {
	  // If no bounds, short-circuit and move on
	  if (!draggable.props.bounds) return [x, y];
	
	  // Clone new bounds
	  var bounds = draggable.props.bounds;
	
	  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);
	  var node = _reactDom2.default.findDOMNode(draggable);
	
	  if (typeof bounds === 'string') {
	    var ownerDocument = node.ownerDocument;
	
	    var ownerWindow = ownerDocument.defaultView;
	    var boundNode = void 0;
	    if (bounds === 'parent') {
	      boundNode = node.parentNode;
	    } else {
	      boundNode = ownerDocument.querySelector(bounds);
	      if (!boundNode) throw new Error('Bounds selector "' + bounds + '" could not find an element.');
	    }
	    var nodeStyle = ownerWindow.getComputedStyle(node);
	    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode);
	    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
	    bounds = {
	      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),
	      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),
	      right: (0, _domFns.innerWidth)(boundNode) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),
	      bottom: (0, _domFns.innerHeight)(boundNode) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)
	    };
	  }
	
	  // Keep x and y below right and bottom limits...
	  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
	  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);
	
	  // But above left and top limits.
	  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
	  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);
	
	  return [x, y];
	}
	
	function snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/ {
	  var x = Math.round(pendingX / grid[0]) * grid[0];
	  var y = Math.round(pendingY / grid[1]) * grid[1];
	  return [x, y];
	}
	
	function canDragX(draggable /*: Draggable*/) /*: boolean*/ {
	  return draggable.props.axis === 'both' || draggable.props.axis === 'x';
	}
	
	function canDragY(draggable /*: Draggable*/) /*: boolean*/ {
	  return draggable.props.axis === 'both' || draggable.props.axis === 'y';
	}
	
	// Get {x, y} positions from event.
	function getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/ {
	  var touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
	  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch
	  var node = _reactDom2.default.findDOMNode(draggableCore);
	  // User can provide an offsetParent if desired.
	  var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
	  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent);
	}
	
	// Create an data object exposed by <DraggableCore>'s events
	function createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/ {
	  var state = draggable.state;
	  var isStart = !(0, _shims.isNum)(state.lastX);
	
	  if (isStart) {
	    // If this is our first move, use the x and y as last coords.
	    return {
	      node: _reactDom2.default.findDOMNode(draggable),
	      deltaX: 0, deltaY: 0,
	      lastX: x, lastY: y,
	      x: x, y: y
	    };
	  } else {
	    // Otherwise calculate proper values.
	    return {
	      node: _reactDom2.default.findDOMNode(draggable),
	      deltaX: x - state.lastX, deltaY: y - state.lastY,
	      lastX: state.lastX, lastY: state.lastY,
	      x: x, y: y
	    };
	  }
	}
	
	// Create an data exposed by <Draggable>'s events
	function createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/ {
	  return {
	    node: coreData.node,
	    x: draggable.state.x + coreData.deltaX,
	    y: draggable.state.y + coreData.deltaY,
	    deltaX: coreData.deltaX,
	    deltaY: coreData.deltaY,
	    lastX: draggable.state.x,
	    lastY: draggable.state.y
	  };
	}
	
	// A lot faster than stringify/parse
	function cloneBounds(bounds /*: Bounds*/) /*: Bounds*/ {
	  return {
	    left: bounds.left,
	    top: bounds.top,
	    right: bounds.right,
	    bottom: bounds.bottom
	  };
	}

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(3);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _reactDom = __webpack_require__(11);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _domFns = __webpack_require__(13);
	
	var _positionFns = __webpack_require__(16);
	
	var _shims = __webpack_require__(14);
	
	var _log = __webpack_require__(19);
	
	var _log2 = _interopRequireDefault(_log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// Simple abstraction for dragging events names.
	/*:: import type {EventHandler} from './utils/types';*/
	var eventsFor = {
	  touch: {
	    start: 'touchstart',
	    move: 'touchmove',
	    stop: 'touchend'
	  },
	  mouse: {
	    start: 'mousedown',
	    move: 'mousemove',
	    stop: 'mouseup'
	  }
	};
	
	// Default to mouse events.
	var dragEventFor = eventsFor.mouse;
	
	//
	// Define <DraggableCore>.
	//
	// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can
	// work well with libraries that require more control over the element.
	//
	
	/*:: type CoreState = {
	  dragging: boolean,
	  lastX: number,
	  lastY: number,
	  touchIdentifier: ?number
	};*/
	
	var DraggableCore = function (_React$Component) {
	  _inherits(DraggableCore, _React$Component);
	
	  function DraggableCore() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, DraggableCore);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DraggableCore.__proto__ || Object.getPrototypeOf(DraggableCore)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	      dragging: false,
	      // Used while dragging to determine deltas.
	      lastX: NaN, lastY: NaN,
	      touchIdentifier: null
	    }, _this.handleDragStart = function (e) {
	      // Make it possible to attach event handlers on top of this one.
	      _this.props.onMouseDown(e);
	
	      // Only accept left-clicks.
	      if (!_this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;
	
	      // Get nodes. Be sure to grab relative document (could be iframed)
	      var domNode = _reactDom2.default.findDOMNode(_this);
	      var ownerDocument = domNode.ownerDocument;
	
	      // Short circuit if handle or cancel prop was provided and selector doesn't match.
	
	      if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.handle, domNode) || _this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.cancel, domNode)) {
	        return;
	      }
	
	      // Set touch identifier in component state if this is a touch event. This allows us to
	      // distinguish between individual touches on multitouch screens by identifying which
	      // touchpoint was set to this element.
	      var touchIdentifier = (0, _domFns.getTouchIdentifier)(e);
	      _this.setState({ touchIdentifier: touchIdentifier });
	
	      // Get the current drag point from the event. This is used as the offset.
	      var position = (0, _positionFns.getControlPosition)(e, touchIdentifier, _this);
	      if (position == null) return; // not possible but satisfies flow
	      var x = position.x,
	          y = position.y;
	
	      // Create an event object with all the data parents need to make a decision here.
	
	      var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);
	
	      (0, _log2.default)('DraggableCore: handleDragStart: %j', coreEvent);
	
	      // Call event handler. If it returns explicit false, cancel.
	      (0, _log2.default)('calling', _this.props.onStart);
	      var shouldUpdate = _this.props.onStart(e, coreEvent);
	      if (shouldUpdate === false) return;
	
	      // Add a style to the body to disable user-select. This prevents text from
	      // being selected all over the page.
	      if (_this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument.body);
	
	      // Initiate dragging. Set the current x and y as offsets
	      // so we know how much we've moved during the drag. This allows us
	      // to drag elements around even if they have been moved, without issue.
	      _this.setState({
	        dragging: true,
	
	        lastX: x,
	        lastY: y
	      });
	
	      // Add events to the document directly so we catch when the user's mouse/touch moves outside of
	      // this element. We use different events depending on whether or not we have detected that this
	      // is a touch-capable device.
	      (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
	      (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
	    }, _this.handleDrag = function (e) {
	
	      // Prevent scrolling on mobile devices, like ipad/iphone.
	      if (e.type === 'touchmove') e.preventDefault();
	
	      // Get the current drag point from the event. This is used as the offset.
	      var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
	      if (position == null) return;
	      var x = position.x,
	          y = position.y;
	
	      // Snap to grid if prop has been provided
	
	      if (Array.isArray(_this.props.grid)) {
	        var deltaX = x - _this.state.lastX,
	            deltaY = y - _this.state.lastY;
	
	        var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, deltaX, deltaY);
	
	        var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);
	
	        deltaX = _snapToGrid2[0];
	        deltaY = _snapToGrid2[1];
	
	        if (!deltaX && !deltaY) return; // skip useless drag
	        x = _this.state.lastX + deltaX, y = _this.state.lastY + deltaY;
	      }
	
	      var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);
	
	      (0, _log2.default)('DraggableCore: handleDrag: %j', coreEvent);
	
	      // Call event handler. If it returns explicit false, trigger end.
	      var shouldUpdate = _this.props.onDrag(e, coreEvent);
	      if (shouldUpdate === false) {
	        try {
	          // $FlowIgnore
	          _this.handleDragStop(new MouseEvent('mouseup'));
	        } catch (err) {
	          // Old browsers
	          var event = ((document.createEvent('MouseEvents') /*: any*/) /*: MouseTouchEvent*/);
	          // I see why this insanity was deprecated
	          // $FlowIgnore
	          event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
	          _this.handleDragStop(event);
	        }
	        return;
	      }
	
	      _this.setState({
	        lastX: x,
	        lastY: y
	      });
	    }, _this.handleDragStop = function (e) {
	      if (!_this.state.dragging) return;
	
	      var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
	      if (position == null) return;
	      var x = position.x,
	          y = position.y;
	
	      var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);
	
	      var _ReactDOM$findDOMNode = _reactDom2.default.findDOMNode(_this),
	          ownerDocument = _ReactDOM$findDOMNode.ownerDocument;
	
	      // Remove user-select hack
	
	
	      if (_this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument.body);
	
	      (0, _log2.default)('DraggableCore: handleDragStop: %j', coreEvent);
	
	      // Reset the el.
	      _this.setState({
	        dragging: false,
	        lastX: NaN,
	        lastY: NaN
	      });
	
	      // Call event handler
	      _this.props.onStop(e, coreEvent);
	
	      // Remove event handlers
	      (0, _log2.default)('DraggableCore: Removing handlers');
	      (0, _domFns.removeEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
	      (0, _domFns.removeEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
	    }, _this.onMouseDown = function (e) {
	      dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse
	
	      return _this.handleDragStart(e);
	    }, _this.onMouseUp = function (e) {
	      dragEventFor = eventsFor.mouse;
	
	      return _this.handleDragStop(e);
	    }, _this.onTouchStart = function (e) {
	      // We're on a touch device now, so change the event handlers
	      dragEventFor = eventsFor.touch;
	
	      return _this.handleDragStart(e);
	    }, _this.onTouchEnd = function (e) {
	      // We're on a touch device now, so change the event handlers
	      dragEventFor = eventsFor.touch;
	
	      return _this.handleDragStop(e);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  _createClass(DraggableCore, [{
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      // Remove any leftover event handlers. Remove both touch and mouse handlers in case
	      // some browser quirk caused a touch event to fire during a mouse move, or vice versa.
	      var _ReactDOM$findDOMNode2 = _reactDom2.default.findDOMNode(this),
	          ownerDocument = _ReactDOM$findDOMNode2.ownerDocument;
	
	      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
	      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
	      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
	      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
	      if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument.body);
	    }
	
	    // Same as onMouseDown (start drag), but now consider this a touch device.
	
	  }, {
	    key: 'render',
	    value: function render() /*: React.Element<any>*/ {
	      // Reuse the child provided
	      // This makes it flexible to use whatever element is wanted (div, ul, etc)
	      return _react2.default.cloneElement(_react2.default.Children.only(this.props.children), {
	        style: (0, _domFns.styleHacks)(this.props.children.props.style),
	
	        // Note: mouseMove handler is attached to document so it will still function
	        // when the user drags quickly and leaves the bounds of the element.
	        onMouseDown: this.onMouseDown,
	        onTouchStart: this.onTouchStart,
	        onMouseUp: this.onMouseUp,
	        onTouchEnd: this.onTouchEnd
	      });
	    }
	  }]);
	
	  return DraggableCore;
	}(_react2.default.Component);
	
	DraggableCore.displayName = 'DraggableCore';
	DraggableCore.propTypes = {
	  /**
	   * `allowAnyClick` allows dragging using any mouse button.
	   * By default, we only accept the left button.
	   *
	   * Defaults to `false`.
	   */
	  allowAnyClick: _propTypes2.default.bool,
	
	  /**
	   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
	   * with the exception of `onMouseDown`, will not fire.
	   */
	  disabled: _propTypes2.default.bool,
	
	  /**
	   * By default, we add 'user-select:none' attributes to the document body
	   * to prevent ugly text selection during drag. If this is causing problems
	   * for your app, set this to `false`.
	   */
	  enableUserSelectHack: _propTypes2.default.bool,
	
	  /**
	   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
	   * instead of using the parent node.
	   */
	  offsetParent: function offsetParent(props, propName) {
	    if (process.browser && props[propName] && props[propName].nodeType !== 1) {
	      throw new Error('Draggable\'s offsetParent must be a DOM Node.');
	    }
	  },
	
	  /**
	   * `grid` specifies the x and y that dragging should snap to.
	   */
	  grid: _propTypes2.default.arrayOf(_propTypes2.default.number),
	
	  /**
	   * `handle` specifies a selector to be used as the handle that initiates drag.
	   *
	   * Example:
	   *
	   * ```jsx
	   *   let App = React.createClass({
	   *       render: function () {
	   *         return (
	   *            <Draggable handle=".handle">
	   *              <div>
	   *                  <div className="handle">Click me to drag</div>
	   *                  <div>This is some other content</div>
	   *              </div>
	   *           </Draggable>
	   *         );
	   *       }
	   *   });
	   * ```
	   */
	  handle: _propTypes2.default.string,
	
	  /**
	   * `cancel` specifies a selector to be used to prevent drag initialization.
	   *
	   * Example:
	   *
	   * ```jsx
	   *   let App = React.createClass({
	   *       render: function () {
	   *           return(
	   *               <Draggable cancel=".cancel">
	   *                   <div>
	   *                     <div className="cancel">You can't drag from here</div>
	   *                     <div>Dragging here works fine</div>
	   *                   </div>
	   *               </Draggable>
	   *           );
	   *       }
	   *   });
	   * ```
	   */
	  cancel: _propTypes2.default.string,
	
	  /**
	   * Called when dragging starts.
	   * If this function returns the boolean false, dragging will be canceled.
	   */
	  onStart: _propTypes2.default.func,
	
	  /**
	   * Called while dragging.
	   * If this function returns the boolean false, dragging will be canceled.
	   */
	  onDrag: _propTypes2.default.func,
	
	  /**
	   * Called when dragging stops.
	   * If this function returns the boolean false, the drag will remain active.
	   */
	  onStop: _propTypes2.default.func,
	
	  /**
	   * A workaround option which can be passed if onMouseDown needs to be accessed,
	   * since it'll always be blocked (as there is internal use of onMouseDown)
	   */
	  onMouseDown: _propTypes2.default.func,
	
	  /**
	   * These properties should be defined on the child, not here.
	   */
	  className: _shims.dontSetMe,
	  style: _shims.dontSetMe,
	  transform: _shims.dontSetMe
	};
	DraggableCore.defaultProps = {
	  allowAnyClick: false, // by default only accept left click
	  cancel: null,
	  disabled: false,
	  enableUserSelectHack: true,
	  offsetParent: null,
	  handle: null,
	  grid: null,
	  transform: null,
	  onStart: function onStart() {},
	  onDrag: function onDrag() {},
	  onStop: function onStop() {},
	  onMouseDown: function onMouseDown() {}
	};
	exports.default = DraggableCore;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18)))

/***/ },
/* 18 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = log;
	
	/*eslint no-console:0*/
	function log() {
	  var _console;
	
	  if ((undefined)) (_console = console).log.apply(_console, arguments);
	}

/***/ }
/******/ ])
});
;
//# sourceMappingURL=react-draggable.js.map

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// React.addons.cloneWithProps look-alike that merges style & className.
module.exports = function cloneElement(element, props) {
  if (props.style && element.props.style) {
    props.style = _extends({}, element.props.style, props.style);
  }
  if (props.className && element.props.className) {
    props.className = element.props.className + ' ' + props.className;
  }
  return _react2.default.cloneElement(element, props);
};

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Resizable = __webpack_require__(187);

var _Resizable2 = _interopRequireDefault(_Resizable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// An example use of Resizable.
var ResizableBox = function (_React$Component) {
  _inherits(ResizableBox, _React$Component);

  function ResizableBox() {
    var _temp, _this, _ret;

    _classCallCheck(this, ResizableBox);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      width: _this.props.width,
      height: _this.props.height
    }, _this.onResize = function (e, data) {
      var size = data.size;
      var width = size.width,
          height = size.height;


      if (_this.props.onResize) {
        e.persist && e.persist();
        _this.setState(size, function () {
          return _this.props.onResize && _this.props.onResize(e, data);
        });
      } else {
        _this.setState(size);
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  ResizableBox.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.width !== this.props.width || nextProps.height !== this.props.height) {
      this.setState({
        width: nextProps.width,
        height: nextProps.height
      });
    }
  };

  ResizableBox.prototype.render = function render() {
    // Basic wrapper around a Resizable instance.
    // If you use Resizable directly, you are responsible for updating the child component
    // with a new width and height.
    var _props = this.props,
        handleSize = _props.handleSize,
        onResize = _props.onResize,
        onResizeStart = _props.onResizeStart,
        onResizeStop = _props.onResizeStop,
        draggableOpts = _props.draggableOpts,
        minConstraints = _props.minConstraints,
        maxConstraints = _props.maxConstraints,
        lockAspectRatio = _props.lockAspectRatio,
        axis = _props.axis,
        width = _props.width,
        height = _props.height,
        props = _objectWithoutProperties(_props, ['handleSize', 'onResize', 'onResizeStart', 'onResizeStop', 'draggableOpts', 'minConstraints', 'maxConstraints', 'lockAspectRatio', 'axis', 'width', 'height']);

    return _react2.default.createElement(
      _Resizable2.default,
      {
        handleSize: handleSize,
        width: this.state.width,
        height: this.state.height,
        onResizeStart: onResizeStart,
        onResize: this.onResize,
        onResizeStop: onResizeStop,
        draggableOpts: draggableOpts,
        minConstraints: minConstraints,
        maxConstraints: maxConstraints,
        lockAspectRatio: lockAspectRatio,
        axis: axis
      },
      _react2.default.createElement('div', _extends({ style: { width: this.state.width + 'px', height: this.state.height + 'px' } }, props))
    );
  };

  return ResizableBox;
}(_react2.default.Component);

ResizableBox.propTypes = {
  height: _propTypes2.default.number,
  width: _propTypes2.default.number
};
ResizableBox.defaultProps = {
  handleSize: [20, 20]
};
exports.default = ResizableBox;

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lodash = __webpack_require__(119);

var _lodash2 = _interopRequireDefault(_lodash);

var _utils = __webpack_require__(56);

var _responsiveUtils = __webpack_require__(188);

var _ReactGridLayout = __webpack_require__(185);

var _ReactGridLayout2 = _interopRequireDefault(_ReactGridLayout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var type = function type(obj) {
  return Object.prototype.toString.call(obj);
};

var ResponsiveReactGridLayout = function (_React$Component) {
  _inherits(ResponsiveReactGridLayout, _React$Component);

  function ResponsiveReactGridLayout() {
    var _temp, _this, _ret;

    _classCallCheck(this, ResponsiveReactGridLayout);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = _this.generateInitialState(), _this.onLayoutChange = function (layout) {
      var _extends2;

      _this.props.onLayoutChange(layout, _extends({}, _this.props.layouts, (_extends2 = {}, _extends2[_this.state.breakpoint] = layout, _extends2)));
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }
  // This should only include propTypes needed in this code; RGL itself
  // will do validation of the rest props passed to it.


  ResponsiveReactGridLayout.prototype.generateInitialState = function generateInitialState() {
    var _props = this.props,
        width = _props.width,
        breakpoints = _props.breakpoints,
        layouts = _props.layouts,
        cols = _props.cols;

    var breakpoint = (0, _responsiveUtils.getBreakpointFromWidth)(breakpoints, width);
    var colNo = (0, _responsiveUtils.getColsFromBreakpoint)(breakpoint, cols);
    // verticalCompact compatibility, now deprecated
    var compactType = this.props.verticalCompact === false ? null : this.props.compactType;
    // Get the initial layout. This can tricky; we try to generate one however possible if one doesn't exist
    // for this layout.
    var initialLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(layouts, breakpoints, breakpoint, breakpoint, colNo, compactType);

    return {
      layout: initialLayout,
      breakpoint: breakpoint,
      cols: colNo
    };
  };

  ResponsiveReactGridLayout.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    // Allow parent to set width or breakpoint directly.
    if (nextProps.width != this.props.width || nextProps.breakpoint !== this.props.breakpoint || !(0, _lodash2.default)(nextProps.breakpoints, this.props.breakpoints) || !(0, _lodash2.default)(nextProps.cols, this.props.cols)) {
      this.onWidthChange(nextProps);
    } else if (!(0, _lodash2.default)(nextProps.layouts, this.props.layouts)) {
      // Allow parent to set layouts directly.
      var _state = this.state,
          _breakpoint = _state.breakpoint,
          _cols = _state.cols;

      // Since we're setting an entirely new layout object, we must generate a new responsive layout
      // if one does not exist.

      var newLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(nextProps.layouts, nextProps.breakpoints, _breakpoint, _breakpoint, _cols, nextProps.compactType);
      this.setState({ layout: newLayout });
    }
  };

  // wrap layouts so we do not need to pass layouts to child


  /**
   * When the width changes work through breakpoints and reset state with the new width & breakpoint.
   * Width changes are necessary to figure out the widget widths.
   */
  ResponsiveReactGridLayout.prototype.onWidthChange = function onWidthChange(nextProps) {
    var breakpoints = nextProps.breakpoints,
        cols = nextProps.cols,
        layouts = nextProps.layouts,
        compactType = nextProps.compactType;

    var newBreakpoint = nextProps.breakpoint || (0, _responsiveUtils.getBreakpointFromWidth)(nextProps.breakpoints, nextProps.width);

    var lastBreakpoint = this.state.breakpoint;

    // Breakpoint change
    if (lastBreakpoint !== newBreakpoint || this.props.breakpoints !== breakpoints || this.props.cols !== cols) {
      // Preserve the current layout if the current breakpoint is not present in the next layouts.
      if (!(lastBreakpoint in layouts)) layouts[lastBreakpoint] = (0, _utils.cloneLayout)(this.state.layout);

      // Find or generate a new layout.
      var newCols = (0, _responsiveUtils.getColsFromBreakpoint)(newBreakpoint, cols);
      var _layout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(layouts, breakpoints, newBreakpoint, lastBreakpoint, newCols, compactType);

      // This adds missing items.
      _layout = (0, _utils.synchronizeLayoutWithChildren)(_layout, nextProps.children, newCols, compactType);

      // Store the new layout.
      layouts[newBreakpoint] = _layout;

      // callbacks
      this.props.onLayoutChange(_layout, layouts);
      this.props.onBreakpointChange(newBreakpoint, newCols);
      this.props.onWidthChange(nextProps.width, nextProps.margin, newCols, nextProps.containerPadding);

      this.setState({
        breakpoint: newBreakpoint,
        layout: _layout,
        cols: newCols
      });
    }
  };

  ResponsiveReactGridLayout.prototype.render = function render() {
    /* eslint-disable no-unused-vars */
    var _props2 = this.props,
        breakpoint = _props2.breakpoint,
        breakpoints = _props2.breakpoints,
        cols = _props2.cols,
        layouts = _props2.layouts,
        onBreakpointChange = _props2.onBreakpointChange,
        onLayoutChange = _props2.onLayoutChange,
        onWidthChange = _props2.onWidthChange,
        other = _objectWithoutProperties(_props2, ["breakpoint", "breakpoints", "cols", "layouts", "onBreakpointChange", "onLayoutChange", "onWidthChange"]);
    /* eslint-enable no-unused-vars */

    return _react2.default.createElement(_ReactGridLayout2.default, _extends({}, other, {
      onLayoutChange: this.onLayoutChange,
      layout: this.state.layout,
      cols: this.state.cols
    }));
  };

  return ResponsiveReactGridLayout;
}(_react2.default.Component);

ResponsiveReactGridLayout.propTypes = {
  //
  // Basic props
  //

  // Optional, but if you are managing width yourself you may want to set the breakpoint
  // yourself as well.
  breakpoint: _propTypes2.default.string,

  // {name: pxVal}, e.g. {lg: 1200, md: 996, sm: 768, xs: 480}
  breakpoints: _propTypes2.default.object,

  // # of cols. This is a breakpoint -> cols map
  cols: _propTypes2.default.object,

  // layouts is an object mapping breakpoints to layouts.
  // e.g. {lg: Layout, md: Layout, ...}
  layouts: function layouts(props, propName) {
    if (type(props[propName]) !== "[object Object]") {
      throw new Error("Layout property must be an object. Received: " + type(props[propName]));
    }
    Object.keys(props[propName]).forEach(function (key) {
      if (!(key in props.breakpoints)) {
        throw new Error("Each key in layouts must align with a key in breakpoints.");
      }
      (0, _utils.validateLayout)(props.layouts[key], "layouts." + key);
    });
  },


  // The width of this component.
  // Required in this propTypes stanza because generateInitialState() will fail without it.
  width: _propTypes2.default.number.isRequired,

  //
  // Callbacks
  //

  // Calls back with breakpoint and new # cols
  onBreakpointChange: _propTypes2.default.func,

  // Callback so you can save the layout.
  // Calls back with (currentLayout, allLayouts). allLayouts are keyed by breakpoint.
  onLayoutChange: _propTypes2.default.func,

  // Calls back with (containerWidth, margin, cols, containerPadding)
  onWidthChange: _propTypes2.default.func
};
ResponsiveReactGridLayout.defaultProps = {
  breakpoints: { lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 },
  cols: { lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 },
  layouts: {},
  onBreakpointChange: _utils.noop,
  onLayoutChange: _utils.noop,
  onWidthChange: _utils.noop
};
exports.default = ResponsiveReactGridLayout;

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = WidthProvider;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__(8);

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * A simple HOC that provides facility for listening to container resizes.
 */
function WidthProvider(ComposedComponent) {
  var _class, _temp2;

  return _temp2 = _class = function (_React$Component) {
    _inherits(WidthProvider, _React$Component);

    function WidthProvider() {
      var _temp, _this, _ret;

      _classCallCheck(this, WidthProvider);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
        width: 1280
      }, _this.mounted = false, _this.onWindowResize = function () {
        if (!_this.mounted) return;
        // eslint-disable-next-line
        var node = _reactDom2.default.findDOMNode(_this); // Flow casts this to Text | Element
        if (node instanceof HTMLElement) _this.setState({ width: node.offsetWidth });
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    WidthProvider.prototype.componentDidMount = function componentDidMount() {
      this.mounted = true;

      window.addEventListener("resize", this.onWindowResize);
      // Call to properly set the breakpoint and resize the elements.
      // Note that if you're doing a full-width element, this can get a little wonky if a scrollbar
      // appears because of the grid. In that case, fire your own resize event, or set `overflow: scroll` on your body.
      this.onWindowResize();
    };

    WidthProvider.prototype.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
      window.removeEventListener("resize", this.onWindowResize);
    };

    WidthProvider.prototype.render = function render() {
      var _props = this.props,
          measureBeforeMount = _props.measureBeforeMount,
          rest = _objectWithoutProperties(_props, ["measureBeforeMount"]);

      if (measureBeforeMount && !this.mounted) {
        return _react2.default.createElement("div", { className: this.props.className, style: this.props.style });
      }

      return _react2.default.createElement(ComposedComponent, _extends({}, rest, this.state));
    };

    return WidthProvider;
  }(_react2.default.Component), _class.defaultProps = {
    measureBeforeMount: false
  }, _class.propTypes = {
    // If true, will not render children until mounted. Useful for getting the exact width before
    // rendering, to prevent any unsightly resizing.
    measureBeforeMount: _propTypes2.default.bool
  }, _temp2;
}

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/**
 * Copyright Marc J. Schmidt. See the LICENSE file at the top-level
 * directory of this distribution and at
 * https://github.com/marcj/css-element-queries/blob/master/LICENSE.
 */
(function (root, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(190)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === "object") {
        module.exports = factory(require('./ResizeSensor.js'));
    } else {
        root.ElementQueries = factory(root.ResizeSensor);
        root.ElementQueries.listen();
    }
}(typeof window !== 'undefined' ? window : this, function (ResizeSensor) {

    /**
     *
     * @type {Function}
     * @constructor
     */
    var ElementQueries = function () {
        //<style> element with our dynamically created styles
        var cssStyleElement;

        //all rules found for element queries
        var allQueries = {};

        //association map to identify which selector belongs to a element from the animationstart event.
        var idToSelectorMapping = [];

        /**
         *
         * @param element
         * @returns {Number}
         */
        function getEmSize(element) {
            if (!element) {
                element = document.documentElement;
            }
            var fontSize = window.getComputedStyle(element, null).fontSize;
            return parseFloat(fontSize) || 16;
        }

        /**
         * Get element size
         * @param {HTMLElement} element
         * @returns {Object} {width, height}
         */
        function getElementSize(element) {
            if (!element.getBoundingClientRect) {
                return {
                    width: element.offsetWidth,
                    height: element.offsetHeight
                }
            }

            var rect = element.getBoundingClientRect();
            return {
                width: Math.round(rect.width),
                height: Math.round(rect.height)
            }
        }

        /**
         *
         * @copyright https://github.com/Mr0grog/element-query/blob/master/LICENSE
         *
         * @param {HTMLElement} element
         * @param {*} value
         * @returns {*}
         */
        function convertToPx(element, value) {
            var numbers = value.split(/\d/);
            var units = numbers[numbers.length - 1];
            value = parseFloat(value);
            switch (units) {
                case "px":
                    return value;
                case "em":
                    return value * getEmSize(element);
                case "rem":
                    return value * getEmSize();
                // Viewport units!
                // According to http://quirksmode.org/mobile/tableViewport.html
                // documentElement.clientWidth/Height gets us the most reliable info
                case "vw":
                    return value * document.documentElement.clientWidth / 100;
                case "vh":
                    return value * document.documentElement.clientHeight / 100;
                case "vmin":
                case "vmax":
                    var vw = document.documentElement.clientWidth / 100;
                    var vh = document.documentElement.clientHeight / 100;
                    var chooser = Math[units === "vmin" ? "min" : "max"];
                    return value * chooser(vw, vh);
                default:
                    return value;
                // for now, not supporting physical units (since they are just a set number of px)
                // or ex/ch (getting accurate measurements is hard)
            }
        }

        /**
         *
         * @param {HTMLElement} element
         * @param {String} id
         * @constructor
         */
        function SetupInformation(element, id) {
            this.element = element;
            var key, option, elementSize, value, actualValue, attrValues, attrValue, attrName;

            var attributes = ['min-width', 'min-height', 'max-width', 'max-height'];

            /**
             * Extracts the computed width/height and sets to min/max- attribute.
             */
            this.call = function () {
                // extract current dimensions
                elementSize = getElementSize(this.element);

                attrValues = {};

                for (key in allQueries[id]) {
                    if (!allQueries[id].hasOwnProperty(key)) {
                        continue;
                    }
                    option = allQueries[id][key];

                    value = convertToPx(this.element, option.value);

                    actualValue = option.property === 'width' ? elementSize.width : elementSize.height;
                    attrName = option.mode + '-' + option.property;
                    attrValue = '';

                    if (option.mode === 'min' && actualValue >= value) {
                        attrValue += option.value;
                    }

                    if (option.mode === 'max' && actualValue <= value) {
                        attrValue += option.value;
                    }

                    if (!attrValues[attrName]) attrValues[attrName] = '';
                    if (attrValue && -1 === (' ' + attrValues[attrName] + ' ').indexOf(' ' + attrValue + ' ')) {
                        attrValues[attrName] += ' ' + attrValue;
                    }
                }

                for (var k in attributes) {
                    if (!attributes.hasOwnProperty(k)) continue;

                    if (attrValues[attributes[k]]) {
                        this.element.setAttribute(attributes[k], attrValues[attributes[k]].substr(1));
                    } else {
                        this.element.removeAttribute(attributes[k]);
                    }
                }
            };
        }

        /**
         * @param {HTMLElement} element
         * @param {Object}      id
         */
        function setupElement(element, id) {
            if (!element.elementQueriesSetupInformation) {
                element.elementQueriesSetupInformation = new SetupInformation(element, id);
            }
            if (!element.elementQueriesSensor) {
                element.elementQueriesSensor = new ResizeSensor(element, function () {
                    element.elementQueriesSetupInformation.call();
                });
            }

            element.elementQueriesSetupInformation.call();
        }

        /**
         * Stores rules to the selector that should be applied once resized.
         *
         * @param {String} selector
         * @param {String} mode min|max
         * @param {String} property width|height
         * @param {String} value
         */
        function queueQuery(selector, mode, property, value) {
            if (typeof(allQueries[selector]) === 'undefined') {
                allQueries[selector] = [];
                // add animation to trigger animationstart event, so we know exactly when a element appears in the DOM

                var id = idToSelectorMapping.length;
                cssStyleElement.innerHTML += '\n' + selector + ' {animation: 0.1s element-queries;}';
                cssStyleElement.innerHTML += '\n' + selector + ' > .resize-sensor {min-width: '+id+'px;}';
                idToSelectorMapping.push(selector);
            }

            allQueries[selector].push({
                mode: mode,
                property: property,
                value: value
            });
        }

        function getQuery(container) {
            var query;
            if (document.querySelectorAll) query = (container) ? container.querySelectorAll.bind(container) : document.querySelectorAll.bind(document);
            if (!query && 'undefined' !== typeof $$) query = $$;
            if (!query && 'undefined' !== typeof jQuery) query = jQuery;

            if (!query) {
                throw 'No document.querySelectorAll, jQuery or Mootools\'s $$ found.';
            }

            return query;
        }

        /**
         * If animationStart didn't catch a new element in the DOM, we can manually search for it
         */
        function findElementQueriesElements(container) {
            var query = getQuery(container);

            for (var selector in allQueries) if (allQueries.hasOwnProperty(selector)) {
                // find all elements based on the extract query selector from the element query rule
                var elements = query(selector, container);

                for (var i = 0, j = elements.length; i < j; i++) {
                    setupElement(elements[i], selector);
                }
            }
        }

        /**
         *
         * @param {HTMLElement} element
         */
        function attachResponsiveImage(element) {
            var children = [];
            var rules = [];
            var sources = [];
            var defaultImageId = 0;
            var lastActiveImage = -1;
            var loadedImages = [];

            for (var i in element.children) {
                if (!element.children.hasOwnProperty(i)) continue;

                if (element.children[i].tagName && element.children[i].tagName.toLowerCase() === 'img') {
                    children.push(element.children[i]);

                    var minWidth = element.children[i].getAttribute('min-width') || element.children[i].getAttribute('data-min-width');
                    //var minHeight = element.children[i].getAttribute('min-height') || element.children[i].getAttribute('data-min-height');
                    var src = element.children[i].getAttribute('data-src') || element.children[i].getAttribute('url');

                    sources.push(src);

                    var rule = {
                        minWidth: minWidth
                    };

                    rules.push(rule);

                    if (!minWidth) {
                        defaultImageId = children.length - 1;
                        element.children[i].style.display = 'block';
                    } else {
                        element.children[i].style.display = 'none';
                    }
                }
            }

            lastActiveImage = defaultImageId;

            function check() {
                var imageToDisplay = false, i;

                for (i in children) {
                    if (!children.hasOwnProperty(i)) continue;

                    if (rules[i].minWidth) {
                        if (element.offsetWidth > rules[i].minWidth) {
                            imageToDisplay = i;
                        }
                    }
                }

                if (!imageToDisplay) {
                    //no rule matched, show default
                    imageToDisplay = defaultImageId;
                }

                if (lastActiveImage !== imageToDisplay) {
                    //image change

                    if (!loadedImages[imageToDisplay]) {
                        //image has not been loaded yet, we need to load the image first in memory to prevent flash of
                        //no content

                        var image = new Image();
                        image.onload = function () {
                            children[imageToDisplay].src = sources[imageToDisplay];

                            children[lastActiveImage].style.display = 'none';
                            children[imageToDisplay].style.display = 'block';

                            loadedImages[imageToDisplay] = true;

                            lastActiveImage = imageToDisplay;
                        };

                        image.src = sources[imageToDisplay];
                    } else {
                        children[lastActiveImage].style.display = 'none';
                        children[imageToDisplay].style.display = 'block';
                        lastActiveImage = imageToDisplay;
                    }
                } else {
                    //make sure for initial check call the .src is set correctly
                    children[imageToDisplay].src = sources[imageToDisplay];
                }
            }

            element.resizeSensor = new ResizeSensor(element, check);
            check();
        }

        function findResponsiveImages() {
            var query = getQuery();

            var elements = query('[data-responsive-image],[responsive-image]');
            for (var i = 0, j = elements.length; i < j; i++) {
                attachResponsiveImage(elements[i]);
            }
        }

        var regex = /,?[\s\t]*([^,\n]*?)((?:\[[\s\t]*?(?:min|max)-(?:width|height)[\s\t]*?[~$\^]?=[\s\t]*?"[^"]*?"[\s\t]*?])+)([^,\n\s\{]*)/mgi;
        var attrRegex = /\[[\s\t]*?(min|max)-(width|height)[\s\t]*?[~$\^]?=[\s\t]*?"([^"]*?)"[\s\t]*?]/mgi;

        /**
         * @param {String} css
         */
        function extractQuery(css) {
            var match, smatch, attrs, attrMatch;

            css = css.replace(/'/g, '"');
            while (null !== (match = regex.exec(css))) {
                smatch = match[1] + match[3];
                attrs = match[2];

                while (null !== (attrMatch = attrRegex.exec(attrs))) {
                    queueQuery(smatch, attrMatch[1], attrMatch[2], attrMatch[3]);
                }
            }
        }

        /**
         * @param {CssRule[]|String} rules
         */
        function readRules(rules) {
            var selector = '';

            if (!rules) {
                return;
            }

            if ('string' === typeof rules) {
                rules = rules.toLowerCase();
                if (-1 !== rules.indexOf('min-width') || -1 !== rules.indexOf('max-width')) {
                    extractQuery(rules);
                }
            } else {
                for (var i = 0, j = rules.length; i < j; i++) {
                    if (1 === rules[i].type) {
                        selector = rules[i].selectorText || rules[i].cssText;
                        if (-1 !== selector.indexOf('min-height') || -1 !== selector.indexOf('max-height')) {
                            extractQuery(selector);
                        } else if (-1 !== selector.indexOf('min-width') || -1 !== selector.indexOf('max-width')) {
                            extractQuery(selector);
                        }
                    } else if (4 === rules[i].type) {
                        readRules(rules[i].cssRules || rules[i].rules);
                    } else if (3 === rules[i].type) {
                        if(rules[i].styleSheet.hasOwnProperty("cssRules")) {
                            readRules(rules[i].styleSheet.cssRules);
                        }
                    }
                }
            }
        }

        var defaultCssInjected = false;

        /**
         * Searches all css rules and setups the event listener to all elements with element query rules..
         */
        this.init = function () {
            var animationStart = 'animationstart';
            if (typeof document.documentElement.style['webkitAnimationName'] !== 'undefined') {
                animationStart = 'webkitAnimationStart';
            } else if (typeof document.documentElement.style['MozAnimationName'] !== 'undefined') {
                animationStart = 'mozanimationstart';
            } else if (typeof document.documentElement.style['OAnimationName'] !== 'undefined') {
                animationStart = 'oanimationstart';
            }

            document.body.addEventListener(animationStart, function (e) {
                var element = e.target;
                var styles = window.getComputedStyle(element, null);

                if (-1 !== styles.getPropertyValue('animation-name').indexOf('element-queries')) {
                    element.elementQueriesSensor = new ResizeSensor(element, function () {
                        if (element.elementQueriesSetupInformation) {
                            element.elementQueriesSetupInformation.call();
                        }
                    });

                    var sensorStyles = window.getComputedStyle(element.resizeSensor, null);
                    var id = sensorStyles.getPropertyValue('min-width');
                    id = parseInt(id.replace('px', ''));
                    setupElement(e.target, idToSelectorMapping[id]);
                }
            });

            if (!defaultCssInjected) {
                cssStyleElement = document.createElement('style');
                cssStyleElement.type = 'text/css';
                cssStyleElement.innerHTML = '[responsive-image] > img, [data-responsive-image] {overflow: hidden; padding: 0; } [responsive-image] > img, [data-responsive-image] > img {width: 100%;}';

                //safari wants at least one rule in keyframes to start working
                cssStyleElement.innerHTML += '\n@keyframes element-queries { 0% { visibility: inherit; } }';
                document.getElementsByTagName('head')[0].appendChild(cssStyleElement);
                defaultCssInjected = true;
            }

            for (var i = 0, j = document.styleSheets.length; i < j; i++) {
                try {
                    if (document.styleSheets[i].href && 0 === document.styleSheets[i].href.indexOf('file://')) {
                        console.log("CssElementQueries: unable to parse local css files, " + document.styleSheets[i].href);
                    }

                    readRules(document.styleSheets[i].cssRules || document.styleSheets[i].rules || document.styleSheets[i].cssText);
                } catch (e) {
                }
            }

            findResponsiveImages();
        };

        /**
         * Go through all collected rules (readRules()) and attach the resize-listener.
         * Not necessary to call it manually, since we detect automatically when new elements
         * are available in the DOM. However, sometimes handy for dirty DOM modifications.
         *
         * @param {HTMLElement} container only elements of the container are considered (document.body if not set)
         */
        this.findElementQueriesElements = function (container) {
            findElementQueriesElements(container);
        };

        this.update = function () {
            this.init();
        };
    };

    ElementQueries.update = function () {
        ElementQueries.instance.update();
    };

    /**
     * Removes all sensor and elementquery information from the element.
     *
     * @param {HTMLElement} element
     */
    ElementQueries.detach = function (element) {
        if (element.elementQueriesSetupInformation) {
            //element queries
            element.elementQueriesSensor.detach();
            delete element.elementQueriesSetupInformation;
            delete element.elementQueriesSensor;

        } else if (element.resizeSensor) {
            //responsive image

            element.resizeSensor.detach();
            delete element.resizeSensor;
        }
    };

    ElementQueries.init = function () {
        if (!ElementQueries.instance) {
            ElementQueries.instance = new ElementQueries();
        }

        ElementQueries.instance.init();
    };

    var domLoaded = function (callback) {
        /* Mozilla, Chrome, Opera */
        if (document.addEventListener) {
            document.addEventListener('DOMContentLoaded', callback, false);
        }
        /* Safari, iCab, Konqueror */
        else if (/KHTML|WebKit|iCab/i.test(navigator.userAgent)) {
            var DOMLoadTimer = setInterval(function () {
                if (/loaded|complete/i.test(document.readyState)) {
                    callback();
                    clearInterval(DOMLoadTimer);
                }
            }, 10);
        }
        /* Other web browsers */
        else window.onload = callback;
    };

    ElementQueries.findElementQueriesElements = function (container) {
        ElementQueries.instance.findElementQueriesElements(container);
    };

    ElementQueries.listen = function () {
        domLoaded(ElementQueries.init);
    };

    return ElementQueries;

}));


/***/ }),
/* 376 */
/***/ (function(module, exports) {

/**
* vkBeautify - javascript plugin to pretty-print or minify text in XML, JSON, CSS and SQL formats.
*
* Copyright (c) 2012 Vadim Kiryukhin
* vkiryukhin @ gmail.com
* http://www.eslinstructor.net/vkbeautify/
*
* Dual licensed under the MIT and GPL licenses:
*   http://www.opensource.org/licenses/mit-license.php
*   http://www.gnu.org/licenses/gpl.html
*
*   Pretty print
*
*        vkbeautify.xml(text [,indent_pattern]);
*        vkbeautify.json(text [,indent_pattern]);
*        vkbeautify.css(text [,indent_pattern]);
*        vkbeautify.sql(text [,indent_pattern]);
*
*        @text - String; text to beatufy;
*        @indent_pattern - Integer | String;
*                Integer:  number of white spaces;
*                String:   character string to visualize indentation ( can also be a set of white spaces )
*   Minify
*
*        vkbeautify.xmlmin(text [,preserve_comments]);
*        vkbeautify.jsonmin(text);
*        vkbeautify.cssmin(text [,preserve_comments]);
*        vkbeautify.sqlmin(text);
*
*        @text - String; text to minify;
*        @preserve_comments - Bool; [optional];
*                Set this flag to true to prevent removing comments from @text ( minxml and mincss functions only. )
*
*   Examples:
*        vkbeautify.xml(text); // pretty print XML
*        vkbeautify.json(text, 4 ); // pretty print JSON
*        vkbeautify.css(text, '. . . .'); // pretty print CSS
*        vkbeautify.sql(text, '----'); // pretty print SQL
*
*        vkbeautify.xmlmin(text, true);// minify XML, preserve comments
*        vkbeautify.jsonmin(text);// minify JSON
*        vkbeautify.cssmin(text);// minify CSS, remove comments ( default )
*        vkbeautify.sqlmin(text);// minify SQL
*
*/
function createShiftArr(step) {

	var space = '    ';

	if ( isNaN(parseInt(step)) ) {  // argument is string
		space = step;
	} else { // argument is integer
		switch(step) {
			case 1: space = ' '; break;
			case 2: space = '  '; break;
			case 3: space = '   '; break;
			case 4: space = '    '; break;
			case 5: space = '     '; break;
			case 6: space = '      '; break;
			case 7: space = '       '; break;
			case 8: space = '        '; break;
			case 9: space = '         '; break;
			case 10: space = '          '; break;
			case 11: space = '           '; break;
			case 12: space = '            '; break;
		}
	}

	var shift = ['\n']; // array of shifts
	for(var ix=0;ix<100;ix++) {
		shift.push(shift[ix]+space);
	}
	return shift;
}

function vkbeautify(){
	this.step = '    '; // 4 spaces
	this.shift = createShiftArr(this.step);
};

vkbeautify.prototype.xml = function(text,step) {

	var ar = text.replace(/>\s{0,}</g,"><")
				 .replace(/</g,"~::~<")
				 .replace(/\s*xmlns\:/g,"~::~xmlns:")
				 .replace(/\s*xmlns\=/g,"~::~xmlns=")
				 .split('~::~'),
		len = ar.length,
		inComment = false,
		deep = 0,
		str = '',
		ix = 0,
		shift = step ? createShiftArr(step) : this.shift;

		for(ix=0;ix<len;ix++) {
			// start comment or <![CDATA[...]]> or <!DOCTYPE //
			if(ar[ix].search(/<!/) > -1) {
				str += shift[deep]+ar[ix];
				inComment = true;
				// end comment  or <![CDATA[...]]> //
				if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1 || ar[ix].search(/!DOCTYPE/) > -1 ) {
					inComment = false;
				}
			} else
			// end comment  or <![CDATA[...]]> //
			if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1) {
				str += ar[ix];
				inComment = false;
			} else
			// <elm></elm> //
			if( /^<\w/.exec(ar[ix-1]) && /^<\/\w/.exec(ar[ix]) &&
				/^<[\w:\-\.\,]+/.exec(ar[ix-1]) == /^<\/[\w:\-\.\,]+/.exec(ar[ix])[0].replace('/','')) {
				str += ar[ix];
				if(!inComment) deep--;
			} else
			 // <elm> //
			if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) == -1 && ar[ix].search(/\/>/) == -1 ) {
				str = !inComment ? str += shift[deep++]+ar[ix] : str += ar[ix];
			} else
			 // <elm>...</elm> //
			if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) > -1) {
				str = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];
			} else
			// </elm> //
			if(ar[ix].search(/<\//) > -1) {
				str = !inComment ? str += shift[--deep]+ar[ix] : str += ar[ix];
			} else
			// <elm/> //
			if(ar[ix].search(/\/>/) > -1 ) {
				str = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];
			} else
			// <? xml ... ?> //
			if(ar[ix].search(/<\?/) > -1) {
				str += shift[deep]+ar[ix];
			} else
			// xmlns //
			if( ar[ix].search(/xmlns\:/) > -1  || ar[ix].search(/xmlns\=/) > -1) {
				str += shift[deep]+ar[ix];
			}

			else {
				str += ar[ix];
			}
		}

	return  (str[0] == '\n') ? str.slice(1) : str;
}

vkbeautify.prototype.json = function(text,step) {

	var step = step ? step : this.step;

	if (typeof JSON === 'undefined' ) return text;

	if ( typeof text === "string" ) return JSON.stringify(JSON.parse(text), null, step);
	if ( typeof text === "object" ) return JSON.stringify(text, null, step);

	return text; // text is not string nor object
}

vkbeautify.prototype.css = function(text, step) {

	var ar = text.replace(/\s{1,}/g,' ')
				.replace(/\{/g,"{~::~")
				.replace(/\}/g,"~::~}~::~")
				.replace(/\;/g,";~::~")
				.replace(/\/\*/g,"~::~/*")
				.replace(/\*\//g,"*/~::~")
				.replace(/~::~\s{0,}~::~/g,"~::~")
				.split('~::~'),
		len = ar.length,
		deep = 0,
		str = '',
		ix = 0,
		shift = step ? createShiftArr(step) : this.shift;

		for(ix=0;ix<len;ix++) {

			if( /\{/.exec(ar[ix]))  {
				str += shift[deep++]+ar[ix];
			} else
			if( /\}/.exec(ar[ix]))  {
				str += shift[--deep]+ar[ix];
			} else
			if( /\*\\/.exec(ar[ix]))  {
				str += shift[deep]+ar[ix];
			}
			else {
				str += shift[deep]+ar[ix];
			}
		}
		return str.replace(/^\n{1,}/,'');
}

//----------------------------------------------------------------------------

function isSubquery(str, parenthesisLevel) {
	return  parenthesisLevel - (str.replace(/\(/g,'').length - str.replace(/\)/g,'').length )
}

function split_sql(str, tab) {

	return str.replace(/\s{1,}/g," ")

				.replace(/ AND /ig,"~::~"+tab+tab+"AND ")
				.replace(/ BETWEEN /ig,"~::~"+tab+"BETWEEN ")
				.replace(/ CASE /ig,"~::~"+tab+"CASE ")
				.replace(/ ELSE /ig,"~::~"+tab+"ELSE ")
				.replace(/ END /ig,"~::~"+tab+"END ")
				.replace(/ FROM /ig,"~::~FROM ")
				.replace(/ GROUP\s{1,}BY/ig,"~::~GROUP BY ")
				.replace(/ HAVING /ig,"~::~HAVING ")
				//.replace(/ SET /ig," SET~::~")
				.replace(/ IN /ig," IN ")

				.replace(/ JOIN /ig,"~::~JOIN ")
				.replace(/ CROSS~::~{1,}JOIN /ig,"~::~CROSS JOIN ")
				.replace(/ INNER~::~{1,}JOIN /ig,"~::~INNER JOIN ")
				.replace(/ LEFT~::~{1,}JOIN /ig,"~::~LEFT JOIN ")
				.replace(/ RIGHT~::~{1,}JOIN /ig,"~::~RIGHT JOIN ")

				.replace(/ ON /ig,"~::~"+tab+"ON ")
				.replace(/ OR /ig,"~::~"+tab+tab+"OR ")
				.replace(/ ORDER\s{1,}BY/ig,"~::~ORDER BY ")
				.replace(/ OVER /ig,"~::~"+tab+"OVER ")

				.replace(/\(\s{0,}SELECT /ig,"~::~(SELECT ")
				.replace(/\)\s{0,}SELECT /ig,")~::~SELECT ")

				.replace(/ THEN /ig," THEN~::~"+tab+"")
				.replace(/ UNION /ig,"~::~UNION~::~")
				.replace(/ USING /ig,"~::~USING ")
				.replace(/ WHEN /ig,"~::~"+tab+"WHEN ")
				.replace(/ WHERE /ig,"~::~WHERE ")
				.replace(/ WITH /ig,"~::~WITH ")

				//.replace(/\,\s{0,}\(/ig,",~::~( ")
				//.replace(/\,/ig,",~::~"+tab+tab+"")

				.replace(/ ALL /ig," ALL ")
				.replace(/ AS /ig," AS ")
				.replace(/ ASC /ig," ASC ")
				.replace(/ DESC /ig," DESC ")
				.replace(/ DISTINCT /ig," DISTINCT ")
				.replace(/ EXISTS /ig," EXISTS ")
				.replace(/ NOT /ig," NOT ")
				.replace(/ NULL /ig," NULL ")
				.replace(/ LIKE /ig," LIKE ")
				.replace(/\s{0,}SELECT /ig,"SELECT ")
				.replace(/\s{0,}UPDATE /ig,"UPDATE ")
				.replace(/ SET /ig," SET ")

				.replace(/~::~{1,}/g,"~::~")
				.split('~::~');
}

vkbeautify.prototype.sql = function(text,step) {

	var ar_by_quote = text.replace(/\s{1,}/g," ")
							.replace(/\'/ig,"~::~\'")
							.split('~::~'),
		len = ar_by_quote.length,
		ar = [],
		deep = 0,
		tab = this.step,//+this.step,
		inComment = true,
		inQuote = false,
		parenthesisLevel = 0,
		str = '',
		ix = 0,
		shift = step ? createShiftArr(step) : this.shift;;

		for(ix=0;ix<len;ix++) {
			if(ix%2) {
				ar = ar.concat(ar_by_quote[ix]);
			} else {
				ar = ar.concat(split_sql(ar_by_quote[ix], tab) );
			}
		}

		len = ar.length;
		for(ix=0;ix<len;ix++) {

			parenthesisLevel = isSubquery(ar[ix], parenthesisLevel);

			if( /\s{0,}\s{0,}SELECT\s{0,}/.exec(ar[ix]))  {
				ar[ix] = ar[ix].replace(/\,/g,",\n"+tab+tab+"")
			}

			if( /\s{0,}\s{0,}SET\s{0,}/.exec(ar[ix]))  {
				ar[ix] = ar[ix].replace(/\,/g,",\n"+tab+tab+"")
			}

			if( /\s{0,}\(\s{0,}SELECT\s{0,}/.exec(ar[ix]))  {
				deep++;
				str += shift[deep]+ar[ix];
			} else
			if( /\'/.exec(ar[ix]) )  {
				if(parenthesisLevel<1 && deep) {
					deep--;
				}
				str += ar[ix];
			}
			else  {
				str += shift[deep]+ar[ix];
				if(parenthesisLevel<1 && deep) {
					deep--;
				}
			}
			var junk = 0;
		}

		str = str.replace(/^\n{1,}/,'').replace(/\n{1,}/g,"\n");
		return str;
}


vkbeautify.prototype.xmlmin = function(text, preserveComments) {

	var str = preserveComments ? text
							   : text.replace(/\<![ \r\n\t]*(--([^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)\>/g,"")
									 .replace(/[ \r\n\t]{1,}xmlns/g, ' xmlns');
	return  str.replace(/>\s{0,}</g,"><");
}

vkbeautify.prototype.jsonmin = function(text) {

	if (typeof JSON === 'undefined' ) return text;

	return JSON.stringify(JSON.parse(text), null, 0);

}

vkbeautify.prototype.cssmin = function(text, preserveComments) {

	var str = preserveComments ? text
							   : text.replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//g,"") ;

	return str.replace(/\s{1,}/g,' ')
			  .replace(/\{\s{1,}/g,"{")
			  .replace(/\}\s{1,}/g,"}")
			  .replace(/\;\s{1,}/g,";")
			  .replace(/\/\*\s{1,}/g,"/*")
			  .replace(/\*\/\s{1,}/g,"*/");
}

vkbeautify.prototype.sqlmin = function(text) {
	return text.replace(/\s{1,}/g," ").replace(/\s{1,}\(/,"(").replace(/\s{1,}\)/,")");
}

module.exports = new vkbeautify();


/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var required = __webpack_require__(378)
  , qs = __webpack_require__(379)
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @api public
 */
function lolcation(loc) {
  loc = loc || global.location || {};

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new URL(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new URL(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @api private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @api private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @api public
 */
function URL(address, location, parser) {
  if (!(this instanceof URL)) {
    return new URL(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];
    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL}
 * @api public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String}
 * @api public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

URL.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
URL.extractProtocol = extractProtocol;
URL.location = lolcation;
URL.qs = qs;

module.exports = URL;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)))

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  //
  // Little nifty parsing hack, leverage the fact that RegExp.exec increments
  // the lastIndex property so we can continue executing this loop until we've
  // parsed all results.
  //
  for (;
    part = parser.exec(query);
    result[decode(part[1])] = decode(part[2])
  );

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TiledPlot = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(8);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _cssElementQueries = __webpack_require__(189);

var _CenterTrack = __webpack_require__(381);

var _CenterTrack2 = _interopRequireDefault(_CenterTrack);

var _TrackRenderer = __webpack_require__(634);

var _TrackRenderer2 = _interopRequireDefault(_TrackRenderer);

var _AddTrackModal = __webpack_require__(679);

var _AddTrackModal2 = _interopRequireDefault(_AddTrackModal);

var _ConfigTrackMenu = __webpack_require__(684);

var _ConfigTrackMenu2 = _interopRequireDefault(_ConfigTrackMenu);

var _CloseTrackMenu = __webpack_require__(687);

var _CloseTrackMenu2 = _interopRequireDefault(_CloseTrackMenu);

var _PopupMenu = __webpack_require__(143);

var _PopupMenu2 = _interopRequireDefault(_PopupMenu);

var _ContextMenuContainer = __webpack_require__(62);

var _ContextMenuContainer2 = _interopRequireDefault(_ContextMenuContainer);

var _HorizontalTiledPlot = __webpack_require__(688);

var _HorizontalTiledPlot2 = _interopRequireDefault(_HorizontalTiledPlot);

var _VerticalTiledPlot = __webpack_require__(695);

var _VerticalTiledPlot2 = _interopRequireDefault(_VerticalTiledPlot);

var _services = __webpack_require__(7);

var _utils = __webpack_require__(3);

var _configs = __webpack_require__(6);

var _TiledPlotModule = __webpack_require__(144);

var _TiledPlotModule2 = _interopRequireDefault(_TiledPlotModule);

var _CenterTrackModule = __webpack_require__(239);

var _CenterTrackModule2 = _interopRequireDefault(_CenterTrackModule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
// import {HeatmapOptions} from './HeatmapOptions';

// Services


// Utils


// Configs


// Styles


// eslint-disable-line no-unused-vars

var TiledPlot = exports.TiledPlot = function (_React$Component) {
  _inherits(TiledPlot, _React$Component);

  function TiledPlot(props) {
    _classCallCheck(this, TiledPlot);

    var _this = _possibleConstructorReturn(this, (TiledPlot.__proto__ || Object.getPrototypeOf(TiledPlot)).call(this, props));

    _this.closing = false;
    _this.yPositionOffset = 0; // the offset from the Canvas and SVG elements
    // that the tracks will be drawn on

    var tracks = _this.props.tracks;

    _this.xScale = null;
    _this.yScale = null;

    _this.addUidsToTracks(tracks);

    // Add names to all the tracks
    _this.trackRenderers = {};
    _this.trackToReplace = null;

    _this.addTrackModal = null;
    _this.configTrackMenu = null;

    /*
    let trackOptions = this.props.editable ?
        {'track': this.props.tracks.center[0].contents[0],
        'configComponent': HeatmapOptions}
        : null;
    */

    // these values should be changed in componentDidMount
    _this.state = {
      sizeMeasured: false,
      height: 10,
      width: 10,

      yPositionOffset: 0,
      xPositionOffset: 0,

      tracks: tracks,
      addTrackPosition: null,
      mouseOverOverlayUid: null,
      // trackOptions: null
      // trackOptions: trackOptions
      forceUpdate: 0, // a random value that will be assigned by crucial functions to force an update

      rangeSelection: [null, null],

      chromInfo: null
    };

    // these dimensions are computed in the render() function and depend
    // on the sizes of the tracks in each section
    _this.topHeight = 0;
    _this.bottomHeight = 0;

    _this.leftWidth = 0;
    _this.rightWidth = 0;

    _this.centerHeight = 0;
    _this.centerWidth = 0;

    _this.dragTimeout = null;
    _this.previousPropsStr = '';

    /*
    this.getChromInfo = chromInfo.get(this.props.chromInfoPath).then(
      chromInfo => this.setState({ chromInfo }),
    );
    */
    return _this;
  }

  _createClass(TiledPlot, [{
    key: 'waitForDOMAttachment',
    value: function () {
      function waitForDOMAttachment(callback) {
        var _this2 = this;

        if (!this.mounted) return;

        var thisElement = _reactDom2['default'].findDOMNode(this);

        if (document.body.contains(thisElement)) {
          callback();
        } else {
          requestAnimationFrame(function () {
            return _this2.waitForDOMAttachment(callback);
          });
        }
      }

      return waitForDOMAttachment;
    }()
  }, {
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {
        var _this3 = this;

        this.mounted = true;
        this.element = _reactDom2['default'].findDOMNode(this);

        //new ResizeSensor(this.element, this.measureSize.bind(this));
        this.waitForDOMAttachment(function () {
          _cssElementQueries.ElementQueries.listen();
          _this3.resizeSensor = new _cssElementQueries.ResizeSensor(_this3.element.parentNode, _this3.measureSize.bind(_this3));

          _this3.measureSize();
        });
      }

      return componentDidMount;
    }()
  }, {
    key: 'componentWillReceiveProps',
    value: function () {
      function componentWillReceiveProps(newProps) {
        this.addUidsToTracks(newProps.tracks);

        this.setState({
          tracks: newProps.tracks
        });
      }

      return componentWillReceiveProps;
    }()
  }, {
    key: 'shouldComponentUpdate',
    value: function () {
      function shouldComponentUpdate(nextProps, nextState) {
        var thisPropsStr = this.previousPropsStr;
        var nextPropsStr = this.updatablePropsToString(nextProps);

        var thisStateStr = JSON.stringify(this.state);
        var nextStateStr = JSON.stringify(nextState);

        var toUpdate = false;

        if (thisPropsStr != nextPropsStr) {
          toUpdate = true;
        }

        if (toUpdate || thisStateStr != nextStateStr) {
          toUpdate = true;
        }

        toUpdate = toUpdate || this.props.chooseTrackHandler != nextProps.chooseTrackHandler;

        if (toUpdate) {
          this.previousPropsStr = nextPropsStr;
        }

        return toUpdate;
      }

      return shouldComponentUpdate;
    }()
  }, {
    key: 'componentWillUpdate',
    value: function () {
      function componentWillUpdate() {
        /**
         * Need to determine the offset of this element relative to the canvas on which stuff
         * will be drawn
         */
      }

      return componentWillUpdate;
    }()
  }, {
    key: 'componentDidUpdate',
    value: function () {
      function componentDidUpdate(prevProps, prevState) {
        if (prevState.rangeSelection !== this.state.rangeSelection && this.props.onRangeSelection) {
          this.props.onRangeSelection(this.state.rangeSelection);
        }
      }

      return componentDidUpdate;
    }()
  }, {
    key: 'componentWillUnmount',
    value: function () {
      function componentWillUnmount() {
        this.closing = true;
      }

      return componentWillUnmount;
    }()
  }, {
    key: 'addUidsToTracks',
    value: function () {
      function addUidsToTracks(tracks) {
        for (var key in tracks) {
          for (var i = 0; i < tracks[key].length; i++) {
            tracks[key][i].uid = tracks[key][i].uid ? tracks[key][i].uid : _slugid2['default'].nice();
          }
        }
      }

      return addUidsToTracks;
    }()
  }, {
    key: 'measureSize',
    value: function () {
      function measureSize() {
        var heightOffset = 0;
        var height = this.element.clientHeight - heightOffset;
        var width = this.element.clientWidth;

        // console.log('TiledPlot height:', height, 'width:', width);

        if (width > 0 && height > 0) {
          this.setState({
            sizeMeasured: true,
            width: width,
            height: height
          });
        }
      }

      return measureSize;
    }()
  }, {
    key: 'handleTrackOptionsChanged',
    value: function () {
      function handleTrackOptionsChanged(trackUid, newOptions) {
        /**
         * The drawing options for a track have changed.
         */
        return this.props.onTrackOptionsChanged(trackUid, newOptions);
      }

      return handleTrackOptionsChanged;
    }()
  }, {
    key: 'handleScalesChanged',
    value: function () {
      function handleScalesChanged(x, y) {
        this.xScale = x;
        this.yScale = y;

        this.props.onScalesChanged(x, y);
      }

      return handleScalesChanged;
    }()
  }, {
    key: 'handleTilesetInfoReceived',
    value: function () {
      function handleTilesetInfoReceived(trackUid, tilesetInfo) {
        /**
         * We've received information about a tileset from the server. Register it
         * with the track definition.
         * @param trackUid (string): The identifier for the track
         * @param tilesetInfo (object): Information about the track (hopefully including
         *                              its name.
         */
        var track = (0, _utils.getTrackByUid)(this.props.tracks, trackUid);

        if (!track.options) {
          track.options = {};
        }

        // track.options.name = tilesetInfo.name;
        track.name = tilesetInfo.name;
        track.maxWidth = tilesetInfo.max_width;
        track.transforms = tilesetInfo.transforms;
        track.header = tilesetInfo.header;
        track.binsPerDimension = tilesetInfo.bins_per_dimension;
        track.maxZoom = tilesetInfo.max_zoom;
        track.coordSystem = tilesetInfo.coordSystem;
      }

      return handleTilesetInfoReceived;
    }()
  }, {
    key: 'handleOverlayMouseEnter',
    value: function () {
      function handleOverlayMouseEnter(uid) {
        this.setState({
          mouseOverOverlayUid: uid
        });
      }

      return handleOverlayMouseEnter;
    }()
  }, {
    key: 'handleOverlayMouseLeave',
    value: function () {
      function handleOverlayMouseLeave() {
        this.setState({
          mouseOverOverlayUid: null
        });
      }

      return handleOverlayMouseLeave;
    }()
  }, {
    key: 'handleTrackPositionChosen',
    value: function () {
      function handleTrackPositionChosen(position) {
        this.handleAddTrack(position);

        // have our parent close the menu
        // parent needs to do it because the button is located in the parent's scope
        this.props.onTrackPositionChosen(position);
      }

      return handleTrackPositionChosen;
    }()
  }, {
    key: 'handleNoTrackAdded',
    value: function () {
      function handleNoTrackAdded() {
        /*
         * User hit cancel on the AddTrack dialog so we need to
         * just close it and do nothin
         */
        this.trackToReplace = null;

        this.props.onNoTrackAdded();

        this.setState({
          addTrackPosition: null,
          addTrackHost: null
        });
      }

      return handleNoTrackAdded;
    }()
  }, {
    key: 'handleDivideSeries',
    value: function () {
      function handleDivideSeries(seriesUid) {
        /*
         * We want to create a new series that consists of this series
         * being divided by another. Useful for comparing two tracks
         * by division.
         *
         * Will start working with just heatmaps and then progress to
         * other track types.
         */

      }

      return handleDivideSeries;
    }()
  }, {
    key: 'handleAddSeries',
    value: function () {
      function handleAddSeries(trackUid) {
        var trackPosition = (0, _utils.getTrackPositionByUid)(this.props.tracks, trackUid);
        var track = (0, _utils.getTrackByUid)(this.props.tracks, trackUid);

        this.setState({
          addTrackPosition: trackPosition,
          addTrackHost: track
        });
      }

      return handleAddSeries;
    }()
  }, {
    key: 'handleReplaceTrack',
    value: function () {
      function handleReplaceTrack(uid, orientation) {
        /**
         * @param uid (string): The uid of the track to replace
         * @param orientation (string): The place where to put the new track
         */

        this.trackToReplace = uid;
        this.handleAddTrack(orientation);
      }

      return handleReplaceTrack;
    }()
  }, {
    key: 'handleAddTrack',
    value: function () {
      function handleAddTrack(position) {
        this.setState({
          addTrackPosition: position,
          addTrackHost: null
        });
      }

      return handleAddTrack;
    }()
  }, {
    key: 'handleResizeTrack',
    value: function () {
      function handleResizeTrack(uid, width, height) {
        var tracks = this.state.tracks;

        for (var trackType in tracks) {
          var theseTracks = tracks[trackType];

          var filteredTracks = theseTracks.filter(function (d) {
            return d.uid == uid;
          });

          if (filteredTracks.length > 0) {
            filteredTracks[0].width = width;
            filteredTracks[0].height = height;
          }
        }

        this.setState({
          tracks: tracks,
          forceUpdate: Math.random()
        });
      }

      return handleResizeTrack;
    }()
  }, {
    key: 'handleLockValueScale',
    value: function () {
      function handleLockValueScale(uid) {
        this.setState({
          closeTrackMenuId: null,
          configTrackMenuId: null
        });

        this.props.onLockValueScale(uid);
      }

      return handleLockValueScale;
    }()
  }, {
    key: 'handleUnlockValueScale',
    value: function () {
      function handleUnlockValueScale(uid) {
        this.setState({
          closeTrackMenuId: null,
          configTrackMenuId: null
        });

        this.props.onUnlockValueScale(uid);
      }

      return handleUnlockValueScale;
    }()
  }, {
    key: 'handleCloseTrack',
    value: function () {
      function handleCloseTrack(uid) {
        this.props.onCloseTrack(uid);

        this.setState({
          closeTrackMenuId: null,
          configTrackMenuId: null
        });
      }

      return handleCloseTrack;
    }()
  }, {
    key: 'handleChangeTrackType',
    value: function () {
      function handleChangeTrackType(uid, newType) {
        // close the config track menu
        this.setState({
          closeTrackMenuId: null,
          configTrackMenuId: null
        });

        // change the track type
        this.props.onChangeTrackType(uid, newType);
      }

      return handleChangeTrackType;
    }()
  }, {
    key: 'handleTracksAdded',
    value: function () {
      function handleTracksAdded(newTracks, position, host) {
        /**
         * Arguments
         * ---------
         *  newTracks: {object}
         *      The description of the track, including its type
         *      and data source.
         *  position: string
         *      Where to place this track
         *
         * Returns
         * -------
         *
         *  { uid: "", width: }:
         *      The trackConfig object describing this track. Essentially
         *      the newTrack object passed in with some extra information
         *      (such as the uid) added.
         */
        if (this.trackToReplace) {
          this.handleCloseTrack(this.trackToReplace);
          this.trackToReplace = null;
        }

        this.props.onTracksAdded(newTracks, position, host);

        this.setState({
          addTrackPosition: null,
          addTrackHost: null
        });

        return newTracks;
      }

      return handleTracksAdded;
    }()
  }, {
    key: 'handleCloseTrackMenuOpened',
    value: function () {
      function handleCloseTrackMenuOpened(uid, clickPosition) {
        this.setState({
          closeTrackMenuId: uid,
          closeTrackMenuLocation: clickPosition
        });
      }

      return handleCloseTrackMenuOpened;
    }()
  }, {
    key: 'handleCloseTrackMenuClosed',
    value: function () {
      function handleCloseTrackMenuClosed() {
        this.setState({
          closeTrackMenuId: null
        });
      }

      return handleCloseTrackMenuClosed;
    }()
  }, {
    key: 'handleConfigTrackMenuOpened',
    value: function () {
      function handleConfigTrackMenuOpened(uid, clickPosition) {
        // let orientation = getTrackPositionByUid(uid);

        this.setState({
          configTrackMenuId: uid,
          configTrackMenuLocation: clickPosition
        });
      }

      return handleConfigTrackMenuOpened;
    }()
  }, {
    key: 'handleConfigTrackMenuClosed',
    value: function () {
      function handleConfigTrackMenuClosed() {
        this.setState({
          configTrackMenuId: null
        });
      }

      return handleConfigTrackMenuClosed;
    }()
  }, {
    key: 'handleConfigureTrack',
    value: function () {
      function handleConfigureTrack(track, configComponent) {
        console.log('configComponent:', configComponent);
        this.setState({
          configTrackMenuId: null,
          trackOptions: { track: track, configComponent: configComponent }
        });
      }

      return handleConfigureTrack;
    }()
  }, {
    key: 'handleSortEnd',
    value: function () {
      function handleSortEnd(sortedTracks) {
        // some tracks were reordered in the list so we need to reorder them in the original
        // dataset
        var tracks = this.state.tracks;

        // calculate the positions of the sortedTracks
        var positions = {};
        for (var i = 0; i < sortedTracks.length; i++) {
          positions[sortedTracks[i].uid] = i;
        }

        for (var trackType in tracks) {
          var theseTracks = tracks[trackType];
          if (!theseTracks.length) {
            continue;
          }

          if (theseTracks[0].uid in positions) {
            var newTracks = new Array(theseTracks.length);
            // this is the right track position
            for (var _i = 0; _i < theseTracks.length; _i++) {
              newTracks[positions[theseTracks[_i].uid]] = theseTracks[_i];
            }

            tracks[trackType] = newTracks;
          }
        }

        this.setState({
          tracks: tracks,
          forceUpdate: Math.random()
        });
      }

      return handleSortEnd;
    }()
  }, {
    key: 'createTracksAndLocations',
    value: function () {
      function createTracksAndLocations() {
        var tracksAndLocations = [];
        var tracks = this.state.tracks;

        for (var trackType in tracks) {
          for (var i = 0; i < tracks[trackType].length; i++) {
            tracksAndLocations.push({ track: tracks[trackType][i], location: trackType });
          }
        }

        return tracksAndLocations;
      }

      return createTracksAndLocations;
    }()
  }, {
    key: 'calculateTrackPosition',
    value: function () {
      function calculateTrackPosition(track, location) {
        /**
         * Calculate where a track is absoluately positioned within the drawing area
         *
         * @param track: The track object (with members, e.g. track.uid, track.width, track.height)
         * @param location: Where it's being plotted (e.g. 'top', 'bottom')
         * @return: The position of the track and it's height and width
         *          (e.g. {left: 10, top: 20, width: 30, height: 40}
         */
        var top = this.props.verticalMargin,
            left = this.props.horizontalMargin;

        if (location == 'top') {
          left += this.leftWidth;
          top += 0;

          for (var i = 0; i < this.state.tracks.top.length; i++) {
            if (this.state.tracks.top[i].uid == track.uid) {
              break;
            } else {
              top += this.state.tracks.top[i].height;
            }
          }

          return { left: left,
            top: top,
            width: this.centerWidth,
            height: track.height,
            track: track };
        } else if (location == 'bottom') {
          left += this.leftWidth;
          top += this.topHeight + this.centerHeight;

          for (var _i2 = 0; _i2 < this.state.tracks.bottom.length; _i2++) {
            if (this.state.tracks.bottom[_i2].uid == track.uid) {
              break;
            } else {
              top += this.state.tracks.bottom[_i2].height;
            }
          }

          return { left: left,
            top: top,
            width: this.centerWidth,
            height: track.height,
            track: track };
        } else if (location == 'left') {
          top += this.topHeight;

          for (var _i3 = 0; _i3 < this.state.tracks.left.length; _i3++) {
            if (this.state.tracks.left[_i3].uid == track.uid) {
              break;
            } else {
              left += this.state.tracks.left[_i3].width;
            }
          }

          return { left: left,
            top: top,
            width: track.width,
            height: this.centerHeight,
            track: track };
        } else if (location == 'right') {
          left += this.leftWidth + this.centerWidth;
          top += this.topHeight;

          for (var _i4 = 0; _i4 < this.state.tracks.right.length; _i4++) {
            if (this.state.tracks.right[_i4].uid == track.uid) {
              break;
            } else {
              left += this.state.tracks.right[_i4].width;
            }
          }

          return { left: left,
            top: top,
            width: track.width,
            height: this.centerHeight,
            track: track };
        } else if (location == 'center') {
          left += this.leftWidth;
          top += this.topHeight;

          return { left: left,
            top: top,
            width: this.centerWidth,
            height: this.centerHeight,
            track: track };
        }
      }

      return calculateTrackPosition;
    }()
  }, {
    key: 'positionedTracks',
    value: function () {
      function positionedTracks() {
        var _this4 = this;

        /**
         * Return the current set of tracks along with their positions
         * and dimensions
         */
        var tracksAndLocations = this.createTracksAndLocations().map(function (_ref) {
          var track = _ref.track,
              location = _ref.location;
          return _this4.calculateTrackPosition(track, location);
        });

        return tracksAndLocations;
      }

      return positionedTracks;
    }()
  }, {
    key: 'createTrackPositionTexts',
    value: function () {
      function createTrackPositionTexts() {
        /**
         * Create little text fields that show the position and width of
         * each track, just to show that we can calculate that and pass
         * it to the rendering context.
         */
        var positionedTracks = this.positionedTracks();
        this.createTracksAndLocations();

        var trackElements = positionedTracks.map(function (trackPosition) {
          var track = trackPosition.track;

          return _react2['default'].createElement(
            'div',
            {
              key: track.uid,
              style: {
                left: trackPosition.left,
                top: trackPosition.top,
                width: trackPosition.width,
                height: trackPosition.height,
                position: 'absolute'
              }
            },
            track.uid.slice(0, 2)
          );
        });

        return trackElements;
      }

      return createTrackPositionTexts;
    }()
  }, {
    key: 'handleExportTrackData',
    value: function () {
      function handleExportTrackData(hostTrackUid, trackUid) {
        /*
         * Export the data present in a track. Whether a track can export data is defined
         * in the track type definition in config.js
         */
        var track = (0, _utils.getTrackByUid)(this.props.tracks, trackUid);
        var trackObject = null;

        if (hostTrackUid != trackUid) {
          // the track whose data we're trying to export is part of a combined track
          trackObject = this.trackRenderer.trackDefObjects[hostTrackUid].trackObject.createdTracks[track.uid];
        } else {
          trackObject = this.trackRenderer.trackDefObjects[hostTrackUid].trackObject.createdTracks[track.uid];
        }

        trackObject.exportData();
      }

      return handleExportTrackData;
    }()
  }, {
    key: 'handleZoomToData',
    value: function () {
      function handleZoomToData() {
        /**
         * Try to zoom in or out so that the bounds of the view correspond to the
         * extent of the data.
         */
        var minPos = [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER];
        var maxPos = [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];

        // go through every track definition
        for (var uid in this.trackRenderer.trackDefObjects) {
          var tdo = this.trackRenderer.trackDefObjects[uid];
          var trackObjectsToCheck = [tdo.trackObject];

          // if this is a combined track then we need to recurse into its
          // subtracks
          for (var uid1 in tdo.trackObject.createdTracks) {
            var trackObject = tdo.trackObject.createdTracks[uid1];
            trackObjectsToCheck.push(trackObject);
          }

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = trackObjectsToCheck[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _trackObject = _step.value;

              // get the minimum and maximum positions of all the subtracks
              if (_trackObject.tilesetInfo) {
                if (_trackObject.tilesetInfo.min_pos) {
                  for (var j = 0; j < _trackObject.tilesetInfo.min_pos.length; j++) {
                    if (_trackObject.tilesetInfo.min_pos[j] < minPos[j]) {
                      minPos[j] = _trackObject.tilesetInfo.min_pos[j];
                    }

                    if (_trackObject.tilesetInfo.max_pos[j] > maxPos[j]) {
                      maxPos[j] = _trackObject.tilesetInfo.max_pos[j];
                    }
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator['return']) {
                _iterator['return']();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        // set the initial domain
        var newXDomain = [this.trackRenderer.currentProps.marginLeft + this.trackRenderer.currentProps.leftWidth, this.trackRenderer.currentProps.marginLeft + this.trackRenderer.currentProps.leftWidth + this.trackRenderer.currentProps.centerWidth].map(this.trackRenderer.zoomTransform.rescaleX(this.trackRenderer.xScale).invert);

        var newYDomain = [this.trackRenderer.currentProps.marginTop + this.trackRenderer.currentProps.topHeight, this.trackRenderer.currentProps.marginTop + this.trackRenderer.currentProps.topHeight + this.trackRenderer.currentProps.centerHeight].map(this.trackRenderer.zoomTransform.rescaleY(this.trackRenderer.yScale).invert);

        // reset the zoom transform
        this.trackRenderer.zoomTransform.k = 1;

        this.trackRenderer.zoomTransform.x = 0;
        this.trackRenderer.zoomTransform.y = 0;
        this.trackRenderer.applyZoomTransform();

        if (minPos[0] < Number.MAX_SAFE_INTEGER && maxPos[0] > Number.MIN_SAFE_INTEGER) {
          newXDomain = [minPos[0], maxPos[0]];
        }

        if (minPos[1] < Number.MAX_SAFE_INTEGER && maxPos[1] > Number.MIN_SAFE_INTEGER) {
          newYDomain = [minPos[1], maxPos[1]];
        }

        this.props.onDataDomainChanged(newXDomain, newYDomain);
      }

      return handleZoomToData;
    }()
  }, {
    key: 'updatablePropsToString',
    value: function () {
      function updatablePropsToString(props) {
        return JSON.stringify({
          tracks: props.tracks,
          uid: props.uid,
          addTrackPosition: props.addTrackPosition,
          editable: props.editable,
          horizontalMargin: props.horizontalMargin,
          mouseTool: props.mouseTool,
          verticalTiledPlot: props.verticalMargin,
          initialXDomain: props.initialXDomain,
          initialYDomain: props.initialYDomain,
          trackSourceServers: props.trackSourceServers,
          zoomable: props.zoomable
        });
      }

      return updatablePropsToString;
    }()
  }, {
    key: 'rangeToGenomeLoci',
    value: function () {
      function rangeToGenomeLoci(range, scale) {
        if (!scale || !this.state.chromInfo) return null;

        return (0, _utils.pixelToGenomeLoci)(parseInt(scale.invert(range[0]), 10), parseInt(scale.invert(range[1]), 10), this.state.chromInfo);
      }

      return rangeToGenomeLoci;
    }()
  }, {
    key: 'rangeSelectionEndHandler',
    value: function () {
      function rangeSelectionEndHandler() {
        if (this.state.rangeSelectionMaster) {
          this.setState({
            is1dRangeSelection: null,
            rangeSelection: [null, null],
            rangeSelectionMaster: null
          });
        }
      }

      return rangeSelectionEndHandler;
    }()
  }, {
    key: 'rangeSelection1dHandler',
    value: function () {
      function rangeSelection1dHandler(axis) {
        var _this5 = this;

        var scale = axis === 'x' ? this.xScale : this.yScale;

        return function (range) {
          var newRangeSelection = _this5.state.is1dRangeSelection ? [null, null] : _this5.state.rangeSelection.slice();

          var accessor = !_this5.state.is1dRangeSelection && axis === 'y' ? 1 : 0;

          newRangeSelection[accessor] = _this5.rangeToGenomeLoci(range, scale);

          _this5.setState({
            rangeSelection: newRangeSelection
          });
        };
      }

      return rangeSelection1dHandler;
    }()
  }, {
    key: 'rangeSelection1dStartHandler',
    value: function () {
      function rangeSelection1dStartHandler() {
        if (!this.state.rangeSelectionMaster) {
          this.setState({
            is1dRangeSelection: true,
            rangeSelectionMaster: true
          });
        }
      }

      return rangeSelection1dStartHandler;
    }()
  }, {
    key: 'rangeSelection2dHandler',
    value: function () {
      function rangeSelection2dHandler(range) {
        this.setState({
          rangeSelection: [this.rangeToGenomeLoci(range[0], this.xScale), this.rangeToGenomeLoci(range[1], this.yScale)]
        });
      }

      return rangeSelection2dHandler;
    }()
  }, {
    key: 'rangeSelection2dStartHandler',
    value: function () {
      function rangeSelection2dStartHandler() {
        if (!this.state.rangeSelectionMaster) {
          this.setState({
            is1dRangeSelection: false,
            rangeSelectionMaster: true
          });
        }
      }

      return rangeSelection2dStartHandler;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this6 = this;

        // left, top, right, and bottom have fixed heights / widths
        // the center will vary to accomodate their dimensions
        this.topHeight = this.props.tracks.top.map(function (x) {
          return x.height;
        }).reduce(function (a, b) {
          return a + b;
        }, 0);
        this.bottomHeight = this.props.tracks.bottom.map(function (x) {
          return x.height;
        }).reduce(function (a, b) {
          return a + b;
        }, 0);
        this.leftWidth = this.props.tracks.left.map(function (x) {
          return x.width;
        }).reduce(function (a, b) {
          return a + b;
        }, 0);
        this.rightWidth = this.props.tracks.right.map(function (x) {
          return x.width;
        }).reduce(function (a, b) {
          return a + b;
        }, 0);

        this.centerHeight = this.state.height - this.topHeight - this.bottomHeight - 2 * this.props.verticalMargin;
        this.centerWidth = this.state.width - this.leftWidth - this.rightWidth - 2 * this.props.horizontalMargin;

        var trackOutline = 'none';

        var topTracks = _react2['default'].createElement(
          'div',
          {
            key: 'topTracksDiv',
            style: {
              left: this.leftWidth + this.props.horizontalMargin,
              top: this.props.verticalMargin,
              width: this.centerWidth,
              height: this.topHeight,
              outline: trackOutline,
              position: 'absolute'
            }
          },
          _react2['default'].createElement(_HorizontalTiledPlot2['default'], {
            configTrackMenuId: this.state.configTrackMenuId,
            chromInfo: this.state.chromInfo,
            editable: this.props.editable,
            handleConfigTrack: this.handleConfigTrackMenuOpened.bind(this),
            handleResizeTrack: this.handleResizeTrack.bind(this),
            handleSortEnd: this.handleSortEnd.bind(this),
            is1dRangeSelection: this.state.is1dRangeSelection,
            isRangeSelectionActive: this.props.mouseTool === _configs.MOUSE_TOOL_SELECT,
            onAddSeries: this.handleAddSeries.bind(this),
            onCloseTrack: this.handleCloseTrack.bind(this),
            onCloseTrackMenuOpened: this.handleCloseTrackMenuOpened.bind(this),
            onConfigTrackMenuOpened: this.handleConfigTrackMenuOpened.bind(this),
            onRangeSelection: this.rangeSelection1dHandler('x').bind(this),
            onRangeSelectionEnd: this.rangeSelectionEndHandler.bind(this),
            onRangeSelectionStart: this.rangeSelection1dStartHandler.bind(this),
            rangeSelection: this.state.rangeSelection,
            resizeHandles: new Set(['bottom']),
            scale: this.xScale,
            tracks: this.props.tracks.top,
            width: this.centerWidth
          })
        );

        var leftTracks = _react2['default'].createElement(
          'div',
          {
            key: 'leftTracksPlot',
            style: {
              left: this.props.horizontalMargin,
              top: this.topHeight + this.props.verticalMargin,
              width: this.leftWidth,
              height: this.centerHeight,
              outline: trackOutline,
              position: 'absolute'
            }
          },
          _react2['default'].createElement(_VerticalTiledPlot2['default'], {
            configTrackMenuId: this.state.configTrackMenuId,
            chromInfo: this.state.chromInfo,
            editable: this.props.editable,
            handleConfigTrack: this.handleConfigTrackMenuOpened.bind(this),
            handleResizeTrack: this.handleResizeTrack.bind(this),
            handleSortEnd: this.handleSortEnd.bind(this),
            height: this.centerHeight,
            is1dRangeSelection: this.state.is1dRangeSelection,
            isRangeSelectionActive: this.props.mouseTool === _configs.MOUSE_TOOL_SELECT,
            onAddSeries: this.handleAddSeries.bind(this),
            onCloseTrack: this.handleCloseTrack.bind(this),
            onCloseTrackMenuOpened: this.handleCloseTrackMenuOpened.bind(this),
            onConfigTrackMenuOpened: this.handleConfigTrackMenuOpened.bind(this),
            onRangeSelection: this.rangeSelection1dHandler('y').bind(this),
            onRangeSelectionEnd: this.rangeSelectionEndHandler.bind(this),
            onRangeSelectionStart: this.rangeSelection1dStartHandler.bind(this),
            rangeSelection: this.state.rangeSelection,
            resizeHandles: new Set(['right']),
            scale: this.yScale,
            tracks: this.props.tracks.left
          })
        );

        var rightTracks = _react2['default'].createElement(
          'div',
          { style: {
              right: this.props.horizontalMargin,
              top: this.topHeight + this.props.verticalMargin,
              width: this.rightWidth,
              height: this.centerHeight,
              outline: trackOutline,
              position: 'absolute'
            }
          },
          _react2['default'].createElement(_VerticalTiledPlot2['default'], {
            configTrackMenuId: this.state.configTrackMenuId,
            chromInfo: this.state.chromInfo,
            editable: this.props.editable,
            handleConfigTrack: this.handleConfigTrackMenuOpened.bind(this),
            handleResizeTrack: this.handleResizeTrack.bind(this),
            handleSortEnd: this.handleSortEnd.bind(this),
            height: this.centerHeight,
            is1dRangeSelection: this.state.is1dRangeSelection,
            isRangeSelectionActive: this.props.mouseTool === _configs.MOUSE_TOOL_SELECT,
            onAddSeries: this.handleAddSeries.bind(this),
            onCloseTrack: this.handleCloseTrack.bind(this),
            onCloseTrackMenuOpened: this.handleCloseTrackMenuOpened.bind(this),
            onConfigTrackMenuOpened: this.handleConfigTrackMenuOpened.bind(this),
            onRangeSelection: this.rangeSelection1dHandler('y').bind(this),
            onRangeSelectionEnd: this.rangeSelectionEndHandler.bind(this),
            onRangeSelectionStart: this.rangeSelection1dStartHandler.bind(this),
            rangeSelection: this.state.rangeSelection,
            resizeHandles: new Set(['left']),
            scale: this.yScale,
            tracks: this.props.tracks.right,
            tracksControlAlignLeft: true
          })
        );

        var bottomTracks = _react2['default'].createElement(
          'div',
          { style: {
              left: this.leftWidth + this.props.horizontalMargin,
              bottom: this.props.verticalMargin,
              width: this.centerWidth,
              height: this.bottomHeight,
              outline: trackOutline,
              position: 'absolute'
            }
          },
          _react2['default'].createElement(_HorizontalTiledPlot2['default'], {
            configTrackMenuId: this.state.configTrackMenuId,
            chromInfo: this.state.chromInfo,
            editable: this.props.editable,
            handleConfigTrack: this.handleConfigTrackMenuOpened.bind(this),
            handleResizeTrack: this.handleResizeTrack.bind(this),
            handleSortEnd: this.handleSortEnd.bind(this),
            is1dRangeSelection: this.state.is1dRangeSelection,
            isRangeSelectionActive: this.props.mouseTool === _configs.MOUSE_TOOL_SELECT,
            onAddSeries: this.handleAddSeries.bind(this),
            onCloseTrack: this.handleCloseTrack.bind(this),
            onCloseTrackMenuOpened: this.handleCloseTrackMenuOpened.bind(this),
            onConfigTrackMenuOpened: this.handleConfigTrackMenuOpened.bind(this),
            onRangeSelection: this.rangeSelection1dHandler('x').bind(this),
            onRangeSelectionEnd: this.rangeSelectionEndHandler.bind(this),
            onRangeSelectionStart: this.rangeSelection1dStartHandler.bind(this),
            rangeSelection: this.state.rangeSelection,
            resizeHandles: new Set(['top']),
            scale: this.xScale,
            tracks: this.props.tracks.bottom,
            width: this.centerWidth
          })
        );

        var centerTrack = _react2['default'].createElement('div', {
          style: {
            left: this.leftWidth + this.props.horizontalMargin,
            top: this.props.verticalMargin + this.topHeight,
            width: this.centerWidth,
            height: this.bottomHeight,
            outline: trackOutline
          },
          className: 'CenterTrack-module_center-track-container-2ELhp'
        });

        if (this.props.tracks.center.length) {
          centerTrack = _react2['default'].createElement(
            'div',
            {
              style: {
                left: this.leftWidth + this.props.horizontalMargin,
                top: this.props.verticalMargin + this.topHeight,
                width: this.centerWidth,
                height: this.centerHeight,
                outline: trackOutline
              },
              className: 'CenterTrack-module_center-track-container-2ELhp'
            },
            _react2['default'].createElement(_CenterTrack2['default'], {
              configTrackMenuId: this.state.configTrackMenuId,
              chromInfo: this.state.chromInfo,
              editable: this.props.editable,
              height: this.centerHeight,
              is1dRangeSelection: this.state.is1dRangeSelection,
              isRangeSelectionActive: this.props.mouseTool === _configs.MOUSE_TOOL_SELECT,
              onAddSeries: this.handleAddSeries.bind(this),
              onCloseTrackMenuOpened: this.handleCloseTrackMenuOpened.bind(this),
              onConfigTrackMenuOpened: this.handleConfigTrackMenuOpened.bind(this),
              onRangeSelectionEnd: this.rangeSelectionEndHandler.bind(this),
              onRangeSelectionStart: this.rangeSelection2dStartHandler.bind(this),
              onRangeSelectionX: this.rangeSelection1dHandler('x').bind(this),
              onRangeSelectionXY: this.rangeSelection2dHandler.bind(this),
              onRangeSelectionY: this.rangeSelection1dHandler('y').bind(this),
              rangeSelection: this.state.rangeSelection,
              scaleX: this.xScale,
              scaleY: this.yScale,
              tracks: this.props.tracks.center,
              uid: this.props.tracks.center[0].uid,
              width: this.centerWidth
            })
          );
        }

        this.createTrackPositionTexts();

        var positionedTracks = this.positionedTracks();

        var trackRenderer = null;
        if (this.state.sizeMeasured) {
          trackRenderer = _react2['default'].createElement(
            _TrackRenderer2['default']
            // Reserved props
            ,
            { ref: function () {
                function ref(c) {
                  _this6.trackRenderer = c;
                }

                return ref;
              }()

              // Custom props
              , canvasElement: this.props.canvasElement,
              centerHeight: this.centerHeight,
              centerWidth: this.centerWidth,
              dragging: this.props.dragging,
              height: this.state.height,
              initialXDomain: this.props.initialXDomain,
              initialYDomain: this.props.initialYDomain,
              isRangeSelection: this.props.mouseTool === _configs.MOUSE_TOOL_SELECT,
              leftWidth: this.leftWidth,
              marginLeft: this.props.horizontalMargin,
              marginTop: this.props.verticalMargin,
              onNewTilesLoaded: this.props.onNewTilesLoaded,
              onScalesChanged: this.handleScalesChanged.bind(this),
              onTilesetInfoReceived: this.handleTilesetInfoReceived.bind(this),
              onTrackOptionsChanged: this.handleTrackOptionsChanged.bind(this),
              onValueScaleChanged: this.props.onValueScaleChanged,
              pixiStage: this.props.pixiStage,
              positionedTracks: positionedTracks,
              registerDraggingChangedListener: this.props.registerDraggingChangedListener,
              removeDraggingChangedListener: this.props.removeDraggingChangedListener,
              setCentersFunction: this.props.setCentersFunction,
              svgElement: this.props.svgElement,
              topHeight: this.topHeight,
              uid: this.props.uid,
              width: this.state.width,
              zoomable: this.props.zoomable
            },
            topTracks,
            leftTracks,
            rightTracks,
            bottomTracks,
            centerTrack
          );
        }

        var configTrackMenu = null;
        var closeTrackMenu = null;

        if (this.state.configTrackMenuId) {
          configTrackMenu = _react2['default'].createElement(
            _PopupMenu2['default'],
            {
              onMenuClosed: this.handleConfigTrackMenuClosed.bind(this)
            },
            _react2['default'].createElement(_ConfigTrackMenu2['default'], {
              closeMenu: this.handleConfigTrackMenuClosed.bind(this),
              onAddSeries: this.handleAddSeries.bind(this),
              onAddTrack: this.handleAddTrack.bind(this),
              onChangeTrackType: this.handleChangeTrackType.bind(this),
              onCloseTrack: this.handleCloseTrack.bind(this),
              onConfigureTrack: this.handleConfigureTrack.bind(this),
              onExportData: this.handleExportTrackData.bind(this),
              onLockValueScale: this.handleLockValueScale.bind(this),
              onReplaceTrack: this.handleReplaceTrack.bind(this),
              onTrackOptionsChanged: this.handleTrackOptionsChanged.bind(this),
              onUnlockValueScale: this.handleUnlockValueScale.bind(this),
              ref: function () {
                function ref(c) {
                  return _this6.configTrackMenu = c;
                }

                return ref;
              }(),
              position: this.state.configTrackMenuLocation,
              track: (0, _utils.getTrackByUid)(this.props.tracks, this.state.configTrackMenuId),
              trackOrientation: (0, _utils.getTrackPositionByUid)(this.props.tracks, this.state.configTrackMenuId)
            })
          );
        }

        if (this.state.closeTrackMenuId) {
          closeTrackMenu = _react2['default'].createElement(
            _PopupMenu2['default'],
            {
              onMenuClosed: this.handleCloseTrackMenuClosed.bind(this)
            },
            _react2['default'].createElement(
              _ContextMenuContainer2['default'],
              {
                position: this.state.closeTrackMenuLocation
              },
              _react2['default'].createElement(_CloseTrackMenu2['default'], {
                onCloseTrack: this.handleCloseTrack.bind(this),
                track: (0, _utils.getTrackByUid)(this.props.tracks, this.state.closeTrackMenuId)
              })
            )
          );
        }

        var overlays = null;
        if (this.props.chooseTrackHandler) {
          // We want to choose a track and call a function. To choose the track, we display
          // an overlay on top of each track
          overlays = positionedTracks.map(function (pTrack) {
            var background = 'transparent';
            var border = 'none';

            if (_this6.state.mouseOverOverlayUid == pTrack.track.uid) {
              background = 'yellow';
              border = '1px solid black';
            }

            return _react2['default'].createElement('div', {
              className: 'tiled-plot-track-overlay',
              key: pTrack.track.uid

              // we want to remove the mouseOverOverlayUid so that next time we try
              // to choose an overlay track, the previously selected one isn't
              // automatically highlighted
              , onClick: function () {
                function onClick() {
                  _this6.setState({ mouseOverOverlayUid: null });
                  _this6.props.chooseTrackHandler(pTrack.track.uid);
                }

                return onClick;
              }(),
              onMouseEnter: function () {
                function onMouseEnter() {
                  return _this6.handleOverlayMouseEnter(pTrack.track.uid);
                }

                return onMouseEnter;
              }(),
              onMouseLeave: function () {
                function onMouseLeave() {
                  return _this6.handleOverlayMouseLeave(pTrack.track.uid);
                }

                return onMouseLeave;
              }(),
              style: {
                position: 'absolute',
                left: pTrack.left,
                top: pTrack.top,
                width: pTrack.width,
                height: pTrack.height,
                background: background,
                opacity: 0.4,
                border: border
              }
            });
          });
        }

        var trackOptionsElement = null;

        if (this.xScale && this.yScale && this.props.editable && this.state.trackOptions) {
          var configComponent = this.state.trackOptions.configComponent;
          var track = this.state.trackOptions.track;

          trackOptionsElement = _react2['default'].createElement(configComponent, {
            track: track,
            xScale: this.xScale,
            yScale: this.yScale,
            onCancel: function () {
              function onCancel() {
                _this6.setState({
                  trackOptions: null
                });
              }

              return onCancel;
            }(),
            onTrackOptionsChanged: function () {
              function onTrackOptionsChanged(newOptions) {
                return newOptions;
              }

              return onTrackOptionsChanged;
            }(),
            onSubmit: function () {
              function onSubmit(newOptions) {
                _this6.handleTrackOptionsChanged(_this6.state.trackOptions.track.uid, newOptions);
                _this6.setState({
                  trackOptions: null
                });
              }

              return onSubmit;
            }()
          });
        }

        var addTrackModal = null;
        var position = this.state.addTrackPosition ? this.state.addTrackPosition : this.props.addTrackPosition;

        if (this.state.addTrackPosition || this.props.addTrackPosition) {
          addTrackModal = _react2['default'].createElement(_AddTrackModal2['default'], {
            host: this.state.addTrackHost,
            onCancel: this.handleNoTrackAdded.bind(this),
            onTracksChosen: this.handleTracksAdded.bind(this),
            position: position,
            ref: function () {
              function ref(c) {
                _this6.addTrackModal = c;
              }

              return ref;
            }(),
            show: this.state.addTrackPosition != null || this.props.addTrackPosition != null,
            trackSourceServers: this.props.trackSourceServers
          });
        }

        // track renderer needs to enclose all the other divs so that it
        // can catch the zoom events
        return _react2['default'].createElement(
          'div',
          {
            ref: function () {
              function ref(c) {
                _this6.divTiledPlot = c;
              }

              return ref;
            }(),
            className: 'TiledPlot-module_tiled-plot-uFHiB'
          },
          trackRenderer,
          overlays,
          addTrackModal,
          configTrackMenu,
          closeTrackMenu,
          trackOptionsElement
        );
      }

      return render;
    }()
  }]);

  return TiledPlot;
}(_react2['default'].Component);

TiledPlot.propTypes = {
  addTrackPosition: _propTypes2['default'].string,
  canvasElement: _propTypes2['default'].object,
  chooseTrackHandler: _propTypes2['default'].func,
  chromInfoPath: _propTypes2['default'].string,
  dragging: _propTypes2['default'].bool,
  editable: _propTypes2['default'].bool,
  horizontalMargin: _propTypes2['default'].number,
  initialXDomain: _propTypes2['default'].array,
  initialYDomain: _propTypes2['default'].array,
  mouseTool: _propTypes2['default'].string,
  onCloseTrack: _propTypes2['default'].func,
  onDataDomainChanged: _propTypes2['default'].func,
  onLockValueScale: _propTypes2['default'].func,
  onNoTrackAdded: _propTypes2['default'].func,
  onNewTilesLoaded: _propTypes2['default'].func,
  onRangeSelection: _propTypes2['default'].func,
  onScalesChanged: _propTypes2['default'].func,
  onTracksAdded: _propTypes2['default'].func,
  onTrackOptionsChanged: _propTypes2['default'].func,
  onTrackPositionChosen: _propTypes2['default'].func,
  onValueScaleChanged: _propTypes2['default'].func,
  onUnlockValueScale: _propTypes2['default'].func,
  registerDraggingChangedListener: _propTypes2['default'].func,
  removeDraggingChangedListener: _propTypes2['default'].func,
  setCentersFunction: _propTypes2['default'].func,
  pixiStage: _propTypes2['default'].object,
  svgElement: _propTypes2['default'].object,
  trackSourceServers: _propTypes2['default'].array,
  tracks: _propTypes2['default'].object,
  'tracks.top': _propTypes2['default'].array,
  'tracks.bottom': _propTypes2['default'].array,
  'tracks.left': _propTypes2['default'].array,
  'tracks.right': _propTypes2['default'].array,
  verticalMargin: _propTypes2['default'].number,
  uid: _propTypes2['default'].string,
  zoomable: _propTypes2['default'].bool
};

exports['default'] = TiledPlot;

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CenterTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _getClassName2 = __webpack_require__(36);

var _getClassName3 = _interopRequireDefault(_getClassName2);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _d3Brush = __webpack_require__(25);

var _d3Selection = __webpack_require__(4);

var _TrackControl = __webpack_require__(122);

var _TrackControl2 = _interopRequireDefault(_TrackControl);

var _utils = __webpack_require__(3);

var _configs = __webpack_require__(6);

var _CenterTrackModule = __webpack_require__(239);

var _CenterTrackModule2 = _interopRequireDefault(_CenterTrackModule);

var _TrackModule = __webpack_require__(139);

var _TrackModule2 = _interopRequireDefault(_TrackModule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _styleModuleImportMap = {
  'styles': {
    'center-track': 'CenterTrack-module_center-track-3ptRW',
    'center-track-container': 'CenterTrack-module_center-track-container-2ELhp'
  },
  'stylesTrack': {
    'track-range-selection': 'Track-module_track-range-selection-1yrDf',
    'track-range-selection-active': 'Track-module_track-range-selection-active-1oljJ Track-module_track-range-selection-1yrDf',
    'track-range-selection-active-primary': 'Track-module_track-range-selection-active-primary-29M73 Track-module_track-range-selection-active-1oljJ Track-module_track-range-selection-1yrDf',
    'track-range-selection-active-secondary': 'Track-module_track-range-selection-active-secondary-1s0t5 Track-module_track-range-selection-active-1oljJ Track-module_track-range-selection-1yrDf',
    'track-range-selection-group-inactive': 'Track-module_track-range-selection-group-inactive-YNRM4'
  }
};

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Utils


// Configs


// Styles
// eslint-disable-line no-unused-vars


// eslint-disable-line no-unused-vars

var STYLES = {
  pointerEvents: 'all'
};

var CenterTrack = exports.CenterTrack = function (_React$Component) {
  _inherits(CenterTrack, _React$Component);

  function CenterTrack(props) {
    _classCallCheck(this, CenterTrack);

    var _this = _possibleConstructorReturn(this, (CenterTrack.__proto__ || Object.getPrototypeOf(CenterTrack)).call(this, props));

    _this.state = {
      isVisible: false
    };

    _this.brushBehaviorX = (0, _d3Brush.brushX)(true, true).on('brush', _this.brushedX.bind(_this));

    _this.brushBehaviorY = (0, _d3Brush.brushY)(true, true, true).on('brush', _this.brushedY.bind(_this));

    _this.brushBehaviorXY = (0, _d3Brush.brush)(true).on('start', _this.brushStarted.bind(_this)).on('brush', _this.brushedXY.bind(_this)).on('end', _this.brushedXYEnded.bind(_this));
    return _this;
  }

  /* -------------------------- Life Cycle Methods -------------------------- */

  _createClass(CenterTrack, [{
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {
        if (this.props.isRangeSelectionActive) {
          this.addBrush2d();
        }
      }

      return componentDidMount;
    }()
  }, {
    key: 'shouldComponentUpdate',
    value: function () {
      function shouldComponentUpdate(nextProps, nextState) {
        if (this.rangeSelectionTriggeredXY) {
          this.rangeSelectionTriggeredXY = false;
          return this.state !== nextState;
        } else if (this.props.rangeSelection !== nextProps.rangeSelection) {
          var dim1 = nextProps.rangeSelection[0] ? (0, _utils.genomeLociToPixels)(nextProps.rangeSelection[0], this.props.chromInfo) : null;

          if (this.props.chromInfo) {
            if (this.props.is1dRangeSelection) {
              if (!this.rangeSelectionTriggeredX) {
                this.moveBrushX(dim1);
              }
              if (!this.rangeSelectionTriggeredY) {
                this.moveBrushY(dim1);
              }
              this.rangeSelectionTriggeredX = false;
              this.rangeSelectionTriggeredY = false;
            } else {
              this.moveBrushXY([dim1, (0, _utils.genomeLociToPixels)(nextProps.rangeSelection[1], this.props.chromInfo)]);
            }
          }

          var isUnset = this.props.is1dRangeSelection && !nextProps.is1dRangeSelection && dim1 === null;

          return this.state !== nextState || isUnset;
        }
        return true;
      }

      return shouldComponentUpdate;
    }()
  }, {
    key: 'componentDidUpdate',
    value: function () {
      function componentDidUpdate() {
        if (this.props.isRangeSelectionActive) {
          this.addBrush2d();
        } else {
          this.removeBrush1d();
          this.removeBrush2d();
        }
      }

      return componentDidUpdate;
    }()

    /* ---------------------------- Custom Methods ---------------------------- */

  }, {
    key: 'addBrush1d',
    value: function () {
      function addBrush1d() {
        if (!this.brushElX || !this.brushElY || this.brushElXOld === this.brushElX && this.brushElYOld === this.brushElY) {
          return;
        }

        if (this.brushElXOld) {
          // Remove event listener on old element to avoid memory leaks
          this.brushElXOld.on('.brush', null);
        }

        if (this.brushElYOld) {
          // Remove event listener on old element to avoid memory leaks
          this.brushElYOld.on('.brush', null);
        }

        this.brushElX.call(this.brushBehaviorX);
        this.brushElY.call(this.brushBehaviorY);

        this.brushElXOld = this.brushElX;
        this.brushElYOld = this.brushElY;

        this.brushIs1dBound = true;
      }

      return addBrush1d;
    }()
  }, {
    key: 'addBrush2d',
    value: function () {
      function addBrush2d() {
        if (!this.brushElXY || this.brushElXYOld === this.brushElXY) {
          return;
        }

        if (this.brushElXYOld) {
          // Remove event listener on old element to avoid memory leaks
          this.brushElXYOld.on('.brush', null);
        }

        this.brushElXY.call(this.brushBehaviorXY);
        this.brushElXYOld = this.brushElXY;
        this.brushIs2dBound = true;
      }

      return addBrush2d;
    }()
  }, {
    key: 'brushedX',
    value: function () {
      function brushedX() {
        // Need to reassign variable to check after reset
        var rangeSelectionMoved = this.rangeSelectionMoved;
        this.rangeSelectionMoved = false;

        if (!_d3Selection.event.sourceEvent || !this.props.onRangeSelectionX || !this.props.is1dRangeSelection || rangeSelectionMoved) return;

        this.rangeSelectionTriggeredX = true;
        this.props.onRangeSelectionX(_d3Selection.event.selection);
      }

      return brushedX;
    }()
  }, {
    key: 'brushedY',
    value: function () {
      function brushedY() {
        // Need to reassign variable to check after reset
        var rangeSelectionMoved = this.rangeSelectionMoved;
        this.rangeSelectionMoved = false;

        if (!_d3Selection.event.sourceEvent || !this.props.onRangeSelectionY || !this.props.is1dRangeSelection || rangeSelectionMoved) return;

        this.rangeSelectionTriggeredY = true;
        this.props.onRangeSelectionY(_d3Selection.event.selection);
      }

      return brushedY;
    }()
  }, {
    key: 'brushedXY',
    value: function () {
      function brushedXY() {
        // Need to reassign variable to check after reset
        var rangeSelectionMoved = this.rangeSelectionMoved;
        this.rangeSelectionMoved = false;

        if (!_d3Selection.event.sourceEvent || !this.props.onRangeSelectionXY || rangeSelectionMoved || this.props.is1dRangeSelection) return;

        this.rangeSelectionTriggeredXY = true;
        this.props.onRangeSelectionXY([[_d3Selection.event.selection[0][0], _d3Selection.event.selection[1][0]], [_d3Selection.event.selection[0][1], _d3Selection.event.selection[1][1]]]);
      }

      return brushedXY;
    }()
  }, {
    key: 'brushedXYEnded',
    value: function () {
      function brushedXYEnded() {
        if (!_d3Selection.event.selection && !this.props.is1dRangeSelection) {
          this.rangeSelectionTriggeredXY = true;
          this.props.onRangeSelectionEnd();
        }
      }

      return brushedXYEnded;
    }()
  }, {
    key: 'brushStarted',
    value: function () {
      function brushStarted() {
        if (!_d3Selection.event.sourceEvent) return;

        this.props.onRangeSelectionStart();
      }

      return brushStarted;
    }()
  }, {
    key: 'moveBrushX',
    value: function () {
      function moveBrushX(rangeSelection) {
        if (!this.brushEl && !_d3Selection.event.sourceEvent) {
          return;
        }

        if (this.brushIs2dBound) {
          this.removeBrush2d();
          this.addBrush1d();
        }

        var relRangeX = rangeSelection ? [this.props.scaleX(rangeSelection[0]), this.props.scaleX(rangeSelection[1])] : null;

        this.rangeSelectionMoved = true;
        this.brushElX.call(this.brushBehaviorX.move, relRangeX);
      }

      return moveBrushX;
    }()
  }, {
    key: 'moveBrushY',
    value: function () {
      function moveBrushY(rangeSelection) {
        if (!this.brushEl && !_d3Selection.event.sourceEvent) {
          return;
        }

        if (this.brushIs2dBound) {
          this.removeBrush2d();
          this.addBrush1d();
        }

        var relRangeY = rangeSelection ? [this.props.scaleY(rangeSelection[0]), this.props.scaleY(rangeSelection[1])] : null;

        this.rangeSelectionMoved = true;
        this.brushElY.call(this.brushBehaviorY.move, relRangeY);
      }

      return moveBrushY;
    }()
  }, {
    key: 'moveBrushXY',
    value: function () {
      function moveBrushXY(rangeSelection) {
        if (!this.brushEl && !_d3Selection.event.sourceEvent) {
          return;
        }

        var relRange = [[this.props.scaleX(rangeSelection[0][0]), this.props.scaleY(rangeSelection[1][0])], [this.props.scaleX(rangeSelection[0][1]), this.props.scaleY(rangeSelection[1][1])]];

        this.rangeSelectionMoved = true;
        this.brushElXY.call(this.brushBehaviorXY.move, relRange);
      }

      return moveBrushXY;
    }()
  }, {
    key: 'mouseEnterHandler',
    value: function () {
      function mouseEnterHandler() {
        if (this.props.isRangeSelectionActive) return;

        this.setState({
          isVisible: true
        });
      }

      return mouseEnterHandler;
    }()
  }, {
    key: 'mouseLeaveHandler',
    value: function () {
      function mouseLeaveHandler() {
        this.setState({
          isVisible: false
        });
      }

      return mouseLeaveHandler;
    }()
  }, {
    key: 'removeBrush1d',
    value: function () {
      function removeBrush1d() {
        if (!this.brushIs1dBound) {
          return;
        }

        if (this.brushElX) {
          // Reset brush selection
          this.brushElX.call(this.brushBehaviorX.move, null);

          // Remove brush behavior
          this.brushElX.on('.brush', null);
        }

        if (this.brushElY) {
          // Reset brush selection
          this.brushElY.call(this.brushBehaviorY.move, null);

          // Remove brush behavior
          this.brushElY.on('.brush', null);
        }

        this.brushIs1dBound = false;
      }

      return removeBrush1d;
    }()
  }, {
    key: 'removeBrush2d',
    value: function () {
      function removeBrush2d() {
        if (!this.brushIs2dBound) {
          return;
        }

        if (this.brushElXY) {
          // Reset brush selection
          this.brushElXY.call(this.brushBehaviorXY.move, null);

          // Remove brush behavior
          this.brushElXY.on('.brush', null);
          this.brushElXYOld = undefined;

          this.brushIs2dBound = false;

          !this.props.is1dRangeSelection && this.props.onRangeSelectionEnd();
        }
      }

      return removeBrush2d;
    }()

    /* ------------------------------ Rendering ------------------------------- */

  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        var isBrushable = this.props.tracks.map(function (track) {
          return (0, _configs.IS_TRACK_RANGE_SELECTABLE)(track);
        }).reduce(_utils.or, false);

        // Althought the tracks property is an array and could contain more than one
        // track, in practice there is only one combined track.
        var menuClash = this.props.tracks.some(function (track) {
          if (track.contents) {
            // if this is a combined track, iterate over children
            return track.contents.some(function (subTrack) {
              if (subTrack.type === 'heatmap') {
                return subTrack.options.colorbarPosition === 'topRight';
              }
              return false;
            });
          } else {
            // if this isn't a combined track, just check if this a heatmap
            // with a topright colorbar
            if (track.type === 'heatmap') {
              return track.options.colorbarPosition === 'topRight';
            }
            return false;
          }
        });

        var rangeSelectorClass = this.props.isRangeSelectionActive ? this.props.is1dRangeSelection ? 'stylesTrack.track-range-selection-active-secondary' : 'stylesTrack.track-range-selection-active-primary' : 'stylesTrack.track-range-selection';

        var rangeSelectorGroup1dClass = !this.props.is1dRangeSelection ? 'stylesTrack.track-range-selection-group-inactive' : '';

        var rangeSelectorGroup2dClass = this.props.is1dRangeSelection ? 'stylesTrack.track-range-selection-group-inactive' : '';

        return _react2['default'].createElement(
          'div',
          {
            className: ((this.props.className ? this.props.className : '') ? (this.props.className ? this.props.className : '') + ' ' : '') + 'CenterTrack-module_center-track-3ptRW',
            onMouseEnter: this.mouseEnterHandler.bind(this),
            onMouseLeave: this.mouseLeaveHandler.bind(this),
            style: {
              height: this.props.height,
              width: this.props.width
            }
          },
          isBrushable && _react2['default'].createElement(
            'svg',
            {
              style: {
                height: this.props.height,
                width: this.props.width
              },

              xmlns: 'http://www.w3.org/2000/svg',
              className: (0, _getClassName3['default'])(rangeSelectorClass, _styleModuleImportMap)
            },
            _react2['default'].createElement('g', {
              ref: function () {
                function ref(el) {
                  return _this2.brushElX = (0, _d3Selection.select)(el);
                }

                return ref;
              }(),
              className: (0, _getClassName3['default'])(rangeSelectorGroup1dClass, _styleModuleImportMap)
            }),
            _react2['default'].createElement('g', {
              ref: function () {
                function ref(el) {
                  return _this2.brushElY = (0, _d3Selection.select)(el);
                }

                return ref;
              }(),
              className: (0, _getClassName3['default'])(rangeSelectorGroup1dClass, _styleModuleImportMap)
            }),
            _react2['default'].createElement('g', {
              ref: function () {
                function ref(el) {
                  return _this2.brushElXY = (0, _d3Selection.select)(el);
                }

                return ref;
              }(),
              className: (0, _getClassName3['default'])(rangeSelectorGroup2dClass, _styleModuleImportMap)
            })
          ),
          this.props.editable &&
          // show track controls if config menu is visible or
          // mouse is within the bounds of the track
          _react2['default'].createElement(_TrackControl2['default'], {
            imgStyleAdd: STYLES,
            imgStyleClose: STYLES,
            imgStyleMove: STYLES,
            imgStyleSettings: STYLES,
            isMoveable: false,
            isVisible: this.state.isVisible || this.props.uid === this.props.configTrackMenuId,
            onAddSeries: this.props.onAddSeries,
            onCloseTrackMenuOpened: this.props.onCloseTrackMenuOpened,
            onConfigTrackMenuOpened: this.props.onConfigTrackMenuOpened,
            paddingRight: menuClash,
            uid: this.props.uid
          })
        );
      }

      return render;
    }()
  }]);

  return CenterTrack;
}(_react2['default'].Component);

CenterTrack.propTypes = {
  chromInfo: _propTypes2['default'].object,
  className: _propTypes2['default'].string,
  editable: _propTypes2['default'].bool,
  height: _propTypes2['default'].number,
  is1dRangeSelection: _propTypes2['default'].bool,
  isRangeSelectionActive: _propTypes2['default'].bool,
  onAddSeries: _propTypes2['default'].func,
  onCloseTrackMenuOpened: _propTypes2['default'].func,
  onConfigTrackMenuOpened: _propTypes2['default'].func,
  onRangeSelectionX: _propTypes2['default'].func,
  onRangeSelectionY: _propTypes2['default'].func,
  onRangeSelectionXY: _propTypes2['default'].func,
  onRangeSelectionEnd: _propTypes2['default'].func,
  onRangeSelectionStart: _propTypes2['default'].func,
  rangeSelection: _propTypes2['default'].array,
  scaleX: _propTypes2['default'].func,
  scaleY: _propTypes2['default'].func,
  tracks: _propTypes2['default'].array,
  uid: _propTypes2['default'].string,
  width: _propTypes2['default'].number
};

exports['default'] = CenterTrack;

/***/ }),
/* 382 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = brushSelection;
/* harmony export (immutable) */ __webpack_exports__["b"] = brushX;
/* harmony export (immutable) */ __webpack_exports__["c"] = brushY;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dispatch__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_drag__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_interpolate__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3_selection__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_d3_transition__ = __webpack_require__(193);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__constant__ = __webpack_require__(419);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__event__ = __webpack_require__(420);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__noevent__ = __webpack_require__(421);









var MODE_DRAG = {name: "drag"},
    MODE_SPACE = {name: "space"},
    MODE_HANDLE = {name: "handle"},
    MODE_CENTER = {name: "center"};

var X = {
  name: "x",
  handles: ["e", "w"].map(type),
  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
  name: "xy",
  handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
  input: function(xy) { return xy; },
  output: function(xy) { return xy; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

// Like d3.local, but with the name __brush rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX(noKeyModifiers, noNew, noEventBlocking) {
  return brush(X, noKeyModifiers, noNew, noEventBlocking);
}

function brushY(noKeyModifiers, noNew, noEventBlocking) {
  return brush(Y, noKeyModifiers, noNew, noEventBlocking);
}

/* harmony default export */ __webpack_exports__["d"] = (function(noKeyModifiers, noNew, noEventBlocking) {
  return brush(XY, noKeyModifiers, noNew, noEventBlocking);
});

function brush(dim, noKeyModifiers, noNew, noEventBlocking) {
  var extent = defaultExtent,
      filter = defaultFilter,
      listeners = Object(__WEBPACK_IMPORTED_MODULE_0_d3_dispatch__["a" /* dispatch */])(brush, "start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", noEventBlocking ? "auto" : "all")
        .attr("cursor", noNew ? 'default' : cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local(this).extent;
          Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["select"])(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([type("selection")])
      .enter()
      .append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", noEventBlocking ? "auto" : "all")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");

    if (noNew) {
      group.on("mousedown.brush touchstart.brush", function() {
        __WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].target.__data__.type !== 'overlay' && started.apply(this, arguments);
      });
    } else {
      group.on("mousedown.brush touchstart.brush", started);
    }
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = Object(__WEBPACK_IMPORTED_MODULE_2_d3_interpolate__["a" /* interpolate */])(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && empty(selection1) ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 && selection1 ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            Object(__WEBPACK_IMPORTED_MODULE_4_d3_transition__["a" /* interrupt */])(that);
            state.selection = selection1 == null || empty(selection1) ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  function redraw() {
    var group = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["select"])(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args) {
    return that.__brush.emitter || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["customEvent"])(new __WEBPACK_IMPORTED_MODULE_6__event__["a" /* default */](brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].touches) { if (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].changedTouches.length < __WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].touches.length) return Object(__WEBPACK_IMPORTED_MODULE_7__noevent__["a" /* default */])(); }
    else if (touchending) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].target.__data__.type,
        mode = (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].metaKey && !noKeyModifiers ? type = "overlay" : type) === "selection" ? MODE_DRAG : (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].altKey && !noKeyModifiers ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx,
        dy,
        moving,
        shifting = signX && signY && __WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].shiftKey,
        lockX,
        lockY,
        point0 = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["mouse"])(that),
        point = point0,
        emit = emitter(that, arguments).beforestart();

    if (type === "overlay") {
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["select"])(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].touches) {
      group
          .on("touchmove.brush", moved, true)
          .on("touchend.brush touchcancel.brush", ended, true);
    } else {
      var view = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["select"])(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].view)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);

      if (!noKeyModifiers) {
        view.on("keydown.brush", keydowned, true)
            .on("keyup.brush", keyupped, true);
      }

      Object(__WEBPACK_IMPORTED_MODULE_1_d3_drag__["dragDisable"])(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].view);
    }

    Object(__WEBPACK_IMPORTED_MODULE_7__noevent__["b" /* nopropagation */])();
    Object(__WEBPACK_IMPORTED_MODULE_4_d3_transition__["a" /* interrupt */])(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["mouse"])(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      Object(__WEBPACK_IMPORTED_MODULE_7__noevent__["a" /* default */])();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      Object(__WEBPACK_IMPORTED_MODULE_7__noevent__["b" /* nopropagation */])();
      if (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].touches) {
        if (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        group.on("touchmove.brush touchend.brush touchcancel.brush", null);
      } else {
        Object(__WEBPACK_IMPORTED_MODULE_1_d3_drag__["dragEnable"])(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      Object(__WEBPACK_IMPORTED_MODULE_7__noevent__["a" /* default */])();
    }

    function keyupped() {
      switch (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      Object(__WEBPACK_IMPORTED_MODULE_7__noevent__["a" /* default */])();
    }
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = extent.apply(this, arguments);
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_5__constant__["a" /* default */])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_5__constant__["a" /* default */])(!!_), brush) : filter;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}


/***/ }),
/* 383 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dispatch__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_selection__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__nodrag__ = __webpack_require__(191);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__noevent__ = __webpack_require__(192);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constant__ = __webpack_require__(384);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__event__ = __webpack_require__(385);







// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !__WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: __WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].x, y: __WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].y} : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = Object(__WEBPACK_IMPORTED_MODULE_0_d3_dispatch__["a" /* dispatch */])("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), __WEBPACK_IMPORTED_MODULE_1_d3_selection__["mouse"], this, arguments);
    if (!gesture) return;
    Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["select"])(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    Object(__WEBPACK_IMPORTED_MODULE_2__nodrag__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].view);
    Object(__WEBPACK_IMPORTED_MODULE_3__noevent__["b" /* nopropagation */])();
    mousemoving = false;
    mousedownx = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].clientX;
    mousedowny = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].clientY;
    gesture("start");
  }

  function mousemoved() {
    Object(__WEBPACK_IMPORTED_MODULE_3__noevent__["a" /* default */])();
    if (!mousemoving) {
      var dx = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].clientX - mousedownx, dy = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["select"])(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].view).on("mousemove.drag mouseup.drag", null);
    Object(__WEBPACK_IMPORTED_MODULE_2__nodrag__["b" /* yesdrag */])(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].view, mousemoving);
    Object(__WEBPACK_IMPORTED_MODULE_3__noevent__["a" /* default */])();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, __WEBPACK_IMPORTED_MODULE_1_d3_selection__["touch"], this, arguments)) {
        Object(__WEBPACK_IMPORTED_MODULE_3__noevent__["b" /* nopropagation */])();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(__WEBPACK_IMPORTED_MODULE_3__noevent__["a" /* default */])();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(__WEBPACK_IMPORTED_MODULE_3__noevent__["b" /* nopropagation */])();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["customEvent"])(new __WEBPACK_IMPORTED_MODULE_5__event__["a" /* default */](drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((__WEBPACK_IMPORTED_MODULE_1_d3_selection__["event"].subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["customEvent"])(new __WEBPACK_IMPORTED_MODULE_5__event__["a" /* default */](drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_4__constant__["a" /* default */])(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_4__constant__["a" /* default */])(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_4__constant__["a" /* default */])(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_4__constant__["a" /* default */])(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
});


/***/ }),
/* 384 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 385 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DragEvent;
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};


/***/ }),
/* 386 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__interrupt__ = __webpack_require__(387);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__transition__ = __webpack_require__(390);




__WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"].prototype.interrupt = __WEBPACK_IMPORTED_MODULE_1__interrupt__["a" /* default */];
__WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"].prototype.transition = __WEBPACK_IMPORTED_MODULE_2__transition__["a" /* default */];


/***/ }),
/* 387 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interrupt__ = __webpack_require__(194);


/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  return this.each(function() {
    Object(__WEBPACK_IMPORTED_MODULE_0__interrupt__["a" /* default */])(this, name);
  });
});


/***/ }),
/* 388 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__timer__ = __webpack_require__(121);


/* harmony default export */ __webpack_exports__["a"] = (function(callback, delay, time) {
  var t = new __WEBPACK_IMPORTED_MODULE_0__timer__["a" /* Timer */];
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});


/***/ }),
/* 389 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__timer__ = __webpack_require__(121);


/* unused harmony default export */ var _unused_webpack_default_export = (function(callback, delay, time) {
  var t = new __WEBPACK_IMPORTED_MODULE_0__timer__["a" /* Timer */], total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? Object(__WEBPACK_IMPORTED_MODULE_0__timer__["b" /* now */])() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
});


/***/ }),
/* 390 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transition_index__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__transition_schedule__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_ease__ = __webpack_require__(407);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3_timer__ = __webpack_require__(195);





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: __WEBPACK_IMPORTED_MODULE_2_d3_ease__["a" /* easeCubicInOut */]
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = Object(__WEBPACK_IMPORTED_MODULE_3_d3_timer__["a" /* now */])(), defaultTiming;
    }
  }
  return timing;
}

/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var id,
      timing;

  if (name instanceof __WEBPACK_IMPORTED_MODULE_0__transition_index__["a" /* Transition */]) {
    id = name._id, name = name._name;
  } else {
    id = Object(__WEBPACK_IMPORTED_MODULE_0__transition_index__["b" /* newId */])(), (timing = defaultTiming).time = Object(__WEBPACK_IMPORTED_MODULE_3_d3_timer__["a" /* now */])(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        Object(__WEBPACK_IMPORTED_MODULE_1__transition_schedule__["e" /* default */])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__transition_index__["a" /* Transition */](groups, this._parents, name, id);
});


/***/ }),
/* 391 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_selection__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tween__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__interpolate__ = __webpack_require__(196);





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var fullname = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["namespace"])(name), i = fullname === "transform" ? __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__["h" /* interpolateTransformSvg */] : __WEBPACK_IMPORTED_MODULE_3__interpolate__["a" /* default */];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, Object(__WEBPACK_IMPORTED_MODULE_2__tween__["b" /* tweenValue */])(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + ""));
});


/***/ }),
/* 392 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(4);


function attrTweenNS(fullname, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttribute(name, i(t));
    };
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["namespace"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});


/***/ }),
/* 393 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(17);


function delayFunction(id, value) {
  return function() {
    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["g" /* init */])(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["g" /* init */])(this, id).delay = value;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["f" /* get */])(this.node(), id).delay;
});


/***/ }),
/* 394 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(17);


function durationFunction(id, value) {
  return function() {
    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */])(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */])(this, id).duration = value;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["f" /* get */])(this.node(), id).duration;
});


/***/ }),
/* 395 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(17);


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */])(this, id).ease = value;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["f" /* get */])(this.node(), id).ease;
});


/***/ }),
/* 396 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(26);



/* harmony default export */ __webpack_exports__["a"] = (function(match) {
  if (typeof match !== "function") match = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["matcher"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_1__index__["a" /* Transition */](subgroups, this._parents, this._name, this._id);
});


/***/ }),
/* 397 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(26);


/* harmony default export */ __webpack_exports__["a"] = (function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Transition */](merges, this._parents, this._name, this._id);
});


/***/ }),
/* 398 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(17);


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? __WEBPACK_IMPORTED_MODULE_0__schedule__["g" /* init */] : __WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */];
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["f" /* get */])(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
});


/***/ }),
/* 399 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this.on("end.remove", removeFunction(this._id));
});


/***/ }),
/* 400 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__schedule__ = __webpack_require__(17);




/* harmony default export */ __webpack_exports__["a"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["selector"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        Object(__WEBPACK_IMPORTED_MODULE_2__schedule__["e" /* default */])(subgroup[i], name, id, i, subgroup, Object(__WEBPACK_IMPORTED_MODULE_2__schedule__["f" /* get */])(node, id));
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_1__index__["a" /* Transition */](subgroups, this._parents, name, id);
});


/***/ }),
/* 401 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__schedule__ = __webpack_require__(17);




/* harmony default export */ __webpack_exports__["a"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["selectorAll"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = Object(__WEBPACK_IMPORTED_MODULE_2__schedule__["f" /* get */])(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            Object(__WEBPACK_IMPORTED_MODULE_2__schedule__["e" /* default */])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_1__index__["a" /* Transition */](subgroups, parents, name, id);
});


/***/ }),
/* 402 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(4);


var Selection = __WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"].prototype.constructor;

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return new Selection(this._groups, this._parents);
});


/***/ }),
/* 403 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_selection__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tween__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__interpolate__ = __webpack_require__(196);





function styleRemove(name, interpolate) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name),
        value1 = (this.style.removeProperty(name), Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function styleRemoveEnd(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name),
        value1 = value(this);
    if (value1 == null) value1 = (this.style.removeProperty(name), Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value, priority) {
  var i = (name += "") === "transform" ? __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__["g" /* interpolateTransformCss */] : __WEBPACK_IMPORTED_MODULE_3__interpolate__["a" /* default */];
  return value == null ? this
          .styleTween(name, styleRemove(name, i))
          .on("end.style." + name, styleRemoveEnd(name))
      : this.styleTween(name, typeof value === "function"
          ? styleFunction(name, i, Object(__WEBPACK_IMPORTED_MODULE_2__tween__["b" /* tweenValue */])(this, "style." + name, value))
          : styleConstant(name, i, value + ""), priority);
});


/***/ }),
/* 404 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function styleTween(name, value, priority) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.style.setProperty(name, i(t), priority);
    };
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});


/***/ }),
/* 405 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tween__ = __webpack_require__(71);


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(Object(__WEBPACK_IMPORTED_MODULE_0__tween__["b" /* tweenValue */])(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
});


/***/ }),
/* 406 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__schedule__ = __webpack_require__(17);



/* harmony default export */ __webpack_exports__["a"] = (function() {
  var name = this._name,
      id0 = this._id,
      id1 = Object(__WEBPACK_IMPORTED_MODULE_0__index__["b" /* newId */])();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = Object(__WEBPACK_IMPORTED_MODULE_1__schedule__["f" /* get */])(node, id0);
        Object(__WEBPACK_IMPORTED_MODULE_1__schedule__["e" /* default */])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Transition */](groups, this._parents, name, id1);
});


/***/ }),
/* 407 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_linear__ = __webpack_require__(408);
/* unused harmony reexport easeLinear */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_quad__ = __webpack_require__(409);
/* unused harmony reexport easeQuad */
/* unused harmony reexport easeQuadIn */
/* unused harmony reexport easeQuadOut */
/* unused harmony reexport easeQuadInOut */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_cubic__ = __webpack_require__(410);
/* unused harmony reexport easeCubic */
/* unused harmony reexport easeCubicIn */
/* unused harmony reexport easeCubicOut */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_2__src_cubic__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_poly__ = __webpack_require__(411);
/* unused harmony reexport easePoly */
/* unused harmony reexport easePolyIn */
/* unused harmony reexport easePolyOut */
/* unused harmony reexport easePolyInOut */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_sin__ = __webpack_require__(412);
/* unused harmony reexport easeSin */
/* unused harmony reexport easeSinIn */
/* unused harmony reexport easeSinOut */
/* unused harmony reexport easeSinInOut */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_exp__ = __webpack_require__(413);
/* unused harmony reexport easeExp */
/* unused harmony reexport easeExpIn */
/* unused harmony reexport easeExpOut */
/* unused harmony reexport easeExpInOut */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_circle__ = __webpack_require__(414);
/* unused harmony reexport easeCircle */
/* unused harmony reexport easeCircleIn */
/* unused harmony reexport easeCircleOut */
/* unused harmony reexport easeCircleInOut */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_bounce__ = __webpack_require__(415);
/* unused harmony reexport easeBounce */
/* unused harmony reexport easeBounceIn */
/* unused harmony reexport easeBounceOut */
/* unused harmony reexport easeBounceInOut */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_back__ = __webpack_require__(416);
/* unused harmony reexport easeBack */
/* unused harmony reexport easeBackIn */
/* unused harmony reexport easeBackOut */
/* unused harmony reexport easeBackInOut */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_elastic__ = __webpack_require__(417);
/* unused harmony reexport easeElastic */
/* unused harmony reexport easeElasticIn */
/* unused harmony reexport easeElasticOut */
/* unused harmony reexport easeElasticInOut */





















/***/ }),
/* 408 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export linear */
function linear(t) {
  return +t;
}


/***/ }),
/* 409 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export quadIn */
/* unused harmony export quadOut */
/* unused harmony export quadInOut */
function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}


/***/ }),
/* 410 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export cubicIn */
/* unused harmony export cubicOut */
/* harmony export (immutable) */ __webpack_exports__["a"] = cubicInOut;
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),
/* 411 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export polyIn */
/* unused harmony export polyOut */
/* unused harmony export polyInOut */
var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);


/***/ }),
/* 412 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export sinIn */
/* unused harmony export sinOut */
/* unused harmony export sinInOut */
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}


/***/ }),
/* 413 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export expIn */
/* unused harmony export expOut */
/* unused harmony export expInOut */
function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}


/***/ }),
/* 414 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export circleIn */
/* unused harmony export circleOut */
/* unused harmony export circleInOut */
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}


/***/ }),
/* 415 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export bounceIn */
/* unused harmony export bounceOut */
/* unused harmony export bounceInOut */
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}


/***/ }),
/* 416 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export backIn */
/* unused harmony export backOut */
/* unused harmony export backInOut */
var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);


/***/ }),
/* 417 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export elasticIn */
/* unused harmony export elasticOut */
/* unused harmony export elasticInOut */
var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);


/***/ }),
/* 418 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transition_index__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__transition_schedule__ = __webpack_require__(17);



var root = [null];

/* unused harmony default export */ var _unused_webpack_default_export = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > __WEBPACK_IMPORTED_MODULE_1__transition_schedule__["c" /* SCHEDULED */] && schedule.name === name) {
        return new __WEBPACK_IMPORTED_MODULE_0__transition_index__["a" /* Transition */]([[node]], root, name, +i);
      }
    }
  }

  return null;
});


/***/ }),
/* 419 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 420 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
});


/***/ }),
/* 421 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = nopropagation;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(4);


function nopropagation() {
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["event"].stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["event"].preventDefault();
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["event"].stopImmediatePropagation();
});


/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = sortableContainer;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__(8);

var _invariant = __webpack_require__(123);

var _invariant2 = _interopRequireDefault(_invariant);

var _Manager = __webpack_require__(423);

var _Manager2 = _interopRequireDefault(_Manager);

var _utils = __webpack_require__(72);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Export Higher Order Sortable Container Component
function sortableContainer(WrappedComponent) {
  var _class, _temp;

  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { withRef: false };

  return _temp = _class = function (_Component) {
    _inherits(_class, _Component);

    function _class(props) {
      _classCallCheck(this, _class);

      var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, props));

      _this.handleStart = function (e) {
        var _this$props = _this.props,
            distance = _this$props.distance,
            shouldCancelStart = _this$props.shouldCancelStart;


        if (e.button === 2 || shouldCancelStart(e)) {
          return false;
        }

        _this._touched = true;
        _this._pos = {
          x: e.pageX,
          y: e.pageY
        };

        var node = (0, _utils.closest)(e.target, function (el) {
          return el.sortableInfo != null;
        });

        if (node && node.sortableInfo && _this.nodeIsChild(node) && !_this.state.sorting) {
          var useDragHandle = _this.props.useDragHandle;
          var _node$sortableInfo = node.sortableInfo,
              index = _node$sortableInfo.index,
              collection = _node$sortableInfo.collection;


          if (useDragHandle && !(0, _utils.closest)(e.target, function (el) {
            return el.sortableHandle != null;
          })) return;

          _this.manager.active = { index: index, collection: collection };

          /*
          * Fixes a bug in Firefox where the :active state of anchor tags
          * prevent subsequent 'mousemove' events from being fired
          * (see https://github.com/clauderic/react-sortable-hoc/issues/118)
          */
          if (e.target.tagName.toLowerCase() === 'a') {
            e.preventDefault();
          }

          if (!distance) {
            if (_this.props.pressDelay === 0) {
              _this.handlePress(e);
            } else {
              _this.pressTimer = setTimeout(function () {
                return _this.handlePress(e);
              }, _this.props.pressDelay);
            }
          }
        }
      };

      _this.nodeIsChild = function (node) {
        return node.sortableInfo.manager === _this.manager;
      };

      _this.handleMove = function (e) {
        var _this$props2 = _this.props,
            distance = _this$props2.distance,
            pressThreshold = _this$props2.pressThreshold;


        if (!_this.state.sorting && _this._touched) {
          _this._delta = {
            x: _this._pos.x - e.pageX,
            y: _this._pos.y - e.pageY
          };
          var delta = Math.abs(_this._delta.x) + Math.abs(_this._delta.y);

          if (!distance && (!pressThreshold || pressThreshold && delta >= pressThreshold)) {
            clearTimeout(_this.cancelTimer);
            _this.cancelTimer = setTimeout(_this.cancel, 0);
          } else if (distance && delta >= distance && _this.manager.isActive()) {
            _this.handlePress(e);
          }
        }
      };

      _this.handleEnd = function () {
        var distance = _this.props.distance;


        _this._touched = false;

        if (!distance) {
          _this.cancel();
        }
      };

      _this.cancel = function () {
        if (!_this.state.sorting) {
          clearTimeout(_this.pressTimer);
          _this.manager.active = null;
        }
      };

      _this.handlePress = function (e) {
        var active = _this.manager.getActive();

        if (active) {
          var _this$props3 = _this.props,
              axis = _this$props3.axis,
              getHelperDimensions = _this$props3.getHelperDimensions,
              helperClass = _this$props3.helperClass,
              hideSortableGhost = _this$props3.hideSortableGhost,
              onSortStart = _this$props3.onSortStart,
              useWindowAsScrollContainer = _this$props3.useWindowAsScrollContainer;
          var node = active.node,
              collection = active.collection;
          var index = node.sortableInfo.index;

          var margin = (0, _utils.getElementMargin)(node);

          var containerBoundingRect = _this.container.getBoundingClientRect();
          var dimensions = getHelperDimensions({ index: index, node: node, collection: collection });

          _this.node = node;
          _this.margin = margin;
          _this.width = dimensions.width;
          _this.height = dimensions.height;
          _this.marginOffset = {
            x: _this.margin.left + _this.margin.right,
            y: Math.max(_this.margin.top, _this.margin.bottom)
          };
          _this.boundingClientRect = node.getBoundingClientRect();
          _this.containerBoundingRect = containerBoundingRect;
          _this.index = index;
          _this.newIndex = index;

          _this.axis = {
            x: axis.indexOf('x') >= 0,
            y: axis.indexOf('y') >= 0
          };
          _this.offsetEdge = _this.getEdgeOffset(node);
          _this.initialOffset = _this.getOffset(e);
          _this.initialScroll = {
            top: _this.scrollContainer.scrollTop,
            left: _this.scrollContainer.scrollLeft
          };

          _this.initialWindowScroll = {
            top: window.pageYOffset,
            left: window.pageXOffset
          };

          var fields = node.querySelectorAll('input, textarea, select');
          var clonedNode = node.cloneNode(true);
          var clonedFields = [].concat(_toConsumableArray(clonedNode.querySelectorAll('input, textarea, select'))); // Convert NodeList to Array

          clonedFields.forEach(function (field, index) {
            if (field.type !== 'file' && fields[index]) {
              field.value = fields[index].value;
            }
          });

          _this.helper = _this.document.body.appendChild(clonedNode);

          _this.helper.style.position = 'fixed';
          _this.helper.style.top = _this.boundingClientRect.top - margin.top + 'px';
          _this.helper.style.left = _this.boundingClientRect.left - margin.left + 'px';
          _this.helper.style.width = _this.width + 'px';
          _this.helper.style.height = _this.height + 'px';
          _this.helper.style.boxSizing = 'border-box';
          _this.helper.style.pointerEvents = 'none';

          if (hideSortableGhost) {
            _this.sortableGhost = node;
            node.style.visibility = 'hidden';
            node.style.opacity = 0;
          }

          _this.minTranslate = {};
          _this.maxTranslate = {};
          if (_this.axis.x) {
            _this.minTranslate.x = (useWindowAsScrollContainer ? 0 : containerBoundingRect.left) - _this.boundingClientRect.left - _this.width / 2;
            _this.maxTranslate.x = (useWindowAsScrollContainer ? _this.contentWindow.innerWidth : containerBoundingRect.left + containerBoundingRect.width) - _this.boundingClientRect.left - _this.width / 2;
          }
          if (_this.axis.y) {
            _this.minTranslate.y = (useWindowAsScrollContainer ? 0 : containerBoundingRect.top) - _this.boundingClientRect.top - _this.height / 2;
            _this.maxTranslate.y = (useWindowAsScrollContainer ? _this.contentWindow.innerHeight : containerBoundingRect.top + containerBoundingRect.height) - _this.boundingClientRect.top - _this.height / 2;
          }

          if (helperClass) {
            var _this$helper$classLis;

            (_this$helper$classLis = _this.helper.classList).add.apply(_this$helper$classLis, _toConsumableArray(helperClass.split(' ')));
          }

          _this.listenerNode = e.touches ? node : _this.contentWindow;
          _utils.events.move.forEach(function (eventName) {
            return _this.listenerNode.addEventListener(eventName, _this.handleSortMove, false);
          });
          _utils.events.end.forEach(function (eventName) {
            return _this.listenerNode.addEventListener(eventName, _this.handleSortEnd, false);
          });

          _this.setState({
            sorting: true,
            sortingIndex: index
          });

          if (onSortStart) onSortStart({ node: node, index: index, collection: collection }, e);
        }
      };

      _this.handleSortMove = function (e) {
        var onSortMove = _this.props.onSortMove;

        e.preventDefault(); // Prevent scrolling on mobile

        _this.updatePosition(e);
        _this.animateNodes();
        _this.autoscroll();

        if (onSortMove) onSortMove(e);
      };

      _this.handleSortEnd = function (e) {
        var _this$props4 = _this.props,
            hideSortableGhost = _this$props4.hideSortableGhost,
            onSortEnd = _this$props4.onSortEnd;
        var collection = _this.manager.active.collection;

        // Remove the event listeners if the node is still in the DOM

        if (_this.listenerNode) {
          _utils.events.move.forEach(function (eventName) {
            return _this.listenerNode.removeEventListener(eventName, _this.handleSortMove);
          });
          _utils.events.end.forEach(function (eventName) {
            return _this.listenerNode.removeEventListener(eventName, _this.handleSortEnd);
          });
        }

        // Remove the helper from the DOM
        _this.helper.parentNode.removeChild(_this.helper);

        if (hideSortableGhost && _this.sortableGhost) {
          _this.sortableGhost.style.visibility = '';
          _this.sortableGhost.style.opacity = '';
        }

        var nodes = _this.manager.refs[collection];
        for (var i = 0, len = nodes.length; i < len; i++) {
          var node = nodes[i];
          var el = node.node;

          // Clear the cached offsetTop / offsetLeft value
          node.edgeOffset = null;

          // Remove the transforms / transitions
          el.style[_utils.vendorPrefix + 'Transform'] = '';
          el.style[_utils.vendorPrefix + 'TransitionDuration'] = '';
        }

        // Stop autoscroll
        clearInterval(_this.autoscrollInterval);
        _this.autoscrollInterval = null;

        // Update state
        _this.manager.active = null;

        _this.setState({
          sorting: false,
          sortingIndex: null
        });

        if (typeof onSortEnd === 'function') {
          onSortEnd({
            oldIndex: _this.index,
            newIndex: _this.newIndex,
            collection: collection
          }, e);
        }

        _this._touched = false;
      };

      _this.autoscroll = function () {
        var translate = _this.translate;
        var direction = {
          x: 0,
          y: 0
        };
        var speed = {
          x: 1,
          y: 1
        };
        var acceleration = {
          x: 10,
          y: 10
        };

        if (translate.y >= _this.maxTranslate.y - _this.height / 2) {
          direction.y = 1; // Scroll Down
          speed.y = acceleration.y * Math.abs((_this.maxTranslate.y - _this.height / 2 - translate.y) / _this.height);
        } else if (translate.x >= _this.maxTranslate.x - _this.width / 2) {
          direction.x = 1; // Scroll Right
          speed.x = acceleration.x * Math.abs((_this.maxTranslate.x - _this.width / 2 - translate.x) / _this.width);
        } else if (translate.y <= _this.minTranslate.y + _this.height / 2) {
          direction.y = -1; // Scroll Up
          speed.y = acceleration.y * Math.abs((translate.y - _this.height / 2 - _this.minTranslate.y) / _this.height);
        } else if (translate.x <= _this.minTranslate.x + _this.width / 2) {
          direction.x = -1; // Scroll Left
          speed.x = acceleration.x * Math.abs((translate.x - _this.width / 2 - _this.minTranslate.x) / _this.width);
        }

        if (_this.autoscrollInterval) {
          clearInterval(_this.autoscrollInterval);
          _this.autoscrollInterval = null;
          _this.isAutoScrolling = false;
        }

        if (direction.x !== 0 || direction.y !== 0) {
          _this.autoscrollInterval = setInterval(function () {
            _this.isAutoScrolling = true;
            var offset = {
              left: 1 * speed.x * direction.x,
              top: 1 * speed.y * direction.y
            };
            _this.scrollContainer.scrollTop += offset.top;
            _this.scrollContainer.scrollLeft += offset.left;
            _this.translate.x += offset.left;
            _this.translate.y += offset.top;
            _this.animateNodes();
          }, 5);
        }
      };

      _this.manager = new _Manager2.default();
      _this.events = {
        start: _this.handleStart,
        move: _this.handleMove,
        end: _this.handleEnd
      };

      (0, _invariant2.default)(!(props.distance && props.pressDelay), 'Attempted to set both `pressDelay` and `distance` on SortableContainer, you may only use one or the other, not both at the same time.');

      _this.state = {};
      return _this;
    }

    _createClass(_class, [{
      key: 'getChildContext',
      value: function getChildContext() {
        return {
          manager: this.manager
        };
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _this2 = this;

        var _props = this.props,
            getContainer = _props.getContainer,
            useWindowAsScrollContainer = _props.useWindowAsScrollContainer;

        /*
         *  Set our own default rather than using defaultProps because Jest
         *  snapshots will serialize window, causing a RangeError
         *  https://github.com/clauderic/react-sortable-hoc/issues/249
         */

        var contentWindow = this.props.contentWindow || window;

        this.container = typeof getContainer === 'function' ? getContainer(this.getWrappedInstance()) : (0, _reactDom.findDOMNode)(this);
        this.document = this.container.ownerDocument || document;
        this.scrollContainer = useWindowAsScrollContainer ? this.document.body : this.container;
        this.contentWindow = typeof contentWindow === 'function' ? contentWindow() : contentWindow;

        var _loop = function _loop(key) {
          if (_this2.events.hasOwnProperty(key)) {
            _utils.events[key].forEach(function (eventName) {
              return _this2.container.addEventListener(eventName, _this2.events[key], false);
            });
          }
        };

        for (var key in this.events) {
          _loop(key);
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var _this3 = this;

        var _loop2 = function _loop2(key) {
          if (_this3.events.hasOwnProperty(key)) {
            _utils.events[key].forEach(function (eventName) {
              return _this3.container.removeEventListener(eventName, _this3.events[key]);
            });
          }
        };

        for (var key in this.events) {
          _loop2(key);
        }
      }
    }, {
      key: 'getEdgeOffset',
      value: function getEdgeOffset(node) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { top: 0, left: 0 };

        // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested
        if (node) {
          var nodeOffset = {
            top: offset.top + node.offsetTop,
            left: offset.left + node.offsetLeft
          };
          if (node.parentNode !== this.container) {
            return this.getEdgeOffset(node.parentNode, nodeOffset);
          } else {
            return nodeOffset;
          }
        }
      }
    }, {
      key: 'getOffset',
      value: function getOffset(e) {
        return {
          x: e.touches ? e.touches[0].pageX : e.pageX,
          y: e.touches ? e.touches[0].pageY : e.pageY
        };
      }
    }, {
      key: 'getLockPixelOffsets',
      value: function getLockPixelOffsets() {
        var lockOffset = this.props.lockOffset;


        if (!Array.isArray(lockOffset)) {
          lockOffset = [lockOffset, lockOffset];
        }

        (0, _invariant2.default)(lockOffset.length === 2, 'lockOffset prop of SortableContainer should be a single ' + 'value or an array of exactly two values. Given %s', lockOffset);

        var _lockOffset = lockOffset,
            _lockOffset2 = _slicedToArray(_lockOffset, 2),
            minLockOffset = _lockOffset2[0],
            maxLockOffset = _lockOffset2[1];

        return [this.getLockPixelOffset(minLockOffset), this.getLockPixelOffset(maxLockOffset)];
      }
    }, {
      key: 'getLockPixelOffset',
      value: function getLockPixelOffset(lockOffset) {
        var offsetX = lockOffset;
        var offsetY = lockOffset;
        var unit = 'px';

        if (typeof lockOffset === 'string') {
          var match = /^[+-]?\d*(?:\.\d*)?(px|%)$/.exec(lockOffset);

          (0, _invariant2.default)(match !== null, 'lockOffset value should be a number or a string of a ' + 'number followed by "px" or "%". Given %s', lockOffset);

          offsetX = offsetY = parseFloat(lockOffset);
          unit = match[1];
        }

        (0, _invariant2.default)(isFinite(offsetX) && isFinite(offsetY), 'lockOffset value should be a finite. Given %s', lockOffset);

        if (unit === '%') {
          offsetX = offsetX * this.width / 100;
          offsetY = offsetY * this.height / 100;
        }

        return {
          x: offsetX,
          y: offsetY
        };
      }
    }, {
      key: 'updatePosition',
      value: function updatePosition(e) {
        var _props2 = this.props,
            lockAxis = _props2.lockAxis,
            lockToContainerEdges = _props2.lockToContainerEdges;


        var offset = this.getOffset(e);
        var translate = {
          x: offset.x - this.initialOffset.x,
          y: offset.y - this.initialOffset.y
        };
        // Adjust for window scroll
        translate.y -= window.pageYOffset - this.initialWindowScroll.top;
        translate.x -= window.pageXOffset - this.initialWindowScroll.left;

        this.translate = translate;

        if (lockToContainerEdges) {
          var _getLockPixelOffsets = this.getLockPixelOffsets(),
              _getLockPixelOffsets2 = _slicedToArray(_getLockPixelOffsets, 2),
              minLockOffset = _getLockPixelOffsets2[0],
              maxLockOffset = _getLockPixelOffsets2[1];

          var minOffset = {
            x: this.width / 2 - minLockOffset.x,
            y: this.height / 2 - minLockOffset.y
          };
          var maxOffset = {
            x: this.width / 2 - maxLockOffset.x,
            y: this.height / 2 - maxLockOffset.y
          };

          translate.x = (0, _utils.limit)(this.minTranslate.x + minOffset.x, this.maxTranslate.x - maxOffset.x, translate.x);
          translate.y = (0, _utils.limit)(this.minTranslate.y + minOffset.y, this.maxTranslate.y - maxOffset.y, translate.y);
        }

        if (lockAxis === 'x') {
          translate.y = 0;
        } else if (lockAxis === 'y') {
          translate.x = 0;
        }

        this.helper.style[_utils.vendorPrefix + 'Transform'] = 'translate3d(' + translate.x + 'px,' + translate.y + 'px, 0)';
      }
    }, {
      key: 'animateNodes',
      value: function animateNodes() {
        var _props3 = this.props,
            transitionDuration = _props3.transitionDuration,
            hideSortableGhost = _props3.hideSortableGhost;

        var nodes = this.manager.getOrderedRefs();
        var deltaScroll = {
          left: this.scrollContainer.scrollLeft - this.initialScroll.left,
          top: this.scrollContainer.scrollTop - this.initialScroll.top
        };
        var sortingOffset = {
          left: this.offsetEdge.left + this.translate.x + deltaScroll.left,
          top: this.offsetEdge.top + this.translate.y + deltaScroll.top
        };
        var scrollDifference = {
          top: window.pageYOffset - this.initialWindowScroll.top,
          left: window.pageXOffset - this.initialWindowScroll.left
        };
        this.newIndex = null;

        for (var i = 0, len = nodes.length; i < len; i++) {
          var node = nodes[i].node;

          var index = node.sortableInfo.index;
          var width = node.offsetWidth;
          var height = node.offsetHeight;
          var offset = {
            width: this.width > width ? width / 2 : this.width / 2,
            height: this.height > height ? height / 2 : this.height / 2
          };

          var translate = {
            x: 0,
            y: 0
          };
          var edgeOffset = nodes[i].edgeOffset;

          // If we haven't cached the node's offsetTop / offsetLeft value

          if (!edgeOffset) {
            nodes[i].edgeOffset = edgeOffset = this.getEdgeOffset(node);
          }

          // Get a reference to the next and previous node
          var nextNode = i < nodes.length - 1 && nodes[i + 1];
          var prevNode = i > 0 && nodes[i - 1];

          // Also cache the next node's edge offset if needed.
          // We need this for calculating the animation in a grid setup
          if (nextNode && !nextNode.edgeOffset) {
            nextNode.edgeOffset = this.getEdgeOffset(nextNode.node);
          }

          // If the node is the one we're currently animating, skip it
          if (index === this.index) {
            if (hideSortableGhost) {
              /*
              * With windowing libraries such as `react-virtualized`, the sortableGhost
              * node may change while scrolling down and then back up (or vice-versa),
              * so we need to update the reference to the new node just to be safe.
              */
              this.sortableGhost = node;
              node.style.visibility = 'hidden';
              node.style.opacity = 0;
            }
            continue;
          }

          if (transitionDuration) {
            node.style[_utils.vendorPrefix + 'TransitionDuration'] = transitionDuration + 'ms';
          }

          if (this.axis.x) {
            if (this.axis.y) {
              // Calculations for a grid setup
              if (index < this.index && (sortingOffset.left + scrollDifference.left - offset.width <= edgeOffset.left && sortingOffset.top + scrollDifference.top <= edgeOffset.top + offset.height || sortingOffset.top + scrollDifference.top + offset.height <= edgeOffset.top)) {
                // If the current node is to the left on the same row, or above the node that's being dragged
                // then move it to the right
                translate.x = this.width + this.marginOffset.x;
                if (edgeOffset.left + translate.x > this.containerBoundingRect.width - offset.width) {
                  // If it moves passed the right bounds, then animate it to the first position of the next row.
                  // We just use the offset of the next node to calculate where to move, because that node's original position
                  // is exactly where we want to go
                  translate.x = nextNode.edgeOffset.left - edgeOffset.left;
                  translate.y = nextNode.edgeOffset.top - edgeOffset.top;
                }
                if (this.newIndex === null) {
                  this.newIndex = index;
                }
              } else if (index > this.index && (sortingOffset.left + scrollDifference.left + offset.width >= edgeOffset.left && sortingOffset.top + scrollDifference.top + offset.height >= edgeOffset.top || sortingOffset.top + scrollDifference.top + offset.height >= edgeOffset.top + height)) {
                // If the current node is to the right on the same row, or below the node that's being dragged
                // then move it to the left
                translate.x = -(this.width + this.marginOffset.x);
                if (edgeOffset.left + translate.x < this.containerBoundingRect.left + offset.width) {
                  // If it moves passed the left bounds, then animate it to the last position of the previous row.
                  // We just use the offset of the previous node to calculate where to move, because that node's original position
                  // is exactly where we want to go
                  translate.x = prevNode.edgeOffset.left - edgeOffset.left;
                  translate.y = prevNode.edgeOffset.top - edgeOffset.top;
                }
                this.newIndex = index;
              }
            } else {
              if (index > this.index && sortingOffset.left + scrollDifference.left + offset.width >= edgeOffset.left) {
                translate.x = -(this.width + this.marginOffset.x);
                this.newIndex = index;
              } else if (index < this.index && sortingOffset.left + scrollDifference.left <= edgeOffset.left + offset.width) {
                translate.x = this.width + this.marginOffset.x;
                if (this.newIndex == null) {
                  this.newIndex = index;
                }
              }
            }
          } else if (this.axis.y) {
            if (index > this.index && sortingOffset.top + scrollDifference.top + offset.height >= edgeOffset.top) {
              translate.y = -(this.height + this.marginOffset.y);
              this.newIndex = index;
            } else if (index < this.index && sortingOffset.top + scrollDifference.top <= edgeOffset.top + offset.height) {
              translate.y = this.height + this.marginOffset.y;
              if (this.newIndex == null) {
                this.newIndex = index;
              }
            }
          }
          node.style[_utils.vendorPrefix + 'Transform'] = 'translate3d(' + translate.x + 'px,' + translate.y + 'px,0)';
        }

        if (this.newIndex == null) {
          this.newIndex = this.index;
        }
      }
    }, {
      key: 'getWrappedInstance',
      value: function getWrappedInstance() {
        (0, _invariant2.default)(config.withRef, 'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableContainer() call');
        return this.refs.wrappedInstance;
      }
    }, {
      key: 'render',
      value: function render() {
        var ref = config.withRef ? 'wrappedInstance' : null;

        return _react2.default.createElement(WrappedComponent, _extends({
          ref: ref
        }, (0, _utils.omit)(this.props, 'contentWindow', 'useWindowAsScrollContainer', 'distance', 'helperClass', 'hideSortableGhost', 'transitionDuration', 'useDragHandle', 'pressDelay', 'pressThreshold', 'shouldCancelStart', 'onSortStart', 'onSortMove', 'onSortEnd', 'axis', 'lockAxis', 'lockOffset', 'lockToContainerEdges', 'getContainer', 'getHelperDimensions')));
      }
    }]);

    return _class;
  }(_react.Component), _class.displayName = (0, _utils.provideDisplayName)('sortableList', WrappedComponent), _class.defaultProps = {
    axis: 'y',
    transitionDuration: 300,
    pressDelay: 0,
    pressThreshold: 5,
    distance: 0,
    useWindowAsScrollContainer: false,
    hideSortableGhost: true,
    shouldCancelStart: function shouldCancelStart(e) {
      // Cancel sorting if the event target is an `input`, `textarea`, `select` or `option`
      var disabledElements = ['input', 'textarea', 'select', 'option', 'button'];

      if (disabledElements.indexOf(e.target.tagName.toLowerCase()) !== -1) {
        return true; // Return true to cancel sorting
      }
    },
    lockToContainerEdges: false,
    lockOffset: '50%',
    getHelperDimensions: function getHelperDimensions(_ref) {
      var node = _ref.node;
      return {
        width: node.offsetWidth,
        height: node.offsetHeight
      };
    }
  }, _class.propTypes = {
    axis: _propTypes2.default.oneOf(['x', 'y', 'xy']),
    distance: _propTypes2.default.number,
    lockAxis: _propTypes2.default.string,
    helperClass: _propTypes2.default.string,
    transitionDuration: _propTypes2.default.number,
    contentWindow: _propTypes2.default.any,
    onSortStart: _propTypes2.default.func,
    onSortMove: _propTypes2.default.func,
    onSortEnd: _propTypes2.default.func,
    shouldCancelStart: _propTypes2.default.func,
    pressDelay: _propTypes2.default.number,
    useDragHandle: _propTypes2.default.bool,
    useWindowAsScrollContainer: _propTypes2.default.bool,
    hideSortableGhost: _propTypes2.default.bool,
    lockToContainerEdges: _propTypes2.default.bool,
    lockOffset: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string, _propTypes2.default.arrayOf(_propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]))]),
    getContainer: _propTypes2.default.func,
    getHelperDimensions: _propTypes2.default.func
  }, _class.childContextTypes = {
    manager: _propTypes2.default.object.isRequired
  }, _temp;
}

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _find = __webpack_require__(424);

var _find2 = _interopRequireDefault(_find);

var _sortBy = __webpack_require__(494);

var _sortBy2 = _interopRequireDefault(_sortBy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Manager = function () {
  function Manager() {
    _classCallCheck(this, Manager);

    this.refs = {};
  }

  _createClass(Manager, [{
    key: 'add',
    value: function add(collection, ref) {
      if (!this.refs[collection]) {
        this.refs[collection] = [];
      }

      this.refs[collection].push(ref);
    }
  }, {
    key: 'remove',
    value: function remove(collection, ref) {
      var index = this.getIndex(collection, ref);

      if (index !== -1) {
        this.refs[collection].splice(index, 1);
      }
    }
  }, {
    key: 'isActive',
    value: function isActive() {
      return this.active;
    }
  }, {
    key: 'getActive',
    value: function getActive() {
      var _this = this;

      return (0, _find2.default)(this.refs[this.active.collection],
      // eslint-disable-next-line eqeqeq
      function (_ref) {
        var node = _ref.node;
        return node.sortableInfo.index == _this.active.index;
      });
    }
  }, {
    key: 'getIndex',
    value: function getIndex(collection, ref) {
      return this.refs[collection].indexOf(ref);
    }
  }, {
    key: 'getOrderedRefs',
    value: function getOrderedRefs() {
      var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.active.collection;

      return (0, _sortBy2.default)(this.refs[collection], function (_ref2) {
        var node = _ref2.node;
        return node.sortableInfo.index;
      });
    }
  }]);

  return Manager;
}();

exports.default = Manager;

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

var createFind = __webpack_require__(425),
    findIndex = __webpack_require__(490);

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;


/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee = __webpack_require__(73),
    isArrayLike = __webpack_require__(50),
    keys = __webpack_require__(49);

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;


/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMatch = __webpack_require__(427),
    getMatchData = __webpack_require__(476),
    matchesStrictComparable = __webpack_require__(214);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(124),
    baseIsEqual = __webpack_require__(200);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),
/* 428 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(75);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(75);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(75);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(75);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(74);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 434 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 435 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 436 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(74),
    Map = __webpack_require__(125),
    MapCache = __webpack_require__(126);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(197),
    isMasked = __webpack_require__(441),
    isObject = __webpack_require__(21),
    toSource = __webpack_require__(199);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(48);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 440 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(442);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(18);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 443 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(445),
    ListCache = __webpack_require__(74),
    Map = __webpack_require__(125);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(446),
    hashDelete = __webpack_require__(447),
    hashGet = __webpack_require__(448),
    hashHas = __webpack_require__(449),
    hashSet = __webpack_require__(450);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(77);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 447 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(77);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(77);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(77);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(78);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 452 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(78);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(78);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(78);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(124),
    equalArrays = __webpack_require__(201),
    equalByTag = __webpack_require__(462),
    equalObjects = __webpack_require__(463),
    getTag = __webpack_require__(212),
    isArray = __webpack_require__(15),
    isBuffer = __webpack_require__(130),
    isTypedArray = __webpack_require__(209);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(126),
    setCacheAdd = __webpack_require__(458),
    setCacheHas = __webpack_require__(459);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),
/* 458 */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),
/* 459 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),
/* 460 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),
/* 461 */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(48),
    Uint8Array = __webpack_require__(202),
    eq = __webpack_require__(76),
    equalArrays = __webpack_require__(201),
    mapToArray = __webpack_require__(203),
    setToArray = __webpack_require__(204);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__(205);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),
/* 464 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),
/* 465 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(38),
    isObjectLike = __webpack_require__(39);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 467 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(38),
    isLength = __webpack_require__(132),
    isObjectLike = __webpack_require__(39);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(198);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(70)(module)))

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(133),
    nativeKeys = __webpack_require__(471);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(211);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(37),
    root = __webpack_require__(18);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(37),
    root = __webpack_require__(18);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(37),
    root = __webpack_require__(18);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(37),
    root = __webpack_require__(18);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

var isStrictComparable = __webpack_require__(213),
    keys = __webpack_require__(49);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(200),
    get = __webpack_require__(478),
    hasIn = __webpack_require__(484),
    isKey = __webpack_require__(134),
    isStrictComparable = __webpack_require__(213),
    matchesStrictComparable = __webpack_require__(214),
    toKey = __webpack_require__(79);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(215);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(480);

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(481);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(126);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(483);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(48),
    arrayMap = __webpack_require__(135),
    isArray = __webpack_require__(15),
    isSymbol = __webpack_require__(57);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(485),
    hasPath = __webpack_require__(486);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),
/* 485 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(216),
    isArguments = __webpack_require__(129),
    isArray = __webpack_require__(15),
    isIndex = __webpack_require__(131),
    isLength = __webpack_require__(132),
    toKey = __webpack_require__(79);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(488),
    basePropertyDeep = __webpack_require__(489),
    isKey = __webpack_require__(134),
    toKey = __webpack_require__(79);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),
/* 488 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(215);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(491),
    baseIteratee = __webpack_require__(73),
    toInteger = __webpack_require__(492);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;


/***/ }),
/* 491 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

var toFinite = __webpack_require__(493);

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

var toNumber = __webpack_require__(217);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(495),
    baseOrderBy = __webpack_require__(497),
    baseRest = __webpack_require__(504),
    isIterateeCall = __webpack_require__(511);

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;


/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(127),
    isFlattenable = __webpack_require__(496);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(48),
    isArguments = __webpack_require__(129),
    isArray = __webpack_require__(15);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(135),
    baseIteratee = __webpack_require__(73),
    baseMap = __webpack_require__(218),
    baseSortBy = __webpack_require__(501),
    baseUnary = __webpack_require__(210),
    compareMultiple = __webpack_require__(502),
    identity = __webpack_require__(58);

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;


/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(499);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 499 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(50);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),
/* 501 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;


/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

var compareAscending = __webpack_require__(503);

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;


/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(57);

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;


/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(58),
    overRest = __webpack_require__(505),
    setToString = __webpack_require__(507);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(506);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 506 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(508),
    shortOut = __webpack_require__(510);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(509),
    defineProperty = __webpack_require__(221),
    identity = __webpack_require__(58);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 509 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 510 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(76),
    isArrayLike = __webpack_require__(50),
    isIndex = __webpack_require__(131),
    isObject = __webpack_require__(21);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = sortableElement;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__(8);

var _invariant = __webpack_require__(123);

var _invariant2 = _interopRequireDefault(_invariant);

var _utils = __webpack_require__(72);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Export Higher Order Sortable Element Component
function sortableElement(WrappedComponent) {
  var _class, _temp;

  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { withRef: false };

  return _temp = _class = function (_Component) {
    _inherits(_class, _Component);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _props = this.props,
            collection = _props.collection,
            disabled = _props.disabled,
            index = _props.index;


        if (!disabled) {
          this.setDraggable(collection, index);
        }
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        if (this.props.index !== nextProps.index && this.node) {
          this.node.sortableInfo.index = nextProps.index;
        }
        if (this.props.disabled !== nextProps.disabled) {
          var collection = nextProps.collection,
              disabled = nextProps.disabled,
              index = nextProps.index;

          if (disabled) {
            this.removeDraggable(collection);
          } else {
            this.setDraggable(collection, index);
          }
        } else if (this.props.collection !== nextProps.collection) {
          this.removeDraggable(this.props.collection);
          this.setDraggable(nextProps.collection, nextProps.index);
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var _props2 = this.props,
            collection = _props2.collection,
            disabled = _props2.disabled;


        if (!disabled) this.removeDraggable(collection);
      }
    }, {
      key: 'setDraggable',
      value: function setDraggable(collection, index) {
        var node = this.node = (0, _reactDom.findDOMNode)(this);

        node.sortableInfo = {
          index: index,
          collection: collection,
          manager: this.context.manager
        };

        this.ref = { node: node };
        this.context.manager.add(collection, this.ref);
      }
    }, {
      key: 'removeDraggable',
      value: function removeDraggable(collection) {
        this.context.manager.remove(collection, this.ref);
      }
    }, {
      key: 'getWrappedInstance',
      value: function getWrappedInstance() {
        (0, _invariant2.default)(config.withRef, 'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableElement() call');
        return this.refs.wrappedInstance;
      }
    }, {
      key: 'render',
      value: function render() {
        var ref = config.withRef ? 'wrappedInstance' : null;

        return _react2.default.createElement(WrappedComponent, _extends({
          ref: ref
        }, (0, _utils.omit)(this.props, 'collection', 'disabled', 'index')));
      }
    }]);

    return _class;
  }(_react.Component), _class.displayName = (0, _utils.provideDisplayName)('sortableElement', WrappedComponent), _class.contextTypes = {
    manager: _propTypes2.default.object.isRequired
  }, _class.propTypes = {
    index: _propTypes2.default.number.isRequired,
    collection: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    disabled: _propTypes2.default.bool
  }, _class.defaultProps = {
    collection: 0
  }, _temp;
}

/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = sortableHandle;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(8);

var _invariant = __webpack_require__(123);

var _invariant2 = _interopRequireDefault(_invariant);

var _utils = __webpack_require__(72);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Export Higher Order Sortable Element Component
function sortableHandle(WrappedComponent) {
  var _class, _temp;

  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { withRef: false };

  return _temp = _class = function (_Component) {
    _inherits(_class, _Component);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var node = (0, _reactDom.findDOMNode)(this);
        node.sortableHandle = true;
      }
    }, {
      key: 'getWrappedInstance',
      value: function getWrappedInstance() {
        (0, _invariant2.default)(config.withRef, 'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableHandle() call');
        return this.refs.wrappedInstance;
      }
    }, {
      key: 'render',
      value: function render() {
        var ref = config.withRef ? 'wrappedInstance' : null;

        return _react2.default.createElement(WrappedComponent, _extends({ ref: ref }, this.props));
      }
    }]);

    return _class;
  }(_react.Component), _class.displayName = (0, _utils.provideDisplayName)('sortableHandle', WrappedComponent), _temp;
}

/***/ }),
/* 514 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"track-control":"TrackControl-module_track-control-2zDf3","track-control-vertical":"TrackControl-module_track-control-vertical-2McB_","track-control-left":"TrackControl-module_track-control-left-zHd9W","track-control-active":"TrackControl-module_track-control-active-2JD9i TrackControl-module_track-control-2zDf3","track-control-vertical-active":"TrackControl-module_track-control-vertical-active-1QCKn","track-control-padding-right":"TrackControl-module_track-control-padding-right-2p6Lp","track-control-button":"TrackControl-module_track-control-button-2fdIb","track-control-button-vertical":"TrackControl-module_track-control-button-vertical-1s22z"};

/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ = __webpack_require__(3);

var absToChr = function () {
  function absToChr(absPosition, chromInfo) {
    var insertPoint = (0, _.chromInfoBisector)(chromInfo.cumPositions, absPosition);
    var lastChr = chromInfo.cumPositions[chromInfo.cumPositions.length - 1].chr;
    var lastLength = chromInfo.chromLengths[lastChr];

    insertPoint -= insertPoint > 0 && 1;

    var chrPosition = Math.floor(absPosition - chromInfo.cumPositions[insertPoint].pos);
    var offset = 0;

    if (chrPosition < 0) {
      // before the start of the genome
      offset = chrPosition - 1;
      chrPosition = 1;
    }

    if (insertPoint == chromInfo.cumPositions.length - 1 && chrPosition > lastLength) {
      // beyond the last chromosome
      offset = chrPosition - lastLength;
      chrPosition = lastLength;
    }

    return [chromInfo.cumPositions[insertPoint].chr, chrPosition, offset, insertPoint];
  }

  return absToChr;
}();

exports['default'] = absToChr;

/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _d3Array = __webpack_require__(10);

var chromInfoBisector = (0, _d3Array.bisector)(function (d) {
  return d.pos;
}).left;

exports['default'] = chromInfoBisector;

/***/ }),
/* 517 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
var chrToAbs = function () {
  function chrToAbs(chrom, relPosition, chromInfo) {
    return chromInfo.chrPositions[chrom].pos + relPosition;
  }

  return chrToAbs;
}();

exports["default"] = chrToAbs;

/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _d3Scale = __webpack_require__(12);

var _d3Array = __webpack_require__(10);

var _d3Color = __webpack_require__(14);

/**
 * Convert a color domain to a 255 element array of [r,g,b,a]
 * values (all from 0 to 255). The last color (255) will always be
 * transparent
 */
var colorDomainToRgbaArray = function () {
  function colorDomainToRgbaArray(colorRange) {
    // we should always have at least two values in the color range
    var domain = colorRange.map(function (x, i) {
      return i * (255 / (colorRange.length - 1));
    });

    var d3Scale = (0, _d3Scale.scaleLinear)().domain(domain).range(colorRange);

    var rgbaArray = (0, _d3Array.range)(254, -1, -1).map(d3Scale).map(function (x) {
      var r = (0, _d3Color.rgb)(x);
      return [r.r, r.g, r.b, 255];
    });

    // add a transparent color at the end for missing values
    rgbaArray.push([255, 255, 255, 0]);

    return rgbaArray;
  }

  return colorDomainToRgbaArray;
}();

exports['default'] = colorDomainToRgbaArray;

/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _d3Color = __webpack_require__(14);

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

/**
 * Convert a regular color value (e.g. 'red', '#FF0000', 'rgb(255,0,0)') to a
 * hex value which is legible by PIXI
 */
var colorToHex = function () {
  function colorToHex(colorValue) {
    var c = (0, _d3Color.color)(colorValue);
    var hex = PIXI.utils.rgb2hex([c.r / 255.0, c.g / 255.0, c.b / 255.0]);

    return hex;
  }

  return colorToHex;
}();

exports['default'] = colorToHex;

/***/ }),
/* 520 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Debounce a function call
 *
 * @description
 * Function calls are delayed by `wait` milliseconds and only one out of
 * multiple function calls is executed.
 *
 * @note
 * Once webpack 2 with tree-shaking is supported I'd advocate to use lodash's
 * debounce method.
 *
 * @method  debounce
 * @author  Fritz Lekschas
 * @date    2017-01-14
 * @param   {Functiom}   func       Function to be debounced
 * @param   {Number}     wait       Number of milliseconds to debounce the
 *   function call.
 * @param   {Boolean}    immediate  If `true` function is not debounced.
 * @return  {Functiomn}             Debounced function.
 */
var debounce = exports.debounce = function () {
  function debounce(func, wait, immediate) {
    var timeout = void 0;

    var debounced = function () {
      function debounced() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var later = function () {
          function later() {
            timeout = null;
            if (!immediate) {
              func.apply(undefined, args);
            }
          }

          return later;
        }();

        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);

        if (callNow) {
          func.apply(undefined, args);
        }
      }

      return debounced;
    }();

    debounce.cancel = function () {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  }

  return debounce;
}();

exports["default"] = debounce;

/***/ }),
/* 521 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Create a dictionary from a list of [key,value] pairs.
 * @param tuples: A list of [key,value] pairs
 * @return: A dictionary
 */
var dictFromTuples = function () {
  function dictFromTuples(tuples) {
    var dict = {};

    tuples.forEach(function (x) {
      dict[x[0]] = x[1];
    });

    return dict;
  }

  return dictFromTuples;
}();

exports["default"] = dictFromTuples;

/***/ }),
/* 522 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Return an array of (key,value) pairs that are present in this
 * dictionary
 */
var dictItems = function () {
  function dictItems(dictionary) {
    var keyValues = [];

    for (var key in dictionary) {
      if (dictionary.hasOwnProperty(key)) {
        keyValues.push([key, dictionary[key]]);
      }
    }

    return keyValues;
  }

  return dictItems;
}();

exports["default"] = dictItems;

/***/ }),
/* 523 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = dictKeys;
/**
 * Return an array of values that are present in this dictionary
 */
function dictKeys(dictionary) {
  var keys = [];

  for (var key in dictionary) {
    if (dictionary.hasOwnProperty(key)) {
      keys.push(key);
    }
  }

  return keys;
}

/***/ }),
/* 524 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = dictValues;
/**
 * Return an array of values that are present in this dictionary
 */
function dictValues(dictionary) {
  var values = [];

  for (var key in dictionary) {
    if (dictionary.hasOwnProperty(key)) {
      values.push(dictionary[key]);
    }
  }

  return values;
}

/***/ }),
/* 525 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.download = download;
function download(filename, data) {
  // yanked from here
  // https://stackoverflow.com/questions/3665115/create-a-file-in-memory-for-user-to-download-not-through-server
  var blob = new Blob([data], { type: 'text/csv' });
  if (window.navigator.msSaveOrOpenBlob) {
    window.navigator.msSaveBlob(blob, filename);
  } else {
    var elem = window.document.createElement('a');
    elem.href = window.URL.createObjectURL(blob);
    elem.download = filename;
    document.body.appendChild(elem);
    elem.click();
    document.body.removeChild(elem);
  }
}

exports['default'] = download;

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ = __webpack_require__(3);

var genomeLociToPixels = function () {
  function genomeLociToPixels(genomeLoci, chromInfo) {
    return [(0, _.chrToAbs)(genomeLoci[0], genomeLoci[1], chromInfo), (0, _.chrToAbs)(genomeLoci[2], genomeLoci[3], chromInfo)];
  }

  return genomeLociToPixels;
}();

exports['default'] = genomeLociToPixels;

/***/ }),
/* 527 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Return the track object for the track corresponding to this uid
 *
 * Null or undefined if none.
 */
var getTrackByUid = function () {
  function getTrackByUid(tracks, uid) {
    for (var trackType in tracks) {
      var theseTracks = tracks[trackType];

      // no tracks of this type specified, probably
      if (!theseTracks.filter) continue;

      var filteredTracks = theseTracks.filter(function (d) {
        return d.uid == uid;
      });

      if (filteredTracks.length) {
        return filteredTracks[0];
      }

      // check to see if this track is part of a combined track
      var combinedTracks = theseTracks.filter(function (d) {
        return d.type == 'combined';
      });

      if (combinedTracks.length) {
        for (var i = 0; i < combinedTracks.length; i++) {
          var ct = combinedTracks[i];
          var _filteredTracks = ct.contents.filter(function (d) {
            return d.uid == uid;
          });

          if (_filteredTracks.length) {
            return _filteredTracks[0];
          }
        }
      }
    }

    return null;
  }

  return getTrackByUid;
}();

exports['default'] = getTrackByUid;

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _positionedTracksToAllTracks = __webpack_require__(222);

var _positionedTracksToAllTracks2 = _interopRequireDefault(_positionedTracksToAllTracks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Get a track's orientation by it's UID.
 */
var getTrackPositionByUid = function () {
  function getTrackPositionByUid(allTracks, uid) {
    var tracks = (0, _positionedTracksToAllTracks2['default'])(allTracks);
    var thisTrack = tracks.filter(function (x) {
      return x.uid == uid;
    });

    return thisTrack[0].position;
  }

  return getTrackPositionByUid;
}();

exports['default'] = getTrackPositionByUid;

/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _services = __webpack_require__(7);

var _ = __webpack_require__(3);

var loadChromInfos = function () {
  function loadChromInfos(views) {
    return (0, _.objVals)(views).map(function (view) {
      return view.chromInfoPath;
    }).forEach(function (chromInfoPath) {
      return _services.chromInfo.get(chromInfoPath);
    });
  }

  return loadChromInfos;
}();

exports['default'] = loadChromInfos;

/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _d3Dsv = __webpack_require__(33);

var cache = {};

var getFromCache = function () {
  function getFromCache(url, fallback) {
    return cache[url] ? Promise.resolve(cache[url]) : fallback(url);
  }

  return getFromCache;
}();

var parseChromInfo = function () {
  function parseChromInfo(text) {
    var tsv = (0, _d3Dsv.tsvParseRows)(text);
    var cumValues = [];
    var chromLengths = {};
    var chrPositions = {};

    var totalLength = 0;

    for (var i = 0; i < tsv.length; i++) {
      var length = Number(tsv[i][1]);
      totalLength += length;

      var newValue = {
        id: i,
        chr: tsv[i][0],
        pos: totalLength - length
      };

      cumValues.push(newValue);
      chrPositions[newValue.chr] = newValue;
      chromLengths[tsv[i][0]] = length;
    }

    return {
      cumPositions: cumValues,
      chrPositions: chrPositions,
      totalLength: totalLength,
      chromLengths: chromLengths
    };
  }

  return parseChromInfo;
}();

var getFromRemote = function () {
  function getFromRemote(url) {
    return fetch(url).then(function (response) {
      return response.text();
    }).then(function (text) {
      return parseChromInfo(text);
    })['catch'](function (error) {
      console.error('Could not retrieve or parse chrom info.', error);
    });
  }

  return getFromRemote;
}();

var cacheResults = function () {
  function cacheResults(key, getter, fallback) {
    return getter(key, fallback).then(function (results) {
      cache[key] = results;
      return cache[key];
    });
  }

  return cacheResults;
}();

var get = function () {
  function get(url) {
    return cacheResults(url, getFromCache, getFromRemote);
  }

  return get;
}();

var api = { get: get };

exports['default'] = api;

/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pubSub = __webpack_require__(40);

var _pubSub2 = _interopRequireDefault(_pubSub);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Supported event handlers.
 *
 * @type {object}
 */
var customEventHandlers = {};

/**
 * Get event handler.
 *
 * @param {string} eventName - Name of the event.
 * @return {function} Either a custom or generic event handler.
 */
var getEventHandler = function () {
  function getEventHandler(eventName) {
    if (customEventHandlers[eventName]) {
      return customEventHandlers[eventName];
    }
    return function (event) {
      return _pubSub2['default'].publish(eventName, event);
    };
  }

  return getEventHandler;
}();

/**
 * Stack of elements with registered event listeners.
 *
 * @type {object}
 */
var registeredEls = {};

/**
 * Unregister an event listener.
 *
 * @param {string} event - Name of the event to stop listening from.
 * @param {object} element - DOM element which we listened to.
 */
var unregister = function () {
  function unregister(event, element) {
    if (!registeredEls[event] && registeredEls[event] !== element) {
      return;
    }

    registeredEls[event].removeEventListener(event, getEventHandler(event));

    registeredEls[event] = undefined;
    delete registeredEls[event];
  }

  return unregister;
}();

/**
 * Register an event listener.
 *
 * @param {string} event - Name of the event to listen to.
 * @param {object} newElement - DOM element which to listen to.
 */
var register = function () {
  function register(event, newElement) {
    if (!newElement || registeredEls[event] === newElement) {
      return;
    }

    if (registeredEls[event]) {
      unregister(registeredEls[event]);
    }

    registeredEls[event] = newElement;
    registeredEls[event].addEventListener(event, getEventHandler(event));
  }

  return register;
}();

/**
 * Public API.
 *
 * @type {object}
 */
var domEvent = {
  register: register,
  unregister: unregister
};

exports['default'] = domEvent;

/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tileDataToPixData = exports.trackInfo = exports.calculateTilesFromResolution = exports.calculateTiles = exports.calculateZoomLevel = exports.calculateZoomLevelFromResolutions = exports.fetchTiles = exports.fetchTilesDebounced = exports.requestsInFlight = undefined;

var _d3Array = __webpack_require__(10);

var _d3Request = __webpack_require__(30);

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _worker = __webpack_require__(80);

var _pubSub = __webpack_require__(40);

var _pubSub2 = _interopRequireDefault(_pubSub);

var _configs = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var sessionId = _slugid2['default'].nice();

// Config
var requestsInFlight = exports.requestsInFlight = 0;

var debounce = function () {
  function debounce(func, wait) {
    var timeout = void 0;
    var bundledRequest = [];
    var requestMapper = {};

    var bundleRequests = function () {
      function bundleRequests(request) {
        var requestId = requestMapper[request.id];

        if (requestId && bundledRequest[requestId]) {
          bundledRequest[requestId].ids = bundledRequest[requestId].ids.concat(request.ids);
        } else {
          requestMapper[request.id] = bundledRequest.length;
          bundledRequest.push(request);
        }
      }

      return bundleRequests;
    }();

    var reset = function () {
      function reset() {
        timeout = null;
        bundledRequest = [];
        requestMapper = {};
      }

      return reset;
    }();

    var debounced = function () {
      function debounced(request) {
        bundleRequests(request);

        var later = function () {
          function later() {
            func({
              sessionId: sessionId,
              requests: bundledRequest
            });
            reset();
          }

          return later;
        }();

        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      }

      return debounced;
    }();

    debounced.cancel = function () {
      clearTimeout(timeout);
      reset();
    };

    debounced.immediate = function () {
      func({
        sessionId: sessionId,
        requests: bundledRequest
      });
    };

    return debounced;
  }

  return debounce;
}();

var workerFetchTilesDebounced = debounce(_worker.workerFetchMultiRequestTiles, _configs.TILE_FETCH_DEBOUNCE);

/**
 * Retrieve a set of tiles from the server
 *
 * Plenty of room for optimization and caching here.
 *
 * @param server: A string with the server's url (e.g. "http://127.0.0.1")
 * @param tileIds: The ids of the tiles to fetch (e.g. asdf-sdfs-sdfs.0.0.0)
 */
var fetchTilesDebounced = exports.fetchTilesDebounced = function () {
  function fetchTilesDebounced(request) {
    return workerFetchTilesDebounced(request);
  }

  return fetchTilesDebounced;
}();

/**
 * Retrieve a set of tiles from the server
 *
 * Plenty of room for optimization and caching here.
 *
 * @param server: A string with the server's url (e.g. "http://127.0.0.1")
 * @param tileIds: The ids of the tiles to fetch (e.g. asdf-sdfs-sdfs.0.0.0)
 */
var fetchTiles = exports.fetchTiles = function () {
  function fetchTiles(tilesetServer, tilesetIds, done) {
    return (0, _worker.workerFetchTiles)(tilesetServer, tilesetIds, undefined.sessionId, function (results) {
      done(results);
    });
  }

  return fetchTiles;
}();

/**
 * Calculate the zoom level from a list of available resolutions
 */
var calculateZoomLevelFromResolutions = exports.calculateZoomLevelFromResolutions = function () {
  function calculateZoomLevelFromResolutions(resolutions, scale, minX, maxX) {
    var sortedResolutions = resolutions.map(function (x) {
      return +x;
    }).sort(function (a, b) {
      return b - a;
    });

    var trackWidth = scale.range()[1] - scale.range()[0];
    //console.log('trackWidth:', trackWidth, 'scale:', this._xScale.domain()[1] - this._xScale.domain()[0]);

    var binsDisplayed = sortedResolutions.map(function (r) {
      return (scale.domain()[1] - scale.domain()[0]) / r;
    });
    var binsPerPixel = binsDisplayed.map(function (b) {
      return b / trackWidth;
    });

    /*
        console.log('trackWidth:', trackWidth);
        console.log('resolutions:', sortedResolutions);
        console.log('binsDisplayed:', binsDisplayed);
        console.log('binsPerPixel:', binsPerPixel);
        */

    // we're going to show the highest resolution that requires more than one pixel per bin
    var displayableBinsPerPixel = binsPerPixel.filter(function (b) {
      return b < 1;
    });

    if (displayableBinsPerPixel.length == 0) return 0;

    var zoomIndex = binsPerPixel.indexOf(displayableBinsPerPixel[displayableBinsPerPixel.length - 1]);
    /*
        console.log('displayableBinsPerPixel', displayableBinsPerPixel);
        console.log('zoomIndex:', zoomIndex);
        */

    return zoomIndex;
  }

  return calculateZoomLevelFromResolutions;
}();

/**
 * Calculate the current zoom level.
 */
var calculateZoomLevel = exports.calculateZoomLevel = function () {
  function calculateZoomLevel(scale, minX, maxX) {
    var rangeWidth = scale.range()[1] - scale.range()[0];
    var zoomScale = Math.max((maxX - minX) / (scale.domain()[1] - scale.domain()[0]), 1);

    // fun fact: the number 384 is halfway between 256 and 512
    var addedZoom = Math.max(0, Math.ceil(Math.log(rangeWidth / 384) / Math.LN2));
    var zoomLevel = Math.round(Math.log(zoomScale) / Math.LN2) + addedZoom;

    return zoomLevel;
  }

  return calculateZoomLevel;
}();

/**
 * Calculate the tiles that should be visible get a data domain
 * and a tileset info
 *
 * All the parameters except the first should be present in the
 * tileset_info returned by the server.
 *
 * @param zoomLevel: The zoom level at which to find the tiles (can be calculated using
 *                   this.calcaulteZoomLevel, but needs to synchronized across both x
 *                   and y scales so should be calculated externally)
 * @param scale: A d3 scale mapping data domain to visible values
 * @param minX: The minimum possible value in the dataset
 * @param maxX: The maximum possible value in the dataset
 * @param maxZoom: The maximum zoom value in this dataset
 * @param maxWidth: The width of the largest
 *   (roughlty equal to 2 ** maxZoom * tileSize * tileResolution)
 */
var calculateTiles = exports.calculateTiles = function () {
  function calculateTiles(zoomLevel, scale, minX, maxX, maxZoom, maxWidth) {
    var zoomLevelFinal = zoomLevel > maxZoom ? maxZoom : zoomLevel;

    // the ski areas are positioned according to their
    // cumulative widths, which means the tiles need to also
    // be calculated according to cumulative width

    var tileWidth = maxWidth / Math.pow(2, zoomLevelFinal);

    var epsilon = 0.0000001;

    return (0, _d3Array.range)(Math.max(0, Math.floor((scale.domain()[0] - minX) / tileWidth)), Math.min(Math.pow(2, zoomLevelFinal), Math.ceil((scale.domain()[1] - minX - epsilon) / tileWidth)));
  }

  return calculateTiles;
}();

/**
 * Calculate the tiles that sould be visisble given the resolution and
 * the minX and maxX values for the region
 *
 * @param resolution: The number of base pairs per bin
 * @param scale: The scale to use to calculate the currently visible tiles
 * @param minX: The minimum x position of the tileset
 * @param maxX: The maximum x position of the tileset
 */
var calculateTilesFromResolution = exports.calculateTilesFromResolution = function () {
  function calculateTilesFromResolution(resolution, scale, minX, maxX, pixelsPerTile) {
    var epsilon = 0.0000001;
    var PIXELS_PER_TILE = pixelsPerTile || 256;
    var tileWidth = resolution * PIXELS_PER_TILE;
    var MAX_TILES = 20;
    // console.log('PIXELS_PER_TILE:', PIXELS_PER_TILE);

    if (!maxX) maxX = Number.MAX_VALUE;

    var tileRange = (0, _d3Array.range)(Math.max(0, Math.floor((scale.domain()[0] - minX) / tileWidth)), Math.ceil(Math.min(maxX, scale.domain()[1] - minX - epsilon) / tileWidth));

    if (tileRange.length > MAX_TILES) {
      // too many tiles visible in this range
      console.warn('Too many visible tiles: ' + tileRange.length + ' truncating to ' + MAX_TILES);
      tileRange = tileRange.slice(0, MAX_TILES);
    }
    // console.log('tileRange:', tileRange);

    return tileRange;
  }

  return calculateTilesFromResolution;
}();

var trackInfo = exports.trackInfo = function () {
  function trackInfo(server, tilesetUid, done) {
    var outUrl = server + '/tileset_info/?d=' + tilesetUid + '&s=' + sessionId;

    (0, _worker.workerGetTilesetInfo)(outUrl, done);
  }

  return trackInfo;
}();

/**
 * Render 2D tile data. Convert the raw values to an array of
 * color values
 *
 * @param finished: A callback to let the caller know that the worker thread
 *                  has converted tileData to pixData
 * @param minVisibleValue: The minimum visible value (used for setting the color scale)
 * @param maxVisibleValue: The maximum visible value
 * @param colorScale: a 255 x 4 rgba array used as a color scale
 */
var tileDataToPixData = exports.tileDataToPixData = function () {
  function tileDataToPixData(tile, valueScale, pseudocount, colorScale, finished) {
    var tileData = tile.tileData;

    if (!tileData.dense) {
      // if we didn't get any data from the server, don't do anything
      return;
    }

    // clone the tileData so that the original array doesn't get neutered
    // when being passed to the worker script
    var newTileData = new Float32Array(tileData.dense.length);
    newTileData.set(tileData.dense);

    // comment this and uncomment the code afterwards to enable threading
    var pixData = (0, _worker.workerSetPix)(newTileData.length, newTileData, valueScale, pseudocount, colorScale);

    finished(pixData);

    /*
      this.threadPool.run(function(input, done) {
            let tileData = input.tileData;
            importScripts(input.scriptPath + '/scripts/worker.js');
            let pixData = worker.workerSetPix(tileData.length, tileData,
                              input.minVisibleValue,
                              input.maxVisibleValue);
            done.transfer({'pixData': pixData}, [pixData.buffer]);
            })
         .on('done', function(job, message) {
           //console.log('done...', job);
           finished(message.pixData);
         })
         .on('error', function(job, error) {
          //console.log('error', error);
         })
      .send({
        scriptPath: scriptPath,
        tileData: newTileData,
        minVisibleValue: minVisibleValue,
        maxVisibleValue: maxVisibleValue},
        [newTileData.buffer]
      );
      */
  }

  return tileDataToPixData;
}();

function text(url, callback) {
  /**
   * Send a JSON request mark it so that we can tell how many are in flight
   */
  exports.requestsInFlight = requestsInFlight += 1;
  _pubSub2['default'].publish('requestSent', url);

  (0, _d3Request.text)(url, function (error, done) {
    callback(error, done);
    _pubSub2['default'].publish('requestReceived', url);
    exports.requestsInFlight = requestsInFlight -= 1;
  });
}

function json(url, callback) {
  /**
   * Send a JSON request mark it so that we can tell how many are in flight
   */
  exports.requestsInFlight = requestsInFlight += 1;
  _pubSub2['default'].publish('requestSent', url);

  (0, _d3Request.json)(url, function (error, done) {
    _pubSub2['default'].publish('requestReceived', url);
    callback(error, done);
    exports.requestsInFlight = requestsInFlight -= 1;
  });
}

var api = {
  calculateTiles: calculateTiles,
  calculateTilesFromResolution: calculateTilesFromResolution,
  calculateZoomLevel: calculateZoomLevel,
  calculateZoomLevelFromResolutions: calculateZoomLevelFromResolutions,
  fetchTiles: fetchTiles,
  fetchTilesDebounced: fetchTilesDebounced,
  json: json,
  text: text,
  tileDataToPixData: tileDataToPixData,
  trackInfo: trackInfo
};

exports['default'] = api;

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AVAILABLE_TRACK_TYPES = undefined;

var _ = __webpack_require__(6);

/**
 * Return a list of the available track types, given a set of data types
 * and an orientation
 *
 * Arguments
 * ---------
 *
 *  datatypes: list
 *      E.g. ['heatmap', 'vector']
 *
 *  orientation: string
 *      E.g. 'top'
 *
 * Return
 * ------
 *
 *  A list of track-types:
 *      E.g. ['top-line', 'top-rectangle']
 */
var AVAILABLE_TRACK_TYPES = exports.AVAILABLE_TRACK_TYPES = function () {
  function AVAILABLE_TRACK_TYPES(datatypes, orientation) {
    var datatypesToTrackTypes = (0, _.DATATYPE_TO_TRACK_TYPE)(orientation);

    var firstDatatype = datatypes[0];
    var allSame = true;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = datatypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var datatype = _step.value;

        if (datatype !== firstDatatype) {
          allSame = false;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (allSame) {
      // only display available track types if all of the selected datasets are
      // the same
      return datatypesToTrackTypes[datatypes[0]];
    }

    return [];
  }

  return AVAILABLE_TRACK_TYPES;
}();

exports['default'] = AVAILABLE_TRACK_TYPES;

/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DATATYPE_TO_TRACK_TYPE = undefined;

var _ = __webpack_require__(6);

var DATATYPE_TO_TRACK_TYPE = exports.DATATYPE_TO_TRACK_TYPE = function () {
  function DATATYPE_TO_TRACK_TYPE(orientation) {
    var localDatatypeToTrackType = {};

    _.TRACKS_INFO.filter(function (x) {
      return x.orientation == orientation;
    }).forEach(function (ti) {
      var datatypes = ti.datatype;

      if (!Array.isArray(ti.datatype)) {
        datatypes = [datatypes];
      }

      datatypes.forEach(function (datatype) {
        if (!(datatype in localDatatypeToTrackType)) {
          localDatatypeToTrackType[datatype] = [];
        }

        localDatatypeToTrackType[datatype].push(ti);
      });
    });

    localDatatypeToTrackType.none = [];

    return localDatatypeToTrackType;
  }

  return DATATYPE_TO_TRACK_TYPE;
}();

exports['default'] = DATATYPE_TO_TRACK_TYPE;

/***/ }),
/* 535 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
var HEATED_OBJECT_MAP = exports.HEATED_OBJECT_MAP = [[0, 0, 0, 255], [35, 0, 0, 255], [52, 0, 0, 255], [60, 0, 0, 255], [63, 1, 0, 255], [64, 2, 0, 255], [68, 5, 0, 255], [69, 6, 0, 255], [72, 8, 0, 255], [74, 10, 0, 255], [77, 12, 0, 255], [78, 14, 0, 255], [81, 16, 0, 255], [83, 17, 0, 255], [85, 19, 0, 255], [86, 20, 0, 255], [89, 22, 0, 255], [91, 24, 0, 255], [92, 25, 0, 255], [94, 26, 0, 255], [95, 28, 0, 255], [98, 30, 0, 255], [100, 31, 0, 255], [102, 33, 0, 255], [103, 34, 0, 255], [105, 35, 0, 255], [106, 36, 0, 255], [108, 38, 0, 255], [109, 39, 0, 255], [111, 40, 0, 255], [112, 42, 0, 255], [114, 43, 0, 255], [115, 44, 0, 255], [117, 45, 0, 255], [119, 47, 0, 255], [119, 47, 0, 255], [120, 48, 0, 255], [122, 49, 0, 255], [123, 51, 0, 255], [125, 52, 0, 255], [125, 52, 0, 255], [126, 53, 0, 255], [128, 54, 0, 255], [129, 56, 0, 255], [129, 56, 0, 255], [131, 57, 0, 255], [132, 58, 0, 255], [134, 59, 0, 255], [134, 59, 0, 255], [136, 61, 0, 255], [137, 62, 0, 255], [137, 62, 0, 255], [139, 63, 0, 255], [139, 63, 0, 255], [140, 65, 0, 255], [142, 66, 0, 255], [142, 66, 0, 255], [143, 67, 0, 255], [143, 67, 0, 255], [145, 68, 0, 255], [145, 68, 0, 255], [146, 70, 0, 255], [146, 70, 0, 255], [148, 71, 0, 255], [148, 71, 0, 255], [149, 72, 0, 255], [149, 72, 0, 255], [151, 73, 0, 255], [151, 73, 0, 255], [153, 75, 0, 255], [153, 75, 0, 255], [154, 76, 0, 255], [154, 76, 0, 255], [154, 76, 0, 255], [156, 77, 0, 255], [156, 77, 0, 255], [157, 79, 0, 255], [157, 79, 0, 255], [159, 80, 0, 255], [159, 80, 0, 255], [159, 80, 0, 255], [160, 81, 0, 255], [160, 81, 0, 255], [162, 82, 0, 255], [162, 82, 0, 255], [163, 84, 0, 255], [163, 84, 0, 255], [165, 85, 0, 255], [165, 85, 0, 255], [166, 86, 0, 255], [166, 86, 0, 255], [166, 86, 0, 255], [168, 87, 0, 255], [168, 87, 0, 255], [170, 89, 0, 255], [170, 89, 0, 255], [171, 90, 0, 255], [171, 90, 0, 255], [173, 91, 0, 255], [173, 91, 0, 255], [174, 93, 0, 255], [174, 93, 0, 255], [176, 94, 0, 255], [176, 94, 0, 255], [177, 95, 0, 255], [177, 95, 0, 255], [179, 96, 0, 255], [179, 96, 0, 255], [180, 98, 0, 255], [182, 99, 0, 255], [182, 99, 0, 255], [183, 100, 0, 255], [183, 100, 0, 255], [185, 102, 0, 255], [185, 102, 0, 255], [187, 103, 0, 255], [187, 103, 0, 255], [188, 104, 0, 255], [188, 104, 0, 255], [190, 105, 0, 255], [191, 107, 0, 255], [191, 107, 0, 255], [193, 108, 0, 255], [193, 108, 0, 255], [194, 109, 0, 255], [196, 110, 0, 255], [196, 110, 0, 255], [197, 112, 0, 255], [197, 112, 0, 255], [199, 113, 0, 255], [200, 114, 0, 255], [200, 114, 0, 255], [202, 116, 0, 255], [202, 116, 0, 255], [204, 117, 0, 255], [205, 118, 0, 255], [205, 118, 0, 255], [207, 119, 0, 255], [208, 121, 0, 255], [208, 121, 0, 255], [210, 122, 0, 255], [211, 123, 0, 255], [211, 123, 0, 255], [213, 124, 0, 255], [214, 126, 0, 255], [214, 126, 0, 255], [216, 127, 0, 255], [217, 128, 0, 255], [217, 128, 0, 255], [219, 130, 0, 255], [221, 131, 0, 255], [221, 131, 0, 255], [222, 132, 0, 255], [224, 133, 0, 255], [224, 133, 0, 255], [225, 135, 0, 255], [227, 136, 0, 255], [227, 136, 0, 255], [228, 137, 0, 255], [230, 138, 0, 255], [230, 138, 0, 255], [231, 140, 0, 255], [233, 141, 0, 255], [233, 141, 0, 255], [234, 142, 0, 255], [236, 144, 0, 255], [236, 144, 0, 255], [238, 145, 0, 255], [239, 146, 0, 255], [241, 147, 0, 255], [241, 147, 0, 255], [242, 149, 0, 255], [244, 150, 0, 255], [244, 150, 0, 255], [245, 151, 0, 255], [247, 153, 0, 255], [247, 153, 0, 255], [248, 154, 0, 255], [250, 155, 0, 255], [251, 156, 0, 255], [251, 156, 0, 255], [253, 158, 0, 255], [255, 159, 0, 255], [255, 159, 0, 255], [255, 160, 0, 255], [255, 161, 0, 255], [255, 163, 0, 255], [255, 163, 0, 255], [255, 164, 0, 255], [255, 165, 0, 255], [255, 167, 0, 255], [255, 167, 0, 255], [255, 168, 0, 255], [255, 169, 0, 255], [255, 169, 0, 255], [255, 170, 0, 255], [255, 172, 0, 255], [255, 173, 0, 255], [255, 173, 0, 255], [255, 174, 0, 255], [255, 175, 0, 255], [255, 177, 0, 255], [255, 178, 0, 255], [255, 179, 0, 255], [255, 181, 0, 255], [255, 181, 0, 255], [255, 182, 0, 255], [255, 183, 0, 255], [255, 184, 0, 255], [255, 187, 7, 255], [255, 188, 10, 255], [255, 189, 14, 255], [255, 191, 18, 255], [255, 192, 21, 255], [255, 193, 25, 255], [255, 195, 29, 255], [255, 197, 36, 255], [255, 198, 40, 255], [255, 200, 43, 255], [255, 202, 51, 255], [255, 204, 54, 255], [255, 206, 61, 255], [255, 207, 65, 255], [255, 210, 72, 255], [255, 211, 76, 255], [255, 214, 83, 255], [255, 216, 91, 255], [255, 219, 98, 255], [255, 221, 105, 255], [255, 223, 109, 255], [255, 225, 116, 255], [255, 228, 123, 255], [255, 232, 134, 255], [255, 234, 142, 255], [255, 237, 149, 255], [255, 239, 156, 255], [255, 240, 160, 255], [255, 243, 167, 255], [255, 246, 174, 255], [255, 248, 182, 255], [255, 249, 185, 255], [255, 252, 193, 255], [255, 253, 196, 255], [255, 255, 204, 255], [255, 255, 207, 255], [255, 255, 211, 255], [255, 255, 218, 255], [255, 255, 222, 255], [255, 255, 225, 255], [255, 255, 229, 255], [255, 255, 233, 255], [255, 255, 236, 255], [255, 255, 240, 255], [255, 255, 244, 255], [255, 255, 247, 255], [255, 255, 255, 0]];

/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IS_TRACK_RANGE_SELECTABLE = undefined;

var _utils = __webpack_require__(3);

var IS_TRACK_RANGE_SELECTABLE = exports.IS_TRACK_RANGE_SELECTABLE = function () {
  function IS_TRACK_RANGE_SELECTABLE(track) {
    switch (track.type) {
      case 'heatmap':
      case 'horizontal-line':
      case 'vertical-line':
      case 'horizontal-1d-tiles':
      case 'vertical-1d-tiles':
      case '2d-tiles':
      case 'horizontal-gene-annotations':
      case 'vertical-gene-annotations':
      case 'horizontal-heatmap':
      case 'vertical-heatmap':
      case 'osm-tiles':
      case 'mapbox-tiles':
        return true;

      case 'combined':
        {
          return track.contents.map(function (track) {
            return IS_TRACK_RANGE_SELECTABLE(track);
          }).reduce(_utils.or, false);
        }

      default:
        return false;
    }
  }

  return IS_TRACK_RANGE_SELECTABLE;
}();

exports['default'] = IS_TRACK_RANGE_SELECTABLE;

/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OPTIONS_INFO = undefined;

var _d3Format = __webpack_require__(46);

var _HeatmapOptions = __webpack_require__(538);

var _HeatmapOptions2 = _interopRequireDefault(_HeatmapOptions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var AVAILABLE_COLORS = {
  black: { name: 'Black', value: 'black' },
  blue: { name: 'Blue', value: 'blue' },
  brown: { name: 'Brown', value: 'brown' },
  cyan: { name: 'Cyan', value: 'cyan' },
  green: { name: 'Green', value: 'green' },
  grey: { name: 'Grey', value: 'grey' },
  orange: { name: 'Orange', value: 'orange' },
  purple: { name: 'Purple', value: 'purple' },
  turquoise: { name: 'Turquoise', value: 'turquoise' },
  red: { name: 'Red', value: 'red' },
  white: { name: 'White', value: 'white' }
};

var AVAILABLE_WIDTHS = {
  1: { name: '1', value: 1 },
  2: { name: '2', value: 2 },
  3: { name: '3', value: 3 },
  5: { name: '5', value: 5 },
  8: { name: '8', value: 8 },
  13: { name: '13', value: 13 },
  21: { name: '21', value: 21 }
};
var AVAILABLE_WIDTHS_AND_NONE = Object.assign(AVAILABLE_WIDTHS, {
  'none': { name: 'none', value: 'none' } });

var OPACITY_OPTIONS = {
  0: { name: '0%', value: 0.0 },
  0.2: { name: '20%', value: 0.2 },
  0.4: { name: '40%', value: 0.4 },
  0.6: { name: '60%', value: 0.6 },
  0.8: { name: '80%', value: 0.8 },
  '1.0': { name: '100%', value: 1.0 }
};

var OPTIONS_INFO = exports.OPTIONS_INFO = {
  heatmapValueScaling: {
    name: 'Value Scaling',
    inlineOptions: {
      linear: { name: 'Linear', value: 'linear' },
      log: { name: 'Log', value: 'log' }
    }
  },
  valueScaling: {
    name: 'Value Scaling',
    inlineOptions: {
      linear: { name: 'Linear', value: 'linear' },
      log: { name: 'Log', value: 'log' }
    }
  },
  lineStrokeWidth: {
    name: 'Stroke Width',
    inlineOptions: AVAILABLE_WIDTHS
  },
  strokeWidth: {
    name: 'Stroke Width',
    inlineOptions: AVAILABLE_WIDTHS
  },
  trackBorderWidth: {
    name: 'Track Border Width',
    inlineOptions: AVAILABLE_WIDTHS
  },
  minSquareSize: {
    name: 'Minimum size',
    inlineOptions: AVAILABLE_WIDTHS_AND_NONE
  },
  pointSize: {
    name: 'Point Size',
    inlineOptions: AVAILABLE_WIDTHS
  },
  pointColor: {
    name: 'Point Color',
    inlineOptions: AVAILABLE_COLORS
  },
  trackBorderColor: {
    name: 'Track Border Color',
    inlineOptions: AVAILABLE_COLORS
  },
  minusStrandColor: {
    name: '- Strand Color',
    inlineOptions: AVAILABLE_COLORS
  },
  plusStrandColor: {
    name: '+ Strand Color',
    inlineOptions: AVAILABLE_COLORS
  },
  lineStrokeColor: {
    name: 'Stroke color',
    inlineOptions: AVAILABLE_COLORS
  },
  projectionStrokeColor: {
    name: 'Stroke color',
    inlineOptions: AVAILABLE_COLORS
  },
  projectionFillColor: {
    name: 'Fill color',
    inlineOptions: AVAILABLE_COLORS
  },
  strokeColor: {
    name: 'Stroke color',
    inlineOptions: AVAILABLE_COLORS
  },
  fillColor: {
    name: 'Fill color',
    inlineOptions: AVAILABLE_COLORS
  },
  barFillColor: {
    name: 'Fill color',
    inlineOptions: AVAILABLE_COLORS
  },
  barFillColorTop: {
    name: 'Top Fill color',
    inlineOptions: AVAILABLE_COLORS
  },
  barFillColorBottom: {
    name: 'Bottom Fill color',
    inlineOptions: AVAILABLE_COLORS
  },
  barOpacity: {
    name: 'Bar opacity',
    inlineOptions: OPACITY_OPTIONS
  },
  rectangleDomainStrokeColor: {
    name: 'Stroke color',
    inlineOptions: AVAILABLE_COLORS
  },
  rectangleDomainFillColor: {
    name: 'Fill color',
    inlineOptions: AVAILABLE_COLORS
  },
  rectangleDomainOpacity: {
    name: 'Opacity',
    inlineOptions: OPACITY_OPTIONS
  },
  mapboxStyle: {
    name: 'Map style',
    inlineOptions: {
      streets: {
        name: 'streets',
        value: 'mapbox.streets'
      },
      light: {
        name: 'light',
        value: 'mapbox.light'
      },
      dark: {
        name: 'dark',
        value: 'mapbox.dark'
      },
      satellite: {
        name: 'satellite',
        value: 'mapbox.satellite'
      },
      'streets-satellite': {
        name: 'streets-satellite',
        value: 'mapbox.streets-satellite'
      },
      wheatpaste: {
        name: 'wheatpaste',
        value: 'mapbox.wheatpaste'
      },
      'streets-basic': {
        name: 'streets-basic',
        value: 'mapbox.streets-basic'
      },
      comic: {
        name: 'comic',
        value: 'mapbox.comic'
      },
      outdoors: {
        name: 'outdoors',
        value: 'mapbox.outdoors'
      },
      'run-bike-hike': {
        name: 'run-bike-hike',
        value: 'mapbox.run-bike-hike'
      },
      pencil: {
        name: 'pencil',
        value: 'mapbox.pencil'
      },
      pirates: {
        name: 'pirates',
        value: 'mapbox.pirates'
      },
      emerald: {
        name: 'emerald',
        value: 'mapbox.emerald'
      },
      'high-contrast': {
        name: 'high-contrast',
        value: 'mapbox.high-contrast'
      }
    }
  },
  oneDHeatmapFlipped: {
    name: 'Flip Heatmap',
    inlineOptions: {
      yes: { name: 'Yes', value: 'yes' },
      no: { name: 'No', value: null }
    }
  },
  axisPositionHorizontal: {
    name: 'Axis Position',
    inlineOptions: {
      left: { name: 'Left', value: 'left' },
      outsideLeft: { name: 'Outside left', value: 'outsideLeft' },
      right: { name: 'Right', value: 'right' },
      outsideRight: { name: 'Outside right', value: 'outsideRight' },
      hidden: { name: 'Hidden', value: null }
    }
  },

  axisPositionVertical: {
    name: 'Axis Position',
    inlineOptions: {
      top: { name: 'Top', value: 'top' },
      outsideTop: { name: 'Outside top', value: 'outsideTop' },
      bottom: { name: 'Bottom', value: 'bottom' },
      outsideBottom: { name: 'Outside bottom', value: 'outsideBottom' },
      hidden: { name: 'Hidden', value: null }
    }
  },

  colorbarPosition: {
    name: 'Colorbar Position',
    inlineOptions: {
      topLeft: { name: 'Top Left', value: 'topLeft' },
      topRight: { name: 'Top Right', value: 'topRight' },
      bottomLeft: { name: 'Bottom Left', value: 'bottomLeft' },
      bottomRight: { name: 'Bottom Right', value: 'bottomRight' },
      hidden: { name: 'Hidden', value: null }
    }
  },

  /*
  colorbarOrientation: {
    name: 'Colorbar Orientation',
    inlineOptions: {
      'horizontal': { name: 'Horizontal', value: 'horizontal' },
      'vertical': { name: 'Vertical', value: 'vertical' },
    }
  },
  */

  // This will default to 'inside' if it's not set when colorbarPosition
  // is set
  colorbarLabelsPosition: {
    name: 'Colorbar Labels Position',
    inlineOptions: {
      inside: { name: 'Inside', value: 'inside' },
      outside: { name: 'Outside', value: 'outside' }
    }
  },

  labelColor: {
    name: 'Label Color',
    inlineOptions: AVAILABLE_COLORS
  },

  labelPosition: {
    name: 'Label Position',
    inlineOptions: {
      ol: { name: 'Outer left', value: 'outerLeft' },
      or: { name: 'Outer right', value: 'outerRight' },
      ot: { name: 'Outer top', value: 'outerTop' },
      ob: { name: 'Outer bottom', value: 'outerBottom' },
      tl: { name: 'Top left', value: 'topLeft' },
      tr: { name: 'Top right', value: 'topRight' },
      bl: { name: 'Bottom left', value: 'bottomLeft' },
      br: { name: 'Bottom right', value: 'bottomRight' },
      hidden: { name: 'Hidden', value: 'hidden' }
    }
  },

  labelTextOpacity: {
    name: 'Label Text Opacity',
    inlineOptions: OPACITY_OPTIONS
  },

  labelBackgroundOpacity: {
    name: 'Label Background Opacity',
    inlineOptions: OPACITY_OPTIONS
  },

  // colormaps are mostly taken from here:
  // http://matplotlib.org/api/pyplot_summary.html?highlight=colormaps#matplotlib.pyplot.colormaps
  colorRange: {
    name: 'Color map',
    inlineOptions: {
      afmhot: {
        name: 'afmhot',
        value: ['rgba(0,0,0,1.0)', 'rgba(128,0,0,1.0)', 'rgba(256,129,1,1.0)', 'rgba(256,256,129,1.0)', 'rgba(256,256,256,1.0)']
      },
      fall: {
        name: 'fall',
        value: ['white', 'rgba(245,166,35,1.0)', 'rgba(208,2,27,1.0)', 'black']
      },
      hot: {
        name: 'hot',
        value: ['rgba(10,0,0,1.0)', 'rgba(179,0,0,1.0)', 'rgba(256,91,0,1.0)', 'rgba(256,256,6,1.0)', 'rgba(256,256,256,1.0)']
      },
      jet: {
        name: 'jet',
        value: ['rgba(0,0,128,1.0)', 'rgba(0,129,256,1.0)', 'rgba(125,256,122,1.0)', 'rgba(256,148,0,1.0)', 'rgba(128,0,0,1.0)']
      },

      bwr: {
        name: 'bwr',
        value: ['rgba(0,0,256,1.0)', 'rgba(128,128,256,1.0)', 'rgba(256,254,254,1.0)', 'rgba(256,126,126,1.0)', 'rgba(256,0,0,1.0)']
      },
      cubehelix: {
        name: 'cubehelix',
        value: ['rgba(0,0,0,1.0)', 'rgba(21,83,76,1.0)', 'rgba(162,121,74,1.0)', 'rgba(199,180,238,1.0)', 'rgba(256,256,256,1.0)']
      },
      rainbow: {
        name: 'rainbow',
        value: ['rgba(128,0,256,1.0)', 'rgba(0,181,236,1.0)', 'rgba(129,255,180,1.0)', 'rgba(256,179,96,1.0)', 'rgba(256,0,0,1.0)']
      },

      gray: {
        name: 'greys',
        value: ['rgba(255,255,255,1)', 'rgba(0,0,0,1)']
      },
      red: {
        name: 'White to red',
        value: ['rgba(255,255,255,1)', 'rgba(255,0,0,1)']
      },
      green: {
        name: 'White to green',
        value: ['rgba(255,255,255,1)', 'rgba(0,255,0,1)']
      },
      blue: {
        name: 'White to blue',
        value: ['rgba(255,255,255,1)', 'rgba(0,0,255,1)']
      },
      custard: {
        name: 'custard',
        value: ['#FFFFFF', '#F8E71C', 'rgba(245,166,35,1)', 'rgba(0,0,0,1)']
      },
      custom: {
        name: 'Custom...',
        componentPickers: {
          heatmap: _HeatmapOptions2['default'],
          'horizontal-heatmap': _HeatmapOptions2['default']
        }
      }
    }
  },

  dataTransform: {
    name: 'Transforms',
    inlineOptions: {
      'default': { name: 'Default', value: 'default' },
      None: { name: 'None', value: 'None' }
    },
    generateOptions: function () {
      function generateOptions(track) {
        var inlineOptions = [];

        // console.log('track:',track);
        // console.log('track.tilesetInfo:', track.tilesetInfo);

        if (track.transforms) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = track.transforms[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var transform = _step.value;

              inlineOptions.push({
                name: transform.name,
                value: transform.value
              });
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator['return']) {
                _iterator['return']();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        // console.log('inlineOptions:', inlineOptions);
        return inlineOptions;
      }

      return generateOptions;
    }()
  },

  maxZoom: {
    name: 'Zoom limit',
    inlineOptions: {
      none: { name: 'None', value: null }
    },
    generateOptions: function () {
      function generateOptions(track) {
        if (track.maxZoom) {
          var inlineOptions = [];

          for (var i = 0; i <= track.maxZoom; i++) {
            var maxWidth = track.maxWidth;
            var binsPerDimension = track.binsPerDimension;
            var maxZoom = track.maxZoom;

            var resolution = track.maxWidth / (Math.pow(2, i) * track.binsPerDimension);

            var maxResolutionSize = maxWidth / (Math.pow(2, maxZoom) * binsPerDimension);

            var pp = (0, _d3Format.precisionPrefix)(maxResolutionSize, resolution);
            var f = (0, _d3Format.formatPrefix)('.' + pp, resolution);
            var formattedResolution = f(resolution);

            // const formattedName =  ;
            inlineOptions.push({
              name: formattedResolution,
              value: i.toString()
            });

            //
          }

          return inlineOptions;
        }return [];
      }

      return generateOptions;
    }()
  },

  valueColumn: {
    name: 'Value column',
    inlineOptions: {
      none: { name: 'None', value: null }
    },
    generateOptions: function () {
      function generateOptions(track) {
        if (!track.header) return [];

        var headerParts = track.header.split('\t');
        var options = [];

        for (var i = 0; i < headerParts.length; i++) {
          options.push({
            name: headerParts[i],
            value: i + 1
          });
        }

        /*
        console.log('headerParts:', headerParts);
        console.log('options:', options);
        */

        return options;
      }

      return generateOptions;
    }()
  }
};

exports['default'] = OPTIONS_INFO;

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactBootstrap = __webpack_require__(59);

var _HiGlassComponent = __webpack_require__(145);

var _HiGlassComponent2 = _interopRequireDefault(_HiGlassComponent);

var _SketchInlinePicker = __webpack_require__(223);

var _SketchInlinePicker2 = _interopRequireDefault(_SketchInlinePicker);

__webpack_require__(236);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HeatmapOptions = function (_React$Component) {
  _inherits(HeatmapOptions, _React$Component);

  function HeatmapOptions(props) {
    _classCallCheck(this, HeatmapOptions);

    // props should include the definition of the heatmap data series

    var _this = _possibleConstructorReturn(this, (HeatmapOptions.__proto__ || Object.getPrototypeOf(HeatmapOptions)).call(this, props));

    _this.state = {
      colors: props.track.options.colorRange.slice()
    };
    return _this;
  }

  _createClass(HeatmapOptions, [{
    key: 'handleColorsChanged',
    value: function () {
      function handleColorsChanged(newColors) {
        /*
            this.props.onTrackOptionsChanged(Object.assign(this.props.track.options,
                                                           {colorRange: newColors}));
            */
        this.setState({
          colors: newColors
        });
      }

      return handleColorsChanged;
    }()
  }, {
    key: 'handleSubmit',
    value: function () {
      function handleSubmit() {
        var options = this.props.track.options;

        options.colorRange = this.state.colors;

        this.props.onSubmit(this.props.track.options);
      }

      return handleSubmit;
    }()
  }, {
    key: 'handleAddColor',
    value: function () {
      function handleAddColor() {
        /**
             * Add a color to the end
             */
        this.setState({
          colors: this.state.colors.concat(this.state.colors[this.state.colors.length - 1])
        });
      }

      return handleAddColor;
    }()
  }, {
    key: 'handleRemoveColor',
    value: function () {
      function handleRemoveColor(i) {
        /**
             * Remove one of the colors from the color map
             */

        this.setState({
          colors: this.state.colors.slice(0, i).concat(this.state.colors.slice(i + 1))
        });
      }

      return handleRemoveColor;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        var track = JSON.parse(JSON.stringify(this.props.track));

        var centerTrack = Object.assign(track, {
          options: {
            colorRange: this.state.colors
          } });

        var mvConfig = {
          editable: false,
          zoomFixed: true,
          views: [{

            uid: 'hmo-' + this.props.track.uid,
            initialXDomain: this.props.xScale ? this.props.xScale.domain() : [0, 1],
            initialYDomain: this.props.yScale ? this.props.yScale.domain() : [0, 1],
            tracks: { center: [centerTrack] },
            layout: { x: 0, y: 0, h: 12, w: 12, i: 'hmo-' + this.props.track.id }
          }] };

        var colorFields = this.state.colors.map(function (x, i) {
          // only let colors be removed if there's more than two present
          var closeButton = _this2.state.colors.length > 2 && i === _this2.state.colors.length - 1 ? _react2['default'].createElement(
            'div',
            {
              style: {
                background: 'white',
                position: 'absolute',
                top: 0,
                right: 0,
                opacity: 1,
                width: 14,
                height: 14,
                borderRadius: 2

              }
            },
            _react2['default'].createElement(
              'svg',
              {
                onClick: function () {
                  function onClick() {
                    return _this2.handleRemoveColor(i);
                  }

                  return onClick;
                }(),
                style: {
                  position: 'absolute',
                  top: 2,
                  right: 2,
                  opacity: 0.5,
                  width: 10,
                  height: 10
                },
                height: '10px'
              },
              _react2['default'].createElement('use', { xlinkHref: '#cross' })
            )
          ) : null; // closebutton

          return _react2['default'].createElement(
            'td',
            {
              key: 'l' + i,
              style: { border: '0px solid',
                position: 'relative',
                outline: 'none'
              }
            },
            closeButton,
            _react2['default'].createElement(_SketchInlinePicker2['default'], {
              key: i,
              color: _this2.state.colors[i],
              onChange: function () {
                function onChange(c) {
                  _this2.state.colors[i] = c;
                  _this2.handleColorsChanged(_this2.state.colors);
                }

                return onChange;
              }()
            })
          );
        });

        var addButton = this.state.colors.length < 4 ? _react2['default'].createElement(
          'td',
          {
            style: { border: '0px solid',
              position: 'relative',
              outline: 'none'
            }
          },
          _react2['default'].createElement(
            'div',
            {
              style: {
                height: 24,
                marginLeft: 5
              }

            },
            _react2['default'].createElement(
              'svg',
              {
                onClick: this.handleAddColor.bind(this),
                style: {
                  opacity: 0.5
                },
                width: '10px',
                height: '10px'
              },
              _react2['default'].createElement('use', { xlinkHref: '#plus' })
            )
          )
        ) : null; // addButton

        return _react2['default'].createElement(
          _reactBootstrap.Modal,
          {
            onHide: this.props.handleCancel,
            show: true,
            className: 'hg-modal'
          },
          _react2['default'].createElement(
            _reactBootstrap.Modal.Header,
            { closeButton: true },
            _react2['default'].createElement(
              _reactBootstrap.Modal.Title,
              null,
              'Heatmap Options'
            )
          ),
          _react2['default'].createElement(
            _reactBootstrap.Modal.Body,
            null,
            _react2['default'].createElement(
              'table',
              { className: 'table-track-options' },
              _react2['default'].createElement('thead', null),
              _react2['default'].createElement(
                'tbody',
                null,
                _react2['default'].createElement(
                  'tr',
                  null,
                  _react2['default'].createElement(
                    'td',
                    { className: 'td-track-options' },
                    'Colors'
                  )
                ),
                _react2['default'].createElement(
                  'tr',
                  null,
                  _react2['default'].createElement(
                    'td',
                    { className: 'td-track-options' },
                    _react2['default'].createElement(
                      'table',
                      null,
                      _react2['default'].createElement(
                        'tbody',
                        null,
                        _react2['default'].createElement(
                          'tr',
                          null,
                          colorFields,
                          addButton
                        )
                      )
                    )
                  )
                ),
                _react2['default'].createElement(
                  'tr',
                  null,
                  _react2['default'].createElement(
                    'td',
                    { className: 'td-track-options' },
                    'Preview'
                  )
                ),
                _react2['default'].createElement(
                  'tr',
                  null,
                  _react2['default'].createElement(
                    'td',
                    { rowSpan: '2', className: 'td-track-options' },
                    _react2['default'].createElement(
                      'div',
                      { style: { width: 200 } },
                      _react2['default'].createElement(_HiGlassComponent2['default'], {
                        viewConfig: mvConfig,
                        options: { bounded: false }
                      })
                    )
                  )
                ),
                _react2['default'].createElement('tr', null)
              )
            )
          ),
          _react2['default'].createElement(
            _reactBootstrap.Modal.Footer,
            null,
            _react2['default'].createElement(
              _reactBootstrap.Button,
              { onClick: this.props.onCancel },
              'Cancel'
            ),
            _react2['default'].createElement(
              _reactBootstrap.Button,
              { onClick: this.handleSubmit.bind(this) },
              'Submit'
            )
          )
        );
      }

      return render;
    }()
  }]);

  return HeatmapOptions;
}(_react2['default'].Component);

exports['default'] = HeatmapOptions;

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flattenNames = undefined;

var _isString2 = __webpack_require__(540);

var _isString3 = _interopRequireDefault(_isString2);

var _forOwn2 = __webpack_require__(136);

var _forOwn3 = _interopRequireDefault(_forOwn2);

var _isPlainObject2 = __webpack_require__(541);

var _isPlainObject3 = _interopRequireDefault(_isPlainObject2);

var _map2 = __webpack_require__(27);

var _map3 = _interopRequireDefault(_map2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var flattenNames = exports.flattenNames = function flattenNames() {
  var things = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var names = [];

  (0, _map3.default)(things, function (thing) {
    if (Array.isArray(thing)) {
      flattenNames(thing).map(function (name) {
        return names.push(name);
      });
    } else if ((0, _isPlainObject3.default)(thing)) {
      (0, _forOwn3.default)(thing, function (value, key) {
        value === true && names.push(key);
        names.push(key + '-' + value);
      });
    } else if ((0, _isString3.default)(thing)) {
      names.push(thing);
    }
  });

  return names;
};

exports.default = flattenNames;

/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(38),
    isArray = __webpack_require__(15),
    isObjectLike = __webpack_require__(39);

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(38),
    getPrototype = __webpack_require__(137),
    isObjectLike = __webpack_require__(39);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeClasses = undefined;

var _forOwn2 = __webpack_require__(136);

var _forOwn3 = _interopRequireDefault(_forOwn2);

var _cloneDeep2 = __webpack_require__(543);

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mergeClasses = exports.mergeClasses = function mergeClasses(classes) {
  var activeNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var styles = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
  activeNames.map(function (name) {
    var toMerge = classes[name];
    if (toMerge) {
      (0, _forOwn3.default)(toMerge, function (value, key) {
        if (!styles[key]) {
          styles[key] = {};
        }

        styles[key] = _extends({}, styles[key], toMerge[key]);
      });
    }

    return name;
  });
  return styles;
};

exports.default = mergeClasses;

/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(544);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(124),
    arrayEach = __webpack_require__(225),
    assignValue = __webpack_require__(226),
    baseAssign = __webpack_require__(545),
    baseAssignIn = __webpack_require__(546),
    cloneBuffer = __webpack_require__(549),
    copyArray = __webpack_require__(550),
    copySymbols = __webpack_require__(551),
    copySymbolsIn = __webpack_require__(552),
    getAllKeys = __webpack_require__(205),
    getAllKeysIn = __webpack_require__(553),
    getTag = __webpack_require__(212),
    initCloneArray = __webpack_require__(554),
    initCloneByTag = __webpack_require__(555),
    initCloneObject = __webpack_require__(564),
    isArray = __webpack_require__(15),
    isBuffer = __webpack_require__(130),
    isObject = __webpack_require__(21),
    keys = __webpack_require__(49);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(81),
    keys = __webpack_require__(49);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(81),
    keysIn = __webpack_require__(228);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(21),
    isPrototype = __webpack_require__(133),
    nativeKeysIn = __webpack_require__(548);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 548 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(18);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(70)(module)))

/***/ }),
/* 550 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(81),
    getSymbols = __webpack_require__(128);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(81),
    getSymbolsIn = __webpack_require__(229);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),
/* 553 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(206),
    getSymbolsIn = __webpack_require__(229),
    keysIn = __webpack_require__(228);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),
/* 554 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(138),
    cloneDataView = __webpack_require__(556),
    cloneMap = __webpack_require__(557),
    cloneRegExp = __webpack_require__(559),
    cloneSet = __webpack_require__(560),
    cloneSymbol = __webpack_require__(562),
    cloneTypedArray = __webpack_require__(563);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(138);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

var addMapEntry = __webpack_require__(558),
    arrayReduce = __webpack_require__(230),
    mapToArray = __webpack_require__(203);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;


/***/ }),
/* 558 */
/***/ (function(module, exports) {

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;


/***/ }),
/* 559 */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),
/* 560 */
/***/ (function(module, exports, __webpack_require__) {

var addSetEntry = __webpack_require__(561),
    arrayReduce = __webpack_require__(230),
    setToArray = __webpack_require__(204);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;


/***/ }),
/* 561 */
/***/ (function(module, exports) {

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;


/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(48);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(138);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(565),
    getPrototype = __webpack_require__(137),
    isPrototype = __webpack_require__(133);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(21);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autoprefix = undefined;

var _forOwn2 = __webpack_require__(136);

var _forOwn3 = _interopRequireDefault(_forOwn2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var transforms = {
  borderRadius: function borderRadius(value) {
    return {
      msBorderRadius: value,
      MozBorderRadius: value,
      OBorderRadius: value,
      WebkitBorderRadius: value,
      borderRadius: value
    };
  },
  boxShadow: function boxShadow(value) {
    return {
      msBoxShadow: value,
      MozBoxShadow: value,
      OBoxShadow: value,
      WebkitBoxShadow: value,
      boxShadow: value
    };
  },
  userSelect: function userSelect(value) {
    return {
      WebkitTouchCallout: value,
      KhtmlUserSelect: value,
      MozUserSelect: value,
      msUserSelect: value,
      WebkitUserSelect: value,
      userSelect: value
    };
  },

  flex: function flex(value) {
    return {
      WebkitBoxFlex: value,
      MozBoxFlex: value,
      WebkitFlex: value,
      msFlex: value,
      flex: value
    };
  },
  flexBasis: function flexBasis(value) {
    return {
      WebkitFlexBasis: value,
      flexBasis: value
    };
  },
  justifyContent: function justifyContent(value) {
    return {
      WebkitJustifyContent: value,
      justifyContent: value
    };
  },

  transition: function transition(value) {
    return {
      msTransition: value,
      MozTransition: value,
      OTransition: value,
      WebkitTransition: value,
      transition: value
    };
  },

  transform: function transform(value) {
    return {
      msTransform: value,
      MozTransform: value,
      OTransform: value,
      WebkitTransform: value,
      transform: value
    };
  },
  absolute: function absolute(value) {
    var direction = value && value.split(' ');
    return {
      position: 'absolute',
      top: direction && direction[0],
      right: direction && direction[1],
      bottom: direction && direction[2],
      left: direction && direction[3]
    };
  },
  extend: function extend(name, otherElementStyles) {
    var otherStyle = otherElementStyles[name];
    if (otherStyle) {
      return otherStyle;
    }
    return {
      'extend': name
    };
  }
};

var autoprefix = exports.autoprefix = function autoprefix(elements) {
  var prefixed = {};
  (0, _forOwn3.default)(elements, function (styles, element) {
    var expanded = {};
    (0, _forOwn3.default)(styles, function (value, key) {
      var transform = transforms[key];
      if (transform) {
        expanded = _extends({}, expanded, transform(value));
      } else {
        expanded[key] = value;
      }
    });
    prefixed[element] = expanded;
  });
  return prefixed;
};

exports.default = autoprefix;

/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hover = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var hover = exports.hover = function hover(Component) {
  var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';

  return function (_React$Component) {
    _inherits(Hover, _React$Component);

    function Hover() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, Hover);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = { hover: false }, _this.handleMouseOver = function () {
        return _this.setState({ hover: true });
      }, _this.handleMouseOut = function () {
        return _this.setState({ hover: false });
      }, _this.render = function () {
        return _react2.default.createElement(
          Span,
          { onMouseOver: _this.handleMouseOver, onMouseOut: _this.handleMouseOut },
          _react2.default.createElement(Component, _extends({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    return Hover;
  }(_react2.default.Component);
};

exports.default = hover;

/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.active = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var active = exports.active = function active(Component) {
  var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';

  return function (_React$Component) {
    _inherits(Active, _React$Component);

    function Active() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, Active);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = { active: false }, _this.handleMouseDown = function () {
        return _this.setState({ active: true });
      }, _this.handleMouseUp = function () {
        return _this.setState({ active: false });
      }, _this.render = function () {
        return _react2.default.createElement(
          Span,
          { onMouseDown: _this.handleMouseDown, onMouseUp: _this.handleMouseUp },
          _react2.default.createElement(Component, _extends({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    return Active;
  }(_react2.default.Component);
};

exports.default = active;

/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var loopable = function loopable(i, length) {
  var props = {};
  var setProp = function setProp(name) {
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    props[name] = value;
  };

  i === 0 && setProp('first-child');
  i === length - 1 && setProp('last-child');
  (i === 0 || i % 2 === 0) && setProp('even');
  Math.abs(i % 2) === 1 && setProp('odd');
  setProp('nth-child', i);

  return props;
};

exports.default = loopable;

/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlphaPicker = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(5);

var _AlphaPointer = __webpack_require__(587);

var _AlphaPointer2 = _interopRequireDefault(_AlphaPointer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AlphaPicker = exports.AlphaPicker = function AlphaPicker(_ref) {
  var rgb = _ref.rgb,
      hsl = _ref.hsl,
      width = _ref.width,
      height = _ref.height,
      onChange = _ref.onChange,
      direction = _ref.direction,
      style = _ref.style,
      renderers = _ref.renderers,
      pointer = _ref.pointer,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        position: 'relative',
        width: width,
        height: height
      },
      alpha: {
        radius: '2px',
        style: style
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'alpha-picker ' + className },
    _react2.default.createElement(_common.Alpha, _extends({}, styles.alpha, {
      rgb: rgb,
      hsl: hsl,
      pointer: pointer,
      renderers: renderers,
      onChange: onChange,
      direction: direction
    }))
  );
};

AlphaPicker.defaultProps = {
  width: '316px',
  height: '16px',
  direction: 'horizontal',
  pointer: _AlphaPointer2.default
};

exports.default = (0, _common.ColorWrap)(AlphaPicker);

/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Alpha = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _alpha = __webpack_require__(572);

var alpha = _interopRequireWildcard(_alpha);

var _Checkboard = __webpack_require__(232);

var _Checkboard2 = _interopRequireDefault(_Checkboard);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Alpha = exports.Alpha = function (_ref) {
  _inherits(Alpha, _ref);

  function Alpha() {
    var _ref2;

    var _temp, _this, _ret;

    _classCallCheck(this, Alpha);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Alpha.__proto__ || Object.getPrototypeOf(Alpha)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function (e, skip) {
      var change = alpha.calculateChange(e, skip, _this.props, _this.container);
      change && _this.props.onChange && _this.props.onChange(change, e);
    }, _this.handleMouseDown = function (e) {
      _this.handleChange(e, true);
      window.addEventListener('mousemove', _this.handleChange);
      window.addEventListener('mouseup', _this.handleMouseUp);
    }, _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    }, _this.unbindEventListeners = function () {
      window.removeEventListener('mousemove', _this.handleChange);
      window.removeEventListener('mouseup', _this.handleMouseUp);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Alpha, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var rgb = this.props.rgb;
      var styles = (0, _reactcss2.default)({
        'default': {
          alpha: {
            absolute: '0px 0px 0px 0px',
            borderRadius: this.props.radius
          },
          checkboard: {
            absolute: '0px 0px 0px 0px',
            overflow: 'hidden',
            borderRadius: this.props.radius
          },
          gradient: {
            absolute: '0px 0px 0px 0px',
            background: 'linear-gradient(to right, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 0) 0%,\n           rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 1) 100%)',
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          container: {
            position: 'relative',
            height: '100%',
            margin: '0 3px'
          },
          pointer: {
            position: 'absolute',
            left: rgb.a * 100 + '%'
          },
          slider: {
            width: '4px',
            borderRadius: '1px',
            height: '8px',
            boxShadow: '0 0 2px rgba(0, 0, 0, .6)',
            background: '#fff',
            marginTop: '1px',
            transform: 'translateX(-2px)'
          }
        },
        'vertical': {
          gradient: {
            background: 'linear-gradient(to bottom, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 0) 0%,\n           rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 1) 100%)'
          },
          pointer: {
            left: 0,
            top: rgb.a * 100 + '%'
          }
        },
        'overwrite': _extends({}, this.props.style)
      }, {
        vertical: this.props.direction === 'vertical',
        overwrite: true
      });

      return _react2.default.createElement(
        'div',
        { style: styles.alpha },
        _react2.default.createElement(
          'div',
          { style: styles.checkboard },
          _react2.default.createElement(_Checkboard2.default, { renderers: this.props.renderers })
        ),
        _react2.default.createElement('div', { style: styles.gradient }),
        _react2.default.createElement(
          'div',
          {
            style: styles.container,
            ref: function ref(container) {
              return _this2.container = container;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          _react2.default.createElement(
            'div',
            { style: styles.pointer },
            this.props.pointer ? _react2.default.createElement(this.props.pointer, this.props) : _react2.default.createElement('div', { style: styles.slider })
          )
        )
      );
    }
  }]);

  return Alpha;
}(_react.PureComponent || _react.Component);

exports.default = Alpha;

/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var calculateChange = exports.calculateChange = function calculateChange(e, skip, props, container) {
  e.preventDefault();
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);

  if (props.direction === 'vertical') {
    var a = void 0;
    if (top < 0) {
      a = 0;
    } else if (top > containerHeight) {
      a = 1;
    } else {
      a = Math.round(top * 100 / containerHeight) / 100;
    }

    if (props.hsl.a !== a) {
      return {
        h: props.hsl.h,
        s: props.hsl.s,
        l: props.hsl.l,
        a: a,
        source: 'rgb'
      };
    }
  } else {
    var _a = void 0;
    if (left < 0) {
      _a = 0;
    } else if (left > containerWidth) {
      _a = 1;
    } else {
      _a = Math.round(left * 100 / containerWidth) / 100;
    }

    if (props.a !== _a) {
      return {
        h: props.hsl.h,
        s: props.hsl.s,
        l: props.hsl.l,
        a: _a,
        source: 'rgb'
      };
    }
  }
  return null;
};

/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var checkboardCache = {};

var render = exports.render = function render(c1, c2, size, serverCanvas) {
  if (typeof document === 'undefined' && !serverCanvas) {
    return null;
  }
  var canvas = serverCanvas ? new serverCanvas() : document.createElement('canvas');
  canvas.width = size * 2;
  canvas.height = size * 2;
  var ctx = canvas.getContext('2d');
  if (!ctx) {
    return null;
  } // If no context can be found, return early.
  ctx.fillStyle = c1;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = c2;
  ctx.fillRect(0, 0, size, size);
  ctx.translate(size, size);
  ctx.fillRect(0, 0, size, size);
  return canvas.toDataURL();
};

var get = exports.get = function get(c1, c2, size, serverCanvas) {
  var key = c1 + '-' + c2 + '-' + size + (serverCanvas ? '-server' : '');
  var checkboard = render(c1, c2, size, serverCanvas);

  if (checkboardCache[key]) {
    return checkboardCache[key];
  }
  checkboardCache[key] = checkboard;
  return checkboard;
};

/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditableInput = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditableInput = exports.EditableInput = function (_ref) {
  _inherits(EditableInput, _ref);

  function EditableInput(props) {
    _classCallCheck(this, EditableInput);

    var _this = _possibleConstructorReturn(this, (EditableInput.__proto__ || Object.getPrototypeOf(EditableInput)).call(this));

    _this.handleBlur = function () {
      if (_this.state.blurValue) {
        _this.setState({ value: _this.state.blurValue, blurValue: null });
      }
    };

    _this.handleChange = function (e) {
      if (_this.props.label) {
        _this.props.onChange && _this.props.onChange(_defineProperty({}, _this.props.label, e.target.value), e);
      } else {
        _this.props.onChange && _this.props.onChange(e.target.value, e);
      }

      _this.setState({ value: e.target.value });
    };

    _this.handleKeyDown = function (e) {
      // In case `e.target.value` is a percentage remove the `%` character
      // and update accordingly with a percentage
      // https://github.com/casesandberg/react-color/issues/383
      var stringValue = String(e.target.value);
      var isPercentage = stringValue.indexOf('%') > -1;
      var number = Number(stringValue.replace(/%/g, ''));
      if (!isNaN(number)) {
        var amount = _this.props.arrowOffset || 1;

        // Up
        if (e.keyCode === 38) {
          if (_this.props.label !== null) {
            _this.props.onChange && _this.props.onChange(_defineProperty({}, _this.props.label, number + amount), e);
          } else {
            _this.props.onChange && _this.props.onChange(number + amount, e);
          }

          if (isPercentage) {
            _this.setState({ value: number + amount + '%' });
          } else {
            _this.setState({ value: number + amount });
          }
        }

        // Down
        if (e.keyCode === 40) {
          if (_this.props.label !== null) {
            _this.props.onChange && _this.props.onChange(_defineProperty({}, _this.props.label, number - amount), e);
          } else {
            _this.props.onChange && _this.props.onChange(number - amount, e);
          }

          if (isPercentage) {
            _this.setState({ value: number - amount + '%' });
          } else {
            _this.setState({ value: number - amount });
          }
        }
      }
    };

    _this.handleDrag = function (e) {
      if (_this.props.dragLabel) {
        var newValue = Math.round(_this.props.value + e.movementX);
        if (newValue >= 0 && newValue <= _this.props.dragMax) {
          _this.props.onChange && _this.props.onChange(_defineProperty({}, _this.props.label, newValue), e);
        }
      }
    };

    _this.handleMouseDown = function (e) {
      if (_this.props.dragLabel) {
        e.preventDefault();
        _this.handleDrag(e);
        window.addEventListener('mousemove', _this.handleDrag);
        window.addEventListener('mouseup', _this.handleMouseUp);
      }
    };

    _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    };

    _this.unbindEventListeners = function () {
      window.removeEventListener('mousemove', _this.handleDrag);
      window.removeEventListener('mouseup', _this.handleMouseUp);
    };

    _this.state = {
      value: String(props.value).toUpperCase(),
      blurValue: String(props.value).toUpperCase()
    };
    return _this;
  }

  _createClass(EditableInput, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var input = this.input;
      if (nextProps.value !== this.state.value) {
        if (input === document.activeElement) {
          this.setState({ blurValue: String(nextProps.value).toUpperCase() });
        } else {
          this.setState({ value: String(nextProps.value).toUpperCase(), blurValue: !this.state.blurValue && String(nextProps.value).toUpperCase() });
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var styles = (0, _reactcss2.default)({
        'default': {
          wrap: {
            position: 'relative'
          }
        },
        'user-override': {
          wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
          input: this.props.style && this.props.style.input ? this.props.style.input : {},
          label: this.props.style && this.props.style.label ? this.props.style.label : {}
        },
        'dragLabel-true': {
          label: {
            cursor: 'ew-resize'
          }
        }
      }, {
        'user-override': true
      }, this.props);

      return _react2.default.createElement(
        'div',
        { style: styles.wrap },
        _react2.default.createElement('input', {
          style: styles.input,
          ref: function ref(input) {
            return _this2.input = input;
          },
          value: this.state.value,
          onKeyDown: this.handleKeyDown,
          onChange: this.handleChange,
          onBlur: this.handleBlur,
          placeholder: this.props.placeholder,
          spellCheck: 'false'
        }),
        this.props.label && !this.props.hideLabel ? _react2.default.createElement(
          'span',
          { style: styles.label, onMouseDown: this.handleMouseDown },
          this.props.label
        ) : null
      );
    }
  }]);

  return EditableInput;
}(_react.PureComponent || _react.Component);

exports.default = EditableInput;

/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Hue = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _hue = __webpack_require__(576);

var hue = _interopRequireWildcard(_hue);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Hue = exports.Hue = function (_ref) {
  _inherits(Hue, _ref);

  function Hue() {
    var _ref2;

    var _temp, _this, _ret;

    _classCallCheck(this, Hue);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Hue.__proto__ || Object.getPrototypeOf(Hue)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function (e, skip) {
      var change = hue.calculateChange(e, skip, _this.props, _this.container);
      change && _this.props.onChange && _this.props.onChange(change, e);
    }, _this.handleMouseDown = function (e) {
      _this.handleChange(e, true);
      window.addEventListener('mousemove', _this.handleChange);
      window.addEventListener('mouseup', _this.handleMouseUp);
    }, _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Hue, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'unbindEventListeners',
    value: function unbindEventListeners() {
      window.removeEventListener('mousemove', this.handleChange);
      window.removeEventListener('mouseup', this.handleMouseUp);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props$direction = this.props.direction,
          direction = _props$direction === undefined ? 'horizontal' : _props$direction;


      var styles = (0, _reactcss2.default)({
        'default': {
          hue: {
            absolute: '0px 0px 0px 0px',
            borderRadius: this.props.radius,
            boxShadow: this.props.shadow
          },
          container: {
            padding: '0 2px',
            position: 'relative',
            height: '100%',
            borderRadius: this.props.radius
          },
          pointer: {
            position: 'absolute',
            left: this.props.hsl.h * 100 / 360 + '%'
          },
          slider: {
            marginTop: '1px',
            width: '4px',
            borderRadius: '1px',
            height: '8px',
            boxShadow: '0 0 2px rgba(0, 0, 0, .6)',
            background: '#fff',
            transform: 'translateX(-2px)'
          }
        },
        'vertical': {
          pointer: {
            left: '0px',
            top: -(this.props.hsl.h * 100 / 360) + 100 + '%'
          }
        }
      }, { vertical: direction === 'vertical' });

      return _react2.default.createElement(
        'div',
        { style: styles.hue },
        _react2.default.createElement(
          'div',
          {
            className: 'hue-' + direction,
            style: styles.container,
            ref: function ref(container) {
              return _this2.container = container;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          _react2.default.createElement(
            'style',
            null,
            '\n            .hue-horizontal {\n              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to right, #f00 0%, #ff0\n                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n\n            .hue-vertical {\n              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,\n                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n          '
          ),
          _react2.default.createElement(
            'div',
            { style: styles.pointer },
            this.props.pointer ? _react2.default.createElement(this.props.pointer, this.props) : _react2.default.createElement('div', { style: styles.slider })
          )
        )
      );
    }
  }]);

  return Hue;
}(_react.PureComponent || _react.Component);

exports.default = Hue;

/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var calculateChange = exports.calculateChange = function calculateChange(e, skip, props, container) {
  e.preventDefault();
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);

  if (props.direction === 'vertical') {
    var h = void 0;
    if (top < 0) {
      h = 359;
    } else if (top > containerHeight) {
      h = 0;
    } else {
      var percent = -(top * 100 / containerHeight) + 100;
      h = 360 * percent / 100;
    }

    if (props.hsl.h !== h) {
      return {
        h: h,
        s: props.hsl.s,
        l: props.hsl.l,
        a: props.hsl.a,
        source: 'rgb'
      };
    }
  } else {
    var _h = void 0;
    if (left < 0) {
      _h = 0;
    } else if (left > containerWidth) {
      _h = 359;
    } else {
      var _percent = left * 100 / containerWidth;
      _h = 360 * _percent / 100;
    }

    if (props.hsl.h !== _h) {
      return {
        h: _h,
        s: props.hsl.s,
        l: props.hsl.l,
        a: props.hsl.a,
        source: 'rgb'
      };
    }
  }
  return null;
};

/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Raised = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Raised = exports.Raised = function Raised(_ref) {
  var zDepth = _ref.zDepth,
      radius = _ref.radius,
      background = _ref.background,
      children = _ref.children;

  var styles = (0, _reactcss2.default)({
    'default': {
      wrap: {
        position: 'relative',
        display: 'inline-block'
      },
      content: {
        position: 'relative'
      },
      bg: {
        absolute: '0px 0px 0px 0px',
        boxShadow: '0 ' + zDepth + 'px ' + zDepth * 4 + 'px rgba(0,0,0,.24)',
        borderRadius: radius,
        background: background
      }
    },
    'zDepth-0': {
      bg: {
        boxShadow: 'none'
      }
    },

    'zDepth-1': {
      bg: {
        boxShadow: '0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)'
      }
    },
    'zDepth-2': {
      bg: {
        boxShadow: '0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)'
      }
    },
    'zDepth-3': {
      bg: {
        boxShadow: '0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)'
      }
    },
    'zDepth-4': {
      bg: {
        boxShadow: '0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)'
      }
    },
    'zDepth-5': {
      bg: {
        boxShadow: '0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)'
      }
    },
    'square': {
      bg: {
        borderRadius: '0'
      }
    },
    'circle': {
      bg: {
        borderRadius: '50%'
      }
    }
  }, { 'zDepth-1': zDepth === 1 });

  return _react2.default.createElement(
    'div',
    { style: styles.wrap },
    _react2.default.createElement('div', { style: styles.bg }),
    _react2.default.createElement(
      'div',
      { style: styles.content },
      children
    )
  );
};

Raised.propTypes = {
  background: _propTypes2.default.string,
  zDepth: _propTypes2.default.oneOf([0, 1, 2, 3, 4, 5]),
  radius: _propTypes2.default.number
};

Raised.defaultProps = {
  background: '#fff',
  zDepth: 1,
  radius: 2
};

exports.default = Raised;

/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Saturation = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _throttle = __webpack_require__(579);

var _throttle2 = _interopRequireDefault(_throttle);

var _saturation = __webpack_require__(581);

var saturation = _interopRequireWildcard(_saturation);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Saturation = exports.Saturation = function (_ref) {
  _inherits(Saturation, _ref);

  function Saturation(props) {
    _classCallCheck(this, Saturation);

    var _this = _possibleConstructorReturn(this, (Saturation.__proto__ || Object.getPrototypeOf(Saturation)).call(this, props));

    _this.handleChange = function (e, skip) {
      _this.props.onChange && _this.throttle(_this.props.onChange, saturation.calculateChange(e, skip, _this.props, _this.container), e);
    };

    _this.handleMouseDown = function (e) {
      _this.handleChange(e, true);
      window.addEventListener('mousemove', _this.handleChange);
      window.addEventListener('mouseup', _this.handleMouseUp);
    };

    _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    };

    _this.throttle = (0, _throttle2.default)(function (fn, data, e) {
      fn(data, e);
    }, 50);
    return _this;
  }

  _createClass(Saturation, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'unbindEventListeners',
    value: function unbindEventListeners() {
      window.removeEventListener('mousemove', this.handleChange);
      window.removeEventListener('mouseup', this.handleMouseUp);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _ref2 = this.props.style || {},
          color = _ref2.color,
          white = _ref2.white,
          black = _ref2.black,
          pointer = _ref2.pointer,
          circle = _ref2.circle;

      var styles = (0, _reactcss2.default)({
        'default': {
          color: {
            absolute: '0px 0px 0px 0px',
            background: 'hsl(' + this.props.hsl.h + ',100%, 50%)',
            borderRadius: this.props.radius
          },
          white: {
            absolute: '0px 0px 0px 0px',
            borderRadius: this.props.radius
          },
          black: {
            absolute: '0px 0px 0px 0px',
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          pointer: {
            position: 'absolute',
            top: -(this.props.hsv.v * 100) + 100 + '%',
            left: this.props.hsv.s * 100 + '%',
            cursor: 'default'
          },
          circle: {
            width: '4px',
            height: '4px',
            boxShadow: '0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)',
            borderRadius: '50%',
            cursor: 'hand',
            transform: 'translate(-2px, -2px)'
          }
        },
        'custom': {
          color: color,
          white: white,
          black: black,
          pointer: pointer,
          circle: circle
        }
      }, { 'custom': !!this.props.style });

      return _react2.default.createElement(
        'div',
        {
          style: styles.color,
          ref: function ref(container) {
            return _this2.container = container;
          },
          onMouseDown: this.handleMouseDown,
          onTouchMove: this.handleChange,
          onTouchStart: this.handleChange
        },
        _react2.default.createElement(
          'style',
          null,
          '\n          .saturation-white {\n            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));\n            background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n          }\n          .saturation-black {\n            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));\n            background: linear-gradient(to top, #000, rgba(0,0,0,0));\n          }\n        '
        ),
        _react2.default.createElement(
          'div',
          { style: styles.white, className: 'saturation-white' },
          _react2.default.createElement('div', { style: styles.black, className: 'saturation-black' }),
          _react2.default.createElement(
            'div',
            { style: styles.pointer },
            this.props.pointer ? _react2.default.createElement(this.props.pointer, this.props) : _react2.default.createElement('div', { style: styles.circle })
          )
        )
      );
    }
  }]);

  return Saturation;
}(_react.PureComponent || _react.Component);

exports.default = Saturation;

/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(233),
    isObject = __webpack_require__(21);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;


/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(18);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var calculateChange = exports.calculateChange = function calculateChange(e, skip, props, container) {
  e.preventDefault();

  var _container$getBoundin = container.getBoundingClientRect(),
      containerWidth = _container$getBoundin.width,
      containerHeight = _container$getBoundin.height;

  var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);

  if (left < 0) {
    left = 0;
  } else if (left > containerWidth) {
    left = containerWidth;
  } else if (top < 0) {
    top = 0;
  } else if (top > containerHeight) {
    top = containerHeight;
  }

  var saturation = left * 100 / containerWidth;
  var bright = -(top * 100 / containerHeight) + 100;

  return {
    h: props.hsl.h,
    s: saturation,
    v: bright,
    a: props.hsl.a,
    source: 'rgb'
  };
};

/***/ }),
/* 582 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(583);


/***/ }),
/* 583 */
/***/ (function(module, exports, __webpack_require__) {

var arrayEach = __webpack_require__(225),
    baseEach = __webpack_require__(219),
    castFunction = __webpack_require__(224),
    isArray = __webpack_require__(15);

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;


/***/ }),
/* 584 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];

    // Return a 4 character hex if possible
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if (typeof module !== "undefined" && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {return tinycolor;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}
// Browser: Expose to window
else {
    window.tinycolor = tinycolor;
}

})(Math);


/***/ }),
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Swatch = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _interaction = __webpack_require__(586);

var _ = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ENTER = 13;

var Swatch = exports.Swatch = function Swatch(_ref) {
  var color = _ref.color,
      style = _ref.style,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      onHover = _ref.onHover,
      _ref$title = _ref.title,
      title = _ref$title === undefined ? color : _ref$title,
      children = _ref.children,
      focus = _ref.focus,
      _ref$focusStyle = _ref.focusStyle,
      focusStyle = _ref$focusStyle === undefined ? {} : _ref$focusStyle;

  var transparent = color === 'transparent';
  var styles = (0, _reactcss2.default)({
    default: {
      swatch: _extends({
        background: color,
        height: '100%',
        width: '100%',
        cursor: 'pointer',
        position: 'relative',
        outline: 'none'
      }, style, focus ? focusStyle : {})
    }
  });

  var handleClick = function handleClick(e) {
    return onClick(color, e);
  };
  var handleKeyDown = function handleKeyDown(e) {
    return e.keyCode === ENTER && onClick(color, e);
  };
  var handleHover = function handleHover(e) {
    return onHover(color, e);
  };

  var optionalEvents = {};
  if (onHover) {
    optionalEvents.onMouseOver = handleHover;
  }

  return _react2.default.createElement(
    'div',
    _extends({
      style: styles.swatch,
      onClick: handleClick,
      title: title,
      tabIndex: 0,
      onKeyDown: handleKeyDown
    }, optionalEvents),
    children,
    transparent && _react2.default.createElement(_.Checkboard, {
      borderRadius: styles.swatch.borderRadius,
      boxShadow: 'inset 0 0 0 1px rgba(0,0,0,0.1)'
    })
  );
};

exports.default = (0, _interaction.handleFocus)(Swatch);

/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleFocus = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable no-invalid-this */


var handleFocus = exports.handleFocus = function handleFocus(Component) {
  var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';
  return function (_React$Component) {
    _inherits(Focus, _React$Component);

    function Focus() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, Focus);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Focus.__proto__ || Object.getPrototypeOf(Focus)).call.apply(_ref, [this].concat(args))), _this), _this.state = { focus: false }, _this.handleFocus = function () {
        return _this.setState({ focus: true });
      }, _this.handleBlur = function () {
        return _this.setState({ focus: false });
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(Focus, [{
      key: 'render',
      value: function render() {
        return _react2.default.createElement(
          Span,
          { onFocus: this.handleFocus, onBlur: this.handleBlur },
          _react2.default.createElement(Component, _extends({}, this.props, this.state))
        );
      }
    }]);

    return Focus;
  }(_react2.default.Component);
};

/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlphaPointer = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AlphaPointer = exports.AlphaPointer = function AlphaPointer(_ref) {
  var direction = _ref.direction;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '18px',
        height: '18px',
        borderRadius: '50%',
        transform: 'translate(-9px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    },
    'vertical': {
      picker: {
        transform: 'translate(-3px, -9px)'
      }
    }
  }, { vertical: direction === 'vertical' });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = AlphaPointer;

/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Block = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = __webpack_require__(19);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(5);

var _BlockSwatches = __webpack_require__(589);

var _BlockSwatches2 = _interopRequireDefault(_BlockSwatches);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Block = exports.Block = function Block(_ref) {
  var onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      hex = _ref.hex,
      colors = _ref.colors,
      width = _ref.width,
      triangle = _ref.triangle,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var transparent = hex === 'transparent';
  var handleChange = function handleChange(hexCode, e) {
    _color2.default.isValidHex(hexCode) && onChange({
      hex: hexCode,
      source: 'hex'
    }, e);
  };

  var styles = (0, _reactcss2.default)({
    'default': {
      card: {
        width: width,
        background: '#fff',
        boxShadow: '0 1px rgba(0,0,0,.1)',
        borderRadius: '6px',
        position: 'relative'
      },
      head: {
        height: '110px',
        background: hex,
        borderRadius: '6px 6px 0 0',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        position: 'relative'
      },
      body: {
        padding: '10px'
      },
      label: {
        fontSize: '18px',
        color: _color2.default.getContrastingColor(hex),
        position: 'relative'
      },
      triangle: {
        width: '0px',
        height: '0px',
        borderStyle: 'solid',
        borderWidth: '0 10px 10px 10px',
        borderColor: 'transparent transparent ' + hex + ' transparent',
        position: 'absolute',
        top: '-10px',
        left: '50%',
        marginLeft: '-10px'
      },
      input: {
        width: '100%',
        fontSize: '12px',
        color: '#666',
        border: '0px',
        outline: 'none',
        height: '22px',
        boxShadow: 'inset 0 0 0 1px #ddd',
        borderRadius: '4px',
        padding: '0 7px',
        boxSizing: 'border-box'
      }
    },
    'hide-triangle': {
      triangle: {
        display: 'none'
      }
    }
  }, { 'hide-triangle': triangle === 'hide' });

  return _react2.default.createElement(
    'div',
    { style: styles.card, className: 'block-picker ' + className },
    _react2.default.createElement('div', { style: styles.triangle }),
    _react2.default.createElement(
      'div',
      { style: styles.head },
      transparent && _react2.default.createElement(_common.Checkboard, { borderRadius: '6px 6px 0 0' }),
      _react2.default.createElement(
        'div',
        { style: styles.label },
        hex
      )
    ),
    _react2.default.createElement(
      'div',
      { style: styles.body },
      _react2.default.createElement(_BlockSwatches2.default, { colors: colors, onClick: handleChange, onSwatchHover: onSwatchHover }),
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input },
        value: hex,
        onChange: handleChange
      })
    )
  );
};

Block.propTypes = {
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  colors: _propTypes2.default.arrayOf(_propTypes2.default.string),
  triangle: _propTypes2.default.oneOf(['top', 'hide'])
};

Block.defaultProps = {
  width: 170,
  colors: ['#D9E3F0', '#F47373', '#697689', '#37D67A', '#2CCCE4', '#555555', '#dce775', '#ff8a65', '#ba68c8'],
  triangle: 'top'
};

exports.default = (0, _common.ColorWrap)(Block);

/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BlockSwatches = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(27);

var _map2 = _interopRequireDefault(_map);

var _common = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BlockSwatches = exports.BlockSwatches = function BlockSwatches(_ref) {
  var colors = _ref.colors,
      onClick = _ref.onClick,
      onSwatchHover = _ref.onSwatchHover;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatches: {
        marginRight: '-10px'
      },
      swatch: {
        width: '22px',
        height: '22px',
        float: 'left',
        marginRight: '10px',
        marginBottom: '10px',
        borderRadius: '4px'
      },
      clear: {
        clear: 'both'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.swatches },
    (0, _map2.default)(colors, function (c) {
      return _react2.default.createElement(_common.Swatch, {
        key: c,
        color: c,
        style: styles.swatch,
        onClick: onClick,
        onHover: onSwatchHover,
        focusStyle: {
          boxShadow: '0 0 4px ' + c
        }
      });
    }),
    _react2.default.createElement('div', { style: styles.clear })
  );
};

exports.default = BlockSwatches;

/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Circle = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(27);

var _map2 = _interopRequireDefault(_map);

var _materialColors = __webpack_require__(235);

var material = _interopRequireWildcard(_materialColors);

var _common = __webpack_require__(5);

var _CircleSwatch = __webpack_require__(591);

var _CircleSwatch2 = _interopRequireDefault(_CircleSwatch);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Circle = exports.Circle = function Circle(_ref) {
  var width = _ref.width,
      onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      colors = _ref.colors,
      hex = _ref.hex,
      circleSize = _ref.circleSize,
      circleSpacing = _ref.circleSpacing,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)({
    'default': {
      card: {
        width: width,
        display: 'flex',
        flexWrap: 'wrap',
        marginRight: -circleSpacing,
        marginBottom: -circleSpacing
      }
    }
  });

  var handleChange = function handleChange(hexCode, e) {
    return onChange({ hex: hexCode, source: 'hex' }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.card, className: 'circle-picker ' + className },
    (0, _map2.default)(colors, function (c) {
      return _react2.default.createElement(_CircleSwatch2.default, {
        key: c,
        color: c,
        onClick: handleChange,
        onSwatchHover: onSwatchHover,
        active: hex === c.toLowerCase(),
        circleSize: circleSize,
        circleSpacing: circleSpacing
      });
    })
  );
};

Circle.propTypes = {
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  circleSize: _propTypes2.default.number,
  circleSpacing: _propTypes2.default.number
};

Circle.defaultProps = {
  width: 252,
  circleSize: 28,
  circleSpacing: 14,
  colors: [material.red['500'], material.pink['500'], material.purple['500'], material.deepPurple['500'], material.indigo['500'], material.blue['500'], material.lightBlue['500'], material.cyan['500'], material.teal['500'], material.green['500'], material.lightGreen['500'], material.lime['500'], material.yellow['500'], material.amber['500'], material.orange['500'], material.deepOrange['500'], material.brown['500'], material.blueGrey['500']]
};

exports.default = (0, _common.ColorWrap)(Circle);

/***/ }),
/* 591 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CircleSwatch = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CircleSwatch = exports.CircleSwatch = function CircleSwatch(_ref) {
  var color = _ref.color,
      onClick = _ref.onClick,
      onSwatchHover = _ref.onSwatchHover,
      hover = _ref.hover,
      active = _ref.active,
      circleSize = _ref.circleSize,
      circleSpacing = _ref.circleSpacing;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatch: {
        width: circleSize,
        height: circleSize,
        marginRight: circleSpacing,
        marginBottom: circleSpacing,
        transform: 'scale(1)',
        transition: '100ms transform ease'
      },
      Swatch: {
        borderRadius: '50%',
        background: 'transparent',
        boxShadow: 'inset 0 0 0 ' + circleSize / 2 + 'px ' + color,
        transition: '100ms box-shadow ease'
      }
    },
    'hover': {
      swatch: {
        transform: 'scale(1.2)'
      }
    },
    'active': {
      Swatch: {
        boxShadow: 'inset 0 0 0 3px ' + color
      }
    }
  }, { hover: hover, active: active });

  return _react2.default.createElement(
    'div',
    { style: styles.swatch },
    _react2.default.createElement(_common.Swatch, {
      style: styles.Swatch,
      color: color,
      onClick: onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: styles.Swatch.boxShadow + ', 0 0 5px ' + color }
    })
  );
};

CircleSwatch.defaultProps = {
  circleSize: 28,
  circleSpacing: 14
};

exports.default = (0, _reactcss.handleHover)(CircleSwatch);

/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chrome = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(5);

var _ChromeFields = __webpack_require__(593);

var _ChromeFields2 = _interopRequireDefault(_ChromeFields);

var _ChromePointer = __webpack_require__(594);

var _ChromePointer2 = _interopRequireDefault(_ChromePointer);

var _ChromePointerCircle = __webpack_require__(595);

var _ChromePointerCircle2 = _interopRequireDefault(_ChromePointerCircle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Chrome = exports.Chrome = function Chrome(_ref) {
  var onChange = _ref.onChange,
      disableAlpha = _ref.disableAlpha,
      rgb = _ref.rgb,
      hsl = _ref.hsl,
      hsv = _ref.hsv,
      hex = _ref.hex,
      renderers = _ref.renderers,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        background: '#fff',
        borderRadius: '2px',
        boxShadow: '0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)',
        boxSizing: 'initial',
        width: '225px',
        fontFamily: 'Menlo'
      },
      saturation: {
        width: '100%',
        paddingBottom: '55%',
        position: 'relative',
        borderRadius: '2px 2px 0 0',
        overflow: 'hidden'
      },
      Saturation: {
        radius: '2px 2px 0 0'
      },
      body: {
        padding: '16px 16px 12px'
      },
      controls: {
        display: 'flex'
      },
      color: {
        width: '32px'
      },
      swatch: {
        marginTop: '6px',
        width: '16px',
        height: '16px',
        borderRadius: '8px',
        position: 'relative',
        overflow: 'hidden'
      },
      active: {
        absolute: '0px 0px 0px 0px',
        borderRadius: '8px',
        boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.1)',
        background: 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + rgb.a + ')',
        zIndex: '2'
      },
      toggles: {
        flex: '1'
      },
      hue: {
        height: '10px',
        position: 'relative',
        marginBottom: '8px'
      },
      Hue: {
        radius: '2px'
      },
      alpha: {
        height: '10px',
        position: 'relative'
      },
      Alpha: {
        radius: '2px'
      }
    },
    'disableAlpha': {
      color: {
        width: '22px'
      },
      alpha: {
        display: 'none'
      },
      hue: {
        marginBottom: '0px'
      },
      swatch: {
        width: '10px',
        height: '10px',
        marginTop: '0px'
      }
    }
  }, { disableAlpha: disableAlpha });

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'chrome-picker ' + className },
    _react2.default.createElement(
      'div',
      { style: styles.saturation },
      _react2.default.createElement(_common.Saturation, {
        style: styles.Saturation,
        hsl: hsl,
        hsv: hsv,
        pointer: _ChromePointerCircle2.default,
        onChange: onChange
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.body },
      _react2.default.createElement(
        'div',
        { style: styles.controls, className: 'flexbox-fix' },
        _react2.default.createElement(
          'div',
          { style: styles.color },
          _react2.default.createElement(
            'div',
            { style: styles.swatch },
            _react2.default.createElement('div', { style: styles.active }),
            _react2.default.createElement(_common.Checkboard, { renderers: renderers })
          )
        ),
        _react2.default.createElement(
          'div',
          { style: styles.toggles },
          _react2.default.createElement(
            'div',
            { style: styles.hue },
            _react2.default.createElement(_common.Hue, {
              style: styles.Hue,
              hsl: hsl,
              pointer: _ChromePointer2.default,
              onChange: onChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.alpha },
            _react2.default.createElement(_common.Alpha, {
              style: styles.Alpha,
              rgb: rgb,
              hsl: hsl,
              pointer: _ChromePointer2.default,
              renderers: renderers,
              onChange: onChange
            })
          )
        )
      ),
      _react2.default.createElement(_ChromeFields2.default, {
        rgb: rgb,
        hsl: hsl,
        hex: hex,
        onChange: onChange,
        disableAlpha: disableAlpha
      })
    )
  );
};

Chrome.propTypes = {
  disableAlpha: _propTypes2.default.bool
};

Chrome.defaultProps = {
  disableAlpha: false
};

exports.default = (0, _common.ColorWrap)(Chrome);

/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChromeFields = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = __webpack_require__(19);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable react/no-did-mount-set-state, no-param-reassign */

var ChromeFields = exports.ChromeFields = function (_React$Component) {
  _inherits(ChromeFields, _React$Component);

  function ChromeFields() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, ChromeFields);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ChromeFields.__proto__ || Object.getPrototypeOf(ChromeFields)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      view: ''
    }, _this.toggleViews = function () {
      if (_this.state.view === 'hex') {
        _this.setState({ view: 'rgb' });
      } else if (_this.state.view === 'rgb') {
        _this.setState({ view: 'hsl' });
      } else if (_this.state.view === 'hsl') {
        if (_this.props.hsl.a === 1) {
          _this.setState({ view: 'hex' });
        } else {
          _this.setState({ view: 'rgb' });
        }
      }
    }, _this.handleChange = function (data, e) {
      if (data.hex) {
        _color2.default.isValidHex(data.hex) && _this.props.onChange({
          hex: data.hex,
          source: 'hex'
        }, e);
      } else if (data.r || data.g || data.b) {
        _this.props.onChange({
          r: data.r || _this.props.rgb.r,
          g: data.g || _this.props.rgb.g,
          b: data.b || _this.props.rgb.b,
          source: 'rgb'
        }, e);
      } else if (data.a) {
        if (data.a < 0) {
          data.a = 0;
        } else if (data.a > 1) {
          data.a = 1;
        }

        _this.props.onChange({
          h: _this.props.hsl.h,
          s: _this.props.hsl.s,
          l: _this.props.hsl.l,
          a: Math.round(data.a * 100) / 100,
          source: 'rgb'
        }, e);
      } else if (data.h || data.s || data.l) {
        _this.props.onChange({
          h: data.h || _this.props.hsl.h,
          s: Number(data.s && data.s || _this.props.hsl.s),
          l: Number(data.l && data.l || _this.props.hsl.l),
          source: 'hsl'
        }, e);
      }
    }, _this.showHighlight = function (e) {
      e.target.style.background = '#eee';
    }, _this.hideHighlight = function (e) {
      e.target.style.background = 'transparent';
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(ChromeFields, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (this.props.hsl.a === 1 && this.state.view !== 'hex') {
        this.setState({ view: 'hex' });
      } else if (this.state.view !== 'rgb' && this.state.view !== 'hsl') {
        this.setState({ view: 'rgb' });
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.hsl.a !== 1 && this.state.view === 'hex') {
        this.setState({ view: 'rgb' });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var styles = (0, _reactcss2.default)({
        'default': {
          wrap: {
            paddingTop: '16px',
            display: 'flex'
          },
          fields: {
            flex: '1',
            display: 'flex',
            marginLeft: '-6px'
          },
          field: {
            paddingLeft: '6px',
            width: '100%'
          },
          alpha: {
            paddingLeft: '6px',
            width: '100%'
          },
          toggle: {
            width: '32px',
            textAlign: 'right',
            position: 'relative'
          },
          icon: {
            marginRight: '-4px',
            marginTop: '12px',
            cursor: 'pointer',
            position: 'relative'
          },
          iconHighlight: {
            position: 'absolute',
            width: '24px',
            height: '28px',
            background: '#eee',
            borderRadius: '4px',
            top: '10px',
            left: '12px',
            display: 'none'
          },
          input: {
            fontSize: '11px',
            color: '#333',
            width: '100%',
            borderRadius: '2px',
            border: 'none',
            boxShadow: 'inset 0 0 0 1px #dadada',
            height: '21px',
            textAlign: 'center'
          },
          label: {
            textTransform: 'uppercase',
            fontSize: '11px',
            lineHeight: '11px',
            color: '#969696',
            textAlign: 'center',
            display: 'block',
            marginTop: '12px'
          },
          svg: {
            width: '24px',
            height: '24px',
            border: '1px transparent solid',
            borderRadius: '5px'
          }
        },
        'disableAlpha': {
          alpha: {
            display: 'none'
          }
        }
      }, this.props, this.state);

      var fields = void 0;
      if (this.state.view === 'hex') {
        fields = _react2.default.createElement(
          'div',
          { style: styles.fields, className: 'flexbox-fix' },
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'hex', value: this.props.hex,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === 'rgb') {
        fields = _react2.default.createElement(
          'div',
          { style: styles.fields, className: 'flexbox-fix' },
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'r',
              value: this.props.rgb.r,
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'g',
              value: this.props.rgb.g,
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'b',
              value: this.props.rgb.b,
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.alpha },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'a',
              value: this.props.rgb.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === 'hsl') {
        fields = _react2.default.createElement(
          'div',
          { style: styles.fields, className: 'flexbox-fix' },
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'h',
              value: Math.round(this.props.hsl.h),
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 's',
              value: Math.round(this.props.hsl.s * 100) + '%',
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'l',
              value: Math.round(this.props.hsl.l * 100) + '%',
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.alpha },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'a',
              value: this.props.hsl.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      }

      return _react2.default.createElement(
        'div',
        { style: styles.wrap, className: 'flexbox-fix' },
        fields,
        _react2.default.createElement(
          'div',
          { style: styles.toggle },
          _react2.default.createElement(
            'div',
            { style: styles.icon, onClick: this.toggleViews, ref: function ref(icon) {
                return _this2.icon = icon;
              } },
            _react2.default.createElement(
              'svg',
              {
                style: styles.svg,
                viewBox: '0 0 24 24',
                onMouseOver: this.showHighlight,
                onMouseEnter: this.showHighlight,
                onMouseOut: this.hideHighlight
              },
              _react2.default.createElement('path', {
                ref: function ref(iconUp) {
                  return _this2.iconUp = iconUp;
                },
                fill: '#333',
                d: 'M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z'
              }),
              _react2.default.createElement('path', {
                ref: function ref(iconDown) {
                  return _this2.iconDown = iconDown;
                },
                fill: '#333',
                d: 'M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15Z'
              })
            )
          )
        )
      );
    }
  }]);

  return ChromeFields;
}(_react2.default.Component);

exports.default = ChromeFields;

/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChromePointer = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ChromePointer = exports.ChromePointer = function ChromePointer() {
  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '12px',
        height: '12px',
        borderRadius: '6px',
        transform: 'translate(-6px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    }
  });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = ChromePointer;

/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChromePointerCircle = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ChromePointerCircle = exports.ChromePointerCircle = function ChromePointerCircle() {
  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '12px',
        height: '12px',
        borderRadius: '6px',
        boxShadow: 'inset 0 0 0 1px #fff',
        transform: 'translate(-6px, -6px)'
      }
    }
  });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = ChromePointerCircle;

/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Compact = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(27);

var _map2 = _interopRequireDefault(_map);

var _color = __webpack_require__(19);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(5);

var _CompactColor = __webpack_require__(597);

var _CompactColor2 = _interopRequireDefault(_CompactColor);

var _CompactFields = __webpack_require__(598);

var _CompactFields2 = _interopRequireDefault(_CompactFields);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Compact = exports.Compact = function Compact(_ref) {
  var onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      colors = _ref.colors,
      hex = _ref.hex,
      rgb = _ref.rgb,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)({
    'default': {
      Compact: {
        background: '#f6f6f6',
        radius: '4px'
      },
      compact: {
        paddingTop: '5px',
        paddingLeft: '5px',
        boxSizing: 'initial',
        width: '240px'
      },
      clear: {
        clear: 'both'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    if (data.hex) {
      _color2.default.isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    } else {
      onChange(data, e);
    }
  };

  return _react2.default.createElement(
    _common.Raised,
    { style: styles.Compact },
    _react2.default.createElement(
      'div',
      { style: styles.compact, className: 'compact-picker ' + className },
      _react2.default.createElement(
        'div',
        null,
        (0, _map2.default)(colors, function (c) {
          return _react2.default.createElement(_CompactColor2.default, {
            key: c,
            color: c,
            active: c.toLowerCase() === hex,
            onClick: handleChange,
            onSwatchHover: onSwatchHover
          });
        }),
        _react2.default.createElement('div', { style: styles.clear })
      ),
      _react2.default.createElement(_CompactFields2.default, { hex: hex, rgb: rgb, onChange: handleChange })
    )
  );
};

Compact.propTypes = {
  colors: _propTypes2.default.arrayOf(_propTypes2.default.string)
};

Compact.defaultProps = {
  colors: ['#4D4D4D', '#999999', '#FFFFFF', '#F44E3B', '#FE9200', '#FCDC00', '#DBDF00', '#A4DD00', '#68CCCA', '#73D8FF', '#AEA1FF', '#FDA1FF', '#333333', '#808080', '#cccccc', '#D33115', '#E27300', '#FCC400', '#B0BC00', '#68BC00', '#16A5A5', '#009CE0', '#7B64FF', '#FA28FF', '#000000', '#666666', '#B3B3B3', '#9F0500', '#C45100', '#FB9E00', '#808900', '#194D33', '#0C797D', '#0062B1', '#653294', '#AB149E']
};

exports.default = (0, _common.ColorWrap)(Compact);

/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompactColor = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = __webpack_require__(19);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CompactColor = exports.CompactColor = function CompactColor(_ref) {
  var color = _ref.color,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      onSwatchHover = _ref.onSwatchHover,
      active = _ref.active;

  var styles = (0, _reactcss2.default)({
    'default': {
      color: {
        background: color,
        width: '15px',
        height: '15px',
        float: 'left',
        marginRight: '5px',
        marginBottom: '5px',
        position: 'relative',
        cursor: 'pointer'
      },
      dot: {
        absolute: '5px 5px 5px 5px',
        background: _color2.default.getContrastingColor(color),
        borderRadius: '50%',
        opacity: '0'
      }
    },
    'active': {
      dot: {
        opacity: '1'
      }
    },
    'color-#FFFFFF': {
      color: {
        boxShadow: 'inset 0 0 0 1px #ddd'
      },
      dot: {
        background: '#000'
      }
    },
    'transparent': {
      dot: {
        background: '#000'
      }
    }
  }, { active: active, 'color-#FFFFFF': color === '#FFFFFF', 'transparent': color === 'transparent' });

  return _react2.default.createElement(
    _common.Swatch,
    {
      style: styles.color,
      color: color,
      onClick: onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: '0 0 4px ' + color }
    },
    _react2.default.createElement('div', { style: styles.dot })
  );
};

exports.default = CompactColor;

/***/ }),
/* 598 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompactFields = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CompactFields = exports.CompactFields = function CompactFields(_ref) {
  var hex = _ref.hex,
      rgb = _ref.rgb,
      onChange = _ref.onChange;

  var styles = (0, _reactcss2.default)({
    'default': {
      fields: {
        display: 'flex',
        paddingBottom: '6px',
        paddingRight: '5px',
        position: 'relative'
      },
      active: {
        position: 'absolute',
        top: '6px',
        left: '5px',
        height: '9px',
        width: '9px',
        background: hex
      },
      HEXwrap: {
        flex: '6',
        position: 'relative'
      },
      HEXinput: {
        width: '80%',
        padding: '0px',
        paddingLeft: '20%',
        border: 'none',
        outline: 'none',
        background: 'none',
        fontSize: '12px',
        color: '#333',
        height: '16px'
      },
      HEXlabel: {
        display: 'none'
      },
      RGBwrap: {
        flex: '3',
        position: 'relative'
      },
      RGBinput: {
        width: '70%',
        padding: '0px',
        paddingLeft: '30%',
        border: 'none',
        outline: 'none',
        background: 'none',
        fontSize: '12px',
        color: '#333',
        height: '16px'
      },
      RGBlabel: {
        position: 'absolute',
        top: '3px',
        left: '0px',
        lineHeight: '16px',
        textTransform: 'uppercase',
        fontSize: '12px',
        color: '#999'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: 'rgb'
      }, e);
    } else {
      onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    }
  };

  return _react2.default.createElement(
    'div',
    { style: styles.fields, className: 'flexbox-fix' },
    _react2.default.createElement('div', { style: styles.active }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
      label: 'hex',
      value: hex,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'r',
      value: rgb.r,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'g',
      value: rgb.g,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'b',
      value: rgb.b,
      onChange: handleChange
    })
  );
};

exports.default = CompactFields;

/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Github = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(27);

var _map2 = _interopRequireDefault(_map);

var _common = __webpack_require__(5);

var _GithubSwatch = __webpack_require__(600);

var _GithubSwatch2 = _interopRequireDefault(_GithubSwatch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Github = exports.Github = function Github(_ref) {
  var width = _ref.width,
      colors = _ref.colors,
      onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      triangle = _ref.triangle,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)({
    'default': {
      card: {
        width: width,
        background: '#fff',
        border: '1px solid rgba(0,0,0,0.2)',
        boxShadow: '0 3px 12px rgba(0,0,0,0.15)',
        borderRadius: '4px',
        position: 'relative',
        padding: '5px',
        display: 'flex',
        flexWrap: 'wrap'
      },
      triangle: {
        position: 'absolute',
        border: '7px solid transparent',
        borderBottomColor: '#fff'
      },
      triangleShadow: {
        position: 'absolute',
        border: '8px solid transparent',
        borderBottomColor: 'rgba(0,0,0,0.15)'
      }
    },
    'hide-triangle': {
      triangle: {
        display: 'none'
      },
      triangleShadow: {
        display: 'none'
      }
    },
    'top-left-triangle': {
      triangle: {
        top: '-14px',
        left: '10px'
      },
      triangleShadow: {
        top: '-16px',
        left: '9px'
      }
    },
    'top-right-triangle': {
      triangle: {
        top: '-14px',
        right: '10px'
      },
      triangleShadow: {
        top: '-16px',
        right: '9px'
      }
    },
    'bottom-left-triangle': {
      triangle: {
        top: '35px',
        left: '10px',
        transform: 'rotate(180deg)'
      },
      triangleShadow: {
        top: '37px',
        left: '9px',
        transform: 'rotate(180deg)'
      }
    },
    'bottom-right-triangle': {
      triangle: {
        top: '35px',
        right: '10px',
        transform: 'rotate(180deg)'
      },
      triangleShadow: {
        top: '37px',
        right: '9px',
        transform: 'rotate(180deg)'
      }
    }
  }, {
    'hide-triangle': triangle === 'hide',
    'top-left-triangle': triangle === 'top-left',
    'top-right-triangle': triangle === 'top-right',
    'bottom-left-triangle': triangle == 'bottom-left',
    'bottom-right-triangle': triangle === 'bottom-right'
  });

  var handleChange = function handleChange(hex, e) {
    return onChange({ hex: hex, source: 'hex' }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.card, className: 'github-picker ' + className },
    _react2.default.createElement('div', { style: styles.triangleShadow }),
    _react2.default.createElement('div', { style: styles.triangle }),
    (0, _map2.default)(colors, function (c) {
      return _react2.default.createElement(_GithubSwatch2.default, {
        color: c,
        key: c,
        onClick: handleChange,
        onSwatchHover: onSwatchHover
      });
    })
  );
};

Github.propTypes = {
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  colors: _propTypes2.default.arrayOf(_propTypes2.default.string),
  triangle: _propTypes2.default.oneOf(['hide', 'top-left', 'top-right', 'bottom-left', 'bottom-right'])
};

Github.defaultProps = {
  width: 200,
  colors: ['#B80000', '#DB3E00', '#FCCB00', '#008B02', '#006B76', '#1273DE', '#004DCF', '#5300EB', '#EB9694', '#FAD0C3', '#FEF3BD', '#C1E1C5', '#BEDADC', '#C4DEF6', '#BED3F3', '#D4C4FB'],
  triangle: 'top-left'
};

exports.default = (0, _common.ColorWrap)(Github);

/***/ }),
/* 600 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GithubSwatch = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GithubSwatch = exports.GithubSwatch = function GithubSwatch(_ref) {
  var hover = _ref.hover,
      color = _ref.color,
      onClick = _ref.onClick,
      onSwatchHover = _ref.onSwatchHover;

  var hoverSwatch = {
    position: 'relative',
    zIndex: '2',
    outline: '2px solid #fff',
    boxShadow: '0 0 5px 2px rgba(0,0,0,0.25)'
  };

  var styles = (0, _reactcss2.default)({
    'default': {
      swatch: {
        width: '25px',
        height: '25px',
        fontSize: '0'
      }
    },
    'hover': {
      swatch: hoverSwatch
    }
  }, { hover: hover });

  return _react2.default.createElement(
    'div',
    { style: styles.swatch },
    _react2.default.createElement(_common.Swatch, {
      color: color,
      onClick: onClick,
      onHover: onSwatchHover,
      focusStyle: hoverSwatch
    })
  );
};

exports.default = (0, _reactcss.handleHover)(GithubSwatch);

/***/ }),
/* 601 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HuePicker = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(5);

var _HuePointer = __webpack_require__(602);

var _HuePointer2 = _interopRequireDefault(_HuePointer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HuePicker = exports.HuePicker = function HuePicker(_ref) {
  var width = _ref.width,
      height = _ref.height,
      onChange = _ref.onChange,
      hsl = _ref.hsl,
      direction = _ref.direction,
      pointer = _ref.pointer,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        position: 'relative',
        width: width,
        height: height
      },
      hue: {
        radius: '2px'
      }
    }
  });

  // Overwrite to provide pure hue color
  var handleChange = function handleChange(data) {
    return onChange({ a: 1, h: data.h, l: 0.5, s: 1 });
  };

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'hue-picker ' + className },
    _react2.default.createElement(_common.Hue, _extends({}, styles.hue, {
      hsl: hsl,
      pointer: pointer,
      onChange: handleChange,
      direction: direction
    }))
  );
};

HuePicker.defaultProps = {
  width: '316px',
  height: '16px',
  direction: 'horizontal',
  pointer: _HuePointer2.default
};

exports.default = (0, _common.ColorWrap)(HuePicker);

/***/ }),
/* 602 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderPointer = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SliderPointer = exports.SliderPointer = function SliderPointer(_ref) {
  var direction = _ref.direction;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '18px',
        height: '18px',
        borderRadius: '50%',
        transform: 'translate(-9px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    },
    'vertical': {
      picker: {
        transform: 'translate(-3px, -9px)'
      }
    }
  }, { vertical: direction === 'vertical' });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = SliderPointer;

/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Material = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = __webpack_require__(19);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Material = exports.Material = function Material(_ref) {
  var onChange = _ref.onChange,
      hex = _ref.hex,
      rgb = _ref.rgb,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)({
    'default': {
      material: {
        width: '98px',
        height: '98px',
        padding: '16px',
        fontFamily: 'Roboto'
      },
      HEXwrap: {
        position: 'relative'
      },
      HEXinput: {
        width: '100%',
        marginTop: '12px',
        fontSize: '15px',
        color: '#333',
        padding: '0px',
        border: '0px',
        borderBottom: '2px solid ' + hex,
        outline: 'none',
        height: '30px'
      },
      HEXlabel: {
        position: 'absolute',
        top: '0px',
        left: '0px',
        fontSize: '11px',
        color: '#999999',
        textTransform: 'capitalize'
      },
      Hex: {
        style: {}
      },
      RGBwrap: {
        position: 'relative'
      },
      RGBinput: {
        width: '100%',
        marginTop: '12px',
        fontSize: '15px',
        color: '#333',
        padding: '0px',
        border: '0px',
        borderBottom: '1px solid #eee',
        outline: 'none',
        height: '30px'
      },
      RGBlabel: {
        position: 'absolute',
        top: '0px',
        left: '0px',
        fontSize: '11px',
        color: '#999999',
        textTransform: 'capitalize'
      },
      split: {
        display: 'flex',
        marginRight: '-10px',
        paddingTop: '11px'
      },
      third: {
        flex: '1',
        paddingRight: '10px'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    if (data.hex) {
      _color2.default.isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: 'rgb'
      }, e);
    }
  };

  return _react2.default.createElement(
    _common.Raised,
    null,
    _react2.default.createElement(
      'div',
      { style: styles.material, className: 'material-picker ' + className },
      _react2.default.createElement(_common.EditableInput, {
        style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
        label: 'hex',
        value: hex,
        onChange: handleChange
      }),
      _react2.default.createElement(
        'div',
        { style: styles.split, className: 'flexbox-fix' },
        _react2.default.createElement(
          'div',
          { style: styles.third },
          _react2.default.createElement(_common.EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: 'r', value: rgb.r,
            onChange: handleChange
          })
        ),
        _react2.default.createElement(
          'div',
          { style: styles.third },
          _react2.default.createElement(_common.EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: 'g',
            value: rgb.g,
            onChange: handleChange
          })
        ),
        _react2.default.createElement(
          'div',
          { style: styles.third },
          _react2.default.createElement(_common.EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: 'b',
            value: rgb.b,
            onChange: handleChange
          })
        )
      )
    )
  );
};

exports.default = (0, _common.ColorWrap)(Material);

/***/ }),
/* 604 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Photoshop = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(5);

var _PhotoshopFields = __webpack_require__(605);

var _PhotoshopFields2 = _interopRequireDefault(_PhotoshopFields);

var _PhotoshopPointerCircle = __webpack_require__(606);

var _PhotoshopPointerCircle2 = _interopRequireDefault(_PhotoshopPointerCircle);

var _PhotoshopPointer = __webpack_require__(607);

var _PhotoshopPointer2 = _interopRequireDefault(_PhotoshopPointer);

var _PhotoshopButton = __webpack_require__(608);

var _PhotoshopButton2 = _interopRequireDefault(_PhotoshopButton);

var _PhotoshopPreviews = __webpack_require__(609);

var _PhotoshopPreviews2 = _interopRequireDefault(_PhotoshopPreviews);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Photoshop = exports.Photoshop = function (_React$Component) {
  _inherits(Photoshop, _React$Component);

  function Photoshop(props) {
    _classCallCheck(this, Photoshop);

    var _this = _possibleConstructorReturn(this, (Photoshop.__proto__ || Object.getPrototypeOf(Photoshop)).call(this));

    _this.state = {
      currentColor: props.hex
    };
    return _this;
  }

  _createClass(Photoshop, [{
    key: 'render',
    value: function render() {
      var _props$className = this.props.className,
          className = _props$className === undefined ? '' : _props$className;

      var styles = (0, _reactcss2.default)({
        'default': {
          picker: {
            background: '#DCDCDC',
            borderRadius: '4px',
            boxShadow: '0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)',
            boxSizing: 'initial',
            width: '513px'
          },
          head: {
            backgroundImage: 'linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)',
            borderBottom: '1px solid #B1B1B1',
            boxShadow: 'inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)',
            height: '23px',
            lineHeight: '24px',
            borderRadius: '4px 4px 0 0',
            fontSize: '13px',
            color: '#4D4D4D',
            textAlign: 'center'
          },
          body: {
            padding: '15px 15px 0',
            display: 'flex'
          },
          saturation: {
            width: '256px',
            height: '256px',
            position: 'relative',
            border: '2px solid #B3B3B3',
            borderBottom: '2px solid #F0F0F0',
            overflow: 'hidden'
          },
          hue: {
            position: 'relative',
            height: '256px',
            width: '19px',
            marginLeft: '10px',
            border: '2px solid #B3B3B3',
            borderBottom: '2px solid #F0F0F0'
          },
          controls: {
            width: '180px',
            marginLeft: '10px'
          },
          top: {
            display: 'flex'
          },
          previews: {
            width: '60px'
          },
          actions: {
            flex: '1',
            marginLeft: '20px'
          }
        }
      });

      return _react2.default.createElement(
        'div',
        { style: styles.picker, className: 'photoshop-picker ' + className },
        _react2.default.createElement(
          'div',
          { style: styles.head },
          this.props.header
        ),
        _react2.default.createElement(
          'div',
          { style: styles.body, className: 'flexbox-fix' },
          _react2.default.createElement(
            'div',
            { style: styles.saturation },
            _react2.default.createElement(_common.Saturation, {
              hsl: this.props.hsl,
              hsv: this.props.hsv,
              pointer: _PhotoshopPointerCircle2.default,
              onChange: this.props.onChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.hue },
            _react2.default.createElement(_common.Hue, {
              direction: 'vertical',
              hsl: this.props.hsl,
              pointer: _PhotoshopPointer2.default,
              onChange: this.props.onChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.controls },
            _react2.default.createElement(
              'div',
              { style: styles.top, className: 'flexbox-fix' },
              _react2.default.createElement(
                'div',
                { style: styles.previews },
                _react2.default.createElement(_PhotoshopPreviews2.default, {
                  rgb: this.props.rgb,
                  currentColor: this.state.currentColor
                })
              ),
              _react2.default.createElement(
                'div',
                { style: styles.actions },
                _react2.default.createElement(_PhotoshopButton2.default, { label: 'OK', onClick: this.props.onAccept, active: true }),
                _react2.default.createElement(_PhotoshopButton2.default, { label: 'Cancel', onClick: this.props.onCancel }),
                _react2.default.createElement(_PhotoshopFields2.default, {
                  onChange: this.props.onChange,
                  rgb: this.props.rgb,
                  hsv: this.props.hsv,
                  hex: this.props.hex
                })
              )
            )
          )
        )
      );
    }
  }]);

  return Photoshop;
}(_react2.default.Component);

Photoshop.propTypes = {
  header: _propTypes2.default.string
};

Photoshop.defaultProps = {
  header: 'Color Picker'
};

exports.default = (0, _common.ColorWrap)(Photoshop);

/***/ }),
/* 605 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopPicker = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = __webpack_require__(19);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopPicker = exports.PhotoshopPicker = function PhotoshopPicker(_ref) {
  var onChange = _ref.onChange,
      rgb = _ref.rgb,
      hsv = _ref.hsv,
      hex = _ref.hex;

  var styles = (0, _reactcss2.default)({
    'default': {
      fields: {
        paddingTop: '5px',
        paddingBottom: '9px',
        width: '80px',
        position: 'relative'
      },
      divider: {
        height: '5px'
      },
      RGBwrap: {
        position: 'relative'
      },
      RGBinput: {
        marginLeft: '40%',
        width: '40%',
        height: '18px',
        border: '1px solid #888888',
        boxShadow: 'inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC',
        marginBottom: '5px',
        fontSize: '13px',
        paddingLeft: '3px',
        marginRight: '10px'
      },
      RGBlabel: {
        left: '0px',
        width: '34px',
        textTransform: 'uppercase',
        fontSize: '13px',
        height: '18px',
        lineHeight: '22px',
        position: 'absolute'
      },
      HEXwrap: {
        position: 'relative'
      },
      HEXinput: {
        marginLeft: '20%',
        width: '80%',
        height: '18px',
        border: '1px solid #888888',
        boxShadow: 'inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC',
        marginBottom: '6px',
        fontSize: '13px',
        paddingLeft: '3px'
      },
      HEXlabel: {
        position: 'absolute',
        top: '0px',
        left: '0px',
        width: '14px',
        textTransform: 'uppercase',
        fontSize: '13px',
        height: '18px',
        lineHeight: '22px'
      },
      fieldSymbols: {
        position: 'absolute',
        top: '5px',
        right: '-7px',
        fontSize: '13px'
      },
      symbol: {
        height: '20px',
        lineHeight: '22px',
        paddingBottom: '7px'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    if (data['#']) {
      _color2.default.isValidHex(data['#']) && onChange({
        hex: data['#'],
        source: 'hex'
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: 'rgb'
      }, e);
    } else if (data.h || data.s || data.v) {
      onChange({
        h: data.h || hsv.h,
        s: data.s || hsv.s,
        v: data.v || hsv.v,
        source: 'hsv'
      }, e);
    }
  };

  return _react2.default.createElement(
    'div',
    { style: styles.fields },
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'h',
      value: Math.round(hsv.h),
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 's',
      value: Math.round(hsv.s * 100),
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'v',
      value: Math.round(hsv.v * 100),
      onChange: handleChange
    }),
    _react2.default.createElement('div', { style: styles.divider }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'r',
      value: rgb.r,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'g',
      value: rgb.g,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'b',
      value: rgb.b,
      onChange: handleChange
    }),
    _react2.default.createElement('div', { style: styles.divider }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
      label: '#',
      value: hex.replace('#', ''),
      onChange: handleChange
    }),
    _react2.default.createElement(
      'div',
      { style: styles.fieldSymbols },
      _react2.default.createElement(
        'div',
        { style: styles.symbol },
        '\xB0'
      ),
      _react2.default.createElement(
        'div',
        { style: styles.symbol },
        '%'
      ),
      _react2.default.createElement(
        'div',
        { style: styles.symbol },
        '%'
      )
    )
  );
};

exports.default = PhotoshopPicker;

/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopPointerCircle = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopPointerCircle = exports.PhotoshopPointerCircle = function PhotoshopPointerCircle(_ref) {
  var hsl = _ref.hsl;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '12px',
        height: '12px',
        borderRadius: '6px',
        boxShadow: 'inset 0 0 0 1px #fff',
        transform: 'translate(-6px, -6px)'
      }
    },
    'black-outline': {
      picker: {
        boxShadow: 'inset 0 0 0 1px #000'
      }
    }
  }, { 'black-outline': hsl.l > 0.5 });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = PhotoshopPointerCircle;

/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopPointerCircle = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopPointerCircle = exports.PhotoshopPointerCircle = function PhotoshopPointerCircle() {
  var styles = (0, _reactcss2.default)({
    'default': {
      triangle: {
        width: 0,
        height: 0,
        borderStyle: 'solid',
        borderWidth: '4px 0 4px 6px',
        borderColor: 'transparent transparent transparent #fff',
        position: 'absolute',
        top: '1px',
        left: '1px'
      },
      triangleBorder: {
        width: 0,
        height: 0,
        borderStyle: 'solid',
        borderWidth: '5px 0 5px 8px',
        borderColor: 'transparent transparent transparent #555'
      },

      left: {
        Extend: 'triangleBorder',
        transform: 'translate(-13px, -4px)'
      },
      leftInside: {
        Extend: 'triangle',
        transform: 'translate(-8px, -5px)'
      },

      right: {
        Extend: 'triangleBorder',
        transform: 'translate(20px, -14px) rotate(180deg)'
      },
      rightInside: {
        Extend: 'triangle',
        transform: 'translate(-8px, -5px)'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.pointer },
    _react2.default.createElement(
      'div',
      { style: styles.left },
      _react2.default.createElement('div', { style: styles.leftInside })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.right },
      _react2.default.createElement('div', { style: styles.rightInside })
    )
  );
};

exports.default = PhotoshopPointerCircle;

/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopBotton = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopBotton = exports.PhotoshopBotton = function PhotoshopBotton(_ref) {
  var onClick = _ref.onClick,
      label = _ref.label,
      children = _ref.children,
      active = _ref.active;

  var styles = (0, _reactcss2.default)({
    'default': {
      button: {
        backgroundImage: 'linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)',
        border: '1px solid #878787',
        borderRadius: '2px',
        height: '20px',
        boxShadow: '0 1px 0 0 #EAEAEA',
        fontSize: '14px',
        color: '#000',
        lineHeight: '20px',
        textAlign: 'center',
        marginBottom: '10px',
        cursor: 'pointer'
      }
    },
    'active': {
      button: {
        boxShadow: '0 0 0 1px #878787'
      }
    }
  }, { active: active });

  return _react2.default.createElement(
    'div',
    { style: styles.button, onClick: onClick },
    label || children
  );
};

exports.default = PhotoshopBotton;

/***/ }),
/* 609 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopPreviews = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopPreviews = exports.PhotoshopPreviews = function PhotoshopPreviews(_ref) {
  var rgb = _ref.rgb,
      currentColor = _ref.currentColor;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatches: {
        border: '1px solid #B3B3B3',
        borderBottom: '1px solid #F0F0F0',
        marginBottom: '2px',
        marginTop: '1px'
      },
      new: {
        height: '34px',
        background: 'rgb(' + rgb.r + ',' + rgb.g + ', ' + rgb.b + ')',
        boxShadow: 'inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000'
      },
      current: {
        height: '34px',
        background: currentColor,
        boxShadow: 'inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000'
      },
      label: {
        fontSize: '14px',
        color: '#000',
        textAlign: 'center'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    null,
    _react2.default.createElement(
      'div',
      { style: styles.label },
      'new'
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatches },
      _react2.default.createElement('div', { style: styles.new }),
      _react2.default.createElement('div', { style: styles.current })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.label },
      'current'
    )
  );
};

exports.default = PhotoshopPreviews;

/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sketch = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(5);

var _SketchFields = __webpack_require__(611);

var _SketchFields2 = _interopRequireDefault(_SketchFields);

var _SketchPresetColors = __webpack_require__(612);

var _SketchPresetColors2 = _interopRequireDefault(_SketchPresetColors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Sketch = exports.Sketch = function Sketch(_ref) {
  var width = _ref.width,
      rgb = _ref.rgb,
      hex = _ref.hex,
      hsv = _ref.hsv,
      hsl = _ref.hsl,
      onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      disableAlpha = _ref.disableAlpha,
      presetColors = _ref.presetColors,
      renderers = _ref.renderers,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: width,
        padding: '10px 10px 0',
        boxSizing: 'initial',
        background: '#fff',
        borderRadius: '4px',
        boxShadow: '0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)'
      },
      saturation: {
        width: '100%',
        paddingBottom: '75%',
        position: 'relative',
        overflow: 'hidden'
      },
      Saturation: {
        radius: '3px',
        shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      },
      controls: {
        display: 'flex'
      },
      sliders: {
        padding: '4px 0',
        flex: '1'
      },
      color: {
        width: '24px',
        height: '24px',
        position: 'relative',
        marginTop: '4px',
        marginLeft: '4px',
        borderRadius: '3px'
      },
      activeColor: {
        absolute: '0px 0px 0px 0px',
        borderRadius: '2px',
        background: 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + rgb.a + ')',
        boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      },
      hue: {
        position: 'relative',
        height: '10px',
        overflow: 'hidden'
      },
      Hue: {
        radius: '2px',
        shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      },

      alpha: {
        position: 'relative',
        height: '10px',
        marginTop: '4px',
        overflow: 'hidden'
      },
      Alpha: {
        radius: '2px',
        shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      }
    },
    'disableAlpha': {
      color: {
        height: '10px'
      },
      hue: {
        height: '10px'
      },
      alpha: {
        display: 'none'
      }
    }
  }, { disableAlpha: disableAlpha });

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'sketch-picker ' + className },
    _react2.default.createElement(
      'div',
      { style: styles.saturation },
      _react2.default.createElement(_common.Saturation, {
        style: styles.Saturation,
        hsl: hsl,
        hsv: hsv,
        onChange: onChange
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.controls, className: 'flexbox-fix' },
      _react2.default.createElement(
        'div',
        { style: styles.sliders },
        _react2.default.createElement(
          'div',
          { style: styles.hue },
          _react2.default.createElement(_common.Hue, {
            style: styles.Hue,
            hsl: hsl,
            onChange: onChange
          })
        ),
        _react2.default.createElement(
          'div',
          { style: styles.alpha },
          _react2.default.createElement(_common.Alpha, {
            style: styles.Alpha,
            rgb: rgb,
            hsl: hsl,
            renderers: renderers,
            onChange: onChange
          })
        )
      ),
      _react2.default.createElement(
        'div',
        { style: styles.color },
        _react2.default.createElement(_common.Checkboard, null),
        _react2.default.createElement('div', { style: styles.activeColor })
      )
    ),
    _react2.default.createElement(_SketchFields2.default, {
      rgb: rgb,
      hsl: hsl,
      hex: hex,
      onChange: onChange,
      disableAlpha: disableAlpha
    }),
    _react2.default.createElement(_SketchPresetColors2.default, {
      colors: presetColors,
      onClick: onChange,
      onSwatchHover: onSwatchHover
    })
  );
};

Sketch.propTypes = {
  disableAlpha: _propTypes2.default.bool,
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number])
};

Sketch.defaultProps = {
  disableAlpha: false,
  width: 200,
  presetColors: ['#D0021B', '#F5A623', '#F8E71C', '#8B572A', '#7ED321', '#417505', '#BD10E0', '#9013FE', '#4A90E2', '#50E3C2', '#B8E986', '#000000', '#4A4A4A', '#9B9B9B', '#FFFFFF']
};

exports.default = (0, _common.ColorWrap)(Sketch);

/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SketchFields = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = __webpack_require__(19);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-param-reassign */

var SketchFields = exports.SketchFields = function SketchFields(_ref) {
  var onChange = _ref.onChange,
      rgb = _ref.rgb,
      hsl = _ref.hsl,
      hex = _ref.hex,
      disableAlpha = _ref.disableAlpha;

  var styles = (0, _reactcss2.default)({
    'default': {
      fields: {
        display: 'flex',
        paddingTop: '4px'
      },
      single: {
        flex: '1',
        paddingLeft: '6px'
      },
      alpha: {
        flex: '1',
        paddingLeft: '6px'
      },
      double: {
        flex: '2'
      },
      input: {
        width: '80%',
        padding: '4px 10% 3px',
        border: 'none',
        boxShadow: 'inset 0 0 0 1px #ccc',
        fontSize: '11px'
      },
      label: {
        display: 'block',
        textAlign: 'center',
        fontSize: '11px',
        color: '#222',
        paddingTop: '3px',
        paddingBottom: '4px',
        textTransform: 'capitalize'
      }
    },
    'disableAlpha': {
      alpha: {
        display: 'none'
      }
    }
  }, { disableAlpha: disableAlpha });

  var handleChange = function handleChange(data, e) {
    if (data.hex) {
      _color2.default.isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        a: rgb.a,
        source: 'rgb'
      }, e);
    } else if (data.a) {
      if (data.a < 0) {
        data.a = 0;
      } else if (data.a > 100) {
        data.a = 100;
      }

      data.a /= 100;
      onChange({
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: data.a,
        source: 'rgb'
      }, e);
    }
  };

  return _react2.default.createElement(
    'div',
    { style: styles.fields, className: 'flexbox-fix' },
    _react2.default.createElement(
      'div',
      { style: styles.double },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'hex',
        value: hex.replace('#', ''),
        onChange: handleChange
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.single },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'r',
        value: rgb.r,
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '255'
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.single },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'g',
        value: rgb.g,
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '255'
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.single },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'b',
        value: rgb.b,
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '255'
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.alpha },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'a',
        value: Math.round(rgb.a * 100),
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '100'
      })
    )
  );
};

exports.default = SketchFields;

/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SketchPresetColors = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SketchPresetColors = exports.SketchPresetColors = function SketchPresetColors(_ref) {
  var colors = _ref.colors,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      onSwatchHover = _ref.onSwatchHover;

  var styles = (0, _reactcss2.default)({
    'default': {
      colors: {
        margin: '0 -10px',
        padding: '10px 0 0 10px',
        borderTop: '1px solid #eee',
        display: 'flex',
        flexWrap: 'wrap',
        position: 'relative'
      },
      swatchWrap: {
        width: '16px',
        height: '16px',
        margin: '0 10px 10px 0'
      },
      swatch: {
        borderRadius: '3px',
        boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15)'
      }
    },
    'no-presets': {
      colors: {
        display: 'none'
      }
    }
  }, {
    'no-presets': !colors || !colors.length
  });

  var handleClick = function handleClick(hex, e) {
    onClick({
      hex: hex,
      source: 'hex'
    }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.colors, className: 'flexbox-fix' },
    colors.map(function (colorObjOrString) {
      var c = typeof colorObjOrString === 'string' ? { color: colorObjOrString } : colorObjOrString;
      var key = '' + c.color + (c.title || '');
      return _react2.default.createElement(
        'div',
        { key: key, style: styles.swatchWrap },
        _react2.default.createElement(_common.Swatch, _extends({}, c, {
          style: styles.swatch,
          onClick: handleClick,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px ' + c.color
          }
        }))
      );
    })
  );
};

SketchPresetColors.propTypes = {
  colors: _propTypes2.default.arrayOf(_propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({
    color: _propTypes2.default.string,
    title: _propTypes2.default.string
  })])).isRequired
};

exports.default = SketchPresetColors;

/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Slider = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(5);

var _SliderSwatches = __webpack_require__(614);

var _SliderSwatches2 = _interopRequireDefault(_SliderSwatches);

var _SliderPointer = __webpack_require__(616);

var _SliderPointer2 = _interopRequireDefault(_SliderPointer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Slider = exports.Slider = function Slider(_ref) {
  var hsl = _ref.hsl,
      onChange = _ref.onChange,
      pointer = _ref.pointer,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)({
    'default': {
      hue: {
        height: '12px',
        position: 'relative'
      },
      Hue: {
        radius: '2px'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { className: 'slider-picker ' + className },
    _react2.default.createElement(
      'div',
      { style: styles.hue },
      _react2.default.createElement(_common.Hue, {
        style: styles.Hue,
        hsl: hsl,
        pointer: pointer,
        onChange: onChange
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatches },
      _react2.default.createElement(_SliderSwatches2.default, { hsl: hsl, onClick: onChange })
    )
  );
};

Slider.defaultProps = {
  pointer: _SliderPointer2.default
};

exports.default = (0, _common.ColorWrap)(Slider);

/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderSwatches = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _SliderSwatch = __webpack_require__(615);

var _SliderSwatch2 = _interopRequireDefault(_SliderSwatch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SliderSwatches = exports.SliderSwatches = function SliderSwatches(_ref) {
  var onClick = _ref.onClick,
      hsl = _ref.hsl;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatches: {
        marginTop: '20px'
      },
      swatch: {
        boxSizing: 'border-box',
        width: '20%',
        paddingRight: '1px',
        float: 'left'
      },
      clear: {
        clear: 'both'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.swatches },
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.80',
        active: Math.round(hsl.l * 100) / 100 === 0.80 && Math.round(hsl.s * 100) / 100 === 0.50,
        onClick: onClick,
        first: true
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.65',
        active: Math.round(hsl.l * 100) / 100 === 0.65 && Math.round(hsl.s * 100) / 100 === 0.50,
        onClick: onClick
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.50',
        active: Math.round(hsl.l * 100) / 100 === 0.50 && Math.round(hsl.s * 100) / 100 === 0.50,
        onClick: onClick
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.35',
        active: Math.round(hsl.l * 100) / 100 === 0.35 && Math.round(hsl.s * 100) / 100 === 0.50,
        onClick: onClick
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.20',
        active: Math.round(hsl.l * 100) / 100 === 0.20 && Math.round(hsl.s * 100) / 100 === 0.50,
        onClick: onClick,
        last: true
      })
    ),
    _react2.default.createElement('div', { style: styles.clear })
  );
};

exports.default = SliderSwatches;

/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderSwatch = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SliderSwatch = exports.SliderSwatch = function SliderSwatch(_ref) {
  var hsl = _ref.hsl,
      offset = _ref.offset,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      active = _ref.active,
      first = _ref.first,
      last = _ref.last;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatch: {
        height: '12px',
        background: 'hsl(' + hsl.h + ', 50%, ' + offset * 100 + '%)',
        cursor: 'pointer'
      }
    },
    'first': {
      swatch: {
        borderRadius: '2px 0 0 2px'
      }
    },
    'last': {
      swatch: {
        borderRadius: '0 2px 2px 0'
      }
    },
    'active': {
      swatch: {
        transform: 'scaleY(1.8)',
        borderRadius: '3.6px/2px'
      }
    }
  }, { active: active, first: first, last: last });

  var handleClick = function handleClick(e) {
    return onClick({
      h: hsl.h,
      s: 0.5,
      l: offset,
      source: 'hsl'
    }, e);
  };

  return _react2.default.createElement('div', { style: styles.swatch, onClick: handleClick });
};

exports.default = SliderSwatch;

/***/ }),
/* 616 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderPointer = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SliderPointer = exports.SliderPointer = function SliderPointer() {
  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '14px',
        height: '14px',
        borderRadius: '6px',
        transform: 'translate(-7px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    }
  });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = SliderPointer;

/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Swatches = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(27);

var _map2 = _interopRequireDefault(_map);

var _color = __webpack_require__(19);

var _color2 = _interopRequireDefault(_color);

var _materialColors = __webpack_require__(235);

var material = _interopRequireWildcard(_materialColors);

var _common = __webpack_require__(5);

var _SwatchesGroup = __webpack_require__(618);

var _SwatchesGroup2 = _interopRequireDefault(_SwatchesGroup);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Swatches = exports.Swatches = function Swatches(_ref) {
  var width = _ref.width,
      height = _ref.height,
      onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      colors = _ref.colors,
      hex = _ref.hex,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: width,
        height: height
      },
      overflow: {
        height: height,
        overflowY: 'scroll'
      },
      body: {
        padding: '16px 0 6px 16px'
      },
      clear: {
        clear: 'both'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    _color2.default.isValidHex(data) && onChange({
      hex: data,
      source: 'hex'
    }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'swatches-picker ' + className },
    _react2.default.createElement(
      _common.Raised,
      null,
      _react2.default.createElement(
        'div',
        { style: styles.overflow },
        _react2.default.createElement(
          'div',
          { style: styles.body },
          (0, _map2.default)(colors, function (group) {
            return _react2.default.createElement(_SwatchesGroup2.default, {
              key: group.toString(),
              group: group,
              active: hex,
              onClick: handleChange,
              onSwatchHover: onSwatchHover
            });
          }),
          _react2.default.createElement('div', { style: styles.clear })
        )
      )
    )
  );
};

Swatches.propTypes = {
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  height: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  colors: _propTypes2.default.arrayOf(_propTypes2.default.arrayOf(_propTypes2.default.string))

  /* eslint-disable max-len */
};Swatches.defaultProps = {
  width: 320,
  height: 240,
  colors: [[material.red['900'], material.red['700'], material.red['500'], material.red['300'], material.red['100']], [material.pink['900'], material.pink['700'], material.pink['500'], material.pink['300'], material.pink['100']], [material.purple['900'], material.purple['700'], material.purple['500'], material.purple['300'], material.purple['100']], [material.deepPurple['900'], material.deepPurple['700'], material.deepPurple['500'], material.deepPurple['300'], material.deepPurple['100']], [material.indigo['900'], material.indigo['700'], material.indigo['500'], material.indigo['300'], material.indigo['100']], [material.blue['900'], material.blue['700'], material.blue['500'], material.blue['300'], material.blue['100']], [material.lightBlue['900'], material.lightBlue['700'], material.lightBlue['500'], material.lightBlue['300'], material.lightBlue['100']], [material.cyan['900'], material.cyan['700'], material.cyan['500'], material.cyan['300'], material.cyan['100']], [material.teal['900'], material.teal['700'], material.teal['500'], material.teal['300'], material.teal['100']], ['#194D33', material.green['700'], material.green['500'], material.green['300'], material.green['100']], [material.lightGreen['900'], material.lightGreen['700'], material.lightGreen['500'], material.lightGreen['300'], material.lightGreen['100']], [material.lime['900'], material.lime['700'], material.lime['500'], material.lime['300'], material.lime['100']], [material.yellow['900'], material.yellow['700'], material.yellow['500'], material.yellow['300'], material.yellow['100']], [material.amber['900'], material.amber['700'], material.amber['500'], material.amber['300'], material.amber['100']], [material.orange['900'], material.orange['700'], material.orange['500'], material.orange['300'], material.orange['100']], [material.deepOrange['900'], material.deepOrange['700'], material.deepOrange['500'], material.deepOrange['300'], material.deepOrange['100']], [material.brown['900'], material.brown['700'], material.brown['500'], material.brown['300'], material.brown['100']], [material.blueGrey['900'], material.blueGrey['700'], material.blueGrey['500'], material.blueGrey['300'], material.blueGrey['100']], ['#000000', '#525252', '#969696', '#D9D9D9', '#FFFFFF']]
};

exports.default = (0, _common.ColorWrap)(Swatches);

/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SwatchesGroup = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(27);

var _map2 = _interopRequireDefault(_map);

var _SwatchesColor = __webpack_require__(619);

var _SwatchesColor2 = _interopRequireDefault(_SwatchesColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SwatchesGroup = exports.SwatchesGroup = function SwatchesGroup(_ref) {
  var onClick = _ref.onClick,
      onSwatchHover = _ref.onSwatchHover,
      group = _ref.group,
      active = _ref.active;

  var styles = (0, _reactcss2.default)({
    'default': {
      group: {
        paddingBottom: '10px',
        width: '40px',
        float: 'left',
        marginRight: '10px'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.group },
    (0, _map2.default)(group, function (color, i) {
      return _react2.default.createElement(_SwatchesColor2.default, {
        key: color,
        color: color,
        active: color.toLowerCase() === active,
        first: i === 0,
        last: i === group.length - 1,
        onClick: onClick,
        onSwatchHover: onSwatchHover
      });
    })
  );
};

exports.default = SwatchesGroup;

/***/ }),
/* 619 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SwatchesColor = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = __webpack_require__(19);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SwatchesColor = exports.SwatchesColor = function SwatchesColor(_ref) {
  var color = _ref.color,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      onSwatchHover = _ref.onSwatchHover,
      first = _ref.first,
      last = _ref.last,
      active = _ref.active;

  var styles = (0, _reactcss2.default)({
    'default': {
      color: {
        width: '40px',
        height: '24px',
        cursor: 'pointer',
        background: color,
        marginBottom: '1px'
      },
      check: {
        fill: _color2.default.getContrastingColor(color),
        marginLeft: '8px',
        display: 'none'
      }
    },
    'first': {
      color: {
        overflow: 'hidden',
        borderRadius: '2px 2px 0 0'
      }
    },
    'last': {
      color: {
        overflow: 'hidden',
        borderRadius: '0 0 2px 2px'
      }
    },
    'active': {
      check: {
        display: 'block'
      }
    },
    'color-#FFFFFF': {
      color: {
        boxShadow: 'inset 0 0 0 1px #ddd'
      },
      check: {
        fill: '#333'
      }
    },
    'transparent': {
      check: {
        fill: '#333'
      }
    }
  }, {
    first: first,
    last: last,
    active: active,
    'color-#FFFFFF': color === '#FFFFFF',
    'transparent': color === 'transparent'
  });

  return _react2.default.createElement(
    _common.Swatch,
    {
      color: color,
      style: styles.color,
      onClick: onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: '0 0 4px ' + color }
    },
    _react2.default.createElement(
      'div',
      { style: styles.check },
      _react2.default.createElement(
        'svg',
        { style: { width: '24px', height: '24px' }, viewBox: '0 0 24 24' },
        _react2.default.createElement('path', { d: 'M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z' })
      )
    )
  );
};

exports.default = SwatchesColor;

/***/ }),
/* 620 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Twitter = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(1);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(27);

var _map2 = _interopRequireDefault(_map);

var _color = __webpack_require__(19);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Twitter = exports.Twitter = function Twitter(_ref) {
  var onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      hex = _ref.hex,
      colors = _ref.colors,
      width = _ref.width,
      triangle = _ref.triangle,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)({
    'default': {
      card: {
        width: width,
        background: '#fff',
        border: '0 solid rgba(0,0,0,0.25)',
        boxShadow: '0 1px 4px rgba(0,0,0,0.25)',
        borderRadius: '4px',
        position: 'relative'
      },
      body: {
        padding: '15px 9px 9px 15px'
      },
      label: {
        fontSize: '18px',
        color: '#fff'
      },
      triangle: {
        width: '0px',
        height: '0px',
        borderStyle: 'solid',
        borderWidth: '0 9px 10px 9px',
        borderColor: 'transparent transparent #fff transparent',
        position: 'absolute'
      },
      triangleShadow: {
        width: '0px',
        height: '0px',
        borderStyle: 'solid',
        borderWidth: '0 9px 10px 9px',
        borderColor: 'transparent transparent rgba(0,0,0,.1) transparent',
        position: 'absolute'
      },
      hash: {
        background: '#F0F0F0',
        height: '30px',
        width: '30px',
        borderRadius: '4px 0 0 4px',
        float: 'left',
        color: '#98A1A4',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      },
      input: {
        width: '100px',
        fontSize: '14px',
        color: '#666',
        border: '0px',
        outline: 'none',
        height: '28px',
        boxShadow: 'inset 0 0 0 1px #F0F0F0',
        boxSizing: 'content-box',
        borderRadius: '0 4px 4px 0',
        float: 'left',
        paddingLeft: '8px'
      },
      swatch: {
        width: '30px',
        height: '30px',
        float: 'left',
        borderRadius: '4px',
        margin: '0 6px 6px 0'
      },
      clear: {
        clear: 'both'
      }
    },
    'hide-triangle': {
      triangle: {
        display: 'none'
      },
      triangleShadow: {
        display: 'none'
      }
    },
    'top-left-triangle': {
      triangle: {
        top: '-10px',
        left: '12px'
      },
      triangleShadow: {
        top: '-11px',
        left: '12px'
      }
    },
    'top-right-triangle': {
      triangle: {
        top: '-10px',
        right: '12px'
      },
      triangleShadow: {
        top: '-11px',
        right: '12px'
      }
    }
  }, {
    'hide-triangle': triangle === 'hide',
    'top-left-triangle': triangle === 'top-left',
    'top-right-triangle': triangle === 'top-right'
  });

  var handleChange = function handleChange(hexcode, e) {
    _color2.default.isValidHex(hexcode) && onChange({
      hex: hexcode,
      source: 'hex'
    }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.card, className: 'twitter-picker ' + className },
    _react2.default.createElement('div', { style: styles.triangleShadow }),
    _react2.default.createElement('div', { style: styles.triangle }),
    _react2.default.createElement(
      'div',
      { style: styles.body },
      (0, _map2.default)(colors, function (c, i) {
        return _react2.default.createElement(_common.Swatch, {
          key: i,
          color: c,
          hex: c,
          style: styles.swatch,
          onClick: handleChange,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: '0 0 4px ' + c
          }
        });
      }),
      _react2.default.createElement(
        'div',
        { style: styles.hash },
        '#'
      ),
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input },
        value: hex.replace('#', ''),
        onChange: handleChange
      }),
      _react2.default.createElement('div', { style: styles.clear })
    )
  );
};

Twitter.propTypes = {
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  triangle: _propTypes2.default.oneOf(['hide', 'top-left', 'top-right']),
  colors: _propTypes2.default.arrayOf(_propTypes2.default.string)
};

Twitter.defaultProps = {
  width: 276,
  colors: ['#FF6900', '#FCB900', '#7BDCB5', '#00D084', '#8ED1FC', '#0693E3', '#ABB8C3', '#EB144C', '#F78DA7', '#9900EF'],
  triangle: 'top-left'
};

exports.default = (0, _common.ColorWrap)(Twitter);

/***/ }),
/* 621 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRACKS_INFO = undefined;

var _icons = __webpack_require__(237);

var TRACKS_INFO = exports.TRACKS_INFO = [{
  type: 'left-axis',
  datatype: ['axis'],
  local: true,
  orientation: '1d-vertical',
  name: 'Left Axis',
  thumbnail: _icons.svgVertical1DAxisIcon,
  minWidth: 100
}, {
  type: 'top-axis',
  datatype: ['axis'],
  local: true,
  orientation: '1d-horizontal',
  name: 'Top Axis',
  thumbnail: _icons.svg1DAxisIcon,
  defaultOptions: {}
}, {
  type: 'heatmap',
  datatype: ['matrix'],
  local: false,
  minHeight: 100,
  minWidth: 100,
  orientation: '2d',
  thumbnail: _icons.svg2DHeatmapIcon,
  defaultOptions: {
    labelPosition: 'bottomRight',
    colorRange: ['white', 'rgba(245,166,35,1.0)', 'rgba(208,2,27,1.0)', 'black'], // corresponding to the fall colormap
    maxZoom: null,
    colorbarPosition: 'topRight',
    trackBorderWidth: 0,
    trackBorderColor: 'black',
    heatmapValueScaling: 'log'
  },
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'colorRange', 'maxZoom', 'dataTransform', 'colorbarPosition', 'trackBorderWidth', 'trackBorderColor', 'heatmapValueScaling']
  // exportable: true
}, {
  type: 'horizontal-heatmap',
  datatype: ['matrix'],
  local: false,
  minHeight: 40,
  minWidth: 100,
  orientation: '1d-horizontal',
  thumbnail: _icons.svg2DHeatmapIcon,
  defaultOptions: {
    labelPosition: 'bottomRight',
    labelColor: 'black',
    colorRange: ['white', 'rgba(245,166,35,1.0)', 'rgba(208,2,27,1.0)', 'black'], // corresponding to the fall colormap
    maxZoom: null,
    trackBorderWidth: 0,
    trackBorderColor: 'black'
  },
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'colorRange', 'maxZoom', 'dataTransform', 'oneDHeatmapFlipped', 'colorbarPosition', 'trackBorderWidth', 'trackBorderColor', 'heatmapValueScaling']
}, {
  type: 'vertical-heatmap',
  datatype: ['matrix'],
  local: false,
  minWidth: 50,
  minHeight: 100,
  orientation: '1d-vertical',
  thumbnail: _icons.svg2DHeatmapIcon,
  defaultOptions: {
    labelPosition: 'bottomRight',
    labelColor: 'black',
    colorRange: ['white', 'rgba(245,166,35,1.0)', 'rgba(208,2,27,1.0)', 'black'], // corresponding to the fall colormap
    maxZoom: null,
    colorbarPosition: 'topRight',
    trackBorderWidth: 0,
    trackBorderColor: 'black'
  },
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'colorRange', 'maxZoom', 'dataTransform', 'oneDHeatmapFlipped', 'colorbarPosition', 'trackBorderWidth', 'trackBorderColor', 'heatmapValueScaling']
}, {
  type: 'horizontal-line',
  datatype: ['vector'],
  local: false,
  orientation: '1d-horizontal',
  thumbnail: _icons.svgHorizontalLineIcon,
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'axisPositionHorizontal', 'lineStrokeWidth', 'lineStrokeColor', 'valueScaling', 'trackBorderWidth', 'trackBorderColor', 'trackType'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'topLeft',
    axisPositionHorizontal: 'right',
    lineStrokeColor: 'blue',
    lineStrokeWidth: 1,
    valueScaling: 'linear',
    trackBorderWidth: 0,
    trackBorderColor: 'black',
    labelTextOpacity: 0.4
  }
}, {
  type: 'horizontal-multivec',
  datatype: ['multivec'],
  local: false,
  orientation: '1d-horizontal',
  thumbnail: null,
  availableOptions: ['labelPosition', 'labelColor', 'valueScaling', 'labelTextOpacity', 'labelBackgroundOpacity', 'colorRange', 'trackBorderWidth', 'trackBorderColor', 'trackType'],
  defaultOptions: {
    labelPosition: 'topLeft',
    labelColor: 'black',
    labelTextOpacity: 0.4,
    valueScaling: 'linear',
    trackBorderWidth: 0,
    trackBorderColor: 'black'
  }
},
//
{
  type: 'vertical-line',
  datatype: ['vector'],
  local: false,
  orientation: '1d-vertical',
  thumbnail: _icons.svgVerticalLineIcon,
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'axisPositionVertical', 'lineStrokeWidth', 'lineStrokeColor', 'valueScaling', 'trackBorderWidth', 'trackBorderColor'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'bottomLeft',
    axisPositionVertical: 'top',
    lineStrokeWidth: 1,
    lineStrokeColor: 'blue',
    valueScaling: 'linear',
    trackBorderWidth: 0,
    trackBorderColor: 'black',
    labelTextOpacity: 0.4
  }
}, {
  type: 'horizontal-point',
  datatype: ['vector'],
  local: false,
  orientation: '1d-horizontal',
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'axisPositionHorizontal', 'pointColor', 'pointSize', 'valueScaling', 'trackBorderWidth', 'trackBorderColor'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'topLeft',
    axisPositionHorizontal: 'right',
    pointColor: 'red',
    pointSize: 3,
    valueScaling: 'linear',
    trackBorderWidth: 0,
    trackBorderColor: 'black',
    labelTextOpacity: 0.4
  }
}, {
  type: 'horizontal-divergent-bar',
  datatype: ['vector'],
  local: false,
  orientation: '1d-horizontal',
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'axisPositionHorizontal', 'barFillColorTop', 'barFillColorBottom', 'valueScaling', 'trackBorderWidth', 'trackBorderColor', 'barOpacity'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'topLeft',
    axisPositionHorizontal: 'right',
    barFillColorBottom: 'red',
    barFillColorTop: 'green',
    valueScaling: 'linear',
    trackBorderWidth: 0,
    trackBorderColor: 'black',
    labelTextOpacity: 0.4,
    barOpacity: 1
  }
}, {
  type: 'horizontal-bar',
  datatype: ['vector'],
  local: false,
  orientation: '1d-horizontal',
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'axisPositionHorizontal', 'barFillColor', 'valueScaling', 'trackBorderWidth', 'trackBorderColor', 'barOpacity'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'topLeft',
    axisPositionHorizontal: 'right',
    barFillColor: 'darkgreen',
    valueScaling: 'linear',
    trackBorderWidth: 0,
    trackBorderColor: 'black',
    labelTextOpacity: 0.4,
    barOpacity: 1
  }
}, {
  type: 'vertical-bar',
  datatype: ['vector'],
  local: false,
  orientation: '1d-vertical',
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'axisPositionHorizontal', 'barFillColor', 'valueScaling', 'trackBorderWidth', 'trackBorderColor', 'barOpacity'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'topLeft',
    axisPositionHorizontal: 'right',
    barFillColor: 'darkgreen',
    valueScaling: 'linear',
    trackBorderWidth: 0,
    trackBorderColor: 'black',
    labelTextOpacity: 0.4,
    barOpacity: 1
  }
}, {
  type: 'vertical-point',
  datatype: ['vector'],
  local: false,
  orientation: '1d-vertical',
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'axisPositionHorizontal', 'lineStrokeWidth', 'lineStrokeColor', 'valueScaling', 'trackBorderWidth', 'trackBorderColor'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'topLeft',
    axisPositionHorizontal: 'right',
    lineStrokeColor: 'red',
    lineStrokeWidth: 1,
    valueScaling: 'linear',
    trackBorderWidth: 0,
    trackBorderColor: 'black',
    labelTextOpacity: 0.4
  }
}, {
  type: '2d-tiles',
  datatype: ['matrix'],
  local: false,
  orientation: '2d',
  name: '2D Tile Outlines',
  thumbnail: _icons.svg2DTilesIcon
}, {
  type: 'horizontal-1d-value-interval',
  datatype: ['bed-value'],
  local: false,
  orientation: ['1d-horizontal'],
  name: '1D Rectangles',
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'axisPositionHorizontal'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'bottomLeft',
    axisPositionHorizontal: 'left',
    lineStrokeColor: 'blue',
    valueScaling: 'linear'
  }
}, {
  type: 'vertical-1d-value-interval',
  datatype: ['bed-value'],
  local: false,
  orientation: ['1d-vertical'],
  name: '1D Rectangles',
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'axisPositionVertical'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'bottomLeft',
    axisPositionVertical: 'top',
    lineStrokeColor: 'blue',
    valueScaling: 'linear'
  }
}, {
  type: 'top-stacked-interval',
  datatype: ['stacked-interval'],
  local: false,
  orientation: '1d-horizontal',
  thumbnail: 'horizontal-stacked-interval.png',
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity']
}, {
  type: 'left-stacked-interval',
  datatype: ['stacked-interval'],
  local: false,
  orientation: '1d-vertical',
  thumbnail: 'vertical-stacked-interval.png',
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity']
}, {
  type: 'viewport-projection-vertical',
  datatype: ['1d-projection'],
  local: true,
  hidden: true,
  orientation: '1d-vertical',
  name: 'Viewport Projection',
  thumbnail: 'viewport-projection-center.png',
  availableOptions: ['projectionFillColor', 'projectionStrokeColor', 'strokeWidth'],
  defaultOptions: {
    projectionFillColor: '#777',
    projectionStrokeColor: '#777',
    projectionFillOpacity: 0.3,
    projectionStrokeOpacity: 0.7,
    strokeWidth: 1
  }
}, {
  type: 'viewport-projection-horizontal',
  datatype: ['1d-projection'],
  local: true,
  hidden: true,
  orientation: '1d-horizontal',
  name: 'Viewport Projection',
  thumbnail: 'viewport-projection-center.png',
  availableOptions: ['projectionFillColor', 'projectionStrokeColor', 'strokeWidth'],
  defaultOptions: {
    projectionFillColor: '#777',
    projectionStrokeColor: '#777',
    projectionFillOpacity: 0.3,
    projectionStrokeOpacity: 0.7,
    strokeWidth: 1
  }
}, {
  type: 'viewport-projection-center',
  datatype: ['2d-projection'],
  local: true,
  hidden: true,
  orientation: '2d',
  name: 'Viewport Projection',
  thumbnail: 'viewport-projection-center.png',
  availableOptions: ['projectionFillColor', 'projectionStrokeColor', 'strokeWidth'],
  defaultOptions: {
    projectionFillColor: '#777',
    projectionStrokeColor: '#777',
    projectionFillOpacity: 0.3,
    projectionStrokeOpacity: 0.7,
    strokeWidth: 1
  }
}, {
  type: 'horizontal-gene-annotations',
  datatype: ['gene-annotation'],
  local: false,
  minHeight: 55,
  orientation: '1d-horizontal',
  name: 'Gene Annotations',
  thumbnail: _icons.svgGeneAnnotationsIcon,
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'plusStrandColor', 'minusStrandColor', 'trackBorderWidth', 'trackBorderColor'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'hidden',
    plusStrandColor: 'blue',
    minusStrandColor: 'red',
    trackBorderWidth: 0,
    trackBorderColor: 'black'
  }
}, {
  type: 'vertical-gene-annotations',
  datatype: ['gene-annotation'],
  local: false,
  minWidth: 55,
  orientation: '1d-vertical',
  name: 'Gene Annotations',
  thumbnail: _icons.svgVerticalGeneAnnotationsIcon,
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'plusStrandColor', 'minusStrandColor', 'trackBorderWidth', 'trackBorderColor'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'hidden',
    plusStrandColor: 'blue',
    minusStrandColor: 'red',
    trackBorderWidth: 0,
    trackBorderColor: 'black'
  }
}, {
  type: 'arrowhead-domains',
  datatype: ['arrowhead-domains'],
  local: false,
  orientation: '2d',
  name: 'Arrowhead Domains',
  thumbnail: _icons.svgArrowheadDomainsIcon,
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'trackBorderWidth', 'trackBorderColor'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'hidden',
    trackBorderWidth: 0,
    trackBorderColor: 'black'
  }
}, {
  type: 'vertical-2d-rectangle-domains',
  datatype: ['2d-rectangle-domains'],
  local: false,
  orientation: '1d-vertical',
  name: 'Vertical 2D Rectangle Domains',
  thumbnail: _icons.svgArrowheadDomainsIcon,
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'trackBorderWidth', 'trackBorderColor'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'hidden',
    trackBorderWidth: 0,
    trackBorderColor: 'black'
  }
}, {
  type: 'horizontal-2d-rectangle-domains',
  datatype: ['2d-rectangle-domains'],
  local: false,
  orientation: '1d-horizontal',
  name: 'Horizontal 2D Rectangle Domains',
  thumbnail: _icons.svgArrowheadDomainsIcon,
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'trackBorderWidth', 'trackBorderColor', 'rectangleDomainFillColor', 'rectangleDomainStrokeColor', 'rectangleDomainOpacity', 'minSquareSize'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'bottomLeft',
    trackBorderWidth: 0,
    trackBorderColor: 'black',
    rectangleDomainFillColor: 'grey',
    rectangleDomainStrokeColor: 'black',
    rectangleDomainOpacity: 0.6,
    minSquareSize: 'none'
  }
}, {
  type: '2d-rectangle-domains',
  datatype: ['2d-rectangle-domains'],
  local: false,
  orientation: '2d',
  name: '2D Rectangle Domains',
  thumbnail: _icons.svgArrowheadDomainsIcon,
  availableOptions: ['labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'trackBorderWidth', 'trackBorderColor', 'rectangleDomainFillColor', 'rectangleDomainStrokeColor', 'rectangleDomainOpacity', 'minSquareSize'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'hidden',
    trackBorderWidth: 0,
    trackBorderColor: 'black',
    rectangleDomainFillColor: 'grey',
    rectangleDomainStrokeColor: 'black',
    rectangleDomainOpacity: 0.6,
    minSquareSize: 'none'
  }
}, {
  type: 'square-markers',
  datatype: ['bedpe'],
  local: false,
  orientation: '2d',
  name: 'Square Markers',
  thumbnail: _icons.svgArrowheadDomainsIcon,
  availableOptions: ['labelPosition', 'labelColor'],
  defaultOptions: {
    labelColor: 'black',
    labelPosition: 'hidden',
    trackBorderWidth: 0,
    trackBorderColor: 'black'
  }
}, {
  type: 'combined',
  datatype: 'any',
  local: true,
  orientation: 'any'
}, {
  type: '2d-chromosome-grid',
  datatype: ['chromsizes'],
  local: false,
  orientation: '2d',
  name: 'Chromosome Grid',
  chromInfoPath: '//s3.amazonaws.com/pkerp/data/hg19/chromSizes.tsv',
  thumbnail: null,
  availableOptions: ['lineStrokeWidth', 'lineStrokeColor'],
  defaultOptions: {
    lineStrokeWidth: 1,
    lineStrokeColor: 'grey'
  }
}, {
  type: '2d-chromosome-annotations',
  local: true,
  orientation: '2d',
  name: '2D Chromosome Annotations',
  thumbnail: null,
  hidden: true
}, {
  type: '2d-chromosome-labels',
  datatype: ['chromsizes'],
  local: true,
  orientation: '2d',
  name: 'Pairwise Chromosome Labels',
  thumbnail: null
}, {
  type: 'horizontal-chromosome-labels',
  datatype: ['chromsizes'],
  orientation: '1d-horizontal',
  minHeight: 30,
  name: 'Chromosome Axis',
  thumbnail: null
}, {
  type: 'vertical-chromosome-labels',
  datatype: ['chromsizes'],
  orientation: '1d-vertical',
  minWidth: 20,
  minHeight: 30,
  name: 'Chromosome Axis',
  thumbnail: null
}, {
  type: 'vertical-1d-tiles',
  datatype: ['1d-tiles'],
  local: false,
  orientation: '1d-vertical',
  name: 'Vertical 1D Tile Outlines',
  thumbnail: _icons.svgVertical1DTilesIcon
}, {
  type: 'horizontal-1d-tiles',
  datatype: ['vector', 'stacked-interval', 'gene-annotation'],
  local: false,
  orientation: '1d-horizontal',
  name: 'Horizontal 1D Tile Outlines',
  thumbnail: _icons.svg1DTilesIcon
}, {
  type: 'osm-tiles',
  datatype: ['map-tiles'],
  local: true,
  orientation: '2d',
  hidden: true,
  name: 'OSM Tiles',
  thumbnail: null,
  defaultOptions: {
    minPos: 0,
    maxPos: 3120000000
  }
}, {
  type: 'mapbox-tiles',
  datatype: ['map-tiles'],
  local: true,
  orientation: '2d',
  hidden: true,
  name: 'Mapbox Tiles',
  thumbnail: null,
  availableOptions: ['mapboxStyle'],
  defaultOptions: {
    mapboxStyle: 'mapbox.streets'
  }
}, {
  type: 'bedlike',
  datatype: ['bedlike'],
  local: false,
  minHeight: 55,
  orientation: '1d-horizontal',
  name: 'BED-like track',
  thumbnail: null,
  availableOptions: ['fillColor', 'labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'trackBorderWidth', 'trackBorderColor', 'valueColumn'],
  defaultOptions: {
    fillColor: 'blue',
    axisPositionHorizontal: 'right',
    labelColor: 'black',
    labelPosition: 'hidden',
    trackBorderWidth: 0,
    trackBorderColor: 'black',
    valueColumn: null
  }
}, {
  type: 'vertical-bedlike',
  datatype: ['bedlike'],
  local: false,
  minWidth: 55,
  orientation: '1d-vertical',
  name: 'BED-like track',
  thumbnail: null,
  availableOptions: ['fillColor', 'labelPosition', 'labelColor', 'labelTextOpacity', 'labelBackgroundOpacity', 'trackBorderWidth', 'trackBorderColor', 'valueColumn'],
  defaultOptions: {
    axisPositionHorizontal: 'right',
    fillColor: 'blue',
    labelColor: 'black',
    labelPosition: 'hidden',
    trackBorderWidth: 0,
    trackBorderColor: 'black',
    valueColumn: null
  }
}];

exports['default'] = TRACKS_INFO;

/***/ }),
/* 622 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRACKS_INFO_BY_TYPE = undefined;

var _ = __webpack_require__(6);

var TRACKS_INFO_BY_TYPE = exports.TRACKS_INFO_BY_TYPE = _.TRACKS_INFO.reduce(function (tracksByType, track) {
  tracksByType[track.type] = track;
  return tracksByType;
}, {});

exports['default'] = TRACKS_INFO_BY_TYPE;

/***/ }),
/* 623 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
// const localServer = 'localhost:8000';
var REMOTE_SERVER = '52.45.229.11';

// export const USED_SERVER = localServer;
var USED_SERVER = exports.USED_SERVER = REMOTE_SERVER;

/***/ }),
/* 624 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
var map = function () {
  function map(f) {
    return function (x) {
      return Array.prototype.map.call(x, f);
    };
  }

  return map;
}();

exports["default"] = map;

/***/ }),
/* 625 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ = __webpack_require__(3);

var objVals = function () {
  function objVals(obj) {
    return (0, _.map)(function (key) {
      return obj[key];
    })(Object.keys(obj));
  }

  return objVals;
}();

exports['default'] = objVals;

/***/ }),
/* 626 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
var or = function () {
  function or(a, b) {
    return a || b;
  }

  return or;
}();

exports["default"] = or;

/***/ }),
/* 627 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Export a PIXI text to an SVG element
 *
 * param {PIXI.Text} pixiText A PIXI.Text object that we want to create an SVG element for
 * returns {Element} A DOM SVG Element with all of the attributes set as to display
 * the given text.
 */
var pixiTextToSvg = exports.pixiTextToSvg = function () {
  function pixiTextToSvg(pixiText) {
    var g = document.createElement('g');
    var t = document.createElement('text');

    t.setAttribute('text-anchor', 'middle');
    t.setAttribute('font-family', pixiText.style.fontFamily);
    t.setAttribute('font-size', pixiText.style.fontSize);
    g.setAttribute('transform', 'scale(' + pixiText.scale.x + ',1)');

    t.setAttribute('fill', pixiText.style.fill);
    t.innerHTML = pixiText.text;

    g.appendChild(t);
    g.setAttribute('transform', 'translate(' + pixiText.x + ',' + pixiText.y + ')scale(' + pixiText.scale.x + ',1)');

    return g;
  }

  return pixiTextToSvg;
}();

exports['default'] = pixiTextToSvg;

/***/ }),
/* 628 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
var relToAbsChromPos = function () {
  function relToAbsChromPos(chrom, x, y, chromInfo) {
    return [chromInfo.chrPositions[chrom].pos + +x, chromInfo.chrPositions[chrom].pos + +y];
  }

  return relToAbsChromPos;
}();

exports["default"] = relToAbsChromPos;

/***/ }),
/* 629 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Calculate the center of the scale as well as its scale
 * factor
 *
 * Assumes the two scales have the same k
 *
 * @param xScale: A d3 scale.
 * @param yScale: A d3 scale.
 * @return: [domainCenter, k]
 */
var scalesCenterAndK = function () {
  function scalesCenterAndK(xScale, yScale) {
    var xCenter = xScale.invert((xScale.range()[0] + xScale.range()[1]) / 2);
    var yCenter = yScale.invert((yScale.range()[0] + yScale.range()[1]) / 2);
    var k = xScale.invert(1) - xScale.invert(0);

    return [xCenter, yCenter, k];
  }

  return scalesCenterAndK;
}();

exports["default"] = scalesCenterAndK;

/***/ }),
/* 630 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scalesToGenomeLoci = undefined;

var _pixelToGenomeLoci = __webpack_require__(238);

var _pixelToGenomeLoci2 = _interopRequireDefault(_pixelToGenomeLoci);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var scalesToGenomeLoci = exports.scalesToGenomeLoci = function () {
  function scalesToGenomeLoci(xScale, yScale, chromInfo) {
    if (chromInfo === null || !xScale || !yScale) {
      return;
    }

    var x0 = xScale.domain()[0];
    var x1 = xScale.domain()[1];
    var y0 = yScale.domain()[0];
    var y1 = yScale.domain()[1];

    return [].concat(_toConsumableArray((0, _pixelToGenomeLoci2['default'])(x0, x1, chromInfo)), _toConsumableArray((0, _pixelToGenomeLoci2['default'])(y0, y1, chromInfo)));
  }

  return scalesToGenomeLoci;
}();

exports['default'] = scalesToGenomeLoci;

/***/ }),
/* 631 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
var sum = function () {
  function sum(a, b) {
    return a + b;
  }

  return sum;
}();

exports["default"] = sum;

/***/ }),
/* 632 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
var svgLine = exports.svgLine = function () {
  function svgLine(x1, y1, x2, y2, strokeWidth, strokeColor) {
    var line = document.createElement('line');

    line.setAttribute('x1', x1);
    line.setAttribute('x2', x2);
    line.setAttribute('y1', y1);
    line.setAttribute('y2', y2);

    if (strokeWidth) {
      line.setAttribute('stroke-width', strokeWidth);
    }
    if (strokeColor) {
      line.setAttribute('stroke', strokeColor);
    }

    return line;
  }

  return svgLine;
}();

exports['default'] = svgLine;

/***/ }),
/* 633 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Calculate the total height of the horizontal and center
 * tracks in pixels
 *
 * Parameters
 * -----------
 *
 *  view : view config object
 *    A typical view configuration containing a list of tracks
 *
 * Returns
 * -------
 *  int
 *    The total height of the top, center and bottom tracks
 */
var totalTrackPixelHeight = function () {
  function totalTrackPixelHeight(view) {
    // no tracks means no height
    if (!view.tracks) return 0;

    var totalHeight = 0;

    if (view.tracks.top) {
      totalHeight += view.tracks.top.map(function (x) {
        return x.height;
      }).reduce(function (a, b) {
        return a + b;
      }, 0);
    }

    if (view.tracks.center) {
      totalHeight += view.tracks.center.map(function (x) {
        return x.height;
      }).reduce(function (a, b) {
        return a + b;
      }, 0);
    }

    if (view.tracks.bottom) {
      totalHeight += view.tracks.bottom.map(function (x) {
        return x.height;
      }).reduce(function (a, b) {
        return a + b;
      }, 0);
    }

    return totalHeight;
  }

  return totalTrackPixelHeight;
}();

exports["default"] = totalTrackPixelHeight;

/***/ }),
/* 634 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TrackRenderer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(8);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _d3Zoom = __webpack_require__(635);

var _d3Selection = __webpack_require__(4);

var _d3Scale = __webpack_require__(12);

var _HeatmapTiledPixiTrack = __webpack_require__(82);

var _HeatmapTiledPixiTrack2 = _interopRequireDefault(_HeatmapTiledPixiTrack);

var _Id2DTiledPixiTrack = __webpack_require__(641);

var _Id2DTiledPixiTrack2 = _interopRequireDefault(_Id2DTiledPixiTrack);

var _IdHorizontal1DTiledPixiTrack = __webpack_require__(642);

var _IdHorizontal1DTiledPixiTrack2 = _interopRequireDefault(_IdHorizontal1DTiledPixiTrack);

var _IdVertical1DTiledPixiTrack = __webpack_require__(643);

var _IdVertical1DTiledPixiTrack2 = _interopRequireDefault(_IdVertical1DTiledPixiTrack);

var _TopAxisTrack = __webpack_require__(645);

var _TopAxisTrack2 = _interopRequireDefault(_TopAxisTrack);

var _LeftAxisTrack = __webpack_require__(649);

var _LeftAxisTrack2 = _interopRequireDefault(_LeftAxisTrack);

var _CombinedTrack = __webpack_require__(650);

var _CombinedTrack2 = _interopRequireDefault(_CombinedTrack);

var _BedLikeTrack = __webpack_require__(651);

var _BedLikeTrack2 = _interopRequireDefault(_BedLikeTrack);

var _HorizontalLine1DPixiTrack = __webpack_require__(85);

var _HorizontalLine1DPixiTrack2 = _interopRequireDefault(_HorizontalLine1DPixiTrack);

var _HorizontalPoint1DPixiTrack = __webpack_require__(657);

var _HorizontalPoint1DPixiTrack2 = _interopRequireDefault(_HorizontalPoint1DPixiTrack);

var _HorizontalMultivecTrack = __webpack_require__(658);

var _HorizontalMultivecTrack2 = _interopRequireDefault(_HorizontalMultivecTrack);

var _BarTrack = __webpack_require__(245);

var _BarTrack2 = _interopRequireDefault(_BarTrack);

var _DivergentBarTrack = __webpack_require__(659);

var _DivergentBarTrack2 = _interopRequireDefault(_DivergentBarTrack);

var _CNVIntervalTrack = __webpack_require__(660);

var _CNVIntervalTrack2 = _interopRequireDefault(_CNVIntervalTrack);

var _LeftTrackModifier = __webpack_require__(662);

var _LeftTrackModifier2 = _interopRequireDefault(_LeftTrackModifier);

var _Track = __webpack_require__(140);

var _Track2 = _interopRequireDefault(_Track);

var _HorizontalGeneAnnotationsTrack = __webpack_require__(663);

var _HorizontalGeneAnnotationsTrack2 = _interopRequireDefault(_HorizontalGeneAnnotationsTrack);

var _ArrowheadDomainsTrack = __webpack_require__(664);

var _ArrowheadDomainsTrack2 = _interopRequireDefault(_ArrowheadDomainsTrack);

var _Horizontal2DDomainsTrack = __webpack_require__(665);

var _Horizontal2DDomainsTrack2 = _interopRequireDefault(_Horizontal2DDomainsTrack);

var _SquareMarkersTrack = __webpack_require__(666);

var _SquareMarkersTrack2 = _interopRequireDefault(_SquareMarkersTrack);

var _Chromosome2DLabels = __webpack_require__(667);

var _Chromosome2DLabels2 = _interopRequireDefault(_Chromosome2DLabels);

var _Chromosome2DGrid = __webpack_require__(668);

var _Chromosome2DGrid2 = _interopRequireDefault(_Chromosome2DGrid);

var _Chromosome2DAnnotations = __webpack_require__(669);

var _Chromosome2DAnnotations2 = _interopRequireDefault(_Chromosome2DAnnotations);

var _HorizontalChromosomeLabels = __webpack_require__(670);

var _HorizontalChromosomeLabels2 = _interopRequireDefault(_HorizontalChromosomeLabels);

var _HorizontalHeatmapTrack = __webpack_require__(671);

var _HorizontalHeatmapTrack2 = _interopRequireDefault(_HorizontalHeatmapTrack);

var _UnknownPixiTrack = __webpack_require__(672);

var _UnknownPixiTrack2 = _interopRequireDefault(_UnknownPixiTrack);

var _ValueIntervalTrack = __webpack_require__(673);

var _ValueIntervalTrack2 = _interopRequireDefault(_ValueIntervalTrack);

var _ViewportTracker2D = __webpack_require__(674);

var _ViewportTracker2D2 = _interopRequireDefault(_ViewportTracker2D);

var _ViewportTrackerHorizontal = __webpack_require__(675);

var _ViewportTrackerHorizontal2 = _interopRequireDefault(_ViewportTrackerHorizontal);

var _ViewportTrackerVertical = __webpack_require__(676);

var _ViewportTrackerVertical2 = _interopRequireDefault(_ViewportTrackerVertical);

var _OSMTilesTrack = __webpack_require__(246);

var _OSMTilesTrack2 = _interopRequireDefault(_OSMTilesTrack);

var _MapboxTilesTrack = __webpack_require__(677);

var _MapboxTilesTrack2 = _interopRequireDefault(_MapboxTilesTrack);

var _utils = __webpack_require__(3);

var _services = __webpack_require__(7);

var _configs = __webpack_require__(6);

__webpack_require__(678);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Utils


// Services


// Configs


// Styles


var SCROLL_TIMEOUT = 100;

var TrackRenderer = exports.TrackRenderer = function (_React$Component) {
  _inherits(TrackRenderer, _React$Component);

  /**
   * Maintain a list of tracks, and re-render them whenever either
   * their size changes or the zoom level changes
   *
   * Zooming changes the domain of the scales.
   *
   * Resizing changes the range. Both trigger a rerender.
   */
  function TrackRenderer(props) {
    _classCallCheck(this, TrackRenderer);

    var _this = _possibleConstructorReturn(this, (TrackRenderer.__proto__ || Object.getPrototypeOf(TrackRenderer)).call(this, props));

    _this.dragging = false; // is this element being dragged?
    _this.element = null;
    _this.closing = false;

    _this.yPositionOffset = 0;
    _this.xPositionOffset = 0;

    _this.scrollTimeout = null;
    _this.activeTransitions = 0;

    _this.zoomTransform = _d3Zoom.zoomIdentity;
    _this.windowScrolledBound = _this.windowScrolled.bind(_this);
    _this.zoomStartedBound = _this.zoomStarted.bind(_this);
    _this.zoomedBound = _this.zoomed.bind(_this);
    _this.zoomEndedBound = _this.zoomEnded.bind(_this);

    _this.mounted = false;

    // create a zoom behavior that we'll just use to transform selections
    // without having it fire an "onZoom" event
    _this.emptyZoomBehavior = (0, _d3Zoom.zoom)();

    // a lot of the updates in TrackRenderer happen in response to
    // componentWillReceiveProps so we need to perform them with the
    // newest set of props. When cWRP is called, this.props still contains
    // the old props, so we need to store them in a new variable
    _this.currentProps = props;
    _this.prevPropsStr = '';

    // catch any zooming behavior within all of the tracks in this plot
    // this.zoomTransform = zoomIdentity();
    _this.zoomBehavior = (0, _d3Zoom.zoom)().filter(function () {
      if (_d3Selection.event.target.classList.contains('no-zoom')) {
        return false;
      }
      if (_d3Selection.event.target.classList.contains('react-resizable-handle')) {
        return false;
      }
      return true;
    })
    // Limit max zoomout level to 0.25
    // .scaleExtent([0.25, Infinity])
    // Define translate extend
    // .translateExtent([[-2000, -2000], [2000, 2000]])
    .on('start', _this.zoomStartedBound).on('zoom', _this.zoomedBound).on('end', _this.zoomEndedBound);

    _this.initialXDomain = [0, 1];
    _this.initialYDomain = [0, 1];

    _this.prevCenterX = _this.currentProps.marginLeft + _this.currentProps.leftWidth + _this.currentProps.centerWidth / 2;
    _this.prevCenterY = _this.currentProps.marginTop + _this.currentProps.topHeight + _this.currentProps.centerHeight / 2;

    // The offset of the center from the original. Used to keep the scales centered on resize events
    _this.cumCenterXOffset = 0;
    _this.cumCenterYOffset = 0;

    _this.setUpInitialScales(_this.currentProps.initialXDomain, _this.currentProps.initialYDomain);

    _this.setUpScales();

    // maintain a list of trackDefObjects which correspond to the input
    // tracks
    // Each object will contain a trackDef
    // {'top': 100, 'left': 50,... 'track': {'source': 'http:...', 'type': 'heatmap'}}
    // And a trackObject which will be responsible for rendering it
    _this.trackDefObjects = {};

    _this.pubSubs = [];
    return _this;
  }

  _createClass(TrackRenderer, [{
    key: 'componentWillMount',
    value: function () {
      function componentWillMount() {
        this.pubSubs = [];
        this.pubSubs.push(_services.pubSub.subscribe('scroll', this.windowScrolledBound));
      }

      return componentWillMount;
    }()
  }, {
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {
        this.element = _reactDom2['default'].findDOMNode(this);
        this.divTrackAreaSelection = (0, _d3Selection.select)(this.divTrackArea);
        this.svgTrackAreaSelection = (0, _d3Selection.select)(this.svgTrackArea);

        this.pStage = new PIXI.Graphics();
        this.pMask = new PIXI.Graphics();

        this.pStage.addChild(this.pMask);

        this.currentProps.pixiStage.addChild(this.pStage);

        this.pStage.mask = this.pMask;

        if (!this.props.isRangeSelection) this.addZoom();

        this.canvasDom = _reactDom2['default'].findDOMNode(this.currentProps.canvasElement);

        // used to determine whether to update the graphics of the 
        // child tracks
        this.mounted = true;

        // need to be mounted to make sure that all the renderers are
        // created before starting to draw tracks
        if (!this.currentProps.svgElement || !this.currentProps.canvasElement) {
          return;
        }

        this.svgElement = this.currentProps.svgElement;
        this.syncTrackObjects(this.currentProps.positionedTracks);

        this.currentProps.setCentersFunction(this.setCenter.bind(this));
        this.currentProps.registerDraggingChangedListener(this.draggingChanged.bind(this));

        this.draggingChanged(true);
      }

      return componentDidMount;
    }()
  }, {
    key: 'componentWillReceiveProps',
    value: function () {
      function componentWillReceiveProps(nextProps) {
        /**
         * The size of some tracks probably changed, so let's just
         * redraw them.
         */

        // don't initiate this component if it has nothing to draw on
        if (!nextProps.svgElement || !nextProps.canvasElement) {
          return;
        }

        var nextPropsStr = this.updatablePropsToString(nextProps);
        this.currentProps = nextProps;

        if (this.prevPropsStr === nextPropsStr) {
          return;
        }

        for (var uid in this.trackDefObjects) {
          var track = this.trackDefObjects[uid].trackObject;

          track.delayDrawing = true;
        }

        this.prevPropsStr = nextPropsStr;

        this.setUpInitialScales(nextProps.initialXDomain, nextProps.initialYDomain);

        this.setUpScales(nextProps.width !== this.props.width || nextProps.height !== this.props.height);
        this.canvasDom = _reactDom2['default'].findDOMNode(nextProps.canvasElement);

        this.svgElement = nextProps.svgElement;

        this.syncTrackObjects(nextProps.positionedTracks);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = nextProps.positionedTracks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _track2 = _step.value;

            // tracks all the way down
            var options = _track2.track.options;
            var trackObject = this.trackDefObjects[_track2.track.uid].trackObject;
            trackObject.rerender(options);

            if (_track2.track.hasOwnProperty('contents')) {
              var ctDefs = {};
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = _track2.track.contents[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var ct = _step2.value;

                  ctDefs[ct.uid] = ct;
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }

              for (var _uid2 in trackObject.createdTracks) {
                trackObject.createdTracks[_uid2].rerender(ctDefs[_uid2].options);
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this.props.onNewTilesLoaded();

        for (var _uid in this.trackDefObjects) {
          var _track = this.trackDefObjects[_uid].trackObject;

          _track.delayDrawing = false;
          _track.draw();
        }
      }

      return componentWillReceiveProps;
    }()
  }, {
    key: 'componentDidUpdate',
    value: function () {
      function componentDidUpdate(prevProps) {
        if (prevProps.isRangeSelection !== this.props.isRangeSelection) {
          if (this.props.isRangeSelection) {
            this.removeZoom();
          } else {
            this.addZoom();
          }
        }
      }

      return componentDidUpdate;
    }()
  }, {
    key: 'componentWillUnmount',
    value: function () {
      function componentWillUnmount() {
        /**
         * This view has been removed so we need to get rid of all the tracks it contains
         */
        this.mounted = false;
        this.removeTracks(Object.keys(this.trackDefObjects));
        this.currentProps.removeDraggingChangedListener(this.draggingChanged);

        this.currentProps.pixiStage.removeChild(this.pStage);

        this.pMask.destroy(true);
        this.pStage.destroy(true);

        this.pubSubs.forEach(function (subscription) {
          return _services.pubSub.unsubscribe(subscription);
        });
        this.pubSubs = [];
      }

      return componentWillUnmount;
    }()

    /* --------------------------- Custom Methods ----------------------------- */

  }, {
    key: 'addZoom',
    value: function () {
      function addZoom() {
        if (!this.divTrackAreaSelection) {
          return;
        }

        // add back the previous transform
        this.divTrackAreaSelection.call(this.zoomBehavior);
        this.zoomBehavior.transform(this.divTrackAreaSelection, this.zoomTransform);
      }

      return addZoom;
    }()
  }, {
    key: 'removeZoom',
    value: function () {
      function removeZoom() {
        if (this.divTrackAreaSelection) {
          this.zoomEnded();
          this.divTrackAreaSelection.on('.zoom', null);
        }
      }

      return removeZoom;
    }()
  }, {
    key: 'setMask',
    value: function () {
      function setMask() {
        /*
         * Add a mask to make sure that the tracks displayed in this view
         * don't overflow its bounds.
         */
        this.pMask.clear();
        this.pMask.beginFill();
        this.pMask.drawRect(this.xPositionOffset, this.yPositionOffset, this.currentProps.width, this.currentProps.height);
        this.pMask.endFill();
      }

      return setMask;
    }()
  }, {
    key: 'windowScrolled',
    value: function () {
      function windowScrolled() {
        var _this2 = this;

        this.removeZoom();

        if (this.scrollTimeout) {
          clearTimeout(this.scrollTimeout);
        }

        this.scrollTimeout = setTimeout(function () {
          _this2.addZoom();
        }, SCROLL_TIMEOUT);
      }

      return windowScrolled;
    }()
  }, {
    key: 'setUpInitialScales',
    value: function () {
      function setUpInitialScales(initialXDomain, initialYDomain) {
        // make sure the two scales are equally wide:
        var xWidth = initialXDomain[1] - initialXDomain[0];
        var yCenter = (initialYDomain[0] + initialYDomain[1]) / 2;
        // initialYDomain = [yCenter - xWidth / 2, yCenter + xWidth / 2];

        // stretch out the y-scale so that views aren't distorted (i.e. maintain
        // a 1 to 1 ratio)
        initialYDomain[0] = yCenter - xWidth / 2, initialYDomain[1] = yCenter + xWidth / 2;

        // if the inital domains haven't changed, then we don't have to
        // worry about resetting anything
        // initial domains should only change when loading a new viewconfig
        if (initialXDomain[0] == this.initialXDomain[0] && initialXDomain[1] == this.initialXDomain[1] && initialYDomain[0] == this.initialYDomain[0] && initialYDomain[1] == this.initialYDomain[1]) {
          return;
        }

        // only update the initial domain
        this.initialXDomain = initialXDomain;
        this.initialYDomain = initialYDomain;

        this.cumCenterYOffset = 0;
        this.cumCenterXOffset = 0;

        this.drawableToDomainX = (0, _d3Scale.scaleLinear)().domain([this.currentProps.marginLeft + this.currentProps.leftWidth, this.currentProps.marginLeft + this.currentProps.leftWidth + this.currentProps.centerWidth]).range([initialXDomain[0], initialXDomain[1]]);

        this.drawableToDomainY = (0, _d3Scale.scaleLinear)().domain([this.currentProps.marginTop + this.currentProps.topHeight + this.currentProps.centerHeight / 2 - this.currentProps.centerWidth / 2, this.currentProps.marginTop + this.currentProps.topHeight + this.currentProps.centerHeight / 2 + this.currentProps.centerWidth / 2]).range([initialYDomain[0], initialYDomain[1]]);

        this.prevCenterX = this.currentProps.marginLeft + this.currentProps.leftWidth + this.currentProps.centerWidth / 2;
        this.prevCenterY = this.currentProps.marginTop + this.currentProps.topHeight + this.currentProps.centerHeight / 2;
      }

      return setUpInitialScales;
    }()
  }, {
    key: 'updatablePropsToString',
    value: function () {
      function updatablePropsToString(props) {
        return JSON.stringify({
          positionedTracks: props.positionedTracks,
          initialXDomain: props.initialXDomain,
          initialYDomain: props.initialYDomain,
          width: props.width,
          height: props.height,
          marginLeft: props.marginLeft,
          marginRight: props.marginRight,
          leftWidth: props.leftWidth,
          topHeight: props.topHeight,
          dragging: props.dragging
        });
      }

      return updatablePropsToString;
    }()
  }, {
    key: 'draggingChanged',
    value: function () {
      function draggingChanged(draggingStatus) {
        this.dragging = draggingStatus;

        this.timedUpdatePositionAndDimensions();
      }

      return draggingChanged;
    }()
  }, {
    key: 'setUpScales',
    value: function () {
      function setUpScales() {
        var notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        var currentCenterX = this.currentProps.marginLeft + this.currentProps.leftWidth + this.currentProps.centerWidth / 2;
        var currentCenterY = this.currentProps.marginTop + this.currentProps.topHeight + this.currentProps.centerHeight / 2;

        // we need to maintain two scales:
        // 1. the scale that is shown
        // 2. the scale that the zooming behavior acts on
        //
        // These need to be separated because the zoom behavior acts on a larger region
        // than the visible scale shows

        // if the window is resized, we don't want to change the scale, but we do want to move the center point
        // this needs to be tempered by the zoom factor so that we keep the visible center point in the center
        var centerDomainXOffset = (this.drawableToDomainX(currentCenterX) - this.drawableToDomainX(this.prevCenterX)) / this.zoomTransform.k;
        var centerDomainYOffset = (this.drawableToDomainY(currentCenterY) - this.drawableToDomainY(this.prevCenterY)) / this.zoomTransform.k;
        //const centerDomainYOffset = 0;

        this.cumCenterYOffset += centerDomainYOffset;
        this.cumCenterXOffset += centerDomainXOffset;

        this.prevCenterY = currentCenterY;
        this.prevCenterX = currentCenterX;

        // the domain of the visible (not drawable area)
        var visibleXDomain = [this.drawableToDomainX(0) - this.cumCenterXOffset, this.drawableToDomainX(this.currentProps.width) - this.cumCenterXOffset];
        var visibleYDomain = [this.drawableToDomainY(0) - this.cumCenterYOffset, this.drawableToDomainY(this.currentProps.height) - this.cumCenterYOffset];

        // [drawableToDomain(0), drawableToDomain(1)]: the domain of the visible area
        // if the screen has been resized, then the domain width should remain the same

        // this.xScale should always span the region that the zoom behavior is being called on
        this.xScale = (0, _d3Scale.scaleLinear)().domain(visibleXDomain).range([0, this.currentProps.width]);

        this.yScale = (0, _d3Scale.scaleLinear)().domain(visibleYDomain).range([0, this.currentProps.height]);

        for (var uid in this.trackDefObjects) {
          var track = this.trackDefObjects[uid].trackObject;

          // track.refXScale(this.xScale);
          // track.refYScale(this.yScale);

          // e.g. when the track is resized... we want to redraw it
          track.refScalesChanged(this.xScale, this.yScale);
          // track.draw();
        }

        this.applyZoomTransform(notify);
      }

      return setUpScales;
    }()
  }, {
    key: 'getTrackObject',
    value: function () {
      function getTrackObject(trackId) {
        /*
         * Fetch the trackObject for a track with a given ID
         *
         */
        var trackDefItems = (0, _utils.dictItems)(this.trackDefObjects);

        for (var i = 0; i < trackDefItems.length; i++) {
          var uid = trackDefItems[i][0];
          var trackObject = trackDefItems[i][1].trackObject;

          if (uid == trackId) {
            return trackObject;
          }

          // maybe this track is in a combined track
          if (trackObject.createdTracks) {
            var createdTrackItems = (0, _utils.dictItems)(trackObject.createdTracks);

            for (var _i = 0; _i < createdTrackItems.length; _i++) {
              var createdTrackUid = createdTrackItems[_i][0];
              var createdTrackObject = createdTrackItems[_i][1];

              if (createdTrackUid == trackId) {
                return createdTrackObject;
              }
            }
          }
        }
      }

      return getTrackObject;
    }()
  }, {
    key: 'timedUpdatePositionAndDimensions',
    value: function () {
      function timedUpdatePositionAndDimensions() {
        if (this.closing) {
          return;
        }
        if (!this.mounted) {
          return;
        }

        if (this.dragging) {
          this.yPositionOffset = this.element.getBoundingClientRect().top - this.canvasDom.getBoundingClientRect().top;
          this.xPositionOffset = this.element.getBoundingClientRect().left - this.canvasDom.getBoundingClientRect().left;

          this.setMask();

          var updated = this.updateTrackPositions();

          if (updated) {
            // only redraw if positions changed
            this.applyZoomTransform(true);
          }

          requestAnimationFrame(this.timedUpdatePositionAndDimensions.bind(this));
        }
      }

      return timedUpdatePositionAndDimensions;
    }()
  }, {
    key: 'syncTrackObjects',
    value: function () {
      function syncTrackObjects(trackDefinitions) {
        /**
         * Make sure we have a track object for every passed track definition.
         *
         * If we get a track definition for which we have no Track object, we
         * create a new one.
         *
         * If we have a track object for which we have no definition, we remove
         * the object.
         *
         * All the others we ignore.
         *
         * Track definitions should be of the following form:
         *
         * { height:  100, width: 50, top: 30, left: 40, track: {...}}
         *
         * @param trackDefinitions: The definition of the track
         * @return: Nothing
         */
        var receivedTracksDict = {};
        for (var i = 0; i < trackDefinitions.length; i++) {
          receivedTracksDict[trackDefinitions[i].track.uid] = trackDefinitions[i];
        }

        var knownTracks = new Set(Object.keys(this.trackDefObjects));
        var receivedTracks = new Set(Object.keys(receivedTracksDict));

        // track definitions we don't have objects for
        var enterTrackDefs = new Set([].concat(_toConsumableArray(receivedTracks)).filter(function (x) {
          return !knownTracks.has(x);
        }));

        // track objects for which there is no definition
        // (i.e. they no longer need to exist)
        var exitTracks = new Set([].concat(_toConsumableArray(knownTracks)).filter(function (x) {
          return !receivedTracks.has(x);
        }));

        // we already have these tracks, but need to change their dimensions
        var updateTrackDefs = new Set([].concat(_toConsumableArray(receivedTracks)).filter(function (x) {
          return knownTracks.has(x);
        }));

        // update existing tracks
        this.updateExistingTrackDefs([].concat(_toConsumableArray(updateTrackDefs)).map(function (x) {
          return receivedTracksDict[x];
        }));

        // add new tracks and update them (setting dimensions and positions)
        this.addNewTracks([].concat(_toConsumableArray(enterTrackDefs)).map(function (x) {
          return receivedTracksDict[x];
        }));
        this.updateExistingTrackDefs([].concat(_toConsumableArray(enterTrackDefs)).map(function (x) {
          return receivedTracksDict[x];
        }));

        this.removeTracks([].concat(_toConsumableArray(exitTracks)));
      }

      return syncTrackObjects;
    }()
  }, {
    key: 'addNewTracks',
    value: function () {
      function addNewTracks(newTrackDefinitions) {
        /**
         * We need to create new track objects for the given track
         * definitions.
         */
        if (!this.currentProps.pixiStage) {
          return;
        } // we need a pixi stage to start rendering
        // the parent component where it lives probably
        // hasn't been mounted yet

        for (var i = 0; i < newTrackDefinitions.length; i++) {
          var newTrackDef = newTrackDefinitions[i];
          var newTrackObj = this.createTrackObject(newTrackDef.track);

          // newTrackObj.refXScale(this.xScale);
          // newTrackObj.refYScale(this.yScale);

          newTrackObj.refScalesChanged(this.xScale, this.yScale);

          this.trackDefObjects[newTrackDef.track.uid] = { trackDef: newTrackDef,
            trackObject: newTrackObj };

          var zoomedXScale = this.zoomTransform.rescaleX(this.xScale);
          var zoomedYScale = this.zoomTransform.rescaleY(this.yScale);

          newTrackObj.setDimensions([newTrackDef.width, newTrackDef.height]);
          newTrackObj.zoomed(zoomedXScale, zoomedYScale);
        }

        // this could be replaced with a call that only applies the zoom
        // transform to the newly added tracks
        this.applyZoomTransform(false);
      }

      return addNewTracks;
    }()
  }, {
    key: 'updateExistingTrackDefs',
    value: function () {
      function updateExistingTrackDefs(newTrackDefs) {
        for (var i = 0; i < newTrackDefs.length; i++) {
          this.trackDefObjects[newTrackDefs[i].track.uid].trackDef = newTrackDefs[i];

          // if it's a CombinedTrack, we have to see if its contents have changed
          // e.g. somebody may have added a new Series
          if (newTrackDefs[i].track.type == 'combined') {
            this.trackDefObjects[newTrackDefs[i].track.uid].trackObject.updateContents(newTrackDefs[i].track.contents, this.createTrackObject.bind(this)).refScalesChanged(this.xScale, this.yScale);
          }
        }

        var updated = this.updateTrackPositions();
        // this.applyZoomTransform();
        if (updated) {
          // only redraw if positions changed
          this.applyZoomTransform(false);
        }
      }

      return updateExistingTrackDefs;
    }()
  }, {
    key: 'updateTrackPositions',
    value: function () {
      function updateTrackPositions() {
        var updated = false;

        for (var uid in this.trackDefObjects) {
          var trackDef = this.trackDefObjects[uid].trackDef;
          var trackObject = this.trackDefObjects[uid].trackObject;

          var prevPosition = trackObject.position;
          var prevDimensions = trackObject.dimensions;

          var newPosition = [this.xPositionOffset + trackDef.left, this.yPositionOffset + trackDef.top];
          var newDimensions = [trackDef.width, trackDef.height];

          // check if any of the track's positions have changed
          // before trying to update them

          if (!prevPosition || newPosition[0] != prevPosition[0] || newPosition[1] != prevPosition[1]) {
            trackObject.setPosition(newPosition);
            updated = true;
          }

          if (!prevDimensions || newDimensions[0] != prevDimensions[0] || newDimensions[1] != prevDimensions[1]) {
            trackObject.setDimensions(newDimensions);
            updated = true;
          }

          var widthDifference = trackDef.width - this.currentProps.width;
          var heightDifference = trackDef.height - this.currentProps.height;
        }

        // report on whether any track positions or dimensions have changed
        // so that downstream code can decide whether to redraw
        return updated;
      }

      return updateTrackPositions;
    }()
  }, {
    key: 'removeTracks',
    value: function () {
      function removeTracks(trackUids) {
        for (var i = 0; i < trackUids.length; i++) {
          this.trackDefObjects[trackUids[i]].trackObject.remove();
          delete this.trackDefObjects[trackUids[i]];
        }
      }

      return removeTracks;
    }()
  }, {
    key: 'setCenter',
    value: function () {
      function setCenter(centerX, centerY, sourceK, notify) {
        var _this3 = this;

        var animate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        var animateTime = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _configs.ZOOM_TRANSITION_DURATION;

        /*
         * Set the center of this view to a paticular X and Y coordinate
         *
         * @param notify: Notify listeners that the scales have changed. This
         *      can be turned off to prevent circular updates when scales are
         *      locked.
         */
        var refK = this.xScale.invert(1) - this.xScale.invert(0);

        var k = refK / sourceK;

        var middleViewX = this.currentProps.marginLeft + this.currentProps.leftWidth + this.currentProps.centerWidth / 2;
        var middleViewY = this.currentProps.marginTop + this.currentProps.topHeight + this.currentProps.centerHeight / 2;

        // After applying the zoom transform, the xScale of the target centerX
        // should be equal to the middle of the viewport
        // this.xScale(centerX) * k + translate[0] = middleViewX
        var translateX = middleViewX - this.xScale(centerX) * k;
        var translateY = middleViewY - this.yScale(centerY) * k;

        // the ref scale spans the width of the viewport

        var last = void 0;

        var setZoom = function () {
          function setZoom() {
            var newTransform = _d3Zoom.zoomIdentity.translate(translateX, translateY).scale(k);

            _this3.zoomTransform = newTransform;
            _this3.emptyZoomBehavior.transform(_this3.divTrackAreaSelection, newTransform);

            last = _this3.applyZoomTransform(notify);
          }

          return setZoom;
        }();

        if (animate) {
          var selection = this.divTrackAreaSelection;
          this.activeTransitions += 1;

          if (!document.hidden) {
            // only transition if the window is hidden
            selection = selection.transition().duration(animateTime);
          }

          selection.call(this.zoomBehavior.transform, _d3Zoom.zoomIdentity.translate(translateX, translateY).scale(k)).on('end', function () {
            setZoom();
            _this3.activeTransitions -= 1;
          });
        } else {
          setZoom();
        }

        return last;
      }

      return setCenter;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed() {
        /**
         * Respond to a zoom event.
         *
         * We need to update our local record of the zoom transform and apply it
         * to all the tracks.
         */
        this.zoomTransform = !this.currentProps.zoomable ? _d3Zoom.zoomIdentity : _d3Selection.event.transform;

        this.applyZoomTransform(true);
      }

      return zoomed;
    }()
  }, {
    key: 'zoomStarted',
    value: function () {
      function zoomStarted() {
        this.zooming = true;
      }

      return zoomStarted;
    }()
  }, {
    key: 'zoomEnded',
    value: function () {
      function zoomEnded() {
        this.zooming = false;
      }

      return zoomEnded;
    }()
  }, {
    key: 'applyZoomTransform',
    value: function () {
      function applyZoomTransform() {
        var notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        var zoomedXScale = this.zoomTransform.rescaleX(this.xScale);
        var zoomedYScale = this.zoomTransform.rescaleY(this.yScale);

        var newXScale = (0, _d3Scale.scaleLinear)().domain([this.currentProps.marginLeft + this.currentProps.leftWidth, this.currentProps.marginLeft + this.currentProps.leftWidth + this.currentProps.centerWidth].map(zoomedXScale.invert)).range([0, this.currentProps.centerWidth]);

        var newYScale = (0, _d3Scale.scaleLinear)().domain([this.currentProps.marginTop + this.currentProps.topHeight, this.currentProps.marginTop + this.currentProps.topHeight + this.currentProps.centerHeight].map(zoomedYScale.invert)).range([0, this.currentProps.centerHeight]);

        for (var uid in this.trackDefObjects) {
          var track = this.trackDefObjects[uid].trackObject;

          track.zoomed(newXScale.copy(), newYScale.copy(), this.zoomTransform.k, this.zoomTransform.x + this.xPositionOffset, this.zoomTransform.y + this.yPositionOffset, this.currentProps.marginLeft + this.currentProps.leftWidth, this.currentProps.marginTop + this.currentProps.topHeight);
        }

        if (notify) {
          this.currentProps.onScalesChanged(newXScale, newYScale);
        }

        return [newXScale, newYScale];
      }

      return applyZoomTransform;
    }()
  }, {
    key: 'createTrackObject',
    value: function () {
      function createTrackObject(track) {
        var _this4 = this;

        var handleTilesetInfoReceived = function () {
          function handleTilesetInfoReceived(x) {
            _this4.currentProps.onTilesetInfoReceived(track.uid, x);
          }

          return handleTilesetInfoReceived;
        }();

        // See if this track has a data config section.
        // If it doesn't, we assume that it has the standard 
        // server / tilesetUid sections
        // if the track has no data server, then this will just
        // be blank and we can go on our merry way
        var dataConfig = track.data;
        if (!dataConfig) {
          dataConfig = {
            server: track.server,
            tilesetUid: track.tilesetUid
          };
        }

        // console.log('track:', track);
        // console.log('dataConfig:', dataConfig);

        switch (track.type) {
          case 'left-axis':
            return new _LeftAxisTrack2['default'](this.svgElement);

          case 'top-axis':
            return new _TopAxisTrack2['default'](this.svgElement);

          case 'heatmap':
            return new _HeatmapTiledPixiTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, this.svgElement, function () {
              return _this4.currentProps.onValueScaleChanged(track.uid);
            }, function (newOptions) {
              return _this4.currentProps.onTrackOptionsChanged(track.uid, newOptions);
            });

          case 'horizontal-multivec':
            return new _HorizontalMultivecTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, this.svgElement, function () {
              return _this4.currentProps.onValueScaleChanged(track.uid);
            }, function (newOptions) {
              return _this4.currentProps.onTrackOptionsChanged(track.uid, newOptions);
            });

          case 'horizontal-line':
            return new _HorizontalLine1DPixiTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, function () {
              return _this4.currentProps.onValueScaleChanged(track.uid);
            });

          case 'vertical-line':
            return new _LeftTrackModifier2['default'](new _HorizontalLine1DPixiTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, function () {
              return _this4.currentProps.onValueScaleChanged(track.uid);
            }));

          case 'horizontal-point':
            return new _HorizontalPoint1DPixiTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, function () {
              return _this4.currentProps.onValueScaleChanged(track.uid);
            });

          case 'vertical-point':
            return new _LeftTrackModifier2['default'](new _HorizontalPoint1DPixiTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, function () {
              return _this4.currentProps.onValueScaleChanged(track.uid);
            }));

          case 'horizontal-bar':
            return new _BarTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, function () {
              return _this4.currentProps.onValueScaleChanged(track.uid);
            });

          case 'horizontal-divergent-bar':
            return new _DivergentBarTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, function () {
              return _this4.currentProps.onValueScaleChanged(track.uid);
            });

          case 'vertical-bar':
            return new _LeftTrackModifier2['default'](new _BarTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, function () {
              return _this4.currentProps.onValueScaleChanged(track.uid);
            }));

          case 'horizontal-1d-tiles':
            return new _IdHorizontal1DTiledPixiTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            });

          case 'vertical-1d-tiles':
            return new _IdVertical1DTiledPixiTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            });

          case '2d-tiles':
            return new _Id2DTiledPixiTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            });

          case 'top-stacked-interval':
            return new _CNVIntervalTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, function () {
              return _this4.currentProps.onValueScaleChanged(track.uid);
            });

          case 'left-stacked-interval':
            return new _LeftTrackModifier2['default'](new _CNVIntervalTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, function () {
              return _this4.currentProps.onValueScaleChanged(track.uid);
            }));

          case 'viewport-projection-center':
            // TODO: Fix this so that these functions are defined somewhere else
            if (track.registerViewportChanged && track.removeViewportChanged && track.setDomainsCallback) {
              return new _ViewportTracker2D2['default'](this.svgElement, track.registerViewportChanged, track.removeViewportChanged, track.setDomainsCallback, track.options);
            }
            return new _Track2['default']();

          case 'viewport-projection-horizontal':
            // TODO: Fix this so that these functions are defined somewhere else
            if (track.registerViewportChanged && track.removeViewportChanged && track.setDomainsCallback) {
              return new _ViewportTrackerHorizontal2['default'](this.svgElement, track.registerViewportChanged, track.removeViewportChanged, track.setDomainsCallback, track.options);
            }
            return new _Track2['default']();

          case 'viewport-projection-vertical':
            // TODO: Fix this so that these functions are defined somewhere else
            if (track.registerViewportChanged && track.removeViewportChanged && track.setDomainsCallback) {
              return new _ViewportTrackerVertical2['default'](this.svgElement, track.registerViewportChanged, track.removeViewportChanged, track.setDomainsCallback, track.options);
            }
            return new _Track2['default']();

          case 'horizontal-gene-annotations':
            return new _HorizontalGeneAnnotationsTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            });

          case 'vertical-gene-annotations':
            return new _LeftTrackModifier2['default'](new _HorizontalGeneAnnotationsTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }));

          case '2d-rectangle-domains':
            return new _ArrowheadDomainsTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            });

          case 'vertical-2d-rectangle-domains':
            return new _LeftTrackModifier2['default'](new _Horizontal2DDomainsTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }));

          case 'horizontal-2d-rectangle-domains':
            return new _Horizontal2DDomainsTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            });

          case 'arrowhead-domains':
            return new _ArrowheadDomainsTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            });

          case 'square-markers':
            return new _SquareMarkersTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            });

          case 'combined':
            return new _CombinedTrack2['default'](track.contents, this.createTrackObject.bind(this), handleTilesetInfoReceived, track.options);

          case '2d-chromosome-labels':
            return new _Chromosome2DLabels2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            });

          case '2d-chromosome-grid':
            return new _Chromosome2DGrid2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, track.chromInfoPath);

          case 'horizontal-chromosome-labels':
            // chromInfoPath is passed in for backwards compatibility
            // it can be used to provide custom chromosome sizes
            return new _HorizontalChromosomeLabels2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, track.chromInfoPath);

          case 'vertical-chromosome-labels':
            // chromInfoPath is passed in for backwards compatibility
            // it can be used to provide custom chromosome sizes
            return new _LeftTrackModifier2['default'](new _HorizontalChromosomeLabels2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, track.chromInfoPath));
          case 'horizontal-heatmap':
            return new _HorizontalHeatmapTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, this.svgElement, function () {
              return _this4.currentProps.onValueScaleChanged(track.uid);
            }, function (newOptions) {
              return _this4.currentProps.onTrackOptionsChanged(track.uid, newOptions);
            });

          case 'vertical-heatmap':
            return new _LeftTrackModifier2['default'](new _HorizontalHeatmapTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }, this.svgElement, function () {
              return _this4.currentProps.onValueScaleChanged(track.uid);
            }, function (newOptions) {
              return _this4.currentProps.onTrackOptionsChanged(track.uid, newOptions);
            }));

          case '2d-chromosome-annotations':
            return new _Chromosome2DAnnotations2['default'](this.pStage, track.chromInfoPath, track.options);

          case 'horizontal-1d-value-interval':
            return new _ValueIntervalTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            });

          case 'vertical-1d-value-interval':
            return new _LeftTrackModifier2['default'](new _ValueIntervalTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }));

          case 'osm-tiles':
            return new _OSMTilesTrack2['default'](this.pStage, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            });

          case 'mapbox-tiles':
            return new _MapboxTilesTrack2['default'](this.pStage, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            });

          case 'bedlike':
            return new _BedLikeTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            });

          case 'vertical-bedlike':
            return new _LeftTrackModifier2['default'](new _BedLikeTrack2['default'](this.pStage, dataConfig, handleTilesetInfoReceived, track.options, function () {
              return _this4.currentProps.onNewTilesLoaded(track.uid);
            }));

          default:
            console.warn('WARNING: unknown track type:', track.type);
            return new _UnknownPixiTrack2['default'](this.pStage, { name: 'Unknown Track Type' });
        }
      }

      return createTrackObject;
    }()

    /* ------------------------------- Render ------------------------------- */

  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this5 = this;

        return _react2['default'].createElement(
          'div',
          {
            ref: function () {
              function ref(c) {
                return _this5.divTrackArea = c;
              }

              return ref;
            }(),
            style: {
              height: this.currentProps.height,
              width: this.currentProps.width
            },
            className: 'TrackRenderer-module_track-renderer-3TM7n'
          },
          this.currentProps.children
        );
      }

      return render;
    }()
  }]);

  return TrackRenderer;
}(_react2['default'].Component);

TrackRenderer.propTypes = {
  canvasElement: _propTypes2['default'].object,
  centerHeight: _propTypes2['default'].number,
  centerWidth: _propTypes2['default'].number,
  children: _propTypes2['default'].array,
  height: _propTypes2['default'].number,
  initialXDomain: _propTypes2['default'].array,
  initialYDomain: _propTypes2['default'].array,
  isRangeSelection: _propTypes2['default'].bool,
  leftWidth: _propTypes2['default'].number,
  marginLeft: _propTypes2['default'].number,
  marginTop: _propTypes2['default'].number,
  onScalesChanged: _propTypes2['default'].func,
  pixiStage: _propTypes2['default'].object,
  positionedTracks: _propTypes2['default'].array,
  svgElement: _propTypes2['default'].object,
  topHeight: _propTypes2['default'].number,
  width: _propTypes2['default'].number
};

exports['default'] = TrackRenderer;

/***/ }),
/* 635 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_zoom__ = __webpack_require__(636);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return __WEBPACK_IMPORTED_MODULE_0__src_zoom__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_transform__ = __webpack_require__(240);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return __WEBPACK_IMPORTED_MODULE_1__src_transform__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return __WEBPACK_IMPORTED_MODULE_1__src_transform__["c"]; });




/***/ }),
/* 636 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dispatch__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_drag__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_interpolate__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3_selection__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_d3_transition__ = __webpack_require__(193);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__constant__ = __webpack_require__(637);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__event__ = __webpack_require__(638);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__transform__ = __webpack_require__(240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__noevent__ = __webpack_require__(639);










// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].button;
}

function defaultExtent() {
  var e = this, w, h;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    w = e.width.baseVal.value;
    h = e.height.baseVal.value;
  } else {
    w = e.clientWidth;
    h = e.clientHeight;
  }
  return [[0, 0], [w, h]];
}

function defaultTransform() {
  return this.__zoom || __WEBPACK_IMPORTED_MODULE_7__transform__["c" /* identity */];
}

function defaultWheelDelta() {
  return -__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].deltaY * (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].deltaMode ? 120 : 1) / 500;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = __WEBPACK_IMPORTED_MODULE_2_d3_interpolate__["i" /* interpolateZoom */],
      gestures = [],
      listeners = Object(__WEBPACK_IMPORTED_MODULE_0_d3_dispatch__["a" /* dispatch */])("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    });
  };

  zoom.scaleTo = function(selection, k) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = centroid(e),
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    });
  };

  zoom.translateBy = function(selection, x, y) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function(selection, x, y) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p = centroid(e);
      return constrain(__WEBPACK_IMPORTED_MODULE_7__transform__["c" /* identity */].translate(p[0], p[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    });
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new __WEBPACK_IMPORTED_MODULE_7__transform__["a" /* Transform */](k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new __WEBPACK_IMPORTED_MODULE_7__transform__["a" /* Transform */](transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, center) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = center || centroid(e),
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new __WEBPACK_IMPORTED_MODULE_7__transform__["a" /* Transform */](k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args) {
    for (var i = 0, n = gestures.length, g; i < n; ++i) {
      if ((g = gestures[i]).that === that) {
        return g;
      }
    }
    return new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.index = -1;
    this.active = 0;
    this.extent = extent.apply(that, args);
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.index = gestures.push(this) - 1;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        gestures.splice(this.index, 1);
        this.index = -1;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["customEvent"])(new __WEBPACK_IMPORTED_MODULE_6__event__["a" /* default */](zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["mouse"])(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      Object(__WEBPACK_IMPORTED_MODULE_4_d3_transition__["a" /* interrupt */])(this);
      g.start();
    }

    Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["a" /* default */])();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        v = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["select"])(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["mouse"])(this),
        x0 = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].clientX,
        y0 = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].clientY;

    Object(__WEBPACK_IMPORTED_MODULE_1_d3_drag__["dragDisable"])(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].view);
    Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["b" /* nopropagation */])();
    g.mouse = [p, this.__zoom.invert(p)];
    Object(__WEBPACK_IMPORTED_MODULE_4_d3_transition__["a" /* interrupt */])(this);
    g.start();

    function mousemoved() {
      Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["a" /* default */])();
      if (!g.moved) {
        var dx = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].clientX - x0, dy = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["mouse"])(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      Object(__WEBPACK_IMPORTED_MODULE_1_d3_drag__["dragEnable"])(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].view, g.moved);
      Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["a" /* default */])();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["mouse"])(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

    Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["a" /* default */])();
    if (duration > 0) Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["select"])(this).transition().duration(duration).call(schedule, t1, p0);
    else Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["select"])(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        touches = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].changedTouches,
        started,
        n = touches.length, i, t, p;

    Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["b" /* nopropagation */])();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["touch"])(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true;
      else if (!g.touch1) g.touch1 = p;
    }

    // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.
    if (touchstarting) {
      touchstarting = clearTimeout(touchstarting);
      if (!g.touch1) {
        g.end();
        p = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["select"])(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
        return;
      }
    }

    if (started) {
      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      Object(__WEBPACK_IMPORTED_MODULE_4_d3_transition__["a" /* interrupt */])(this);
      g.start();
    }
  }

  function touchmoved() {
    var g = gesture(this, arguments),
        touches = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].changedTouches,
        n = touches.length, i, t, p, l;

    Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["a" /* default */])();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["touch"])(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    var g = gesture(this, arguments),
        touches = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["event"].changedTouches,
        n = touches.length, i, t;

    Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["b" /* nopropagation */])();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else g.end();
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_5__constant__["a" /* default */])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_5__constant__["a" /* default */])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_5__constant__["a" /* default */])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_5__constant__["a" /* default */])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
});


/***/ }),
/* 637 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 638 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ZoomEvent;
function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}


/***/ }),
/* 639 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = nopropagation;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(4);


function nopropagation() {
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["event"].stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["event"].preventDefault();
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["event"].stopImmediatePropagation();
});


/***/ }),
/* 640 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

// Services


var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _utils = __webpack_require__(3);

var _services = __webpack_require__(7);

var _worker = __webpack_require__(80);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DataFetcher = function () {
  function DataFetcher(dataConfig) {
    _classCallCheck(this, DataFetcher);

    //console.log('data fetcher config:',  dataConfig);
    this.tilesetInfoLoading = true;

    // copy the dataConfig so that it doesn't dirty so that
    // it doesn't get modified when we make objects of its
    // children below
    this.dataConfig = JSON.parse(JSON.stringify(dataConfig));
    this.uuid = _slugid2['default'].nice();

    if (this.dataConfig.children) {
      // convert each child into an object
      this.dataConfig.children = dataConfig.children.map(function (c) {
        return new DataFetcher(c);
      });
    }
  }

  _createClass(DataFetcher, [{
    key: 'tilesetInfo',
    value: function () {
      function tilesetInfo(finished) {
        var _this = this;

        /**
         * Obtain tileset infos for all of the tilesets listed
         *
         * If there is more than one tileset info, this function
         * should (not currently implemented) check if the tileset
         * infos have the same dimensions and then return a common
         * one.
         * 
         * Paremeters
         * ----------
         *  finished: function
         *    A callback that will be called when all tileset infos are loaded
         */

        if (!this.dataConfig.children) {
          if (!this.dataConfig.server && !this.dataConfig.tilesetUid) {
            console.warn('No dataConfig children, server or tilesetUid:', this.dataConfig);
            finished(null);
          } else {
            // pass in the callback
            _services.tileProxy.trackInfo(this.dataConfig.server, this.dataConfig.tilesetUid, function (tilesetInfo) {
              // tileset infos are indxed by by tilesetUids, we can just resolve
              // that here before passing it back to the track
              finished(tilesetInfo[_this.dataConfig.tilesetUid]);
            });
          }
        } else {
          // this data source has children, so we need to wait to get
          // all of their tileset infos in order to return them to the track
          var promises = this.dataConfig.children.map(function (x) {
            return new Promise(function (resolve, reject) {
              x.tilesetInfo(resolve);
            });
          });

          Promise.all(promises).then(function (values) {
            // this is where we should check if all the children's tileset
            // infos match
            finished(values[0]);
          });
        }
      }

      return tilesetInfo;
    }()
  }, {
    key: 'fullTileId',
    value: function () {
      function fullTileId(tilesetUid, tileId) {
        /**
         * Convert a tilesetUid and tileId into a full tile
         * identifier
         *
         * Parameters
         * ----------
         *  tilesetUid: string
         *    Uid of the tileset on the server
         *
         *  tileId: string
         *    The tileId of the tile
         *
         *  Returns
         *  -------
         *    fullTileId: string
         *      The full tile id that the server will parse.
         *      E.g. xyxx.0.0.0.default
         */

        return tilesetUid + '.' + tileId;
      }

      return fullTileId;
    }()
  }, {
    key: 'fetchTilesDebounced',
    value: function () {
      function fetchTilesDebounced(receivedTiles, tileIds) {
        var _this2 = this;

        /**
         * Fetch a set of tiles.
         *
         * Because the track shouldn't care about tileset ids, the tile ids
         * should just include positions and any necessary transforms.
         *
         * Parameters
         * ----------
         *  receivedTiles: callback
         *    A function to call once the tiles have been
         *    fetched
         *  tileIds: []
         *    The tile ids to fetch
         */

        if (!this.dataConfig.children) {
          // no children, just return the fetched tiles as is
          var promise = new Promise(function (resolve, reject) {
            return _services.tileProxy.fetchTilesDebounced({
              id: _slugid2['default'].nice(),
              server: _this2.dataConfig.server,
              done: resolve,
              ids: tileIds.map(function (x) {
                return _this2.dataConfig.tilesetUid + '.' + x;
              })
            });
          });
          promise.then(function (returnedTiles) {
            // console.log('tileIds:', tileIds);
            var tilesetUid = (0, _utils.dictValues)(returnedTiles)[0].tilesetUid;
            // console.log('tilesetUid:', tilesetUid);
            var newTiles = {};

            for (var i = 0; i < tileIds.length; i++) {
              var fullTileId = _this2.fullTileId(tilesetUid, tileIds[i]);

              returnedTiles[fullTileId].tilePositionId = tileIds[i];
              newTiles[tileIds[i]] = returnedTiles[fullTileId];
            }

            receivedTiles(newTiles);
          });
        } else {
          // multiple child tracks, need to wait for all of them to
          // fetch their data before returning to the parent
          var promises = this.dataConfig.children.map(function (x) {
            return new Promise(function (resolve, reject) {
              x.fetchTilesDebounced(resolve, tileIds);
            });
          });

          Promise.all(promises).then(function (returnedTiles) {
            //console.log('returnedTiles:', returnedTiles);

            // if we're trying to divide two datasets, 
            if (_this2.dataConfig.type == 'divided') {
              if (returnedTiles.length < 2) {
                console.warn("Only one tileset specified for a divided datafetcher:", _this2.dataConfig);
              }

              //console.log('tileUids:', tileIds);

              var numeratorTilesetUid = (0, _utils.dictValues)(returnedTiles[0])[0].tilesetUid;
              var denominatorTilesetUid = (0, _utils.dictValues)(returnedTiles[1])[0].tilesetUid;

              var newTiles = {};

              for (var i = 0; i < tileIds.length; i++) {
                var numeratorUid = _this2.fullTileId(numeratorTilesetUid, tileIds[i]);
                var denominatorUid = _this2.fullTileId(denominatorTilesetUid, tileIds[i]);

                newData = _this2.divideData(returnedTiles[0][tileIds[i]].dense, returnedTiles[1][tileIds[i]].dense);

                var zoomLevel = returnedTiles[0][tileIds[i]].zoomLevel;
                var tilePos = returnedTiles[0][tileIds[i]].tilePos;

                var newTile = {
                  dense: newData,
                  minNonZero: (0, _worker.minNonZero)(newData),
                  maxNonZero: (0, _worker.maxNonZero)(newData),
                  zoomLevel: zoomLevel,
                  tilePos: tilePos,
                  tilePositionId: tileIds[i]

                  // returned ids will be indexed by the tile id and won't include the 
                  // tileset uid
                };newTiles[tileIds[i]] = newTile;
              }

              receivedTiles(newTiles);
            } else {
              // assume we're just returning raw tiles
              console.warn('Unimplemented dataConfig type. Returning first data source.', _this2.dataConfig);

              receivedTiles(returnedTiles[0]);
            }
          });
        }
      }

      return fetchTilesDebounced;
    }()
  }, {
    key: 'divideData',
    value: function () {
      function divideData(numeratorData, denominatorData) {
        /**
         * Return an array consisting of the division of the numerator
         * array by the denominator array
         *
         * Parameters
         * ----------
         *  numeratorData: array
         *    An array of numerical values
         *  denominatorData:
         *    An array of numerical values
         *
         * Returns
         * -------
         *  divided: array
         *    An array consisting of the division of the
         *    numerator by the denominator
         */
        var result = new Float32Array(numeratorData.length);

        for (var i = 0; i < result.length; i++) {
          if (denominatorData[i] == 0.) result[i] = NaN;else result[i] = numeratorData[i] / denominatorData[i];
        }

        return result;
      }

      return divideData;
    }()
  }]);

  return DataFetcher;
}();

exports['default'] = DataFetcher;

/***/ }),
/* 641 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Id2DTiledPixiTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _HeatmapTiledPixiTrack = __webpack_require__(82);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Id2DTiledPixiTrack = exports.Id2DTiledPixiTrack = function (_HeatmapTiledPixiTrac) {
  _inherits(Id2DTiledPixiTrack, _HeatmapTiledPixiTrac);

  function Id2DTiledPixiTrack(scene, dataConfig, handleTilesetInfoReceived, options, animate) {
    _classCallCheck(this, Id2DTiledPixiTrack);

    return _possibleConstructorReturn(this, (Id2DTiledPixiTrack.__proto__ || Object.getPrototypeOf(Id2DTiledPixiTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, options, animate));
  }

  _createClass(Id2DTiledPixiTrack, [{
    key: 'areAllVisibleTilesLoaded',
    value: function () {
      function areAllVisibleTilesLoaded() {
        // we don't need to wait for any tiles to load before
        // drawing
        //
        return true;
      }

      return areAllVisibleTilesLoaded;
    }()
  }, {
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        /**
             * Create whatever is needed to draw this tile.
             */

        var graphics = tile.graphics;
        tile.textGraphics = new PIXI.Graphics();
        // tile.text = new PIXI.Text(tile.tileData.zoomLevel + "/" + tile.tileData.tilePos.join('/') + '/' + tile.mirrored,

        if (tile.mirrored) {
          // mirrored tiles have their x and y coordinates reversed
          tile.text = new PIXI.Text(tile.tileData.zoomLevel + '/' + [tile.tileData.tilePos[1], tile.tileData.tilePos[0]].join('/'), { fontFamily: 'Arial', fontSize: 48, fill: 0xff1010, align: 'center' });
        } else {
          tile.text = new PIXI.Text(tile.tileData.zoomLevel + '/' + tile.tileData.tilePos.join('/'), { fontFamily: 'Arial', fontSize: 48, fill: 0xff1010, align: 'center' });
        }

        // tile.text.y = 100;
        tile.textGraphics.addChild(tile.text);

        tile.text.anchor.x = 0.5;
        tile.text.anchor.y = 0.5;

        graphics.addChild(tile.textGraphics);

        this.drawTile(tile, graphics);
      }

      return initTile;
    }()
  }, {
    key: 'destroyTile',
    value: function () {
      function destroyTile(tile, graphics) {}

      return destroyTile;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tile) {
        if (!tile.graphics) {
          return;
        }

        // console.log('Id2DTiled drawTile...', tile);
        var graphics = tile.graphics;

        var _getTilePosAndDimensi = this.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos),
            tileX = _getTilePosAndDimensi.tileX,
            tileY = _getTilePosAndDimensi.tileY,
            tileWidth = _getTilePosAndDimensi.tileWidth,
            tileHeight = _getTilePosAndDimensi.tileHeight;

        // console.log('tileX:', tileX, 'tileY:', tileY, 'tileWidth:', tileWidth, 'tileHeight:', tileHeight);

        // the text needs to be scaled down so that it doesn't become huge
        // when we zoom in


        var tSX = 1 / ((this._xScale(1) - this._xScale(0)) / (this._refXScale(1) - this._refXScale(0)));
        var tSY = 1 / ((this._yScale(1) - this._yScale(0)) / (this._refYScale(1) - this._refYScale(0)));

        tile.text.scale.x = tSX;
        tile.text.scale.y = tSY;

        // console.log('tSX:', tSX, 'tSY:',tSY);

        graphics.clear();

        graphics.lineStyle(4 * tSX, 0x0000FF, 1);
        graphics.beginFill(0xFF700B, 0.4);
        graphics.alpha = 0.5;

        // line needs to be scaled down so that it doesn't become huge


        // fun tile positioning when it's mirrored, except this is just a rectangle
        // that doesn't need to be rotated so it's easy
        if (tile.mirrored) {
          var tileScaledWidth = this._refXScale(tileY + tileWidth) - this._refXScale(tileY);
          var tileScaledHeight = this._refYScale(tileX + tileWidth) - this._refYScale(tileX);

          // add tileScaledHeight / 2 and tileScaledWidth / 2 to center the text on the tile
          tile.textGraphics.position.x = this._refXScale(tileY) + tileScaledWidth / 2;
          tile.textGraphics.position.y = this._refYScale(tileX) + tileScaledHeight / 2;

          graphics.drawRect(this._refXScale(tileY), this._refYScale(tileX), tileScaledWidth, tileScaledHeight);
        } else {
          var _tileScaledWidth = this._refXScale(tileX + tileWidth) - this._refXScale(tileX);
          var _tileScaledHeight = this._refYScale(tileY + tileWidth) - this._refYScale(tileY);

          // add tileScaledHeight / 2 and tileScaledWidth / 2 to center the text on the tile
          tile.textGraphics.position.x = this._refXScale(tileX) + _tileScaledWidth / 2;
          tile.textGraphics.position.y = this._refYScale(tileY) + _tileScaledHeight / 2;

          var x = this._refXScale(tileX);
          var y = this._refYScale(tileY);

          graphics.drawRect(this._refXScale(tileX), this._refYScale(tileY), _tileScaledWidth, _tileScaledHeight);
        }
      }

      return drawTile;
    }()
  }, {
    key: 'fetchNewTiles',
    value: function () {
      function fetchNewTiles(toFetch) {
        var _this2 = this;

        // no real fetching involved... we just need to display the data
        toFetch.map(function (x) {
          var key = x.remoteId;
          var keyParts = key.split('.');

          var data = {
            zoomLevel: keyParts[0],
            tilePos: keyParts.slice(1, keyParts.length).map(function (x) {
              return +x;
            })
          };

          _this2.fetchedTiles[x.tileId] = x;
          _this2.fetchedTiles[x.tileId].tileData = data;

          // since we're not actually fetching remote data, we can easily
          // remove these tiles from the fetching list
          if (_this2.fetching.has(x.remoteId)) {
            _this2.fetching['delete'](x.remoteId);
          }
        });

        this.synchronizeTilesAndGraphics();
      }

      return fetchNewTiles;
    }()
  }]);

  return Id2DTiledPixiTrack;
}(_HeatmapTiledPixiTrack.HeatmapTiledPixiTrack);

exports['default'] = Id2DTiledPixiTrack;

/***/ }),
/* 642 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IdHorizontal1DTiledPixiTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _HorizontalTiled1DPixiTrack = __webpack_require__(60);

var _HorizontalTiled1DPixiTrack2 = _interopRequireDefault(_HorizontalTiled1DPixiTrack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var IdHorizontal1DTiledPixiTrack = exports.IdHorizontal1DTiledPixiTrack = function (_HorizontalTiled1DPix) {
  _inherits(IdHorizontal1DTiledPixiTrack, _HorizontalTiled1DPix);

  function IdHorizontal1DTiledPixiTrack(scene, dataConfig, handleTilesetInfoReceived, options, animate) {
    _classCallCheck(this, IdHorizontal1DTiledPixiTrack);

    var _this = _possibleConstructorReturn(this, (IdHorizontal1DTiledPixiTrack.__proto__ || Object.getPrototypeOf(IdHorizontal1DTiledPixiTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, options, animate));

    _this.pMain = _this.pMobile;
    return _this;
  }

  _createClass(IdHorizontal1DTiledPixiTrack, [{
    key: 'areAllVisibleTilesLoaded',
    value: function () {
      function areAllVisibleTilesLoaded() {
        // we don't need to wait for any tiles to load before
        // drawing
        //
        return true;
      }

      return areAllVisibleTilesLoaded;
    }()
  }, {
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        /**
             * Create whatever is needed to draw this tile.
             */

        var graphics = tile.graphics;
        tile.textGraphics = new PIXI.Graphics();
        // tile.text = new PIXI.Text(tile.tileData.zoomLevel + "/" + tile.tileData.tilePos.join('/') + '/' + tile.mirrored,

        tile.text = new PIXI.Text(tile.tileData.zoomLevel + '/' + tile.tileData.tilePos.join('/'), { fontFamily: 'Arial', fontSize: 32, fill: 0xff1010, align: 'center' });

        // tile.text.y = 100;
        tile.textGraphics.addChild(tile.text);

        tile.text.anchor.x = 0.5;
        tile.text.anchor.y = 0.5;

        graphics.addChild(tile.textGraphics);

        this.drawTile(tile);
      }

      return initTile;
    }()
  }, {
    key: 'destroyTile',
    value: function () {
      function destroyTile(tile) {}

      return destroyTile;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tile) {
        _get(IdHorizontal1DTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(IdHorizontal1DTiledPixiTrack.prototype), 'drawTile', this).call(this, tile);

        if (!tile.graphics) {
          return;
        }

        var graphics = tile.graphics;

        var _getTilePosAndDimensi = this.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos),
            tileX = _getTilePosAndDimensi.tileX,
            tileY = _getTilePosAndDimensi.tileY,
            tileWidth = _getTilePosAndDimensi.tileWidth,
            tileHeight = _getTilePosAndDimensi.tileHeight;

        // the text needs to be scaled down so that it doesn't become huge
        // when we zoom in


        var tSX = 1 / ((this._xScale(1) - this._xScale(0)) / (this._refXScale(1) - this._refXScale(0)));
        // let tSY = 1 / ((this._yScale(1) - this._yScale(0)) / (this._refYScale(1) - this._refYScale(0)));

        tile.text.scale.x = tSX;
        // tile.text.scale.y = tSY;

        // console.log('tSX:', tSX, 'tSY:',tSY);

        graphics.clear();

        // line needs to be scaled down so that it doesn't become huge

        var tileScaledHeight = this.dimensions[1];
        // fun tile positioning when it's mirrored, except this is just a rectangle
        // that doesn't need to be rotated so it's easy
        var tileScaledWidth = this._refXScale(tileX + tileWidth) - this._refXScale(tileX);

        // add tileScaledHeight / 2 and tileScaledWidth / 2 to center the text on the tile
        tile.textGraphics.position.x = this._refXScale(tileX) + tileScaledWidth / 2;
        tile.textGraphics.position.y = tileScaledHeight / 2;

        var rectX = this._refXScale(tileX);
        var rectY = 0;

        // console.log('rectX:', rectX, 'rectY:', rectY);
        // position the graphics
        // graphics.drawRect(rectX, 0, tileScaledWidth, tileScaledHeight);
        graphics.lineStyle(4 * tSX, 0x0000FF, 1);
        graphics.beginFill(0xFF700B, 0.4);
        graphics.alpha = 0.5;

        graphics.moveTo(rectX, 0);
        graphics.lineTo(rectX, tileScaledHeight);

        graphics.moveTo(rectX + tileScaledWidth, 0);
        graphics.lineTo(rectX + tileScaledWidth, tileScaledHeight);

        graphics.lineStyle(0, 0x0000FF, 1);
        graphics.drawRect(rectX, 0, tileScaledWidth, tileScaledHeight);
      }

      return drawTile;
    }()
  }, {
    key: 'fetchNewTiles',
    value: function () {
      function fetchNewTiles(toFetch) {
        var _this2 = this;

        // no real fetching involved... we just need to display the data
        toFetch.map(function (x) {
          var key = x.remoteId;
          var keyParts = key.split('.');

          var data = {
            zoomLevel: keyParts[1],
            tilePos: keyParts.slice(2, keyParts.length).map(function (x) {
              return +x;
            })
          };

          _this2.fetchedTiles[x.tileId] = x;
          _this2.fetchedTiles[x.tileId].tileData = data;

          // since we're not actually fetching remote data, we can easily
          // remove these tiles from the fetching list
          if (_this2.fetching.has(x.remoteId)) {
            _this2.fetching['delete'](x.remoteId);
          }
        });

        this.synchronizeTilesAndGraphics();
      }

      return fetchNewTiles;
    }()
  }]);

  return IdHorizontal1DTiledPixiTrack;
}(_HorizontalTiled1DPixiTrack2['default']);

exports['default'] = IdHorizontal1DTiledPixiTrack;

/***/ }),
/* 643 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IdVertical1DTiledPixiTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _VerticalTiled1DPixiTrack = __webpack_require__(644);

var _VerticalTiled1DPixiTrack2 = _interopRequireDefault(_VerticalTiled1DPixiTrack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var IdVertical1DTiledPixiTrack = exports.IdVertical1DTiledPixiTrack = function (_VerticalTiled1DPixiT) {
  _inherits(IdVertical1DTiledPixiTrack, _VerticalTiled1DPixiT);

  function IdVertical1DTiledPixiTrack(scene, dataConfig, handleTilesetInfoReceived, options, animate) {
    _classCallCheck(this, IdVertical1DTiledPixiTrack);

    return _possibleConstructorReturn(this, (IdVertical1DTiledPixiTrack.__proto__ || Object.getPrototypeOf(IdVertical1DTiledPixiTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, options, animate));
  }

  _createClass(IdVertical1DTiledPixiTrack, [{
    key: 'areAllVisibleTilesLoaded',
    value: function () {
      function areAllVisibleTilesLoaded() {
        // we don't need to wait for any tiles to load before
        // drawing
        //
        return true;
      }

      return areAllVisibleTilesLoaded;
    }()
  }, {
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        /**
             * Create whatever is needed to draw this tile.
             */

        var graphics = tile.graphics;
        tile.textGraphics = new PIXI.Graphics();
        // tile.text = new PIXI.Text(tile.tileData.zoomLevel + "/" + tile.tileData.tilePos.join('/') + '/' + tile.mirrored,

        tile.text = new PIXI.Text(tile.tileData.zoomLevel + '/' + tile.tileData.tilePos.join('/'), { fontFamily: 'Arial', fontSize: 32, fill: 0xff1010, align: 'center' });

        // tile.text.y = 100;
        tile.textGraphics.addChild(tile.text);

        tile.text.anchor.x = 0.5;
        tile.text.anchor.y = 0.5;

        tile.text.rotation = -Math.PI / 2;

        graphics.addChild(tile.textGraphics);

        this.drawTile(tile, graphics);
      }

      return initTile;
    }()
  }, {
    key: 'destroyTile',
    value: function () {
      function destroyTile(tile, graphics) {}

      return destroyTile;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tile) {
        _get(IdVertical1DTiledPixiTrack.prototype.__proto__ || Object.getPrototypeOf(IdVertical1DTiledPixiTrack.prototype), 'drawTile', this).call(this, tile);

        if (!tile.graphics) {
          return;
        }

        var graphics = tile.graphics;

        var _getTilePosAndDimensi = this.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos),
            tileY = _getTilePosAndDimensi.tileY,
            tileHeight = _getTilePosAndDimensi.tileHeight;

        // the text needs to be scaled down so that it doesn't become huge
        // when we zoom in
        // let tSX = 1 / ((this._xScale(1) - this._xScale(0)) / (this._refXScale(1) - this._refXScale(0)));


        var tSY = 1 / ((this._yScale(1) - this._yScale(0)) / (this._refYScale(1) - this._refYScale(0)));

        // tile.text.scale.x = tSX;
        tile.text.scale.x = tSY;

        // console.log('tSX:', tSX, 'tSY:',tSY);

        graphics.clear();

        graphics.lineStyle(4 * tSY, 0x0000FF, 1);
        graphics.beginFill(0xFF700B, 0.4);
        graphics.alpha = 0.5;

        // line needs to be scaled down so that it doesn't become huge

        var tileScaledWidth = this.dimensions[0];
        var tileScaledHeight = this._refYScale(tileY + tileHeight) - this._refYScale(tileY);

        // add tileScaledHeight / 2 and tileScaledWidth / 2 to center the text on the tile
        tile.textGraphics.position.x = tileScaledWidth / 2;
        tile.textGraphics.position.y = this._refYScale(tileY) + tileScaledHeight / 2;

        // position the graphics
        graphics.drawRect(0, this._refYScale(tileY), tileScaledWidth, tileScaledHeight);
      }

      return drawTile;
    }()
  }, {
    key: 'fetchNewTiles',
    value: function () {
      function fetchNewTiles(toFetch) {
        var _this2 = this;

        // no real fetching involved... we just need to display the data
        toFetch.map(function (x) {
          var key = x.remoteId;
          var keyParts = key.split('.');

          var data = {
            zoomLevel: keyParts[1],
            tilePos: keyParts.slice(2, keyParts.length).map(function (x) {
              return +x;
            })
          };

          _this2.fetchedTiles[x.tileId] = x;
          _this2.fetchedTiles[x.tileId].tileData = data;

          // since we're not actually fetching remote data, we can easily
          // remove these tiles from the fetching list
          if (_this2.fetching.has(x.remoteId)) {
            _this2.fetching['delete'](x.remoteId);
          }
        });

        this.synchronizeTilesAndGraphics();
      }

      return fetchNewTiles;
    }()
  }]);

  return IdVertical1DTiledPixiTrack;
}(_VerticalTiled1DPixiTrack2['default']);

exports['default'] = IdVertical1DTiledPixiTrack;

/***/ }),
/* 644 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerticalTiled1DPixiTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _Tiled1DPixiTrack2 = __webpack_require__(241);

var _Tiled1DPixiTrack3 = _interopRequireDefault(_Tiled1DPixiTrack2);

var _services = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VerticalTiled1DPixiTrack = exports.VerticalTiled1DPixiTrack = function (_Tiled1DPixiTrack) {
  _inherits(VerticalTiled1DPixiTrack, _Tiled1DPixiTrack);

  function VerticalTiled1DPixiTrack() {
    _classCallCheck(this, VerticalTiled1DPixiTrack);

    return _possibleConstructorReturn(this, (VerticalTiled1DPixiTrack.__proto__ || Object.getPrototypeOf(VerticalTiled1DPixiTrack)).apply(this, arguments));
  }

  _createClass(VerticalTiled1DPixiTrack, [{
    key: 'calculateZoomLevel',
    value: function () {
      function calculateZoomLevel() {
        var yZoomLevel = _services.tileProxy.calculateZoomLevel(this._yScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);

        var zoomLevel = Math.min(yZoomLevel, this.maxZoom);

        return zoomLevel;
      }

      return calculateZoomLevel;
    }()
  }, {
    key: 'relevantScale',
    value: function () {
      function relevantScale() {
        /**
             * Which scale should we use for calculating tile positions?
             *
             * Horizontal tracks should use the xScale and vertical tracks
             * should use the yScale
             *
             * This function should be overwritten by HorizontalTiled1DPixiTrack.js
             * and VerticalTiled1DPixiTrack.js
             */
        return this._yScale;
      }

      return relevantScale;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        _get(VerticalTiled1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(VerticalTiled1DPixiTrack.prototype), 'zoomed', this).call(this, newXScale, newYScale);

        // we only scale along 1 dimension
        var scaleX = 1;
        var scaleY = (newYScale(1) - newYScale(0)) / (this._refYScale(1) - this._refYScale(0));

        var translateX = this.position[0];
        var translateY = newYScale(0) + this.position[1] - this._refYScale(1) * scaleY;

        this.pMain.position.x = translateX;
        this.pMain.position.y = translateY;

        this.pMain.scale.x = scaleX;
        this.pMain.scale.y = scaleY;
      }

      return zoomed;
    }()
  }]);

  return VerticalTiled1DPixiTrack;
}(_Tiled1DPixiTrack3['default']);

exports['default'] = VerticalTiled1DPixiTrack;

/***/ }),
/* 645 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TopAxisTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _d3Axis = __webpack_require__(242);

var _SVGTrack2 = __webpack_require__(61);

var _SVGTrack3 = _interopRequireDefault(_SVGTrack2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TopAxisTrack = exports.TopAxisTrack = function (_SVGTrack) {
  _inherits(TopAxisTrack, _SVGTrack);

  function TopAxisTrack(svgElement) {
    _classCallCheck(this, TopAxisTrack);

    var _this = _possibleConstructorReturn(this, (TopAxisTrack.__proto__ || Object.getPrototypeOf(TopAxisTrack)).call(this, svgElement));

    _this.axis = (0, _d3Axis.axisTop)(_this._xScale);
    _this.gAxis = _this.gMain.append('g');

    // to make sure that the isWaitingOnTiles functions
    // return immediately
    _this.tilesetInfo = true;
    return _this;
  }

  _createClass(TopAxisTrack, [{
    key: 'setDimensions',
    value: function () {
      function setDimensions(newDimensions) {
        _get(TopAxisTrack.prototype.__proto__ || Object.getPrototypeOf(TopAxisTrack.prototype), 'setDimensions', this).call(this, newDimensions);

        // we generally want to be able display ticks for values in the billions
        // which means that we need extra spacing in our ticks
        this.axis.ticks(Math.ceil(this.dimensions[0] / 150));

        this.gAxis.attr('transform', 'translate(0,' + newDimensions[1] + ')');
      }

      return setDimensions;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        this.axis.scale(this._xScale);

        this.gAxis.call(this.axis);

        return this;
      }

      return draw;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        _get(TopAxisTrack.prototype.__proto__ || Object.getPrototypeOf(TopAxisTrack.prototype), 'zoomed', this).call(this, newXScale, newYScale);

        this.draw();
      }

      return zoomed;
    }()
  }]);

  return TopAxisTrack;
}(_SVGTrack3['default']);

exports['default'] = TopAxisTrack;

/***/ }),
/* 646 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = axisTop;
/* harmony export (immutable) */ __webpack_exports__["c"] = axisRight;
/* harmony export (immutable) */ __webpack_exports__["a"] = axisBottom;
/* harmony export (immutable) */ __webpack_exports__["b"] = axisLeft;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(647);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__identity__ = __webpack_require__(648);



var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number(scale) {
  return function(d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : __WEBPACK_IMPORTED_MODULE_1__identity__["a" /* default */]) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "#000"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "#000")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "#000")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter
            : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = __WEBPACK_IMPORTED_MODULE_0__array__["a" /* slice */].call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : __WEBPACK_IMPORTED_MODULE_0__array__["a" /* slice */].call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : __WEBPACK_IMPORTED_MODULE_0__array__["a" /* slice */].call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}


/***/ }),
/* 647 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return slice; });
var slice = Array.prototype.slice;


/***/ }),
/* 648 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x;
});


/***/ }),
/* 649 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeftAxisTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _d3Axis = __webpack_require__(242);

var _SVGTrack2 = __webpack_require__(61);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LeftAxisTrack = exports.LeftAxisTrack = function (_SVGTrack) {
  _inherits(LeftAxisTrack, _SVGTrack);

  function LeftAxisTrack(svgElement) {
    _classCallCheck(this, LeftAxisTrack);

    var _this = _possibleConstructorReturn(this, (LeftAxisTrack.__proto__ || Object.getPrototypeOf(LeftAxisTrack)).call(this, svgElement));

    _this.axis = (0, _d3Axis.axisLeft)(_this._yScale);
    _this.gAxis = _this.gMain.append('g');

    // to make sure that the isWaitingOnTiles functions
    // return immediately
    _this.tilesetInfo = true;
    return _this;
  }

  _createClass(LeftAxisTrack, [{
    key: 'setDimensions',
    value: function () {
      function setDimensions(newDimensions) {
        _get(LeftAxisTrack.prototype.__proto__ || Object.getPrototypeOf(LeftAxisTrack.prototype), 'setDimensions', this).call(this, newDimensions);

        // match the spacing of the TopAxisTrack ticks
        this.axis.ticks(Math.ceil(this.dimensions[1] / 150));
        this.gAxis.attr('transform', 'translate(' + newDimensions[0] + ',0)');
      }

      return setDimensions;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        this.axis.scale(this._yScale);
        this.gAxis.call(this.axis);

        return this;
      }

      return draw;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        _get(LeftAxisTrack.prototype.__proto__ || Object.getPrototypeOf(LeftAxisTrack.prototype), 'zoomed', this).call(this, newXScale, newYScale);

        this.draw();
      }

      return zoomed;
    }()
  }]);

  return LeftAxisTrack;
}(_SVGTrack2.SVGTrack);

exports['default'] = LeftAxisTrack;

/***/ }),
/* 650 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CombinedTrack = function () {
  function CombinedTrack(trackDefs, trackCreator) {
    var _this = this;

    _classCallCheck(this, CombinedTrack);

    this.childTracks = trackDefs.map(trackCreator);
    this.createdTracks = {};

    this.childTracks.forEach(function (ct, i) {
      _this.createdTracks[trackDefs[i].uid] = ct;
    });

    for (var i = 0; i < this.childTracks.length; i++) {
      if (!this.childTracks[i]) {
        console.error('Empty child track in CombinedTrack:', this);
      }
    }
  }

  _createClass(CombinedTrack, [{
    key: 'updateContents',
    value: function () {
      function updateContents(newContents, trackCreator) {
        var _this2 = this;

        var newTracks = [];
        var currentTracks = new Set();

        // go through the new track list and create tracks which we don't
        // already have
        newContents.forEach(function (nc) {
          currentTracks.add(nc.uid);

          if (nc.uid in _this2.createdTracks) {
            newTracks.push(_this2.createdTracks[nc.uid]);
          } else {
            var newTrack = trackCreator(nc);
            newTrack.setPosition(_this2.position);
            newTrack.setDimensions(_this2.dimensions);
            newTracks.push(newTrack);

            newTrack.zoomed(_this2._xScale, _this2._yScale);

            _this2.createdTracks[nc.uid] = newTrack;
          }
        });

        this.childTracks = newTracks;

        // remove the ones that were previously, but no longer, present
        var knownTracks = new Set(Object.keys(this.createdTracks));
        var exitTracks = new Set([].concat(_toConsumableArray(knownTracks)).filter(function (x) {
          return !currentTracks.has(x);
        }));
        [].concat(_toConsumableArray(exitTracks)).forEach(function (trackUid) {
          _this2.createdTracks[trackUid].remove();
          delete _this2.createdTracks[trackUid];
        });

        return this;
      }

      return updateContents;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        /**
             * Setting the position of this track simply means setting the positions
             * of its children.
             */
        this.position = newPosition;

        for (var i = 0; i < this.childTracks.length; i++) {
          this.childTracks[i].setPosition(newPosition);
        }
      }

      return setPosition;
    }()
  }, {
    key: 'setDimensions',
    value: function () {
      function setDimensions(newDimensions) {
        this.dimensions = newDimensions;

        for (var i = 0; i < this.childTracks.length; i++) {
          this.childTracks[i].setDimensions(newDimensions);
        }
      }

      return setDimensions;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale, k, x, y, xPositionOffset, yPositionOffset) {
        this._xScale = newXScale;
        this._yScale = newYScale;

        for (var i = 0; i < this.childTracks.length; i++) {
          this.childTracks[i].zoomed(newXScale, newYScale, k, x, y, xPositionOffset, yPositionOffset);
        }
      }

      return zoomed;
    }()
  }, {
    key: 'refXScale',
    value: function () {
      function refXScale(xScale) {
        for (var i = 0; i < this.childTracks.length; i++) {
          this.childTracks[i].refXScale(xScale);
        }
      }

      return refXScale;
    }()
  }, {
    key: 'refYScale',
    value: function () {
      function refYScale(yScale) {
        for (var i = 0; i < this.childTracks.length; i++) {
          this.childTracks[i].refYScale(yScale);
        }
      }

      return refYScale;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        for (var i = 0; i < this.childTracks.length; i++) {
          this.childTracks[i].draw();
        }
      }

      return draw;
    }()
  }, {
    key: 'xScale',
    value: function () {
      function xScale(_xScale) {
        this._xScale = _xScale;

        for (var i = 0; i < this.childTracks.length; i++) {
          this.childTracks[i].xScale(_xScale);
        }
      }

      return xScale;
    }()
  }, {
    key: 'yScale',
    value: function (_yScale) {
      function yScale(_x) {
        return _yScale.apply(this, arguments);
      }

      yScale.toString = function () {
        return _yScale.toString();
      };

      return yScale;
    }(function (xScale) {
      this._yScale = yScale;

      for (var i = 0; i < this.childTracks.length; i++) {
        this.childTracks[i].yScale(yScale);
      }
    })
  }, {
    key: 'refScalesChanged',
    value: function () {
      function refScalesChanged(refXScale, refYScale) {
        for (var i = 0; i < this.childTracks.length; i++) {
          this.childTracks[i].refScalesChanged(refXScale, refYScale);
        }
      }

      return refScalesChanged;
    }()
  }, {
    key: 'remove',
    value: function () {
      function remove() {
        for (var i = 0; i < this.childTracks.length; i++) {
          this.childTracks[i].remove();
        }
      }

      return remove;
    }()
  }, {
    key: 'exportSVG',
    value: function () {
      function exportSVG() {
        var svg = document.createElement('g');

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.childTracks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var childTrack = _step.value;

            if (childTrack.exportSVG) {
              // exportSVG returns a tuple containing the base element
              // and the element onto which to draw extra features
              // in our case, we only need the complete svg
              svg.appendChild(childTrack.exportSVG()[0]);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return [svg, svg];
      }

      return exportSVG;
    }()
  }, {
    key: 'rerender',
    value: function () {
      function rerender(options) {
        // console.log('COMBINED TRACK rerender...');
      }

      return rerender;
    }()
  }, {
    key: 'minValue',
    value: function () {
      function minValue() {
        if (arguments.length == 0) {
          var minValues = this.childTracks.filter(function (x) {
            return x.minValue;
          }) // filter for tracks which have the minValue function
          .map(function (x) {
            return x.minValue();
          }) // get the minValue for each track
          .filter(function (x) {
            return x;
          }); // filter out undefineds

          return Math.min.apply(Math, _toConsumableArray(minValues));
        }
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.childTracks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var childTrack = _step2.value;

            if (childTrack.minValue) {
              childTrack.minValue(_);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      return minValue;
    }()
  }, {
    key: 'maxValue',
    value: function () {
      function maxValue(_) {
        if (arguments.length == 0) {
          var maxValues = this.childTracks.filter(function (x) {
            return x.maxValue;
          }) // filter for tracks which have the minValue function
          .map(function (x) {
            return x.maxValue();
          }) // get the minValue for each track
          .filter(function (x) {
            return x;
          }); // filter out undefineds

          return Math.max.apply(Math, _toConsumableArray(maxValues));
        }
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.childTracks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var childTrack = _step3.value;

            if (childTrack.maxValue) {
              childTrack.maxValue(_);
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3['return']) {
              _iterator3['return']();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      return maxValue;
    }()
  }]);

  return CombinedTrack;
}();

exports.CombinedTrack = CombinedTrack;
exports['default'] = CombinedTrack;

/***/ }),
/* 651 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BedLikeTrack = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _boxIntersect = __webpack_require__(84);

var _boxIntersect2 = _interopRequireDefault(_boxIntersect);

var _d3Array = __webpack_require__(10);

var _HorizontalTiled1DPixiTrack = __webpack_require__(60);

var _HorizontalTiled1DPixiTrack2 = _interopRequireDefault(_HorizontalTiled1DPixiTrack);

var _services = __webpack_require__(7);

var _utils = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Services


// Utils


var GENE_RECT_WIDTH = 1;
var GENE_RECT_HEIGHT = 10;
var MAX_TEXTS = 20;
var MAX_TILE_ENTRIES = 1000;

var BedLikeTrack = exports.BedLikeTrack = function (_HorizontalTiled1DPix) {
  _inherits(BedLikeTrack, _HorizontalTiled1DPix);

  function BedLikeTrack(scene, dataConfig, handleTilesetInfoReceived, options, animate) {
    _classCallCheck(this, BedLikeTrack);

    var _this = _possibleConstructorReturn(this, (BedLikeTrack.__proto__ || Object.getPrototypeOf(BedLikeTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, options, animate));

    _this.textFontSize = '10px';
    _this.textFontFamily = 'Arial';

    _this.drawnRects = {};
    return _this;
  }

  _createClass(BedLikeTrack, [{
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        var _this2 = this;

        // create texts
        tile.texts = {};

        tile.rectGraphics = new PIXI.Graphics();
        tile.textGraphics = new PIXI.Graphics();

        tile.graphics.addChild(tile.rectGraphics);
        tile.graphics.addChild(tile.textGraphics);

        if (tile.tileData && tile.tileData.length) {
          tile.tileData.sort(function (a, b) {
            return b.importance - a.importance;
          });
          tile.tileData = tile.tileData.slice(0, MAX_TILE_ENTRIES);

          tile.tileData.forEach(function (td, i) {
            var geneInfo = td.fields;
            var fill = _this2.options.fillColor ? _this2.options.fillColor : 'blue';

            tile.textWidths = {};

            // don't draw texts for the latter entries in the tile
            if (i >= MAX_TEXTS) {
              return;
            }

            // geneInfo[3] is the gene symbol
            var text = new PIXI.Text(geneInfo[3], { fontSize: _this2.textFontSize,
              fontFamily: _this2.textFontFamily,
              fill: (0, _utils.colorToHex)(fill) });
            if (_this2.flipText) {
              text.scale.x = -1;
            }

            text.anchor.x = 0.5;
            text.anchor.y = 1;

            tile.texts[geneInfo[3]] = text; // index by geneName

            tile.textGraphics.addChild(text);
          });
        }

        tile.initialized = true;

        this.renderTile(tile);
        // this.draw();
      }

      return initTile;
    }()
  }, {
    key: 'destroyTile',
    value: function () {
      function destroyTile(tile) {
        var _this3 = this;

        // remove texts
        var zoomLevel = +tile.tileId.split('.')[0];

        if (tile.tileData && tile.tileData.length) {
          tile.tileData.forEach(function (td, i) {

            if (_this3.drawnRects[zoomLevel] && _this3.drawnRects[zoomLevel][td.uid]) delete _this3.drawnRects[zoomLevel][td.uid];
          });
        }
      }

      return destroyTile;
    }()
  }, {
    key: 'removeTiles',
    value: function () {
      function removeTiles(toRemoveIds) {
        _get(BedLikeTrack.prototype.__proto__ || Object.getPrototypeOf(BedLikeTrack.prototype), 'removeTiles', this).call(this, toRemoveIds);

        // we're going to rerender after destroying tiles to make sure
        // any rectangles that were listed under 'drawnRects' don't get
        // ignored
        this.rerender(this.options);
      }

      return removeTiles;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tile) {
        if (this.options && this.options.valueColumn) {
          if (this.valueScale)
            // there might no be a value scale if no valueColumn
            // was specified
            this.drawAxis(this.valueScale);
        }
      }

      return drawTile;
    }()
  }, {
    key: 'rerender',
    value: function () {
      function rerender(options, force) {
        _get(BedLikeTrack.prototype.__proto__ || Object.getPrototypeOf(BedLikeTrack.prototype), 'rerender', this).call(this, options, force);

        this.drawnRects = {};

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.visibleAndFetchedTiles()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tile = _step.value;

            tile.rectGraphics.clear();
            this.renderTile(tile);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return rerender;
    }()
  }, {
    key: 'renderTile',
    value: function () {
      function renderTile(tile) {
        var _this4 = this;

        if (!tile.initialized) {
          return;
        }

        var zoomLevel = +tile.tileId.split('.')[0];

        // store the scale at while the tile was drawn at so that
        // we only resize it when redrawing
        tile.drawnAtScale = this._xScale.copy();
        var fill = (0, _utils.colorToHex)(this.options.fillColor ? this.options.fillColor : 'blue');

        if (this.options && this.options.valueColumn) {
          /**
           * These intervals come with some y-value that we want to plot
           */
          this.valueScale = this.makeValueScale(this.minVisibleValue(), this.calculateMedianVisibleValue(), this.maxVisibleValue());
        }

        if (tile.tileData && tile.tileData.length) {
          tile.tileData.forEach(function (td, i) {
            // don't draw anything that has already been drawn
            if (zoomLevel in _this4.drawnRects && td.uid in _this4.drawnRects[zoomLevel]) return;

            var geneInfo = td.fields;
            // the returned positions are chromosome-based and they need to
            // be converted to genome-based
            var chrOffset = +td.chrOffset;

            var txStart = +geneInfo[1] + chrOffset;
            var txEnd = +geneInfo[2] + chrOffset;
            var exonStarts = geneInfo[12],
                exonEnds = geneInfo[13];

            var txMiddle = (txStart + txEnd) / 2;

            var yMiddle = _this4.dimensions[1] / 2;
            var textYMiddle = _this4.dimensions[1] / 2;
            var geneName = geneInfo[3];
            var rectHeight = GENE_RECT_HEIGHT;

            if (_this4.options && _this4.options.valueColumn) {
              // These intervals come with some y-value that we want to plot

              yMiddle = _this4.valueScale(+geneInfo[+_this4.options.valueColumn - 1]);
              // console.log('valueScale:', this.valueScale.domain() );
              // console.log('yMiddle:', +geneInfo[+this.options.valueColumn-1], yMiddle);
              rectHeight = GENE_RECT_HEIGHT / 2;
            }

            // for when there's text
            // yMiddle -= 8;

            tile.rectGraphics.lineStyle(1, fill, 0.3);
            tile.rectGraphics.beginFill(fill, 0.3);

            // let height = valueScale(Math.log(+geneInfo[4]));
            // let width= height;

            var rectX = _this4._xScale(txMiddle) - rectHeight / 2;
            var rectY = yMiddle - rectHeight / 2;

            var xStartPos = _this4._xScale(txStart);
            var xEndPos = _this4._xScale(txEnd);

            var MIN_SIZE_FOR_EXONS = 10;

            // graphics.drawRect(rectX, rectY, width, height);

            // console.log('rectY:', rectY);
            tile.rectGraphics.drawRect(xStartPos, rectY, xEndPos - xStartPos, rectHeight);

            if (!_this4.drawnRects[zoomLevel]) _this4.drawnRects[zoomLevel] = {};

            _this4.drawnRects[zoomLevel][td.uid] = [xStartPos, rectY, xEndPos - xStartPos, GENE_RECT_HEIGHT];

            if (!tile.texts) {
              // tile probably hasn't been initialized yet
              return;
            }

            // don't draw texts for the latter entries in the tile
            if (i >= MAX_TEXTS) {
              return;
            }

            var text = tile.texts[geneName];

            text.position.x = _this4._xScale(txMiddle);
            // text.position.y = textYMiddle;
            text.style = { fontSize: _this4.textFontSize,
              fontFamily: _this4.textFontFamily,
              fill: fill };

            if (!(geneInfo[3] in tile.textWidths)) {
              text.updateTransform();
              var textWidth = text.getBounds().width;

              tile.textWidths[geneInfo[3]] = textWidth;
            }
          });
        }
      }

      return renderTile;
    }()
  }, {
    key: 'calculateZoomLevel',
    value: function () {
      function calculateZoomLevel() {
        // offset by 2 because 1D tiles are more dense than 2D tiles
        // 1024 points per tile vs 256 for 2D tiles
        var xZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);

        var zoomLevel = Math.min(xZoomLevel, this.maxZoom);
        zoomLevel = Math.max(zoomLevel, 0);

        return zoomLevel;
      }

      return calculateZoomLevel;
    }()
  }, {
    key: 'minVisibleValue',
    value: function () {
      function minVisibleValue() {
        var _this5 = this;

        var visibleAndFetchedIds = this.visibleAndFetchedIds();

        if (visibleAndFetchedIds.length == 0) {
          visibleAndFetchedIds = Object.keys(this.fetchedTiles);
        }

        var min = Math.min.apply(null, visibleAndFetchedIds.map(function (x) {
          return _this5.fetchedTiles[x];
        }).filter(function (x) {
          return x.tileData && x.tileData.length;
        }).map(function (x) {
          return x;
        }).map(function (x) {
          return Math.min.apply(null, x.tileData.sort(function (a, b) {
            return b.importance - a.importance;
          }).slice(0, MAX_TILE_ENTRIES).map(function (y) {
            return +y.fields[+_this5.options.valueColumn - 1];
          }));
        }));

        // if there's no data, use null
        if (min === Number.MAX_SAFE_INTEGER) {
          min = null;
        }

        return min;
      }

      return minVisibleValue;
    }()
  }, {
    key: 'maxVisibleValue',
    value: function () {
      function maxVisibleValue() {
        var _this6 = this;

        var visibleAndFetchedIds = this.visibleAndFetchedIds();

        if (visibleAndFetchedIds.length === 0) {
          visibleAndFetchedIds = Object.keys(this.fetchedTiles);
        }

        var max = Math.max.apply(null, visibleAndFetchedIds.map(function (x) {
          return _this6.fetchedTiles[x];
        }).filter(function (x) {
          return x.tileData && x.tileData.length;
        }).map(function (x) {
          return Math.max.apply(null, x.tileData.sort(function (a, b) {
            return b.importance - a.importance;
          }).slice(0, MAX_TILE_ENTRIES).map(function (y) {
            return +y.fields[+_this6.options.valueColumn - 1];
          }));
        }));

        // if there's no data, use null
        if (max === Number.MIN_SAFE_INTEGER) {
          max = null;
        }

        return max;
      }

      return maxVisibleValue;
    }()
  }, {
    key: 'calculateMedianVisibleValue',
    value: function () {
      function calculateMedianVisibleValue() {
        var _this7 = this;

        if (this.areAllVisibleTilesLoaded()) {
          this.allTilesLoaded();
        }

        var visibleAndFetchedIds = this.visibleAndFetchedIds();

        if (visibleAndFetchedIds.length === 0) {
          visibleAndFetchedIds = Object.keys(this.fetchedTiles);
        }

        var values = [].concat.apply([], visibleAndFetchedIds.map(function (x) {
          return _this7.fetchedTiles[x];
        }).filter(function (x) {
          return x.tileData && x.tileData.length;
        }).map(function (x) {
          return x.tileData.sort(function (a, b) {
            return b.importance - a.importance;
          }).slice(0, MAX_TILE_ENTRIES).map(function (y) {
            return +y.fields[+_this7.options.valueColumn - 1];
          });
        })).filter(function (x) {
          return x > 0;
        });

        this.medianVisibleValue = (0, _d3Array.median)(values);
      }

      return calculateMedianVisibleValue;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        var _this8 = this;

        _get(BedLikeTrack.prototype.__proto__ || Object.getPrototypeOf(BedLikeTrack.prototype), 'draw', this).call(this);
        // console.trace('drawing', this, this._xScale.domain(), this._xScale.range());

        // graphics.clear();

        var maxValue = 0;
        this.allTexts = [];
        this.allBoxes = [];

        var _loop = function () {
          function _loop(fetchedTileId) {
            var tile = _this8.fetchedTiles[fetchedTileId];

            // scale the rectangles

            var tileK = (tile.drawnAtScale.domain()[1] - tile.drawnAtScale.domain()[0]) / (_this8._xScale.domain()[1] - _this8._xScale.domain()[0]);
            var newRange = _this8._xScale.domain().map(tile.drawnAtScale);

            var posOffset = newRange[0];
            tile.rectGraphics.scale.x = tileK;
            tile.rectGraphics.position.x = -posOffset * tileK;

            // move the texts

            var parentInFetched = _this8.parentInFetched(tile);

            if (!tile.initialized) {
              return 'continue';
            }

            if (tile.tileData && tile.tileData.length) {
              tile.tileData.forEach(function (td, i) {
                if (!tile.texts) {
                  // tile probably hasn't been initialized yet
                  return;
                }

                var geneInfo = td.fields;
                var geneName = geneInfo[3];
                var text = tile.texts[geneName];

                if (!text) {
                  return;
                }

                var chrOffset = +td.chrOffset;
                var txStart = +geneInfo[1] + chrOffset;
                var txEnd = +geneInfo[2] + chrOffset;
                var txMiddle = (txStart + txEnd) / 2;
                var textYMiddle = _this8.dimensions[1] / 2;
                textYMiddle += 10;

                text.position.x = _this8._xScale(txMiddle);
                text.position.y = textYMiddle;

                if (!parentInFetched) {
                  // TODO, change the line below to true if texts are desired in the future
                  text.visible = false;

                  var TEXT_MARGIN = 3;
                  _this8.allBoxes.push([text.position.x - TEXT_MARGIN, textYMiddle - 1, text.position.x + tile.textWidths[geneInfo[3]] + TEXT_MARGIN, textYMiddle + 1]);
                  _this8.allTexts.push({ importance: +geneInfo[5], text: text, caption: geneName, strand: geneInfo[5] });
                } else {
                  text.visible = false;
                }
              });
            }
          }

          return _loop;
        }();

        for (var fetchedTileId in this.fetchedTiles) {
          var _ret = _loop(fetchedTileId);

          if (_ret === 'continue') continue;
        }

        /*
            for (let fetchedTileId in this.fetchedTiles) {
                let ft = this.fetchedTiles[fetchedTileId];
                 ft.tileData.forEach(td => {
                    let geneInfo = td.fields;
                    if (+geneInfo[4] > maxValue)
                        maxValue = geneInfo[4];
                });
            }
            */

        // console.trace('draw', allTexts.length);
        this.hideOverlaps(this.allBoxes, this.allTexts);
      }

      return draw;
    }()
  }, {
    key: 'hideOverlaps',
    value: function () {
      function hideOverlaps(allBoxes, allTexts) {
        // store the bounding boxes of the text objects so we can
        // calculate overlaps

        /*
            let allBoxes = allTexts.map(val => {
                let text = val.text;
                text.updateTransform();
                let b = text.getBounds();
                let box = [b.x, b.y, b.x + b.width, b.y + b.height];
                 return box;
            });
            */

        var result = (0, _boxIntersect2['default'])(allBoxes, function (i, j) {
          if (allTexts[i].importance > allTexts[j].importance) {
            allTexts[j].text.visible = false;
          } else {
            allTexts[i].text.visible = false;
          }
        });
      }

      return hideOverlaps;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(BedLikeTrack.prototype.__proto__ || Object.getPrototypeOf(BedLikeTrack.prototype), 'setPosition', this).call(this, newPosition);

        this.pMain.position.y = this.position[1];
        this.pMain.position.x = this.position[0];
      }

      return setPosition;
    }()
  }, {
    key: 'setDimensions',
    value: function () {
      function setDimensions(newDimensions) {
        _get(BedLikeTrack.prototype.__proto__ || Object.getPrototypeOf(BedLikeTrack.prototype), 'setDimensions', this).call(this, newDimensions);

        // redraw the contents
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.visibleAndFetchedTiles()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _tile = _step2.value;

            _tile.rectGraphics.clear();

            this.renderTile(_tile);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      return setDimensions;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        this.xScale(newXScale);
        this.yScale(newYScale);

        this.refreshTiles();

        this.draw();
      }

      return zoomed;
    }()
  }, {
    key: 'exportSVG',
    value: function () {
      function exportSVG() {
        var _this9 = this;

        var track = null,
            base = null;

        if (_get(BedLikeTrack.prototype.__proto__ || Object.getPrototypeOf(BedLikeTrack.prototype), 'exportSVG', this)) {
          var _get$call = _get(BedLikeTrack.prototype.__proto__ || Object.getPrototypeOf(BedLikeTrack.prototype), 'exportSVG', this).call(this);

          var _get$call2 = _slicedToArray(_get$call, 2);

          base = _get$call2[0];
          track = _get$call2[1];
        } else {
          base = document.createElement('g');
          track = base;
        }
        var output = document.createElement('g');
        output.setAttribute('transform', 'translate(' + this.position[0] + ',' + this.position[1] + ')');

        track.appendChild(output);

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          var _loop2 = function () {
            function _loop2() {
              var tile = _step3.value;

              tile.tileData.forEach(function (td, i) {
                var zoomLevel = +tile.tileId.split('.')[0];

                var gTile = document.createElement('g');
                gTile.setAttribute('transform', 'translate(' + tile.rectGraphics.position.x + ',' + tile.rectGraphics.position.y + ')scale(' + tile.rectGraphics.scale.x + ',' + tile.rectGraphics.scale.y + ')');
                output.appendChild(gTile);

                if (_this9.drawnRects[zoomLevel] && td.uid in _this9.drawnRects[zoomLevel]) {
                  var rect = _this9.drawnRects[zoomLevel][td.uid];

                  var r = document.createElement('rect');
                  r.setAttribute('x', rect[0]);
                  r.setAttribute('y', rect[1]);
                  r.setAttribute('width', rect[2]);
                  r.setAttribute('height', rect[3]);

                  r.setAttribute('fill', _this9.options.fillColor ? _this9.options.fillColor : 'blue');
                  r.setAttribute('opacity', 0.3);

                  r.style.stroke = _this9.options.fillColor ? _this9.options.fillColor : 'blue';
                  r.style.strokeWidth = "1px";

                  gTile.appendChild(r);
                }
              });
            }

            return _loop2;
          }();

          for (var _iterator3 = this.visibleAndFetchedTiles()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            _loop2();
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3['return']) {
              _iterator3['return']();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        return [base, base];
      }

      return exportSVG;
    }()
  }]);

  return BedLikeTrack;
}(_HorizontalTiled1DPixiTrack2['default']);

exports['default'] = BedLikeTrack;

/***/ }),
/* 652 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe

/***/ }),
/* 653 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//This code is extracted from ndarray-sort
//It is inlined here as a temporary workaround

module.exports = wrapper;

var INSERT_SORT_CUTOFF = 32

function wrapper(data, n0) {
  if (n0 <= 4*INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data);
  } else {
    quickSort(0, n0 - 1, data);
  }
}

function insertionSort(left, right, data) {
  var ptr = 2*(left+1)
  for(var i=left+1; i<=right; ++i) {
    var a = data[ptr++]
    var b = data[ptr++]
    var j = i
    var jptr = ptr-2
    while(j-- > left) {
      var x = data[jptr-2]
      var y = data[jptr-1]
      if(x < a) {
        break
      } else if(x === a && y < b) {
        break
      }
      data[jptr]   = x
      data[jptr+1] = y
      jptr -= 2
    }
    data[jptr]   = a
    data[jptr+1] = b
  }
}

function swap(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = x
  data[j+1] = y
}

function move(i, j, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[i+1] = data[j+1]
}

function rotate(i, j, k, data) {
  i *= 2
  j *= 2
  k *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = data[k]
  data[j+1] = data[k+1]
  data[k] = x
  data[k+1] = y
}

function shufflePivot(i, j, px, py, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[j] = px
  data[i+1] = data[j+1]
  data[j+1] = py
}

function compare(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i],
      y = data[j]
  if(x < y) {
    return false
  } else if(x === y) {
    return data[i+1] > data[j+1]
  }
  return true
}

function comparePivot(i, y, b, data) {
  i *= 2
  var x = data[i]
  if(x < y) {
    return true
  } else if(x === y) {
    return data[i+1] < b
  }
  return false
}

function quickSort(left, right, data) {
  var sixth = (right - left + 1) / 6 | 0, 
      index1 = left + sixth, 
      index5 = right - sixth, 
      index3 = left + right >> 1, 
      index2 = index3 - sixth, 
      index4 = index3 + sixth, 
      el1 = index1, 
      el2 = index2, 
      el3 = index3, 
      el4 = index4, 
      el5 = index5, 
      less = left + 1, 
      great = right - 1, 
      tmp = 0
  if(compare(el1, el2, data)) {
    tmp = el1
    el1 = el2
    el2 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }
  if(compare(el1, el3, data)) {
    tmp = el1
    el1 = el3
    el3 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el1, el4, data)) {
    tmp = el1
    el1 = el4
    el4 = tmp
  }
  if(compare(el3, el4, data)) {
    tmp = el3
    el3 = el4
    el4 = tmp
  }
  if(compare(el2, el5, data)) {
    tmp = el2
    el2 = el5
    el5 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }

  var pivot1X = data[2*el2]
  var pivot1Y = data[2*el2+1]
  var pivot2X = data[2*el4]
  var pivot2Y = data[2*el4+1]

  var ptr0 = 2 * el1;
  var ptr2 = 2 * el3;
  var ptr4 = 2 * el5;
  var ptr5 = 2 * index1;
  var ptr6 = 2 * index3;
  var ptr7 = 2 * index5;
  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data[ptr0+i1];
    var y = data[ptr2+i1];
    var z = data[ptr4+i1];
    data[ptr5+i1] = x;
    data[ptr6+i1] = y;
    data[ptr7+i1] = z;
  }

  move(index2, left, data)
  move(index4, right, data)
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1X, pivot1Y, data)) {
      if (k !== less) {
        swap(k, less, data)
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2X, pivot2Y, data)) {
        while (true) {
          if (!comparePivot(great, pivot2X, pivot2Y, data)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1X, pivot1Y, data)) {
              rotate(k, less, great, data)
              ++less;
              --great;
            } else {
              swap(k, great, data)
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less-1, pivot1X, pivot1Y, data)
  shufflePivot(right, great+1, pivot2X, pivot2Y, data)
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data);
  } else {
    quickSort(left, less - 2, data);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data);
  } else {
    quickSort(great + 2, right, data);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data);
  } else {
    quickSort(less, great, data);
  }
}

/***/ }),
/* 654 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = boxIntersectIter

var pool = __webpack_require__(141)
var bits = __webpack_require__(142)
var bruteForce = __webpack_require__(655)
var bruteForcePartial = bruteForce.partial
var bruteForceFull = bruteForce.full
var sweep = __webpack_require__(243)
var findMedian = __webpack_require__(656)
var genPartition = __webpack_require__(244)

//Twiddle parameters
var BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search
var SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan
var SCAN_COMPLETE_CUTOFF  = (1<<22)  

//Partition functions
var partitionInteriorContainsInterval = genPartition(
  '!(lo>=p0)&&!(p1>=hi)', 
  ['p0', 'p1'])

var partitionStartEqual = genPartition(
  'lo===p0',
  ['p0'])

var partitionStartLessThan = genPartition(
  'lo<p0',
  ['p0'])

var partitionEndLessThanEqual = genPartition(
  'hi<=p0',
  ['p0'])

var partitionContainsPoint = genPartition(
  'lo<=p0&&p0<=hi',
  ['p0'])

var partitionContainsPointProper = genPartition(
  'lo<p0&&p0<=hi',
  ['p0'])

//Frame size for iterative loop
var IFRAME_SIZE = 6
var DFRAME_SIZE = 2

//Data for box statck
var INIT_CAPACITY = 1024
var BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)
var BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)

//Initialize iterative loop queue
function iterInit(d, count) {
  var levels = (8 * bits.log2(count+1) * (d+1))|0
  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)
  if(BOX_ISTACK.length < maxInts) {
    pool.free(BOX_ISTACK)
    BOX_ISTACK = pool.mallocInt32(maxInts)
  }
  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)
  if(BOX_DSTACK < maxDoubles) {
    pool.free(BOX_DSTACK)
    BOX_DSTACK = pool.mallocDouble(maxDoubles)
  }
}

//Append item to queue
function iterPush(ptr,
  axis, 
  redStart, redEnd, 
  blueStart, blueEnd, 
  state, 
  lo, hi) {

  var iptr = IFRAME_SIZE * ptr
  BOX_ISTACK[iptr]   = axis
  BOX_ISTACK[iptr+1] = redStart
  BOX_ISTACK[iptr+2] = redEnd
  BOX_ISTACK[iptr+3] = blueStart
  BOX_ISTACK[iptr+4] = blueEnd
  BOX_ISTACK[iptr+5] = state

  var dptr = DFRAME_SIZE * ptr
  BOX_DSTACK[dptr]   = lo
  BOX_DSTACK[dptr+1] = hi
}

//Special case:  Intersect single point with list of intervals
function onePointPartial(
  d, axis, visit, flip,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    if(flip && blueX === r0) {
      continue
    }
    var redId = redIndex[i]
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval
    if(flip) {
      retval = visit(blueId, redId)
    } else {
      retval = visit(redId, blueId)
    }
    if(retval !== void 0) {
      return retval
    }
  }
}

//Special case:  Intersect one point with list of intervals
function onePointFull(
  d, axis, visit,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var redId = redIndex[i]
    if(redId === blueId) {
      continue
    }
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval = visit(redId, blueId)
    if(retval !== void 0) {
      return retval
    }
  }
}

//The main box intersection routine
function boxIntersectIter(
  d, visit, initFull,
  xSize, xBoxes, xIndex,
  ySize, yBoxes, yIndex) {

  //Reserve memory for stack
  iterInit(d, xSize + ySize)

  var top  = 0
  var elemSize = 2 * d
  var retval

  iterPush(top++,
      0,
      0, xSize,
      0, ySize,
      initFull ? 16 : 0, 
      -Infinity, Infinity)
  if(!initFull) {
    iterPush(top++,
      0,
      0, ySize,
      0, xSize,
      1, 
      -Infinity, Infinity)
  }

  while(top > 0) {
    top  -= 1

    var iptr = top * IFRAME_SIZE
    var axis      = BOX_ISTACK[iptr]
    var redStart  = BOX_ISTACK[iptr+1]
    var redEnd    = BOX_ISTACK[iptr+2]
    var blueStart = BOX_ISTACK[iptr+3]
    var blueEnd   = BOX_ISTACK[iptr+4]
    var state     = BOX_ISTACK[iptr+5]

    var dptr = top * DFRAME_SIZE
    var lo        = BOX_DSTACK[dptr]
    var hi        = BOX_DSTACK[dptr+1]

    //Unpack state info
    var flip      = (state & 1)
    var full      = !!(state & 16)

    //Unpack indices
    var red       = xBoxes
    var redIndex  = xIndex
    var blue      = yBoxes
    var blueIndex = yIndex
    if(flip) {
      red         = yBoxes
      redIndex    = yIndex
      blue        = xBoxes
      blueIndex   = xIndex
    }

    if(state & 2) {
      redEnd = partitionStartLessThan(
        d, axis,
        redStart, redEnd, red, redIndex,
        hi)
      if(redStart >= redEnd) {
        continue
      }
    }
    if(state & 4) {
      redStart = partitionEndLessThanEqual(
        d, axis,
        redStart, redEnd, red, redIndex,
        lo)
      if(redStart >= redEnd) {
        continue
      }
    }
    
    var redCount  = redEnd  - redStart
    var blueCount = blueEnd - blueStart

    if(full) {
      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
        retval = sweep.scanComplete(
          d, axis, visit, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    } else {
      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
        //If input small, then use brute force
        retval = bruteForcePartial(
            d, axis, visit, flip,
            redStart,  redEnd,  red,  redIndex,
            blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      } else if(d * redCount * blueCount < SCAN_CUTOFF) {
        //If input medium sized, then use sweep and prune
        retval = sweep.scanBipartite(
          d, axis, visit, flip, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    }
    
    //First, find all red intervals whose interior contains (lo,hi)
    var red0 = partitionInteriorContainsInterval(
      d, axis, 
      redStart, redEnd, red, redIndex,
      lo, hi)

    //Lower dimensional case
    if(redStart < red0) {

      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
        //Special case for small inputs: use brute force
        retval = bruteForceFull(
          d, axis+1, visit,
          redStart, red0, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
      } else if(axis === d-2) {
        if(flip) {
          retval = sweep.sweepBipartite(
            d, visit,
            blueStart, blueEnd, blue, blueIndex,
            redStart, red0, red, redIndex)
        } else {
          retval = sweep.sweepBipartite(
            d, visit,
            redStart, red0, red, redIndex,
            blueStart, blueEnd, blue, blueIndex)
        }
        if(retval !== void 0) {
          return retval
        }
      } else {
        iterPush(top++,
          axis+1,
          redStart, red0,
          blueStart, blueEnd,
          flip,
          -Infinity, Infinity)
        iterPush(top++,
          axis+1,
          blueStart, blueEnd,
          redStart, red0,
          flip^1,
          -Infinity, Infinity)
      }
    }

    //Divide and conquer phase
    if(red0 < redEnd) {

      //Cut blue into 3 parts:
      //
      //  Points < mid point
      //  Points = mid point
      //  Points > mid point
      //
      var blue0 = findMedian(
        d, axis, 
        blueStart, blueEnd, blue, blueIndex)
      var mid = blue[elemSize * blue0 + axis]
      var blue1 = partitionStartEqual(
        d, axis,
        blue0, blueEnd, blue, blueIndex,
        mid)

      //Right case
      if(blue1 < blueEnd) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blue1, blueEnd,
          (flip|4) + (full ? 16 : 0),
          mid, hi)
      }

      //Left case
      if(blueStart < blue0) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blueStart, blue0,
          (flip|2) + (full ? 16 : 0),
          lo, mid)
      }

      //Center case (the hard part)
      if(blue0 + 1 === blue1) {
        //Optimization: Range with exactly 1 point, use a brute force scan
        if(full) {
          retval = onePointFull(
            d, axis, visit,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        } else {
          retval = onePointPartial(
            d, axis, visit, flip,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        }
        if(retval !== void 0) {
          return retval
        }
      } else if(blue0 < blue1) {
        var red1
        if(full) {
          //If full intersection, need to handle special case
          red1 = partitionContainsPoint(
            d, axis,
            red0, redEnd, red, redIndex,
            mid)
          if(red0 < red1) {
            var redX = partitionStartEqual(
              d, axis,
              red0, red1, red, redIndex,
              mid)
            if(axis === d-2) {
              //Degenerate sweep intersection:
              //  [red0, redX] with [blue0, blue1]
              if(red0 < redX) {
                retval = sweep.sweepComplete(
                  d, visit,
                  red0, redX, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }

              //Normal sweep intersection:
              //  [redX, red1] with [blue0, blue1]
              if(redX < red1) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  redX, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }
            } else {
              if(red0 < redX) {
                iterPush(top++,
                  axis+1,
                  red0, redX,
                  blue0, blue1,
                  16,
                  -Infinity, Infinity)
              }
              if(redX < red1) {
                iterPush(top++,
                  axis+1,
                  redX, red1,
                  blue0, blue1,
                  0,
                  -Infinity, Infinity)
                iterPush(top++,
                  axis+1,
                  blue0, blue1,
                  redX, red1,
                  1,
                  -Infinity, Infinity)
              }
            }
          }
        } else {
          if(flip) {
            red1 = partitionContainsPointProper(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          } else {
            red1 = partitionContainsPoint(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          }
          if(red0 < red1) {
            if(axis === d-2) {
              if(flip) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  blue0, blue1, blue, blueIndex,
                  red0, red1, red, redIndex)
              } else {
                retval = sweep.sweepBipartite(
                  d, visit,
                  red0, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
              }
            } else {
              iterPush(top++,
                axis+1,
                red0, red1,
                blue0, blue1,
                flip,
                -Infinity, Infinity)
              iterPush(top++,
                axis+1,
                blue0, blue1,
                red0, red1,
                flip^1,
                -Infinity, Infinity)
            }
          }
        }
      }
    }
  }
}

/***/ }),
/* 655 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DIMENSION   = 'd'
var AXIS        = 'ax'
var VISIT       = 'vv'
var FLIP        = 'fp'

var ELEM_SIZE   = 'es'

var RED_START   = 'rs'
var RED_END     = 're'
var RED_BOXES   = 'rb'
var RED_INDEX   = 'ri'
var RED_PTR     = 'rp'

var BLUE_START  = 'bs'
var BLUE_END    = 'be'
var BLUE_BOXES  = 'bb'
var BLUE_INDEX  = 'bi'
var BLUE_PTR    = 'bp'

var RETVAL      = 'rv'

var INNER_LABEL = 'Q'

var ARGS = [
  DIMENSION,
  AXIS,
  VISIT,
  RED_START,
  RED_END,
  RED_BOXES,
  RED_INDEX,
  BLUE_START,
  BLUE_END,
  BLUE_BOXES,
  BLUE_INDEX
]

function generateBruteForce(redMajor, flip, full) {
  var funcName = 'bruteForce' + 
    (redMajor ? 'Red' : 'Blue') + 
    (flip ? 'Flip' : '') +
    (full ? 'Full' : '')

  var code = ['function ', funcName, '(', ARGS.join(), '){',
    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']

  var redLoop = 
    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +
        'i<' + RED_END +';' +
        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +
        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +
            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +
            'xi=' + RED_INDEX + '[i];'

  var blueLoop = 
    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +
        'j<' + BLUE_END + ';' +
        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +
        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +
            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +
            'yi=' + BLUE_INDEX + '[j];'

  if(redMajor) {
    code.push(redLoop, INNER_LABEL, ':', blueLoop)
  } else {
    code.push(blueLoop, INNER_LABEL, ':', redLoop)
  }

  if(full) {
    code.push('if(y1<x0||x1<y0)continue;')
  } else if(flip) {
    code.push('if(y0<=x0||x1<y0)continue;')
  } else {
    code.push('if(y0<x0||x1<y0)continue;')
  }

  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+
    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+
        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+
        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+
        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+
      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +
      'var ' + RETVAL + '=' + VISIT + '(')

  if(flip) {
    code.push('yi,xi')
  } else {
    code.push('xi,yi')
  }

  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')

  return {
    name: funcName, 
    code: code.join('')
  }
}

function bruteForcePlanner(full) {
  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')
  var prefix = []
  var fargs = ARGS.slice()
  if(!full) {
    fargs.splice(3, 0, FLIP)
  }

  var code = ['function ' + funcName + '(' + fargs.join() + '){']

  function invoke(redMajor, flip) {
    var res = generateBruteForce(redMajor, flip, full)
    prefix.push(res.code)
    code.push('return ' + res.name + '(' + ARGS.join() + ');')
  }

  code.push('if(' + RED_END + '-' + RED_START + '>' +
                    BLUE_END + '-' + BLUE_START + '){')

  if(full) {
    invoke(true, false)
    code.push('}else{')
    invoke(false, false)
  } else {
    code.push('if(' + FLIP + '){')
    invoke(true, true)
    code.push('}else{')
    invoke(true, false)
    code.push('}}else{if(' + FLIP + '){')
    invoke(false, true)
    code.push('}else{')
    invoke(false, false)
    code.push('}')
  }
  code.push('}}return ' + funcName)

  var codeStr = prefix.join('') + code.join('')
  var proc = new Function(codeStr)
  return proc()
}


exports.partial = bruteForcePlanner(false)
exports.full    = bruteForcePlanner(true)

/***/ }),
/* 656 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = findMedian

var genPartition = __webpack_require__(244)

var partitionStartLessThan = genPartition('lo<p0', ['p0'])

var PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian

//Base case for median finding:  Use insertion sort
function insertionSort(d, axis, start, end, boxes, ids) {
  var elemSize = 2 * d
  var boxPtr = elemSize * (start+1) + axis
  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {
    var x = boxes[boxPtr]
    for(var j=i, ptr=elemSize*(i-1); 
        j>start && boxes[ptr+axis] > x; 
        --j, ptr-=elemSize) {
      //Swap
      var aPtr = ptr
      var bPtr = ptr+elemSize
      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {
        var y = boxes[aPtr]
        boxes[aPtr] = boxes[bPtr]
        boxes[bPtr] = y
      }
      var tmp = ids[j]
      ids[j] = ids[j-1]
      ids[j-1] = tmp
    }
  }
}

//Find median using quick select algorithm
//  takes O(n) time with high probability
function findMedian(d, axis, start, end, boxes, ids) {
  if(end <= start+1) {
    return start
  }

  var lo       = start
  var hi       = end
  var mid      = ((end + start) >>> 1)
  var elemSize = 2*d
  var pivot    = mid
  var value    = boxes[elemSize*mid+axis]
  
  while(lo < hi) {
    if(hi - lo < PARTITION_THRESHOLD) {
      insertionSort(d, axis, lo, hi, boxes, ids)
      value = boxes[elemSize*mid+axis]
      break
    }
    
    //Select pivot using median-of-3
    var count  = hi - lo
    var pivot0 = (Math.random()*count+lo)|0
    var value0 = boxes[elemSize*pivot0 + axis]
    var pivot1 = (Math.random()*count+lo)|0
    var value1 = boxes[elemSize*pivot1 + axis]
    var pivot2 = (Math.random()*count+lo)|0
    var value2 = boxes[elemSize*pivot2 + axis]
    if(value0 <= value1) {
      if(value2 >= value1) {
        pivot = pivot1
        value = value1
      } else if(value0 >= value2) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    } else {
      if(value1 >= value2) {
        pivot = pivot1
        value = value1
      } else if(value2 >= value0) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    }

    //Swap pivot to end of array
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Partition using pivot
    pivot = partitionStartLessThan(
      d, axis, 
      lo, hi-1, boxes, ids,
      value)

    //Swap pivot back
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Swap pivot to last pivot
    if(mid < pivot) {
      hi = pivot-1
      while(lo < hi && 
        boxes[elemSize*(hi-1)+axis] === value) {
        hi -= 1
      }
      hi += 1
    } else if(pivot < mid) {
      lo = pivot + 1
      while(lo < hi &&
        boxes[elemSize*lo+axis] === value) {
        lo += 1
      }
    } else {
      break
    }
  }

  //Make sure pivot is at start
  return partitionStartLessThan(
    d, axis, 
    start, mid, boxes, ids,
    boxes[elemSize*mid+axis])
}

/***/ }),
/* 657 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HorizontalPoint1DPixiTrack = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _d3Scale = __webpack_require__(12);

var _HorizontalLine1DPixiTrack = __webpack_require__(85);

var _utils = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HorizontalPoint1DPixiTrack = exports.HorizontalPoint1DPixiTrack = function (_HorizontalLine1DPixi) {
  _inherits(HorizontalPoint1DPixiTrack, _HorizontalLine1DPixi);

  function HorizontalPoint1DPixiTrack(scene, dataConfig, handleTilesetInfoReceived, option, animate, onValueScaleChanged) {
    _classCallCheck(this, HorizontalPoint1DPixiTrack);

    return _possibleConstructorReturn(this, (HorizontalPoint1DPixiTrack.__proto__ || Object.getPrototypeOf(HorizontalPoint1DPixiTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, option, animate, onValueScaleChanged));
  }

  /**
   * Create whatever is needed to draw this tile.
   */


  _createClass(HorizontalPoint1DPixiTrack, [{
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        _get(HorizontalPoint1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalPoint1DPixiTrack.prototype), 'initTile', this).call(this, tile);

        tile.barXValues = new Array(tile.tileData.dense.length);
        tile.barYValues = new Array(tile.tileData.dense.length);
        tile.barWidths = new Array(tile.tileData.dense.length);
        tile.barHeights = new Array(tile.tileData.dense.length);

        this.renderTile(tile);
      }

      return initTile;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tile) {}

      return drawTile;
    }()
  }, {
    key: 'renderTile',
    value: function () {
      function renderTile(tile) {
        _get(HorizontalPoint1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalPoint1DPixiTrack.prototype), 'drawTile', this).call(this, tile);

        if (!tile.graphics) {
          return;
        }

        // console.log('renderTile:');

        var graphics = tile.graphics;

        var _getTilePosAndDimensi = this.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos),
            tileX = _getTilePosAndDimensi.tileX,
            tileWidth = _getTilePosAndDimensi.tileWidth;

        var tileValues = tile.tileData.dense;

        if (tileValues.length == 0) {
          return;
        }

        var pseudocount = 0; // if we use a log scale, then we'll set a pseudocount
        // equal to the smallest non-zero value
        this.valueScale = null;

        // console.log('valueScaling:', this.options.valueScaling);
        if (this.options.valueScaling == 'log') {
          var offsetValue = this.medianVisibleValue;

          if (!this.medianVisibleValue) {
            offsetValue = this.minVisibleValue();
          }

          this.valueScale = (0, _d3Scale.scaleLog)()
          // .base(Math.E)
          .domain([offsetValue, this.maxValue() + offsetValue]).range([this.dimensions[1], 0]);
          pseudocount = offsetValue;
        } else {
          // linear scale
          this.valueScale = (0, _d3Scale.scaleLinear)().domain([this.minValue(), this.maxValue()]).range([this.dimensions[1], 0]);
        }

        graphics.clear();

        this.drawAxis(this.valueScale);

        if (this.options.valueScaling == 'log' && this.valueScale.domain()[1] < 0) {
          console.warn('Negative values present when using a log scale', this.valueScale.domain());
          return;
        }

        var stroke = (0, _utils.colorToHex)(this.options.lineStrokeColor ? this.options.lineStrokeColor : 'blue');
        // this scale should go from an index in the data array to
        // a position in the genome coordinates
        var tileXScale = (0, _d3Scale.scaleLinear)().domain([0, this.tilesetInfo.tile_size]).range([tileX, tileX + tileWidth]);

        // let strokeWidth = this.options.lineStrokeWidth ? this.options.lineStrokeWidth : 1;

        var strokeWidth = 0;
        graphics.lineStyle(strokeWidth, stroke, 1);

        var squareSide = this.options.pointSize ? this.options.pointSize : 3;
        var pointColor = (0, _utils.colorToHex)(this.options.pointColor ? this.options.pointColor : 'red');

        graphics.beginFill(pointColor, 1);

        var j = 0;
        tile.drawnAtScale = this._xScale.copy();

        for (var i = 0; i < tileValues.length; i++) {
          var xPos = this._xScale(tileXScale(i));
          var yPos = this.valueScale(tileValues[i] + pseudocount);

          tile.barXValues[i] = xPos - squareSide / 2 / this.pMain.scale.x;
          tile.barYValues[i] = yPos - squareSide / 2 / this.pMain.scale.y;
          tile.barWidths[i] = squareSide / this.pMain.scale.x;
          tile.barHeights[i] = squareSide / this.pMain.scale.y;

          if (tileXScale(i) > this.tilesetInfo.max_pos[0])
            // this data is in the last tile and extends beyond the length
            // of the coordinate system
            {
              break;
            }

          // console.log('drawRect');
          // console.log('xPos:', xPos)

          graphics.drawRect(xPos - squareSide / 2 / this.pMain.scale.x, yPos - squareSide / 2 / this.pMain.scale.y, squareSide / this.pMain.scale.x, squareSide / this.pMain.scale.y);
        }
      }

      return renderTile;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        _get(HorizontalPoint1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalPoint1DPixiTrack.prototype), 'draw', this).call(this);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _utils.dictValues)(this.fetchedTiles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tile = _step.value;

            // scaling between tiles
            var tileK = (tile.drawnAtScale.domain()[1] - tile.drawnAtScale.domain()[0]) / (this._xScale.domain()[1] - this._xScale.domain()[0]);

            // let posOffset = newRange[0];

            var newRange = this._xScale.domain().map(tile.drawnAtScale);

            var posOffset = newRange[0];
            tile.graphics.scale.x = tileK;
            tile.graphics.position.x = -posOffset * tileK;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return draw;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale, k, tx, ty) {
        _get(HorizontalPoint1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalPoint1DPixiTrack.prototype), 'zoomed', this).call(this, newXScale, newYScale);
      }

      return zoomed;
    }()

    /**
     * Export an SVG representation of this track
     *
     * @returns {[DOMNode,DOMNode]} The two returned DOM nodes are both SVG
     * elements [base,track]. Base is a parent which contains track as a
     * child. Track is clipped with a clipping rectangle contained in base.
     *
     */

  }, {
    key: 'exportSVG',
    value: function () {
      function exportSVG() {
        var track = null;
        var base = null;

        var _get$call = _get(HorizontalPoint1DPixiTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalPoint1DPixiTrack.prototype), 'superSVG', this).call(this);

        var _get$call2 = _slicedToArray(_get$call, 2);

        base = _get$call2[0];
        track = _get$call2[1];


        base.setAttribute('class', 'exported-line-track');
        var output = document.createElement('g');

        track.appendChild(output);
        output.setAttribute('transform', 'translate(' + this.position[0] + ',' + this.position[1] + ')');

        var stroke = this.options.lineStrokeColor ? this.options.lineStrokeColor : 'blue';

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.visibleAndFetchedTiles()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var tile = _step2.value;

            for (var i = 0; i < tile.barXValues.length; i++) {
              var rect = document.createElement('rect');

              var strokeColor = this.options.lineStrokeColor || 'blue';
              var pointColor = this.options.pointColor || 'red';

              rect.setAttribute('fill', pointColor);
              rect.setAttribute('stroke', strokeColor);
              rect.setAttribute('stroke-width', 0);

              rect.setAttribute('x', tile.barXValues[i]);
              rect.setAttribute('y', tile.barYValues[i]);
              rect.setAttribute('height', tile.barHeights[i]);
              rect.setAttribute('width', tile.barWidths[i]);

              output.appendChild(rect);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var gAxis = document.createElement('g');
        gAxis.setAttribute('id', 'axis');

        // append the axis to base so that it's not clipped
        base.appendChild(gAxis);
        gAxis.setAttribute('transform', 'translate(' + this.axis.pAxis.position.x + ', ' + this.axis.pAxis.position.y + ')');

        // add the axis to the export
        if (this.options.axisPositionHorizontal === 'left' || this.options.axisPositionVertical === 'top') {
          // left axis are shown at the beginning of the plot
          var gDrawnAxis = this.axis.exportAxisLeftSVG(this.valueScale, this.dimensions[1]);
          gAxis.appendChild(gDrawnAxis);
        } else if (this.options.axisPositionHorizontal === 'right' || this.options.axisPositionVertical === 'bottom') {
          var _gDrawnAxis = this.axis.exportAxisRightSVG(this.valueScale, this.dimensions[1]);
          gAxis.appendChild(_gDrawnAxis);
        }

        return [base, track];
      }

      return exportSVG;
    }()
  }]);

  return HorizontalPoint1DPixiTrack;
}(_HorizontalLine1DPixiTrack.HorizontalLine1DPixiTrack);

exports['default'] = HorizontalPoint1DPixiTrack;

/***/ }),
/* 658 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _d3Brush = __webpack_require__(25);

var _d3Scale = __webpack_require__(12);

var _d3Selection = __webpack_require__(4);

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _TiledPixiTrack = __webpack_require__(41);

var _HeatmapTiledPixiTrack = __webpack_require__(82);

var _AxisPixi = __webpack_require__(83);

var _services = __webpack_require__(7);

var _utils = __webpack_require__(3);

var _configs = __webpack_require__(6);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var COLORBAR_MAX_HEIGHT = 200;
var COLORBAR_WIDTH = 10;
var COLORBAR_LABELS_WIDTH = 40;
var COLORBAR_MARGIN = 10;
var BRUSH_WIDTH = COLORBAR_MARGIN;
var BRUSH_HEIGHT = 4;
var BRUSH_COLORBAR_GAP = 1;
var BRUSH_MARGIN = 4;
var SCALE_LIMIT_PRECISION = 5;
var BINS_PER_TILE = 256;

var HorizontalMultivecTrack = function (_HeatmapTiledPixiTrac) {
  _inherits(HorizontalMultivecTrack, _HeatmapTiledPixiTrac);

  function HorizontalMultivecTrack(scene, dataConfig, handleTilesetInfoReceived, options, animate, svgElement, onValueScaleChanged, onTrackOptionsChanged) {
    _classCallCheck(this, HorizontalMultivecTrack);

    /**
     * @param scene: A PIXI.js scene to draw everything to.
     * @param server: The server to pull tiles from.
     * @param uid: The data set to get the tiles from the server
     */
    return _possibleConstructorReturn(this, (HorizontalMultivecTrack.__proto__ || Object.getPrototypeOf(HorizontalMultivecTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, options, animate, svgElement, onValueScaleChanged, onTrackOptionsChanged));
  }

  _createClass(HorizontalMultivecTrack, [{
    key: 'tileDataToCanvas',
    value: function () {
      function tileDataToCanvas(pixData) {
        var canvas = document.createElement('canvas');

        canvas.width = this.tilesetInfo.shape[0];
        canvas.height = this.tilesetInfo.shape[1];

        var ctx = canvas.getContext('2d');

        ctx.fillStyle = 'transparent';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        var pix = new ImageData(pixData, canvas.width, canvas.height);

        ctx.putImageData(pix, 0, 0);

        return canvas;
      }

      return tileDataToCanvas;
    }()
  }, {
    key: 'setSpriteProperties',
    value: function () {
      function setSpriteProperties(sprite, zoomLevel, tilePos, mirrored) {
        var _getTilePosAndDimensi = this.getTilePosAndDimensions(zoomLevel, tilePos, this.tilesetInfo.tile_size),
            tileX = _getTilePosAndDimensi.tileX,
            tileY = _getTilePosAndDimensi.tileY,
            tileWidth = _getTilePosAndDimensi.tileWidth,
            tileHeight = _getTilePosAndDimensi.tileHeight;

        var tileEndX = tileX + tileWidth;
        var tileEndY = tileY + tileHeight;

        sprite.width = this._refXScale(tileEndX) - this._refXScale(tileX);
        //sprite.height = this.tilesetInfo.shape[1]; //this._refYScale(tileEndY) - this._refYScale(tileY);
        sprite.height = this.dimensions[1];

        sprite.x = this._refXScale(tileX);
        sprite.y = 0;

        /*
        console.log('sprite.y:', sprite.y);
        console.log('sprite.height:', sprite.height);
        */
      }

      return setSpriteProperties;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale, k, tx, ty) {
        _get(HorizontalMultivecTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalMultivecTrack.prototype), 'zoomed', this).call(this, newXScale, newYScale);

        this.pMain.position.x = tx; // translateX;
        this.pMain.position.y = this.position[1]; // translateY;

        this.pMain.scale.x = k; // scaleX;
        this.pMain.scale.y = 1; // scaleY;

        this.drawColorbar();
      }

      return zoomed;
    }()
  }, {
    key: 'calculateVisibleTiles',
    value: function () {
      function calculateVisibleTiles() {
        var _this2 = this;

        var mirrorTiles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        // if we don't know anything about this dataset, no point
        // in trying to get tiles
        if (!this.tilesetInfo) {
          return;
        }

        this.zoomLevel = this.calculateZoomLevel();

        var sortedResolutions = this.tilesetInfo.resolutions.map(function (x) {
          return +x;
        }).sort(function (a, b) {
          return b - a;
        });

        this.xTiles = _services.tileProxy.calculateTilesFromResolution(sortedResolutions[this.zoomLevel], this._xScale, this.tilesetInfo.min_pos[0], null, this.tilesetInfo.tile_size);
        //console.log('res', sortedResolutions[this.zoomLevel]);
        //console.log('this.xTiles:', this.xTiles);

        var tiles = this.xTiles.map(function (x) {
          return [_this2.zoomLevel, x];
        });

        this.setVisibleTiles(tiles);
      }

      return calculateVisibleTiles;
    }()
  }, {
    key: 'calculateZoomLevel',
    value: function () {
      function calculateZoomLevel() {
        var minX = this.tilesetInfo.min_pos[0];

        var zoomIndexX = _services.tileProxy.calculateZoomLevelFromResolutions(this.tilesetInfo.resolutions, this._xScale, minX);

        return zoomIndexX;
      }

      return calculateZoomLevel;
    }()
  }, {
    key: 'tileToLocalId',
    value: function () {
      function tileToLocalId(tile) {
        /*
         * The local tile identifier
         */

        // tile contains [zoomLevel, xPos, yPos]
        if (tile.dataTransform && tile.dataTransform != 'default') {
          return tile.join('.') + '.' + tile.mirrored + '.' + tile.dataTransform;
        }
        return tile.join('.') + '.' + tile.mirrored;
      }

      return tileToLocalId;
    }()
  }, {
    key: 'tileToLocalId',
    value: function () {
      function tileToLocalId(tile) {
        /*
             * The local tile identifier
             */

        // tile contains [zoomLevel, xPos]
        return '' + tile.join('.');
      }

      return tileToLocalId;
    }()
  }, {
    key: 'tileToRemoteId',
    value: function () {
      function tileToRemoteId(tile) {
        /**
             * The tile identifier used on the server
             */

        // tile contains [zoomLevel, xPos]
        return '' + tile.join('.');
      }

      return tileToRemoteId;
    }()
  }]);

  return HorizontalMultivecTrack;
}(_HeatmapTiledPixiTrack.HeatmapTiledPixiTrack);

exports['default'] = HorizontalMultivecTrack;

/***/ }),
/* 659 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DivergentBarTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _d3Scale = __webpack_require__(12);

var _BarTrack2 = __webpack_require__(245);

var _utils = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Utils


var DivergentBarTrack = exports.DivergentBarTrack = function (_BarTrack) {
  _inherits(DivergentBarTrack, _BarTrack);

  function DivergentBarTrack(scene, dataConfig, handleTilesetInfoReceived, option, animate, onValueScaleChanged) {
    _classCallCheck(this, DivergentBarTrack);

    return _possibleConstructorReturn(this, (DivergentBarTrack.__proto__ || Object.getPrototypeOf(DivergentBarTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, option, animate, onValueScaleChanged));
  }

  _createClass(DivergentBarTrack, [{
    key: 'renderTile',
    value: function () {
      function renderTile(tile) {
        //super.drawTile(tile);

        if (!tile.graphics) {
          return;
        }

        var graphics = tile.graphics;

        var _getTilePosAndDimensi = this.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos),
            tileX = _getTilePosAndDimensi.tileX,
            tileWidth = _getTilePosAndDimensi.tileWidth;

        var tileValues = tile.tileData.dense;

        if (tileValues.length == 0) {
          return;
        }

        var pseudocount = 0; // if we use a log scale, then we'll set a pseudocount
        // equal to the smallest non-zero value
        this.valueScale = null;

        // console.log('valueScaling:', this.options.valueScaling);
        if (this.options.valueScaling == 'log') {
          var offsetValue = this.medianVisibleValue;

          if (!this.medianVisibleValue) {
            offsetValue = this.minVisibleValue();
          }

          this.valueScale = (0, _d3Scale.scaleLog)()
          // .base(Math.E)
          .domain([offsetValue, this.maxValue() + offsetValue]).range([this.dimensions[1], 0]);
          pseudocount = offsetValue;
        } else {
          // linear scale
          this.valueScale = (0, _d3Scale.scaleLinear)().domain([this.minValue(), this.maxValue()]).range([this.dimensions[1], 0]);
        }

        graphics.clear();

        this.drawAxis(this.valueScale);

        if (this.options.valueScaling == 'log' && this.valueScale.domain()[1] < 0) {
          console.warn('Negative values present when using a log scale', this.valueScale.domain());
          return;
        }

        var stroke = (0, _utils.colorToHex)(this.options.lineStrokeColor ? this.options.lineStrokeColor : 'blue');
        // this scale should go from an index in the data array to
        // a position in the genome coordinates
        var tileXScale = (0, _d3Scale.scaleLinear)().domain([0, this.tilesetInfo.tile_size]).range([tileX, tileX + tileWidth]);

        // let strokeWidth = this.options.lineStrokeWidth ? this.options.lineStrokeWidth : 1;

        var strokeWidth = 0;
        graphics.lineStyle(strokeWidth, stroke, 1);

        var topColor = this.options.barFillColorTop ? this.options.barFillColorTop : 'green';
        var bottomColor = this.options.barFillColorBottom ? this.options.barFillColorBottom : 'red';

        // PIXI wants hex colors whereas d3 wants regular colors
        var topColorHex = (0, _utils.colorToHex)(topColor);
        var bottomColorHex = (0, _utils.colorToHex)(bottomColor);

        var opacity = 'barOpacity' in this.options ? this.options.barOpacity : 1;

        var j = 0;
        tile.drawnAtScale = this._xScale.copy();

        // the line at which the values will diverge
        var baseline = 0;
        if (this.options.valueScaling == 'log') {
          baseline = this.valueScale(1);
        } else {
          baseline = this.valueScale(0);
        }

        for (var i = 0; i < tileValues.length; i++) {
          var xPos = this._xScale(tileXScale(i));
          var yPos = this.valueScale(tileValues[i] + pseudocount);

          var width = this._xScale(tileXScale(i + 1)) - xPos;
          var height = this.dimensions[1] - yPos;

          if (yPos > baseline) {
            graphics.beginFill(bottomColorHex, opacity);
            tile.barYValues[i] = baseline;
            tile.barHeights[i] = yPos - baseline;
            tile.barColors[i] = bottomColor;
          } else {
            graphics.beginFill(topColorHex, opacity);
            tile.barYValues[i] = yPos;
            tile.barHeights[i] = baseline - yPos;
            tile.barColors[i] = topColor;
          }

          tile.barXValues[i] = xPos;
          tile.barWidths[i] = width;

          if (tileXScale(i) > this.tilesetInfo.max_pos[0])
            // this data is in the last tile and extends beyond the length
            // of the coordinate system
            {
              break;
            }

          graphics.drawRect(xPos, tile.barYValues[i], width, tile.barHeights[i]);
        }
      }

      return renderTile;
    }()
  }]);

  return DivergentBarTrack;
}(_BarTrack2.BarTrack);

exports['default'] = DivergentBarTrack;

/***/ }),
/* 660 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CNVIntervalTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _d3Scale = __webpack_require__(12);

var _d3Array = __webpack_require__(10);

var _HorizontalTiled1DPixiTrack = __webpack_require__(60);

var _HorizontalTiled1DPixiTrack2 = _interopRequireDefault(_HorizontalTiled1DPixiTrack);

var _intervalTree = __webpack_require__(661);

var _intervalTree2 = _interopRequireDefault(_intervalTree);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CNVIntervalTrack = exports.CNVIntervalTrack = function (_HorizontalTiled1DPix) {
  _inherits(CNVIntervalTrack, _HorizontalTiled1DPix);

  function CNVIntervalTrack(scene, dataConfig, handleTilesetInfoReceived, options, animate, onValueScaleChanged) {
    _classCallCheck(this, CNVIntervalTrack);

    // console.log('CNVInterval:', this);
    var _this = _possibleConstructorReturn(this, (CNVIntervalTrack.__proto__ || Object.getPrototypeOf(CNVIntervalTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, options, animate, onValueScaleChanged));

    _this.seen = new Set();
    _this.pMain = _this.pMobile;

    _this.rows = [];
    return _this;
  }

  _createClass(CNVIntervalTrack, [{
    key: 'uid',
    value: function () {
      function uid(item) {
        return item[item.length - 2];
      }

      return uid;
    }()
  }, {
    key: 'segmentOverlap',
    value: function () {
      function segmentOverlap(segment1, segment2) {}

      return segmentOverlap;
    }()
  }, {
    key: 'segmentsToRows',
    value: function () {
      function segmentsToRows(segments) {
        /**
             * Partition a list of segments into an array of
             * rows containing the segments.
             *
             * @param segments: An array of segments (e.g. [{from: 10, to: 20}, {from: 18, to: 30}])
             * @return: An array of arrays of segments, representing
             *          non-overlapping rows of segments
             */
        // sort by the length of each segment
        segments.sort(function (a, b) {
          return b.to - b.from - (a.to - a.from);
        });

        var rows = [[]];
        var rowIts = [new _intervalTree2['default']()];

        // fill out each row with segments
        for (var i = 0; i < segments.length; i++) {
          var placed = false;

          for (var j = 0; j < rows.length; j++) {
            var it = rowIts[j]; // an interval tree

            var occluded = it.intersects([segments[i].from, segments[i].to]);

            if (!occluded) {
              // no intersections on this row, place this segment here
              it.add([segments[i].from, segments[i].to]);
              rows[j].push(segments[i]);
              placed = true;
              break;
            }
          }

          if (!placed) {
            var newTree = new _intervalTree2['default']();

            newTree.add([segments[i].from, segments[i].to]);
            rows.push([segments[i]]);
            rowIts.push(newTree);
          }
        }

        return rows;
      }

      return segmentsToRows;
    }()
  }, {
    key: 'drawAll',
    value: function () {
      function drawAll(allTileData) {
        var _this2 = this;

        this.pMain.clear();
        var seen = new Set();

        var segments = allTileData.map(function (x) {
          if (seen.has(_this2.uid(x))) {
            return null;
          }
          seen.add(_this2.uid(x));
          // console.log('length:', +x[2] - +x[1], 'id', tile.tileId)
          return { from: +x[1],
            to: +x[2],
            type: x[4],
            uid: _this2.uid(x) };
        }).filter(function (x) {
          return x;
        }); // filter out null values


        var rows = this.segmentsToRows(segments);
        this.rows = rows;

        this.draw();
      }

      return drawAll;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        var rows = this.rows;

        if (!rows) {
          return;
        }

        var valueScale = (0, _d3Scale.scaleBand)().range([0, this.dimensions[1]]).padding(0.1).domain((0, _d3Array.range)(0, this.maxRows())); // draw one away from the center
        // .domain(range(0, 10));  // draw one away from the center

        var graphics = this.pMain;

        graphics.clear();

        graphics.lineStyle(1, 0x0000FF, 0);
        graphics.beginFill(0xFF700B, 0.8);

        for (var i = 0; i < rows.length; i++) {
          for (var j = 0; j < rows[i].length; j++) {
            var interval = rows[i][j];

            var x1 = this._refXScale(interval.from);
            var x2 = this._refXScale(interval.to);

            var y1 = valueScale(i);
            var y2 = y1 + valueScale.bandwidth();

            var width = x2 - x1;
            var height = y2 - y1;

            graphics.drawRect(x1, y1, width, height);
          }
        }
      }

      return draw;
    }()
  }, {
    key: 'allTilesLoaded',
    value: function () {
      function allTilesLoaded() {
        var _this3 = this;

        var visibleAndFetchedIds = this.visibleAndFetchedIds();

        var tileDatas = visibleAndFetchedIds.map(function (x) {
          return _this3.fetchedTiles[x].tileData.discrete;
        });
        var allTileData = [].concat.apply([], tileDatas);

        this.drawAll(allTileData);
      }

      return allTilesLoaded;
    }()
  }, {
    key: 'initTile',
    value: function () {
      function initTile(tile) {}

      return initTile;
    }()
  }, {
    key: 'maxRows',
    value: function () {
      function maxRows() {
        return this.rows.length;
      }

      return maxRows;
    }()
  }, {
    key: 'updateTile',
    value: function () {
      function updateTile(tile) {
        // this.redraw(tile);
      }

      return updateTile;
    }()
  }, {
    key: 'destroyTile',
    value: function () {
      function destroyTile(tile) {
        var _this4 = this;

        tile.tileData.discrete.map(function (x) {
          var uid = x[x.length - 2];

          if (_this4.seen.has(uid)) {
            _this4.seen['delete'](uid);
          }
        });
      }

      return destroyTile;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tile) {}

      return drawTile;
    }()
  }]);

  return CNVIntervalTrack;
}(_HorizontalTiled1DPixiTrack2['default']);

exports['default'] = CNVIntervalTrack;

/***/ }),
/* 661 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = IntervalTree;
var IntervalTreeNode = function () {
  function IntervalTreeNode(start, end, left, right) {
    /**
       * Node interval.
       * @member {Array}
       */
    this.interval = [start, end];
    /**
       * Max endpoint in subtree which starts from this node.
       * @member {Number}
       */
    this.max = -Infinity;
    /**
       * Parent node.
       * @member {IntervalTreeNode}
       */
    this.parentNode = null;
    /**
       * Left child node.
       * @member {IntervalTreeNode}
       */
    this.left = left;
    /**
       * Right child node.
       * @member {IntervalTreeNode}
       */
    this.right = right;
  }

  return IntervalTreeNode;
}();

/**
 * Interval tree.
 *
 * @public
 * @constructor
 */
function IntervalTree() {
  /**
     * Root node of the tree.
     * @member {IntervalTreeNode}
     */
  this.root = null;
}

function addNode(node, side, interval) {
  var child = new IntervalTreeNode(interval[0], interval[1]);
  child.max = interval[1];
  child.parentNode = node;
  node[side] = child;
  if (node.max < interval[1]) {
    while (child) {
      if (child.max < interval[1]) {
        child.max = interval[1];
      }
      child = child.parentNode;
    }
  }
}

function addHelper(node, interval) {
  if (node.interval[0] > interval[0]) {
    if (node.left) {
      addHelper(node.left, interval);
    } else {
      addNode(node, 'left', interval);
    }
  } else if (node.right) {
    addHelper(node.right, interval);
  } else {
    addNode(node, 'right', interval);
  }
}

/**
   * Add new interval to the tree.
   *
   * @public
   * @param {Array} intreval Array with start and end points of the interval.
   */
IntervalTree.prototype.add = function (interval) {
  if (!this.root) {
    this.root = new IntervalTreeNode(interval[0], interval[1]);
    this.root.max = interval[1];
    return;
  }
  addHelper(this.root, interval);
};

function contains(point, node) {
  if (!node) {
    return false;
  }
  if (node.interval[0] <= point && node.interval[1] >= point) {
    return true;
  }
  var result = false;
  var temp = void 0;
  ['left', 'right'].forEach(function (key) {
    temp = node[key];
    if (temp) {
      if (temp.max > point) {
        result = result || contains(point, temp);
      }
    }
  });
  return result;
}

/**
   * Checks or point belongs to at least one intarval from the tree.<br><br>
   * Complexity: O(log N).
   *
   * @public
   * @method
   * @param {Number} point Point which should be checked.
   * @return {Boolean} True if point belongs to one of the intervals.
   */
IntervalTree.prototype.contains = function (point) {
  return contains(point, this.root);
};

function intersects(a, b) {
  return a[0] <= b[0] && a[1] >= b[0] || a[0] <= b[1] && a[1] >= b[1] || b[0] <= a[0] && b[1] >= a[0] || b[0] <= a[1] && b[1] >= a[1];
}

function intersectsHelper(interval, node) {
  if (!node) {
    return false;
  }
  if (intersects(node.interval, interval)) {
    return true;
  }
  var result = false;
  var temp = void 0;
  ['left', 'right'].forEach(function (side) {
    temp = node[side];
    if (temp && temp.max >= interval[0]) {
      result = result || intersectsHelper(interval, temp);
    }
  });
  return result;
}

/**
   * Checks or interval belongs to at least one intarval from the tree.<br><br>
   * Complexity: O(log N).
   *
   * @public
   * @method
   * @param {Array} interval Interval which should be checked.
   * @return {Boolean} True if interval intersects with one of the intervals.
   */
IntervalTree.prototype.intersects = function (interval) {
  return intersectsHelper(interval, this.root);
};

function heightHelper(node) {
  if (!node) {
    return 0;
  }
  return 1 + Math.max(heightHelper(node.left), heightHelper(node.right));
}

/**
   * Returns height of the tree.
   *
   * @public
   * @method
   * @return {Number} Height of the tree.
   */
IntervalTree.prototype.height = function () {
  return heightHelper(this.root);
};

/**
   * Returns node with the max endpoint in subtree.
   *
   * @public
   * @method
   * @param {IntervalTreeNode} node Root node of subtree.
   * @return {IntervalTreeNode} IntervalTreeNode with the largest endpoint.
   */
IntervalTree.prototype.findMax = function (node) {
  var stack = [node];
  var current = void 0;
  var max = -Infinity;
  var maxNode = void 0;
  while (stack.length) {
    current = stack.pop();
    if (current.left) {
      stack.push(current.left);
    }
    if (current.right) {
      stack.push(current.right);
    }
    if (current.interval[1] > max) {
      max = current.interval[1];
      maxNode = current;
    }
  }
  return maxNode;
};

// adjust the max value
IntervalTree.prototype._removeHelper = function (interval, node) {
  if (!node) {
    return;
  }
  if (node.interval[0] === interval[0] && node.interval[1] === interval[1]) {
    // When left and right children exists
    if (node.left && node.right) {
      var replacement = node.left;
      while (replacement.left) {
        replacement = replacement.left;
      }
      var temp = replacement.interval;
      replacement.interval = node.interval;
      node.interval = temp;
      this._removeHelper(replacement.interval, node);
    } else {
      // When only left or right child exists
      var side = 'left';
      if (node.right) {
        side = 'right';
      }
      var parentNode = node.parentNode;
      if (parentNode) {
        if (parentNode.left === node) {
          parentNode.left = node[side];
        } else {
          parentNode.right = node[side];
        }
        if (node[side]) {
          node[side].parentNode = parentNode;
        }
      } else {
        this.root = node[side];
        // last node removed
        if (this.root) {
          this.root.parentNode = null;
        }
      }
    }
    // Adjust the max value
    var p = node.parentNode;
    if (p) {
      var maxNode = this.findMax(p);
      var max = maxNode.interval[1];
      while (maxNode) {
        if (maxNode.max === node.interval[1]) {
          maxNode.max = max;
          maxNode = maxNode.parentNode;
        } else {
          maxNode = false;
        }
      }
    }
  } else {
    // could be optimized
    this._removeHelper(interval, node.left);
    this._removeHelper(interval, node.right);
  }
};

/**
   * Remove interval from the tree.
   *
   * @public
   * @method
   * @param {Array} intreval Array with start and end of the interval.
   */
IntervalTree.prototype.remove = function (interval) {
  return this._removeHelper(interval, this.root);
};

/***/ }),
/* 662 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeftTrackModifier = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LeftTrackModifier = exports.LeftTrackModifier = function () {
  function LeftTrackModifier(originalTrack) {
    _classCallCheck(this, LeftTrackModifier);

    this.scene = originalTrack.scene;

    this.originalTrack = originalTrack;
    this.pBase = new PIXI.Graphics();

    this.scene.removeChild(originalTrack.pBase);
    this.scene.addChild(this.pBase);

    this.moveToOrigin = new PIXI.Graphics();
    this.moveToOrigin.addChild(originalTrack.pBase);

    this.pBase.addChild(this.moveToOrigin);

    this.moveToOrigin.rotation = Math.PI / 2;

    // If the original track has text labels, we need to flip
    // them horizontally, otherwise they'll be mirrored.
    originalTrack.flipText = true;
    this.svgOutput = null;

    if (originalTrack.gBase && originalTrack.gMain) {
      this.originalTrack.gBase.attr('transform', 'translate(' + this.moveToOrigin.position.x + ',' + this.moveToOrigin.position.y + ')\n                             rotate(90)\n                             scale(' + this.moveToOrigin.scale.x + ',' + this.moveToOrigin.scale.y + ')');
      this.originalTrack.gMain.attr('transform', 'translate(' + this.originalTrack.pBase.position.x + ',' + this.originalTrack.pBase.position.y + ')');
    }
  }

  _createClass(LeftTrackModifier, [{
    key: 'remove',
    value: function () {
      function remove() {
        this.originalTrack.remove();

        this.pBase.clear();
        this.scene.removeChild(this.pBase);
      }

      return remove;
    }()
  }, {
    key: 'setDimensions',
    value: function () {
      function setDimensions(newDimensions) {
        this.dimensions = newDimensions;

        var reversedDimensions = [newDimensions[1], newDimensions[0]];

        this.originalTrack.setDimensions(reversedDimensions);
      }

      return setDimensions;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        this.position = newPosition;

        this.originalTrack.setPosition(newPosition);

        this.originalTrack.pBase.position.x = -this.originalTrack.position[0];
        this.originalTrack.pBase.position.y = -this.originalTrack.position[1];

        this.moveToOrigin.scale.y = -1;
        this.moveToOrigin.scale.x = 1;
        this.moveToOrigin.position.x = this.originalTrack.position[0];
        this.moveToOrigin.position.y = this.originalTrack.position[1];

        if (this.originalTrack.gMain) {
          this.originalTrack.gBase.attr('transform', 'translate(' + this.moveToOrigin.position.x + ',' + this.moveToOrigin.position.y + ')\n                                 rotate(90)\n                                 scale(' + this.moveToOrigin.scale.x + ',' + this.moveToOrigin.scale.y + ')');
          this.originalTrack.gMain.attr('transform', 'translate(' + this.originalTrack.pBase.position.x + ',' + this.originalTrack.pBase.position.y + ')');
        }
      }

      return setPosition;
    }()
  }, {
    key: 'refXScale',
    value: function () {
      function refXScale(_) {
        /**
             * Either get or set the reference xScale
             */
        if (!arguments.length) {
          return this.originalTrack._refYScale;
        }

        this.originalTrack._refXScale = _;

        return this;
      }

      return refXScale;
    }()
  }, {
    key: 'refYScale',
    value: function () {
      function refYScale(_) {
        /**
             * Either get or set the reference yScale
             */
        if (!arguments.length) {
          return this.originalTrack._refXScale;
        }

        this.originalTrack._refYScale = _;

        return this;
      }

      return refYScale;
    }()
  }, {
    key: 'xScale',
    value: function () {
      function xScale(_) {
        /**
             * Either get or set the xScale
             */
        if (!arguments.length) {
          return this.originalTrack._xScale;
        }

        this.originalTrack._yScale = _;

        return this;
      }

      return xScale;
    }()
  }, {
    key: 'yScale',
    value: function () {
      function yScale(_) {
        /**
             * Either get or set the yScale
             */
        if (!arguments.length) {
          return this.originalTrack._yScale;
        }

        this.originalTrack._xScale = _;

        return this;
      }

      return yScale;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        this.originalTrack.draw();
      }

      return draw;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        var k = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        var tx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var ty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var xPositionOffset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        var yPositionOffset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;

        this.xScale(newXScale);
        this.yScale(newYScale);

        this.originalTrack.refreshTiles();

        var offset = this.originalTrack._xScale(0) - k * this.originalTrack._refXScale(0);
        this.originalTrack.pMobile.position.x = offset + this.originalTrack.position[0];
        this.originalTrack.pMobile.position.y = this.originalTrack.position[1] + this.originalTrack.dimensions[1];

        this.originalTrack.pMobile.scale.x = k;
        this.originalTrack.pMobile.scale.y = k;

        if (this.originalTrack.options.oneDHeatmapFlipped) {
          this.originalTrack.pMobile.scale.y = -k;
          this.originalTrack.pMobile.position.y = this.originalTrack.position[1];
        }

        this.originalTrack.draw();
      }

      return zoomed;
    }()
  }, {
    key: 'refScalesChanged',
    value: function () {
      function refScalesChanged(refXScale, refYScale) {
        this.originalTrack.refScalesChanged(refYScale, refXScale);
      }

      return refScalesChanged;
    }()
  }, {
    key: 'rerender',
    value: function () {
      function rerender(options) {
        this.originalTrack.rerender(options);
      }

      return rerender;
    }()
  }, {
    key: 'exportSVG',
    value: function () {
      function exportSVG() {
        var output = document.createElement('g');
        output.setAttribute('transform', 'translate(' + this.moveToOrigin.position.x + ',' + this.moveToOrigin.position.y + ')\n                             rotate(90)\n                             scale(' + this.moveToOrigin.scale.x + ',' + this.moveToOrigin.scale.y + ')');

        if (this.originalTrack.exportSVG) {
          var g = document.createElement('g');
          g.setAttribute('transform', 'translate(' + this.originalTrack.pBase.position.x + ', ' + this.originalTrack.pBase.position.y + ')');

          g.appendChild(this.originalTrack.exportSVG()[0]);
          output.appendChild(g);
        }

        return [output, output];
      }

      return exportSVG;
    }()
  }]);

  return LeftTrackModifier;
}();

exports['default'] = LeftTrackModifier;

/***/ }),
/* 663 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HorizontalGeneAnnotationsTrack = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _boxIntersect = __webpack_require__(84);

var _boxIntersect2 = _interopRequireDefault(_boxIntersect);

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _HorizontalTiled1DPixiTrack = __webpack_require__(60);

var _HorizontalTiled1DPixiTrack2 = _interopRequireDefault(_HorizontalTiled1DPixiTrack);

var _services = __webpack_require__(7);

var _utils = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Components


// Services


// Utils


var GENE_RECT_WIDTH = 1;
var GENE_RECT_HEIGHT = 6;
var MAX_TEXTS = 20;

var HorizontalGeneAnnotationsTrack = exports.HorizontalGeneAnnotationsTrack = function (_HorizontalTiled1DPix) {
  _inherits(HorizontalGeneAnnotationsTrack, _HorizontalTiled1DPix);

  /**
   * Create a new track for Gene Annotations
   *
   * Arguments:
   * ----------
   *  scene: PIXI.js scene (or graphics)
   *      Where to draw everything.
   *  server: string
   *      The server from which to retrieve data
   *  uid: string
   *      The uid of the track on the server
   *  handleTilesetInfoReceived: function
   *      A callback to let the caller know that we've received the
   *      tileset information for this track.
   *  options: {}
   *      An object containing all of the options that describe how this track should
   *      be rendered
   *  animate: callback
   *      Function to be called when something in this track changes.
   *  popupCallback: function
   *      Callback for when this track wishes to display extra information
   *      (e.g. gene information)
   */
  function HorizontalGeneAnnotationsTrack(scene, server, uid, handleTilesetInfoReceived, options, animate, popupCallback) {
    _classCallCheck(this, HorizontalGeneAnnotationsTrack);

    var _this = _possibleConstructorReturn(this, (HorizontalGeneAnnotationsTrack.__proto__ || Object.getPrototypeOf(HorizontalGeneAnnotationsTrack)).call(this, scene, server, uid, handleTilesetInfoReceived, options, animate, popupCallback));

    _this.textFontSize = '10px';
    _this.textFontFamily = 'Arial';
    return _this;
  }

  _createClass(HorizontalGeneAnnotationsTrack, [{
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        var _this2 = this;

        // console.log('initTile...', tile.tileId);
        // create texts
        tile.texts = {};

        tile.rectGraphics = new PIXI.Graphics();
        tile.textGraphics = new PIXI.Graphics();

        tile.graphics.addChild(tile.rectGraphics);
        tile.graphics.addChild(tile.textGraphics);

        var MAX_TILE_ENTRIES = 50;

        if (!tile.tileData.sort) {
          //console.warn('Strange tileData', tile);
          return;
        }

        tile.tileData.sort(function (a, b) {
          return b.importance - a.importance;
        });
        tile.tileData = tile.tileData.slice(0, MAX_TILE_ENTRIES);

        tile.tileData.forEach(function (td, i) {
          var geneInfo = td.fields;
          var fill = _this2.options.plusStrandColor ? _this2.options.plusStrandColor : 'blue';

          if (geneInfo[5] == '-') {
            fill = _this2.options.minusStrandColor ? _this2.options.minusStrandColor : 'red';
          }
          tile.textWidths = {};
          tile.textHeights = {};

          // don't draw texts for the latter entries in the tile
          if (i >= MAX_TEXTS) {
            return;
          }

          // geneInfo[3] is the gene symbol
          var text = new PIXI.Text(geneInfo[3], { fontSize: _this2.textFontSize,
            fontFamily: _this2.textFontFamily,
            fill: (0, _utils.colorToHex)(fill) });
          text.interactive = true;
          text.click = function (e) {
            console.log('click');
          };

          if (_this2.flipText) {
            text.scale.x = -1;
          }

          text.anchor.x = 0.5;
          text.anchor.y = 1;

          tile.texts[geneInfo[3]] = text; // index by geneName

          tile.textGraphics.addChild(text);
        });

        tile.initialized = true;

        this.renderTile(tile);
        // this.draw();
      }

      return initTile;
    }()
  }, {
    key: 'destroyTile',
    value: function () {
      function destroyTile(tile) {
        // remove texts

      }

      return destroyTile;
    }()
  }, {
    key: 'rerender',
    value: function () {
      function rerender(options, force) {
        /*
         * Redraw the track because the options
         * changed
         */
        var strOptions = JSON.stringify(options);
        if (!force && strOptions === this.prevOptions) {
          return;
        }

        this.prevOptions = strOptions;
        _get(HorizontalGeneAnnotationsTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalGeneAnnotationsTrack.prototype), 'rerender', this).call(this, options, force);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.visibleAndFetchedTiles()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tile = _step.value;

            this.renderTile(tile);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return rerender;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tile) {}

      return drawTile;
    }()
  }, {
    key: 'renderTile',
    value: function () {
      function renderTile(tile) {
        var _this3 = this;

        if (!tile.initialized) {
          return;
        }

        tile.allRects = [];

        // store the scale at while the tile was drawn at so that
        // we only resize it when redrawing
        tile.drawnAtScale = this._xScale.copy();
        var fill = {};

        fill['+'] = (0, _utils.colorToHex)(this.options.plusStrandColor ? this.options.plusStrandColor : 'blue');
        fill['-'] = (0, _utils.colorToHex)(this.options.minusStrandColor ? this.options.minusStrandColor : 'red');

        tile.tileData.forEach(function (td, i) {
          var geneInfo = td.fields;
          // the returned positions are chromosome-based and they need to
          // be converted to genome-based
          var chrOffset = +td.chrOffset;

          var txStart = +geneInfo[1] + chrOffset;
          var txEnd = +geneInfo[2] + chrOffset;
          var exonStarts = geneInfo[12],
              exonEnds = geneInfo[13];

          var txMiddle = (txStart + txEnd) / 2;

          var yMiddle = _this3.dimensions[1] / 2;
          var textYMiddle = _this3.dimensions[1] / 2;
          var geneName = geneInfo[3];

          if (geneInfo[5] == '+') {
            // genes on the + strand drawn above and in a user-specified color or the default blue
            yMiddle -= 6;
            textYMiddle -= 10;
            tile.rectGraphics.lineStyle(1, fill['+'], 0.3);
            tile.rectGraphics.beginFill(fill['+'], 0.3);
          } else {
            // genes on the - strand drawn below and in a user-specified color or the default red
            yMiddle += 6;
            textYMiddle += 23;
            tile.rectGraphics.lineStyle(1, fill['-'], 0.3);
            tile.rectGraphics.beginFill(fill['-'], 0.3);
          }

          // let height = valueScale(Math.log(+geneInfo[4]));
          // let width= height;

          var rectX = _this3._xScale(txMiddle) - GENE_RECT_WIDTH / 2;
          var rectY = yMiddle - GENE_RECT_HEIGHT / 2;

          var xStartPos = _this3._xScale(txStart);
          var xEndPos = _this3._xScale(txEnd);

          var MIN_SIZE_FOR_EXONS = 10;

          if (xEndPos - xStartPos > MIN_SIZE_FOR_EXONS) {
            if (geneInfo.length < 14) {
              // don't draw if the input is invalid
              console.warn("Gene annotations have less than 14 columns (chrName, chrStart, chrEnd, symbol, importance, transcript_name, geneId, transcript_type, '-', txStart, txEnd, exonStarts, exonEnds:", geneInfo);
            } else {
              tile.allRects = tile.allRects.concat(_this3.drawExons(tile.rectGraphics, txStart, txEnd, exonStarts, exonEnds, chrOffset, yMiddle).map(function (x) {
                return x.concat([geneInfo[5]]);
              }));
            }
            // this.drawExons(tile.textGraphics, txStart, txEnd, exonStarts, exonEnds, chrOffset, yMiddle)
          } else {
            // graphics.drawRect(rectX, rectY, width, height);
            // console.log('rectY', rectY);
            // this.allRects.push([rectX, rectY, GENE_RECT_WIDTH, GENE_RECT_HEIGHT, geneInfo[5]]);
            tile.rectGraphics.drawRect(rectX, rectY, GENE_RECT_WIDTH, GENE_RECT_HEIGHT);
            tile.allRects.push([rectX, rectY, GENE_RECT_WIDTH, GENE_RECT_HEIGHT, geneInfo[5]]);
          }

          if (!tile.texts) {
            // tile probably hasn't been initialized yet
            return;
          }

          // don't draw texts for the latter entries in the tile
          if (i >= MAX_TEXTS) {
            return;
          }

          var text = tile.texts[geneName];

          text.position.x = _this3._xScale(txMiddle);
          text.position.y = textYMiddle;
          text.style = { fontSize: _this3.textFontSize,
            fontFamily: _this3.textFontFamily,
            fill: fill[geneInfo[5]] };

          if (!(geneInfo[3] in tile.textWidths)) {
            text.updateTransform();
            var textWidth = text.getBounds().width;
            var textHeight = text.getBounds().height;

            tile.textWidths[geneInfo[3]] = textWidth;
            tile.textHeights[geneInfo[3]] = textHeight;
          }
        });
      }

      return renderTile;
    }()
  }, {
    key: 'calculateZoomLevel',
    value: function () {
      function calculateZoomLevel() {
        // offset by 2 because 1D tiles are more dense than 2D tiles
        // 1024 points per tile vs 256 for 2D tiles
        var xZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);

        var zoomLevel = Math.min(xZoomLevel, this.maxZoom);
        zoomLevel = Math.max(zoomLevel, 0);

        return zoomLevel;
      }

      return calculateZoomLevel;
    }()
  }, {
    key: 'drawExons',
    value: function () {
      function drawExons(graphics, txStart, txEnd, exonStarts, exonEnds, chrOffset, yMiddle) {
        exonStarts = exonStarts.split(',').map(function (x) {
          return +x + chrOffset;
        });
        exonEnds = exonEnds.split(',').map(function (x) {
          return +x + chrOffset;
        });
        var rects = [];

        var xStartPos = this._xScale(txStart);
        var xEndPos = this._xScale(txEnd);

        var lineHeight = 1.5;
        var exonHeight = GENE_RECT_HEIGHT;
        var yPos = yMiddle - lineHeight / 2;
        // let yPos = (d.height - lineHeight) / 2 + 5 ; //-(d.height - yScale(tileData[i]));
        var width = xEndPos - xStartPos;

        var yExonPos = yMiddle - exonHeight / 2;

        graphics.drawRect(xStartPos, yPos, width, lineHeight);
        rects.push([xStartPos, yPos, width, lineHeight]);

        for (var j = 0; j < exonStarts.length; j++) {
          var exonStart = exonStarts[j];
          var exonEnd = exonEnds[j];

          rects.push([this._xScale(exonStart), yExonPos, this._xScale(exonEnd) - this._xScale(exonStart), exonHeight]);

          graphics.drawRect(this._xScale(exonStart), yExonPos, this._xScale(exonEnd) - this._xScale(exonStart), exonHeight);
        }

        return rects;
      }

      return drawExons;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        var _this4 = this;

        _get(HorizontalGeneAnnotationsTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalGeneAnnotationsTrack.prototype), 'draw', this).call(this);
        // console.trace('drawing', this, this._xScale.domain(), this._xScale.range());

        // graphics.clear();

        var maxValue = 0;
        this.allTexts = [];
        this.allBoxes = [];

        var _loop = function () {
          function _loop(fetchedTileId) {
            var tile = _this4.fetchedTiles[fetchedTileId];

            if (!tile.drawnAtScale) {
              // tile hasn't been drawn properly because we likely got some
              // bogus data from the server
              // console.warn("Tile without drawnAtScale:", tile);
              return 'continue';
            }

            // scale the rectangles

            var tileK = (tile.drawnAtScale.domain()[1] - tile.drawnAtScale.domain()[0]) / (_this4._xScale.domain()[1] - _this4._xScale.domain()[0]);
            var newRange = _this4._xScale.domain().map(tile.drawnAtScale);

            var posOffset = newRange[0];
            tile.rectGraphics.scale.x = tileK;
            tile.rectGraphics.position.x = -posOffset * tileK;

            // move the texts

            var parentInFetched = _this4.parentInFetched(tile);

            if (!tile.initialized) {
              return 'continue';
            }

            tile.tileData.forEach(function (td, i) {
              if (!tile.texts) {
                // tile probably hasn't been initialized yet
                return;
              }

              var geneInfo = td.fields;
              var geneName = geneInfo[3];
              var text = tile.texts[geneName];

              if (!text) {
                return;
              }

              var chrOffset = +td.chrOffset;
              var txStart = +geneInfo[1] + chrOffset;
              var txEnd = +geneInfo[2] + chrOffset;
              var txMiddle = (txStart + txEnd) / 2;
              var textYMiddle = _this4.dimensions[1] / 2;

              if (geneInfo[5] == '+') {
                // genes on the + strand drawn above and in a user-specified color or the default blue
                textYMiddle -= 10;
              } else {
                // genes on the - strand drawn below and in a user-specified color or the default red
                textYMiddle += 23;
              }

              text.position.x = _this4._xScale(txMiddle);
              text.position.y = textYMiddle;

              if (!parentInFetched) {
                text.visible = true;

                var TEXT_MARGIN = 3;

                if (_this4.flipText) {
                  // when flipText is set, that means that the track is being displayed vertically so we need to use
                  // the stored text height rather than width
                  _this4.allBoxes.push([text.position.x, textYMiddle - 1, text.position.x + tile.textHeights[geneInfo[3]] + TEXT_MARGIN, textYMiddle + 1]);
                } else _this4.allBoxes.push([text.position.x, textYMiddle - 1, text.position.x + tile.textWidths[geneInfo[3]] + TEXT_MARGIN, textYMiddle + 1]);

                _this4.allTexts.push({ importance: +geneInfo[4], text: text, caption: geneName, strand: geneInfo[5] });
              } else {
                text.visible = false;
              }
            });
          }

          return _loop;
        }();

        for (var fetchedTileId in this.fetchedTiles) {
          var _ret = _loop(fetchedTileId);

          if (_ret === 'continue') continue;
        }

        /*
            for (let fetchedTileId in this.fetchedTiles) {
                let ft = this.fetchedTiles[fetchedTileId];
                 ft.tileData.forEach(td => {
                    let geneInfo = td.fields;
                    if (+geneInfo[4] > maxValue)
                        maxValue = geneInfo[4];
                });
            }
            */

        // console.trace('draw', allTexts.length);
        this.hideOverlaps(this.allBoxes, this.allTexts);
      }

      return draw;
    }()
  }, {
    key: 'hideOverlaps',
    value: function () {
      function hideOverlaps(allBoxes, allTexts) {
        // store the bounding boxes of the text objects so we can
        // calculate overlaps
        // console.log('allTexts.length', allTexts.length);

        /*
            let allBoxes = allTexts.map(val => {
                let text = val.text;
                text.updateTransform();
                let b = text.getBounds();
                let box = [b.x, b.y, b.x + b.width, b.y + b.height];
                 return box;
            });
            */

        var result = (0, _boxIntersect2['default'])(allBoxes, function (i, j) {
          if (allTexts[i].importance > allTexts[j].importance) {
            // console.log('hiding:', allTexts[j].caption)
            allTexts[j].text.visible = false;
          } else {
            // console.log('hiding:', allTexts[i].caption)
            allTexts[i].text.visible = false;
          }
        });
      }

      return hideOverlaps;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(HorizontalGeneAnnotationsTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalGeneAnnotationsTrack.prototype), 'setPosition', this).call(this, newPosition);

        this.pMain.position.y = this.position[1];
        this.pMain.position.x = this.position[0];
      }

      return setPosition;
    }()
  }, {
    key: 'setDimensions',
    value: function () {
      function setDimensions(newDimensions) {
        _get(HorizontalGeneAnnotationsTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalGeneAnnotationsTrack.prototype), 'setDimensions', this).call(this, newDimensions);

        // redraw the contents
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.visibleAndFetchedTiles()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _tile = _step2.value;

            _tile.rectGraphics.clear();

            this.renderTile(_tile);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      return setDimensions;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        this.xScale(newXScale);
        this.yScale(newYScale);

        this.refreshTiles();

        this.draw();
      }

      return zoomed;
    }()
  }, {
    key: 'exportSVG',
    value: function () {
      function exportSVG() {
        var track = null,
            base = null;

        if (_get(HorizontalGeneAnnotationsTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalGeneAnnotationsTrack.prototype), 'exportSVG', this)) {
          var _get$call = _get(HorizontalGeneAnnotationsTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalGeneAnnotationsTrack.prototype), 'exportSVG', this).call(this);

          var _get$call2 = _slicedToArray(_get$call, 2);

          base = _get$call2[0];
          track = _get$call2[1];
        } else {
          base = document.createElement('g');
          track = base;
        }
        var output = document.createElement('g');
        output.setAttribute('transform', 'translate(' + this.position[0] + ',' + this.position[1] + ')');

        track.appendChild(output);

        var allRects = [];
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.visibleAndFetchedTiles()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _tile2 = _step3.value;

            allRects = allRects.concat(_tile2.allRects);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3['return']) {
              _iterator3['return']();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = allRects[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var rect = _step4.value;

            var r = document.createElement('rect');
            r.setAttribute('x', rect[0]);
            r.setAttribute('y', rect[1]);
            r.setAttribute('width', rect[2]);
            r.setAttribute('height', rect[3]);

            if (rect[4] == '+') {
              r.setAttribute('fill', this.options.plusStrandColor);
            } else {
              r.setAttribute('fill', this.options.minusStrandColor);
            }

            output.appendChild(r);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4['return']) {
              _iterator4['return']();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = this.allTexts[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var text = _step5.value;

            if (!text.text.visible) {
              continue;
            }

            var g = document.createElement('g');
            var t = document.createElement('text');
            t.setAttribute('text-anchor', 'middle');
            t.setAttribute('font-family', this.textFontFamily);
            t.setAttribute('font-size', this.textFontSize);

            // this small adjustment of .2em is to place the text better
            // in relation to the rectangles used for the genes and exons
            t.setAttribute('dy', '-.2em');
            g.setAttribute('transform', 'scale(' + text.text.scale.x + ',1)');

            if (text.strand === '+') {
              // t.setAttribute('stroke', this.options.plusStrandColor);
              t.setAttribute('fill', this.options.plusStrandColor);
            } else {
              // t.setAttribute('stroke', this.options.minusStrandColor);
              t.setAttribute('fill', this.options.minusStrandColor);
            }

            t.innerHTML = text.text.text;

            g.appendChild(t);
            g.setAttribute('transform', 'translate(' + text.text.x + ',' + text.text.y + ')scale(' + text.text.scale.x + ',1)');
            output.appendChild(g);
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5['return']) {
              _iterator5['return']();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }

        return [base, base];
      }

      return exportSVG;
    }()
  }]);

  return HorizontalGeneAnnotationsTrack;
}(_HorizontalTiled1DPixiTrack2['default']);

exports['default'] = HorizontalGeneAnnotationsTrack;

/***/ }),
/* 664 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrowheadDomainsTrack = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _TiledPixiTrack2 = __webpack_require__(41);

var _services = __webpack_require__(7);

var _utils = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Services


// Utils


var ArrowheadDomainsTrack = exports.ArrowheadDomainsTrack = function (_TiledPixiTrack) {
  _inherits(ArrowheadDomainsTrack, _TiledPixiTrack);

  function ArrowheadDomainsTrack(scene, dataConfig, handleTilesetInfoReceived, option, animate) {
    _classCallCheck(this, ArrowheadDomainsTrack);

    var _this = _possibleConstructorReturn(this, (ArrowheadDomainsTrack.__proto__ || Object.getPrototypeOf(ArrowheadDomainsTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, option, animate));

    _this.drawnRects = {};
    return _this;
  }

  _createClass(ArrowheadDomainsTrack, [{
    key: 'tileToLocalId',
    value: function () {
      function tileToLocalId(tile) {
        /*
             * The local tile identifier
             */

        // tile contains [zoomLevel, xPos, yPos]
        return '' + tile.join('.');
      }

      return tileToLocalId;
    }()
  }, {
    key: 'tileToRemoteId',
    value: function () {
      function tileToRemoteId(tile) {
        /**
             * The tile identifier used on the server
             */

        // tile contains [zoomLevel, xPos, yPos]
        return '' + tile.join('.');
      }

      return tileToRemoteId;
    }()
  }, {
    key: 'localToRemoteId',
    value: function () {
      function localToRemoteId(remoteId) {
        var idParts = remoteId.split('.');
        return idParts.slice(0, idParts.length - 1).join('.');
      }

      return localToRemoteId;
    }()
  }, {
    key: 'calculateZoomLevel',
    value: function () {
      function calculateZoomLevel() {
        var xZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);
        var yZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.tilesetInfo.min_pos[1], this.tilesetInfo.max_pos[1]);

        var zoomLevel = Math.max(xZoomLevel, yZoomLevel);
        zoomLevel = Math.min(zoomLevel, this.maxZoom);

        return zoomLevel;
      }

      return calculateZoomLevel;
    }()
  }, {
    key: 'setVisibleTiles',
    value: function () {
      function setVisibleTiles(tilePositions) {
        var _this2 = this;

        /**
             * Set which tiles are visible right now.
             *
             * @param tiles: A set of tiles which will be considered the currently visible
             * tile positions.
             */
        this.visibleTiles = tilePositions.map(function (x) {
          return {
            tileId: _this2.tileToLocalId(x),
            remoteId: _this2.tileToRemoteId(x)
          };
        });

        this.visibleTileIds = new Set(this.visibleTiles.map(function (x) {
          return x.tileId;
        }));
      }

      return setVisibleTiles;
    }()
  }, {
    key: 'calculateVisibleTiles',
    value: function () {
      function calculateVisibleTiles() {
        var mirrorTiles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        // if we don't know anything about this dataset, no point
        // in trying to get tiles
        if (!this.tilesetInfo) {
          return;
        }

        this.zoomLevel = this.calculateZoomLevel();
        // this.zoomLevel = 0;

        this.xTiles = _services.tileProxy.calculateTiles(this.zoomLevel, this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0], this.tilesetInfo.max_zoom, this.tilesetInfo.max_width);

        this.yTiles = _services.tileProxy.calculateTiles(this.zoomLevel, this._yScale, this.tilesetInfo.min_pos[1], this.tilesetInfo.max_pos[1], this.tilesetInfo.max_zoom, this.tilesetInfo.max_width);

        var rows = this.xTiles;
        var cols = this.yTiles;
        var zoomLevel = this.zoomLevel;

        // if we're mirroring tiles, then we only need tiles along the diagonal
        var tiles = [];

        // calculate the ids of the tiles that should be visible
        for (var i = 0; i < rows.length; i++) {
          for (var j = 0; j < cols.length; j++) {
            var newTile = [zoomLevel, rows[i], cols[j]];

            tiles.push(newTile);
          }
        }

        //
        this.setVisibleTiles(tiles);
      }

      return calculateVisibleTiles;
    }()
  }, {
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        /**
             * Create whatever is needed to draw this tile.
             */

        // this.drawTile(tile);
      }

      return initTile;
    }()
  }, {
    key: 'destroyTile',
    value: function () {
      function destroyTile(tile, graphics) {}

      return destroyTile;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        this.drawnRects = {};

        _get(ArrowheadDomainsTrack.prototype.__proto__ || Object.getPrototypeOf(ArrowheadDomainsTrack.prototype), 'draw', this).call(this);
      }

      return draw;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tile) {
        if (!tile.graphics) {
          return;
        }

        // console.log('tile:', tile);
        // console.log('Id2DTiled drawTile...');
        var graphics = tile.graphics;
        graphics.clear();

        var stroke = (0, _utils.colorToHex)(this.options.rectangleDomainStrokeColor || 'black');
        var fill = (0, _utils.colorToHex)(this.options.rectangleDomainFillColor || 'grey');

        graphics.lineStyle(typeof this.options.rectangleDomainStrokeWidth !== 'undefined' ? this.options.rectangleDomainStrokeWidth : 1, stroke, typeof this.options.rectangleDomainStrokeOpacity !== 'undefined' ? this.options.rectangleDomainStrokeOpacity : 1);
        graphics.beginFill(fill, typeof this.options.rectangleDomainFillOpacity !== 'undefined' ? this.options.rectangleDomainFillOpacity : 0.4);

        graphics.alpha = this.options.rectangleDomainOpacity || 0.5;

        if (!tile.tileData.length) return;

        // line needs to be scaled down so that it doesn't become huge
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = tile.tileData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var td = _step.value;

            var line = td.fields;

            var startX = this._xScale(td.xStart);
            var endX = this._xScale(td.xEnd);

            var startY = this._yScale(td.yStart);
            var endY = this._yScale(td.yEnd);

            var uid = td.uid;

            var width = endX - startX;
            var height = endY - startY;

            if (uid in this.drawnRects) {
              continue;
            } // we've already drawn this rectangle in another tile


            var drawnRect = { x: startX, y: startY, width: endY - startY, height: endX - startX };

            if (this.options.minSquareSize && this.options.minSquareSize != 'none') {
              if (width < +this.options.minSquareSize || height < +this.options.minSquareSize) {
                var newWidth = this.options.minSquareSize;
                var newHeight = this.options.minSquareSize;

                drawnRect = { x: (startX + endX) / 2, y: (startY + endY) / 2,
                  width: newWidth, height: newHeight };
              }
            }

            this.drawnRects[uid] = drawnRect;

            graphics.drawRect(drawnRect.x, drawnRect.y, drawnRect.width, drawnRect.height);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return drawTile;
    }()
  }, {
    key: 'exportSVG',
    value: function () {
      function exportSVG() {
        var _this3 = this;

        var track = null,
            base = null;

        if (_get(ArrowheadDomainsTrack.prototype.__proto__ || Object.getPrototypeOf(ArrowheadDomainsTrack.prototype), 'exportSVG', this)) {
          var _get$call = _get(ArrowheadDomainsTrack.prototype.__proto__ || Object.getPrototypeOf(ArrowheadDomainsTrack.prototype), 'exportSVG', this).call(this);

          var _get$call2 = _slicedToArray(_get$call, 2);

          base = _get$call2[0];
          track = _get$call2[1];
        } else {
          base = document.createElement('g');
          track = base;
        }
        var output = document.createElement('g');
        output.setAttribute('transform', 'translate(' + this.position[0] + ',' + this.position[1] + ')');

        track.appendChild(output);

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          var _loop = function () {
            function _loop() {
              var tile = _step2.value;

              if (!tile.tileData || !tile.tileData.length)
                // this tile has no data
                return 'continue';

              tile.tileData.forEach(function (td, i) {
                var gTile = document.createElement('g');
                gTile.setAttribute('transform', 'translate(' + tile.graphics.position.x + ',' + tile.graphics.position.y + ')scale(' + tile.graphics.scale.x + ',' + tile.graphics.scale.y + ')');
                output.appendChild(gTile);

                if (td.uid in _this3.drawnRects) {
                  var rect = _this3.drawnRects[td.uid];

                  var r = document.createElement('rect');
                  r.setAttribute('x', rect.x);
                  r.setAttribute('y', rect.y);
                  r.setAttribute('width', rect.width);
                  r.setAttribute('height', rect.height);

                  r.setAttribute('fill', _this3.options.fillColor ? _this3.options.fillColor : 'grey');
                  r.setAttribute('opacity', 0.3);

                  r.style.stroke = _this3.options.fillColor ? _this3.options.fillColor : 'grey';
                  r.style.strokeWidth = "1px";

                  gTile.appendChild(r);
                }
              });
            }

            return _loop;
          }();

          for (var _iterator2 = this.visibleAndFetchedTiles()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _ret = _loop();

            if (_ret === 'continue') continue;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return [base, base];
      }

      return exportSVG;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(ArrowheadDomainsTrack.prototype.__proto__ || Object.getPrototypeOf(ArrowheadDomainsTrack.prototype), 'setPosition', this).call(this, newPosition);

        this.pMain.position.y = this.position[1];
        this.pMain.position.x = this.position[0];
      }

      return setPosition;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        this.xScale(newXScale);
        this.yScale(newYScale);

        this.refreshTiles();

        this.draw();
      }

      return zoomed;
    }()
  }]);

  return ArrowheadDomainsTrack;
}(_TiledPixiTrack2.TiledPixiTrack);

exports['default'] = ArrowheadDomainsTrack;

/***/ }),
/* 665 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Horizontal2DDomainsTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _TiledPixiTrack2 = __webpack_require__(41);

var _services = __webpack_require__(7);

var _utils = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Horizontal2DDomainsTrack = exports.Horizontal2DDomainsTrack = function (_TiledPixiTrack) {
  _inherits(Horizontal2DDomainsTrack, _TiledPixiTrack);

  function Horizontal2DDomainsTrack(scene, dataConfig, handleTilesetInfoReceived, option, animate) {
    _classCallCheck(this, Horizontal2DDomainsTrack);

    var _this = _possibleConstructorReturn(this, (Horizontal2DDomainsTrack.__proto__ || Object.getPrototypeOf(Horizontal2DDomainsTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, option, animate));

    _this.drawnRects = new Set();
    _this.pMain = _this.pMobile;
    return _this;
  }

  _createClass(Horizontal2DDomainsTrack, [{
    key: 'tileToLocalId',
    value: function () {
      function tileToLocalId(tile) {
        /*
             * The local tile identifier
             */

        // tile contains [zoomLevel, xPos, yPos]
        return '' + tile.join('.');
      }

      return tileToLocalId;
    }()
  }, {
    key: 'tileToRemoteId',
    value: function () {
      function tileToRemoteId(tile) {
        /**
             * The tile identifier used on the server
             */

        // tile contains [zoomLevel, xPos, yPos]
        return '' + tile.join('.');
      }

      return tileToRemoteId;
    }()
  }, {
    key: 'localToRemoteId',
    value: function () {
      function localToRemoteId(remoteId) {
        var idParts = remoteId.split('.');
        return idParts.slice(0, idParts.length - 1).join('.');
      }

      return localToRemoteId;
    }()
  }, {
    key: 'calculateZoomLevel',
    value: function () {
      function calculateZoomLevel() {
        var xZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);
        var yZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.tilesetInfo.min_pos[1], this.tilesetInfo.max_pos[1]);

        var zoomLevel = Math.max(xZoomLevel, yZoomLevel);
        zoomLevel = Math.min(zoomLevel, this.maxZoom);

        if (this.options && this.options.maxZoom) {
          if (this.options.maxZoom >= 0) {
            zoomLevel = Math.min(this.options.maxZoom, zoomLevel);
          } else {
            console.error('Invalid maxZoom on track:', this);
          }
        }

        return zoomLevel;
      }

      return calculateZoomLevel;
    }()
  }, {
    key: 'setVisibleTiles',
    value: function () {
      function setVisibleTiles(tilePositions) {
        var _this2 = this;

        /**
             * Set which tiles are visible right now.
             *
             * @param tiles: A set of tiles which will be considered the currently visible
             * tile positions.
             */
        this.visibleTiles = tilePositions.map(function (x) {
          return {
            tileId: _this2.tileToLocalId(x),
            remoteId: _this2.tileToRemoteId(x)
          };
        });

        this.visibleTileIds = new Set(this.visibleTiles.map(function (x) {
          return x.tileId;
        }));
      }

      return setVisibleTiles;
    }()
  }, {
    key: 'calculateVisibleTiles',
    value: function () {
      function calculateVisibleTiles() {
        /**
             * Taken from HorizontalHeatmapTrack.js
             */

        // if we don't know anything about this dataset, no point
        // in trying to get tiles
        if (!this.tilesetInfo) {
          return;
        }

        this.zoomLevel = this.calculateZoomLevel();

        // this.zoomLevel = 0;
        var expandedXScale = this._xScale.copy();

        var xDomainWidth = this._xScale.domain()[1] - this._xScale.domain()[0];
        var xRangeWidth = this._xScale.range()[1] - this._xScale.range()[0];

        // we need to expand the domain of the X-scale because we are showing diagonal tiles.
        // to make sure the view is covered up the entire height, we need to expand by viewHeight * sqrt(2)
        // on each side
        expandedXScale.domain([this._xScale.invert(this._xScale.range()[0] - this.dimensions[1] * Math.sqrt(2)), this._xScale.invert(this._xScale.range()[1] + this.dimensions[1] * Math.sqrt(2))]);

        this.xTiles = _services.tileProxy.calculateTiles(this.zoomLevel, expandedXScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0], this.tilesetInfo.max_zoom, this.tilesetInfo.max_width);

        this.yTiles = _services.tileProxy.calculateTiles(this.zoomLevel, expandedXScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0], this.tilesetInfo.max_zoom, this.tilesetInfo.max_width);

        var rows = this.xTiles;
        var cols = this.yTiles;
        var zoomLevel = this.zoomLevel;

        var maxWidth = this.tilesetInfo.max_width;
        var tileWidth = maxWidth / Math.pow(2, zoomLevel);

        // if we're mirroring tiles, then we only need tiles along the diagonal
        var tiles = [];

        // calculate the ids of the tiles that should be visible
        for (var i = 0; i < rows.length; i++) {
          for (var j = i; j < cols.length; j++) {
            // the length between the bottom of the track and the bottom corner of the tile
            // draw it out to understand better!
            var tileBottomPosition = (j - i - 2) * (this._xScale(tileWidth) - this._xScale(0)) * Math.sqrt(2) / 2;

            if (tileBottomPosition > this.dimensions[1]) {
              // this tile won't be visible so we don't need to fetch it
              continue;
            }

            var newTile = [zoomLevel, rows[i], cols[j]];
            newTile.mirrored = false;

            tiles.push(newTile);
          }
        }

        this.setVisibleTiles(tiles);
      }

      return calculateVisibleTiles;
    }()
  }, {
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        /**
             * Create whatever is needed to draw this tile.
             */
        _get(Horizontal2DDomainsTrack.prototype.__proto__ || Object.getPrototypeOf(Horizontal2DDomainsTrack.prototype), 'initTile', this).call(this, tile);

        // this.drawTile(tile);
        this.drawTile(tile);
      }

      return initTile;
    }()
  }, {
    key: 'destroyTile',
    value: function () {
      function destroyTile(tile, graphics) {}

      return destroyTile;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        // console.log('delayDrawing:', this.delayDrawing, this.dimensions[1]);
        if (!this.delayDrawing) {
          this.drawnRects.clear();
        }

        _get(Horizontal2DDomainsTrack.prototype.__proto__ || Object.getPrototypeOf(Horizontal2DDomainsTrack.prototype), 'draw', this).call(this);
      }

      return draw;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tile) {
        if (!tile.graphics) {
          return;
        }

        // console.log('Id2DTiled drawTile...');
        var graphics = tile.graphics;

        graphics.clear();

        var stroke = (0, _utils.colorToHex)(this.options.rectangleDomainStrokeColor ? this.options.rectangleDomainStrokeColor : 'black');
        var fill = (0, _utils.colorToHex)(this.options.rectangleDomainFillColor ? this.options.rectangleDomainFillColor : 'grey');

        graphics.lineStyle(1 / this.pMain.scale.x, stroke, 1);
        graphics.beginFill(fill, 0.4);
        graphics.alpha = this.options.rectangleDomainOpacity ? this.options.rectangleDomainOpacity : 0.5;

        if (!tile.tileData.sort) return;

        // line needs to be scaled down so that it doesn't become huge
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = tile.tileData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var td = _step.value;

            var line = td.fields;

            var startX = this._refXScale(td.xStart);
            var endX = this._refXScale(td.xEnd);

            var startY = this._refYScale(td.yStart);
            var endY = this._refYScale(td.yEnd);

            var uid = td.uid;

            if (this.drawnRects.has(uid)) {
              continue;
            } // we've already drawn this rectangle in another tile

            this.drawnRects.add(uid);
            graphics.drawRect(startX, startY, endX - startX, endY - startY);

            graphics.pivot.x = this._refXScale(0);
            graphics.pivot.y = this._refYScale(0);
            graphics.scale.x = -1 / Math.sqrt(2);
            graphics.rotation = -3 * Math.PI / 4;
            graphics.scale.y = 1 / Math.sqrt(2);

            graphics.position.x = this._refXScale(0);
            graphics.position.y = 0;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return drawTile;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(Horizontal2DDomainsTrack.prototype.__proto__ || Object.getPrototypeOf(Horizontal2DDomainsTrack.prototype), 'setPosition', this).call(this, newPosition);

        this.pMain.position.y = this.position[1];
        this.pMain.position.x = this.position[0];
      }

      return setPosition;
    }()
  }, {
    key: 'refScalesChanged',
    value: function () {
      function refScalesChanged(refXScale, refYScale) {
        _get(Horizontal2DDomainsTrack.prototype.__proto__ || Object.getPrototypeOf(Horizontal2DDomainsTrack.prototype), 'refScalesChanged', this).call(this, refXScale, refYScale);

        for (var uid in this.fetchedTiles) {
          var tile = this.fetchedTiles[uid];

          if (tile.sprite) {
            var graphics = tile.graphics;

            graphics.pivot.x = this._refXScale(0);
            graphics.pivot.y = this._refYScale(0);
            graphics.scale.x = -1 / Math.sqrt(2);
            graphics.rotation = -3 * Math.PI / 4;
            graphics.scale.y = 1 / Math.sqrt(2);

            graphics.position.x = this._refXScale(0);
            graphics.position.y = 0;
          } else {
            // console.log('skipping...', tile.tileId);
          }
        }
      }

      return refScalesChanged;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale, k, tx, ty) {
        _get(Horizontal2DDomainsTrack.prototype.__proto__ || Object.getPrototypeOf(Horizontal2DDomainsTrack.prototype), 'zoomed', this).call(this, newXScale, newYScale, k, tx, ty);
        // console.log('zoomed this.pMain.position:', this.pMain.position.x, this.pMain.position.y, this.pMain.scale.x, this.pMain.scale.y);

        this.pMain.position.x = tx;
        this.pMain.position.y = this.position[1] + this.dimensions[1]; // translateY;

        this.pMain.scale.x = k; // scaleX;
        this.pMain.scale.y = k; // scaleY;

        if (this.options.oneDHeatmapFlipped) {
          this.pMain.scale.y = -k;
          this.pMain.position.y = this.position[1];
        }

        this.draw();
      }

      return zoomed;
    }()
  }]);

  return Horizontal2DDomainsTrack;
}(_TiledPixiTrack2.TiledPixiTrack);

exports['default'] = Horizontal2DDomainsTrack;

/***/ }),
/* 666 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SquareMarkersTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _TiledPixiTrack2 = __webpack_require__(41);

var _TiledPixiTrack3 = _interopRequireDefault(_TiledPixiTrack2);

var _services = __webpack_require__(7);

var _utils = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SquareMarkersTrack = exports.SquareMarkersTrack = function (_TiledPixiTrack) {
  _inherits(SquareMarkersTrack, _TiledPixiTrack);

  function SquareMarkersTrack(scene, server, uid, handleTilesetInfoReceived, option, animate) {
    _classCallCheck(this, SquareMarkersTrack);

    var _this = _possibleConstructorReturn(this, (SquareMarkersTrack.__proto__ || Object.getPrototypeOf(SquareMarkersTrack)).call(this, scene, server, uid, handleTilesetInfoReceived, option, animate));

    _this.drawnRects = new Set();
    return _this;
  }

  /*
   * The local tile identifier
   */


  _createClass(SquareMarkersTrack, [{
    key: 'tileToLocalId',
    value: function () {
      function tileToLocalId(tile) {
        // tile contains [zoomLevel, xPos, yPos]
        return '' + tile.join('.');
      }

      return tileToLocalId;
    }()

    /**
     * The tile identifier used on the server
     */

  }, {
    key: 'tileToRemoteId',
    value: function () {
      function tileToRemoteId(tile) {
        // tile contains [zoomLevel, xPos, yPos]
        return '' + tile.join('.');
      }

      return tileToRemoteId;
    }()
  }, {
    key: 'localToRemoteId',
    value: function () {
      function localToRemoteId(remoteId) {
        var idParts = remoteId.split('.');
        return idParts.slice(0, idParts.length - 1).join('.');
      }

      return localToRemoteId;
    }()
  }, {
    key: 'calculateZoomLevel',
    value: function () {
      function calculateZoomLevel() {
        var xZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);
        var yZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.tilesetInfo.min_pos[1], this.tilesetInfo.max_pos[1]);

        var zoomLevel = Math.max(xZoomLevel, yZoomLevel);
        zoomLevel = Math.min(zoomLevel, this.maxZoom);

        return zoomLevel;
      }

      return calculateZoomLevel;
    }()
  }, {
    key: 'setVisibleTiles',
    value: function () {
      function setVisibleTiles(tilePositions) {
        var _this2 = this;

        /**
             * Set which tiles are visible right now.
             *
             * @param tiles: A set of tiles which will be considered the currently visible
             * tile positions.
             */
        this.visibleTiles = tilePositions.map(function (x) {
          return {
            tileId: _this2.tileToLocalId(x),
            remoteId: _this2.tileToRemoteId(x)
          };
        });

        this.visibleTileIds = new Set(this.visibleTiles.map(function (x) {
          return x.tileId;
        }));
      }

      return setVisibleTiles;
    }()
  }, {
    key: 'calculateVisibleTiles',
    value: function () {
      function calculateVisibleTiles() {
        var mirrorTiles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        // if we don't know anything about this dataset, no point
        // in trying to get tiles
        if (!this.tilesetInfo) {
          return;
        }

        this.zoomLevel = this.calculateZoomLevel();
        // this.zoomLevel = 0;

        this.xTiles = _services.tileProxy.calculateTiles(this.zoomLevel, this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0], this.tilesetInfo.max_zoom, this.tilesetInfo.max_width);

        this.yTiles = _services.tileProxy.calculateTiles(this.zoomLevel, this._yScale, this.tilesetInfo.min_pos[1], this.tilesetInfo.max_pos[1], this.tilesetInfo.max_zoom, this.tilesetInfo.max_width);

        var rows = this.xTiles;
        var cols = this.yTiles;
        var zoomLevel = this.zoomLevel;

        // if we're mirroring tiles, then we only need tiles along the diagonal
        var tiles = [];

        // calculate the ids of the tiles that should be visible
        for (var i = 0; i < rows.length; i++) {
          for (var j = 0; j < cols.length; j++) {
            var newTile = [zoomLevel, rows[i], cols[j]];

            tiles.push(newTile);
          }
        }

        //
        this.setVisibleTiles(tiles);
      }

      return calculateVisibleTiles;
    }()
  }, {
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        /**
             * Create whatever is needed to draw this tile.
             */

        // this.drawTile(tile);
      }

      return initTile;
    }()
  }, {
    key: 'destroyTile',
    value: function () {
      function destroyTile(tile, graphics) {}

      return destroyTile;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        this.drawnRects.clear();

        _get(SquareMarkersTrack.prototype.__proto__ || Object.getPrototypeOf(SquareMarkersTrack.prototype), 'draw', this).call(this);
      }

      return draw;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tile) {
        if (!tile.graphics) {
          return;
        }

        // console.log('tile:', tile);
        // console.log('Id2DTiled drawTile...');
        var graphics = tile.graphics;

        graphics.clear();

        var fill = (0, _utils.colorToHex)('green');

        graphics.lineStyle(1, 0x0000FF, 1);
        graphics.beginFill(fill, 0.8);
        graphics.alpha = 0.5;

        // line needs to be scaled down so that it doesn't become huge
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = tile.tileData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var td = _step.value;

            var line = td.fields;

            var startX = this._xScale(td.xStart);
            var endX = this._xScale(td.xEnd);

            var startY = this._yScale(td.yStart);
            var endY = this._yScale(td.yEnd);

            var uid = td.uid;

            if (this.drawnRects.has(uid)) {
              continue;
            } // we've already drawn this rectangle in another tile

            this.drawnRects.add(uid);

            var MIN_WIDTH = 6;
            var MIN_HEIGHT = 6;

            var width = endY - startY;
            var height = endX - startX;

            // we're going to draw stuff relative to the center of this marker so
            // that if we have to draw a bigger outline
            var centerX = (startX + endX) / 2;
            var centerY = (startY + endY) / 2;

            if (width < MIN_WIDTH) {
              width = MIN_WIDTH;
            }
            if (height < MIN_HEIGHT) {
              height = MIN_HEIGHT;
            }

            graphics.drawRect(centerX - width / 2, centerY - height / 2, width, height);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return drawTile;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(SquareMarkersTrack.prototype.__proto__ || Object.getPrototypeOf(SquareMarkersTrack.prototype), 'setPosition', this).call(this, newPosition);

        this.pMain.position.y = this.position[1];
        this.pMain.position.x = this.position[0];
      }

      return setPosition;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        this.xScale(newXScale);
        this.yScale(newYScale);

        this.refreshTiles();

        this.draw();
      }

      return zoomed;
    }()
  }]);

  return SquareMarkersTrack;
}(_TiledPixiTrack3['default']);

exports['default'] = SquareMarkersTrack;

/***/ }),
/* 667 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chromosome2DLabels = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _PixiTrack2 = __webpack_require__(42);

var _ChromosomeInfo = __webpack_require__(43);

var _search_field = __webpack_require__(86);

var _boxIntersect = __webpack_require__(84);

var _boxIntersect2 = _interopRequireDefault(_boxIntersect);

var _utils = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Chromosome2DLabels = exports.Chromosome2DLabels = function (_PixiTrack) {
  _inherits(Chromosome2DLabels, _PixiTrack);

  function Chromosome2DLabels(scene, dataConfig, handleTilesetInfoReceived, options, animate) {
    _classCallCheck(this, Chromosome2DLabels);

    var _this = _possibleConstructorReturn(this, (Chromosome2DLabels.__proto__ || Object.getPrototypeOf(Chromosome2DLabels)).call(this, scene, options));

    _this.searchField = null;
    _this.chromInfo = null;
    _this.animate = animate;

    var server = dataConfig.server;
    var uid = dataConfig.tilesetUid;

    var chromSizesPath = server + '/chrom-sizes/?id=' + uid;

    (0, _ChromosomeInfo.ChromosomeInfo)(chromSizesPath, function (newChromInfo) {
      _this.chromInfo = newChromInfo;
      //

      _this.searchField = new _search_field.SearchField(_this.chromInfo);
      _this.draw();

      _this.texts = [];

      for (var i = 0; i < _this.chromInfo.cumPositions.length; i++) {
        var thisTexts = [];

        for (var j = 0; j < _this.chromInfo.cumPositions.length; j++) {
          var textStr = _this.chromInfo.cumPositions[i].chr + '/' + _this.chromInfo.cumPositions[j].chr;
          var text = new PIXI.Text(textStr, { fontSize: '14px', fontFamily: 'Arial', fill: 'red' });

          text.anchor.x = 0.5;
          text.anchor.y = 0.5;
          text.visible = false;

          // give each string a random hash so that some get hidden
          // when there's overlaps
          text.hashValue = Math.random();

          thisTexts.push(text);

          _this.pMain.addChild(text);
        }

        _this.texts.push(thisTexts);
      }
      _this.draw();
      _this.animate();
    });
    return _this;
  }

  _createClass(Chromosome2DLabels, [{
    key: 'draw',
    value: function () {
      function draw() {
        var leftChrom = null;
        var rightChrom = null;
        var topChrom = null;
        var bottomChrom = null;

        var allTexts = [];

        if (!this.texts) {
          return;
        }

        if (!this.searchField) {
          return;
        }

        var x1 = (0, _utils.absToChr)(this._xScale.domain()[0], this.chromInfo);
        var x2 = (0, _utils.absToChr)(this._xScale.domain()[1], this.chromInfo);

        var y1 = (0, _utils.absToChr)(this._yScale.domain()[0], this.chromInfo);
        var y2 = (0, _utils.absToChr)(this._yScale.domain()[1], this.chromInfo);

        for (var i = 0; i < this.texts.length; i++) {
          for (var j = 0; j < this.texts.length; j++) {
            this.texts[i][j].visible = false;
          }
        }

        for (var _i = x1[3]; _i <= x2[3]; _i++) {
          for (var _j = y1[3]; _j <= y2[3]; _j++) {
            var xCumPos = this.chromInfo.cumPositions[_i];
            var yCumPos = this.chromInfo.cumPositions[_j];

            var midX = xCumPos.pos + this.chromInfo.chromLengths[xCumPos.chr] / 2;
            var midY = yCumPos.pos + this.chromInfo.chromLengths[yCumPos.chr] / 2;

            var viewportMidX = this._xScale(midX);
            var viewportMidY = this._yScale(midY);

            var text = this.texts[_i][_j];

            text.x = viewportMidX;
            text.y = viewportMidY;
            text.updateTransform();

            var bbox = text.getBounds();

            // make sure the chrosome label fits in the x range
            if (viewportMidX + bbox.width / 2 > this.dimensions[0]) {
              text.x -= viewportMidX + bbox.width / 2 - this.dimensions[0];
            } else if (viewportMidX - bbox.width / 2 < 0) {
              //
              text.x -= viewportMidX - bbox.width / 2;
            }

            // make sure the chro
            if (viewportMidY + bbox.height / 2 > this.dimensions[1]) {
              text.y -= viewportMidY + bbox.height / 2 - this.dimensions[1];
            } else if (viewportMidY - bbox.height / 2 < 0) {
              text.y -= viewportMidY - bbox.height / 2;
            }

            text.visible = true;

            allTexts.push({ importance: this.texts[_i][_j].hashValue, text: this.texts[_i][_j], caption: null });
          }
        }

        // define the edge chromosome which are visible
        this.hideOverlaps(allTexts);
      }

      return draw;
    }()
  }, {
    key: 'hideOverlaps',
    value: function () {
      function hideOverlaps(allTexts) {
        var allBoxes = []; // store the bounding boxes of the text objects so we can
        // calculate overlaps
        allBoxes = allTexts.map(function (val) {
          var text = val.text;
          text.updateTransform();
          var b = text.getBounds();
          var box = [b.x, b.y, b.x + b.width, b.y + b.height];

          return box;
        });

        var result = (0, _boxIntersect2['default'])(allBoxes, function (i, j) {
          if (allTexts[i].importance > allTexts[j].importance) {
            allTexts[j].text.visible = 0;
          } else {
            allTexts[i].text.visible = 0;
          }
        });
      }

      return hideOverlaps;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(Chromosome2DLabels.prototype.__proto__ || Object.getPrototypeOf(Chromosome2DLabels.prototype), 'setPosition', this).call(this, newPosition);

        this.pMain.position.y = this.position[1];
        this.pMain.position.x = this.position[0];
      }

      return setPosition;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        this.xScale(newXScale);
        this.yScale(newYScale);

        this.draw();
      }

      return zoomed;
    }()
  }]);

  return Chromosome2DLabels;
}(_PixiTrack2.PixiTrack);

exports['default'] = Chromosome2DLabels;

/***/ }),
/* 668 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chromosome2DGrid = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _PixiTrack2 = __webpack_require__(42);

var _ChromosomeInfo = __webpack_require__(43);

var _search_field = __webpack_require__(86);

var _utils = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Chromosome2DGrid = exports.Chromosome2DGrid = function (_PixiTrack) {
  _inherits(Chromosome2DGrid, _PixiTrack);

  function Chromosome2DGrid(scene, dataConfig, handleTilesetInfoReceived, options, animate, chromInfoPath) {
    _classCallCheck(this, Chromosome2DGrid);

    var _this = _possibleConstructorReturn(this, (Chromosome2DGrid.__proto__ || Object.getPrototypeOf(Chromosome2DGrid)).call(this, scene, dataConfig, handleTilesetInfoReceived, options, animate));

    _this.searchField = null;
    _this.chromInfo = null;
    _this.animate = animate;

    var chromSizesPath = chromInfoPath;

    if (!chromSizesPath) {
      chromSizesPath = dataConfig.server + '/chrom-sizes/?id=' + dataConfig.tilesetUid;
    }

    (0, _ChromosomeInfo.ChromosomeInfo)(chromSizesPath, function (newChromInfo) {
      _this.chromInfo = newChromInfo;

      _this.searchField = new _search_field.SearchField(_this.chromInfo);

      _this.texts = [];
      _this.lineGraphics = new PIXI.Graphics();

      _this.pMain.addChild(_this.lineGraphics);

      _this.draw();
      _this.animate();
    });
    return _this;
  }

  _createClass(Chromosome2DGrid, [{
    key: 'drawLines',
    value: function () {
      function drawLines() {
        var graphics = this.lineGraphics;
        var strokeColor = (0, _utils.colorToHex)(this.options.lineStrokeColor ? this.options.lineStrokeColor : 'blue');

        var strokeWidth = this.options.lineStrokeWidth ? this.options.lineStrokeWidth : 1;

        graphics.clear();
        graphics.lineStyle(strokeWidth, strokeColor, 1.0);

        graphics.moveTo(this._xScale(0), 0);
        graphics.lineTo(this._xScale(0), this.dimensions[1]);

        graphics.moveTo(0, this._yScale(0));
        graphics.lineTo(this.dimensions[0], this._yScale(0));

        for (var i = 0; i < this.chromInfo.cumPositions.length; i++) {
          var chrPos = this.chromInfo.cumPositions[i];
          var chrEnd = chrPos.pos + +this.chromInfo.chromLengths[chrPos.chr] + 1;

          graphics.moveTo(0, this._yScale(chrEnd));
          graphics.lineTo(this.dimensions[0], this._yScale(chrEnd));

          graphics.moveTo(this._xScale(chrEnd), 0);
          graphics.lineTo(this._xScale(chrEnd), this.dimensions[1]);
        }
      }

      return drawLines;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        var leftChrom = null;
        var rightChrom = null;
        var topChrom = null;
        var bottomChrom = null;

        var allTexts = [];

        if (!this.texts) {
          return;
        }

        if (!this.searchField) {
          return;
        }

        this.drawLines();
      }

      return draw;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(Chromosome2DGrid.prototype.__proto__ || Object.getPrototypeOf(Chromosome2DGrid.prototype), 'setPosition', this).call(this, newPosition);

        this.pMain.position.y = this.position[1];
        this.pMain.position.x = this.position[0];
      }

      return setPosition;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        this.xScale(newXScale);
        this.yScale(newYScale);

        this.draw();
      }

      return zoomed;
    }()
  }, {
    key: 'exportSVG',
    value: function () {
      function exportSVG() {
        var track = null,
            base = null;

        if (_get(Chromosome2DGrid.prototype.__proto__ || Object.getPrototypeOf(Chromosome2DGrid.prototype), 'exportSVG', this)) {
          var _get$call = _get(Chromosome2DGrid.prototype.__proto__ || Object.getPrototypeOf(Chromosome2DGrid.prototype), 'exportSVG', this).call(this);

          var _get$call2 = _slicedToArray(_get$call, 2);

          base = _get$call2[0];
          track = _get$call2[1];
        } else {
          base = document.createElement('g');
          track = base;
        }
        var output = document.createElement('g');
        track.appendChild(output);

        base.setAttribute('id', 'Chromosome2DGrid');

        output.setAttribute('transform', 'translate(' + this.position[0] + ',' + this.position[1] + ')');

        if (!this.chromInfo)
          // we haven't received the chromosome info yet
          {
            return [base, track];
          }

        var strokeColor = this.options.gridStrokeColor ? this.options.gridStrokeColor : 'blue';
        var strokeWidth = this.options.gridStrokeWidth;

        for (var i = 0; i < this.chromInfo.cumPositions.length; i++) {
          var chrPos = this.chromInfo.cumPositions[i];
          var chrEnd = chrPos.pos + +this.chromInfo.chromLengths[chrPos.chr] + 1;

          var line = document.createElement('line');

          // draw horizontal lines (all start at x=0)
          line.setAttribute('x1', 0);
          line.setAttribute('x2', this.dimensions[0]);

          line.setAttribute('y1', this._yScale(chrEnd));
          line.setAttribute('y2', this._yScale(chrEnd));

          line.setAttribute('stroke', strokeColor);
          line.setAttribute('stroke-width', strokeWidth);

          output.appendChild(line);

          // draw vertical lines (all start at y=0)
          line = document.createElement('line');

          // draw horizontal lines (all start at x=0)
          line.setAttribute('x1', this._xScale(chrEnd));
          line.setAttribute('x2', this._xScale(chrEnd));

          line.setAttribute('y1', 0);
          line.setAttribute('y1', this.dimensions[1]);

          line.setAttribute('stroke', strokeColor);
          line.setAttribute('stroke-width', strokeWidth);

          output.appendChild(line);
        }

        return [base, track];
      }

      return exportSVG;
    }()
  }]);

  return Chromosome2DGrid;
}(_PixiTrack2.PixiTrack);

exports['default'] = Chromosome2DGrid;

/***/ }),
/* 669 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chromosome2DAnnotations = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _d3Color = __webpack_require__(14);

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _PixiTrack2 = __webpack_require__(42);

var _ChromosomeInfo = __webpack_require__(43);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Chromosome2DAnnotations = exports.Chromosome2DAnnotations = function (_PixiTrack) {
  _inherits(Chromosome2DAnnotations, _PixiTrack);

  function Chromosome2DAnnotations(scene, chromInfoPath, options) {
    _classCallCheck(this, Chromosome2DAnnotations);

    var _this = _possibleConstructorReturn(this, (Chromosome2DAnnotations.__proto__ || Object.getPrototypeOf(Chromosome2DAnnotations)).call(this, scene, options));

    _this.drawnRects = new Set();

    (0, _ChromosomeInfo.ChromosomeInfo)(chromInfoPath, function (newChromInfo) {
      _this.chromInfo = newChromInfo;
      _this.draw();
    });
    return _this;
  }

  _createClass(Chromosome2DAnnotations, [{
    key: 'draw',
    value: function () {
      function draw() {
        if (!this.chromInfo) {
          return;
        }

        this.drawnRects.clear();

        var minRectWidth = this.options.minRectWidth ? this.options.minRectWidth : 10;
        var minRectHeight = this.options.minRectWidth ? this.options.minRectHeight : 10;

        _get(Chromosome2DAnnotations.prototype.__proto__ || Object.getPrototypeOf(Chromosome2DAnnotations.prototype), 'draw', this).call(this);
        var graphics = this.pMain;
        graphics.clear();

        // Regions have to follow the following form:
        // chrom1, start1, end1, chrom2, start2, end2, color-fill, color-line, min-width, min-height
        // If `color-line` is not given, `color-fill` is used
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.options.regions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var region = _step.value;

            var colorFill = (0, _d3Color.color)(region[6]);
            var colorLine = (0, _d3Color.color)(region[7]);

            if (!colorLine) {
              colorLine = colorFill;
            }

            var colorFillHex = PIXI.utils.rgb2hex([colorFill.r / 255.0, colorFill.g / 255.0, colorFill.b / 255.0]);
            var colorLineHex = PIXI.utils.rgb2hex([colorLine.r / 255.0, colorLine.g / 255.0, colorLine.b / 255.0]);

            graphics.lineStyle(1, colorLineHex, colorLine.opacity);
            graphics.beginFill(colorFillHex, colorFill.opacity);

            // console.log('region:', region);
            var startX = this._xScale(this.chromInfo.chrPositions[region[0]].pos + +region[1]);
            var endX = this._xScale(this.chromInfo.chrPositions[region[0]].pos + +region[2]);

            var startY = this._yScale(this.chromInfo.chrPositions[region[3]].pos + +region[4]);
            var endY = this._yScale(this.chromInfo.chrPositions[region[3]].pos + +region[5]);

            var width = endX - startX;
            var height = endY - startY;

            var _minRectWidth = typeof region[8] !== 'undefined' ? region[8] : minRectWidth;
            var _minRectHeight = typeof region[9] !== 'undefined' ? region[9] : minRectHeight;

            if (width < _minRectWidth) {
              // this region is too small to draw so center it on the location
              // where it would be drawn
              startX = (startX + endX) / 2 - _minRectWidth / 2;
              width = _minRectWidth;
            }

            if (height < _minRectHeight) {
              startY = (startY + endY) / 2 - _minRectHeight / 2;
              height = _minRectHeight;
            }

            graphics.drawRect(startX, startY, width, height);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return draw;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(Chromosome2DAnnotations.prototype.__proto__ || Object.getPrototypeOf(Chromosome2DAnnotations.prototype), 'setPosition', this).call(this, newPosition);

        this.pMain.position.y = this.position[1];
        this.pMain.position.x = this.position[0];
      }

      return setPosition;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        this.xScale(newXScale);
        this.yScale(newYScale);

        this.draw();
      }

      return zoomed;
    }()
  }]);

  return Chromosome2DAnnotations;
}(_PixiTrack2.PixiTrack);

exports['default'] = Chromosome2DAnnotations;

/***/ }),
/* 670 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _boxIntersect = __webpack_require__(84);

var _boxIntersect2 = _interopRequireDefault(_boxIntersect);

var _d3Scale = __webpack_require__(12);

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _PixiTrack2 = __webpack_require__(42);

var _ChromosomeInfo = __webpack_require__(43);

var _search_field = __webpack_require__(86);

var _utils = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TICK_WIDTH = 200;
var TICK_HEIGHT = 6;
var TICK_TEXT_SEPARATION = 2;
var TICK_COLOR = '#777777';

var HorizontalChromosomeLabels = function (_PixiTrack) {
  _inherits(HorizontalChromosomeLabels, _PixiTrack);

  function HorizontalChromosomeLabels(scene, dataConfig, handleTilesetInfoReceived, options, animate, chromInfoPath) {
    _classCallCheck(this, HorizontalChromosomeLabels);

    var _this = _possibleConstructorReturn(this, (HorizontalChromosomeLabels.__proto__ || Object.getPrototypeOf(HorizontalChromosomeLabels)).call(this, scene, dataConfig, handleTilesetInfoReceived, options, animate));

    _this.searchField = null;
    _this.chromInfo = null;

    _this.gTicks = {};
    _this.tickTexts = {};

    _this.textFontSize = '12px';
    _this.textFontFamily = 'Arial';
    _this.textFontColor = '#777777';

    _this.animate = animate;

    var chromSizesPath = chromInfoPath;

    if (!chromSizesPath) {
      chromSizesPath = dataConfig.server + '/chrom-sizes/?id=' + dataConfig.tilesetUid;
    }

    (0, _ChromosomeInfo.ChromosomeInfo)(chromSizesPath, function (newChromInfo) {
      _this.chromInfo = newChromInfo;
      //

      _this.searchField = new _search_field.SearchField(_this.chromInfo);

      _this.texts = [];

      for (var i = 0; i < _this.chromInfo.cumPositions.length; i++) {
        var textStr = _this.chromInfo.cumPositions[i].chr;
        _this.gTicks[textStr] = new PIXI.Graphics();

        // create the array that will store tick TEXT objects
        if (!_this.tickTexts[textStr]) {
          _this.tickTexts[textStr] = [];
        }

        var text = new PIXI.Text(textStr, { fontSize: _this.textFontSize, fontFamily: _this.textFontFamily, fill: _this.textFontColor });

        text.anchor.x = 0.5;
        text.anchor.y = 0.5;
        text.visible = false;

        // give each string a random hash so that some get hidden
        // when there's overlaps
        text.hashValue = Math.random();

        _this.pMain.addChild(text);
        _this.pMain.addChild(_this.gTicks[textStr]);

        _this.texts.push(text);
      }

      _this.draw();
      _this.animate();
    });
    return _this;
  }

  _createClass(HorizontalChromosomeLabels, [{
    key: 'drawTicks',
    value: function () {
      function drawTicks(cumPos) {
        var graphics = this.gTicks[cumPos.chr];

        this.gTicks[cumPos.chr].visible = true;
        this.gTicks[cumPos.chr].clear();

        var chromLen = +this.chromInfo.chromLengths[cumPos.chr];

        var vpLeft = Math.max(this._xScale(cumPos.pos), 0);
        var vpRight = Math.min(this._xScale(cumPos.pos + chromLen), this.dimensions[0]);

        var numTicks = (vpRight - vpLeft) / TICK_WIDTH;

        // what is the domain of this chromosome that is visible?
        var xScale = (0, _d3Scale.scaleLinear)().domain([Math.max(1, this._xScale.invert(0) - cumPos.pos), Math.min(chromLen, this._xScale.invert(this.dimensions[0]) - cumPos.pos)]).range(vpLeft, vpRight);

        // calculate a certain number of ticks
        var ticks = xScale.ticks(numTicks);
        var tickFormat = xScale.tickFormat(numTicks);
        var tickTexts = this.tickTexts[cumPos.chr];

        while (tickTexts.length <= ticks.length) {
          var newText = new PIXI.Text('', { fontSize: '12px', fontFamily: 'Helvetica Neue', fill: '#777777' });
          tickTexts.push(newText);
          this.gTicks[cumPos.chr].addChild(newText);
        }

        var i = 0;
        while (i < ticks.length) {
          tickTexts[i].visible = true;

          tickTexts[i].anchor.x = 0.5;
          tickTexts[i].anchor.y = 1;

          if (this.flipText) {
            tickTexts[i].scale.x = -1;
          }

          // draw the tick labels
          tickTexts[i].x = this._xScale(cumPos.pos + ticks[i]);
          tickTexts[i].y = this.dimensions[1] - (TICK_HEIGHT + TICK_TEXT_SEPARATION);

          if (ticks[i] == 0) {
            tickTexts[i].text = cumPos.chr + ':1';
          } else {
            tickTexts[i].text = cumPos.chr + ':' + tickFormat(ticks[i]);
          }

          graphics.lineStyle(1, TICK_COLOR, 1);

          // draw the tick lines
          graphics.moveTo(this._xScale(cumPos.pos + ticks[i]), this.dimensions[1]);
          graphics.lineTo(this._xScale(cumPos.pos + ticks[i]), this.dimensions[1] - TICK_HEIGHT);

          i += 1;
        }

        while (i < tickTexts.length) {
          // we don't need this text so we'll turn it off for now
          tickTexts[i].visible = false;

          i += 1;
        }

        var ticksDrawn = ticks.length;

        /*
            if (ticks.length == 1) {
                // if we just have one tick visible, then we'll display the chromosomes
                // individually
                tickTexts[0].visible = false;
             }
             */
        return ticks.length;
      }

      return drawTicks;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        var leftChrom = null;
        var rightChrom = null;
        var topChrom = null;
        var bottomChrom = null;

        this.allTexts = [];

        if (!this.texts) {
          return;
        }

        if (!this.searchField) {
          return;
        }

        var x1 = (0, _utils.absToChr)(this._xScale.domain()[0], this.chromInfo);
        var x2 = (0, _utils.absToChr)(this._xScale.domain()[1], this.chromInfo);

        for (var i = 0; i < this.texts.length; i++) {
          this.texts[i].visible = false;
          this.gTicks[this.chromInfo.cumPositions[i].chr].visible = false;
        }

        for (var _i = x1[3]; _i <= x2[3]; _i++) {
          var xCumPos = this.chromInfo.cumPositions[_i];

          var midX = xCumPos.pos + this.chromInfo.chromLengths[xCumPos.chr] / 2;

          var viewportMidX = this._xScale(midX);

          var text = this.texts[_i];

          text.anchor.y = 1;
          text.x = viewportMidX;
          text.y = this.dimensions[1] - TICK_TEXT_SEPARATION - TICK_HEIGHT;
          text.updateTransform();

          if (this.flipText) {
            text.scale.x = -1;
          }

          var bbox = text.getBounds();
          // text.y -= bbox.height;

          // make sure the chrosome label fits in the x range
          /* Not necessary because chromosome labels only get drawn
                if (viewportMidX + bbox.width / 2  > this.dimensions[0]) {
                    text.x -= (viewportMidX + bbox.width / 2) - this.dimensions[0];
                } else if (viewportMidX - bbox.width / 2 < 0) {
                    //
                    text.x -= (viewportMidX - bbox.width / 2);
                }
                */

          var numTicksDrawn = this.drawTicks(xCumPos);

          // only show chromsome labels if there's no ticks drawn
          if (numTicksDrawn > 0) {
            text.visible = false;
          } else {
            text.visible = true;
          }

          this.allTexts.push({ importance: this.texts[_i].hashValue, text: this.texts[_i], caption: null });
        }

        // define the edge chromosome which are visible
        this.hideOverlaps(this.allTexts);
      }

      return draw;
    }()
  }, {
    key: 'hideOverlaps',
    value: function () {
      function hideOverlaps(allTexts) {
        var allBoxes = []; // store the bounding boxes of the text objects so we can
        // calculate overlaps
        allBoxes = allTexts.map(function (val) {
          var text = val.text;
          text.updateTransform();
          var b = text.getBounds();
          var box = [b.x, b.y, b.x + b.width, b.y + b.height];

          return box;
        });

        var result = (0, _boxIntersect2['default'])(allBoxes, function (i, j) {
          if (allTexts[i].importance > allTexts[j].importance) {
            // console.log('hiding:', allTexts[j].caption)
            allTexts[j].text.visible = 0;
          } else {
            // console.log('hiding:', allTexts[i].caption)
            allTexts[i].text.visible = 0;
          }
        });
      }

      return hideOverlaps;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(HorizontalChromosomeLabels.prototype.__proto__ || Object.getPrototypeOf(HorizontalChromosomeLabels.prototype), 'setPosition', this).call(this, newPosition);

        this.pMain.position.y = this.position[1];
        this.pMain.position.x = this.position[0];
      }

      return setPosition;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        this.xScale(newXScale);
        this.yScale(newYScale);

        this.draw();
      }

      return zoomed;
    }()
  }, {
    key: 'refreshTiles',
    value: function () {
      function refreshTiles() {
        // dummy function that is called by LeftTrackModifier
      }

      return refreshTiles;
    }()
  }, {
    key: 'exportSVG',
    value: function () {
      function exportSVG() {
        var track = null,
            base = null;

        if (_get(HorizontalChromosomeLabels.prototype.__proto__ || Object.getPrototypeOf(HorizontalChromosomeLabels.prototype), 'exportSVG', this)) {
          var _get$call = _get(HorizontalChromosomeLabels.prototype.__proto__ || Object.getPrototypeOf(HorizontalChromosomeLabels.prototype), 'exportSVG', this).call(this);

          var _get$call2 = _slicedToArray(_get$call, 2);

          base = _get$call2[0];
          track = _get$call2[1];
        } else {
          base = document.createElement('g');
          track = base;
        }
        base.setAttribute('class', 'chromosome-labels');

        var output = document.createElement('g');
        track.appendChild(output);

        output.setAttribute('transform', 'translate(' + this.position[0] + ',' + this.position[1] + ')');

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.allTexts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _text = _step.value;

            if (!_text.text.visible) continue;

            var _g = (0, _utils.pixiTextToSvg)(_text.text);
            output.appendChild(_g);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        for (var key in this.tickTexts) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = this.tickTexts[key][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var text = _step2.value;

              var g = (0, _utils.pixiTextToSvg)(text);
              output.appendChild(g);

              g = (0, _utils.svgLine)(text.x, this.dimensions[1], text.x, this.dimensions[1] - TICK_HEIGHT, 1, TICK_COLOR);

              output.appendChild(g);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                _iterator2['return']();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }

        return [base, track];
      }

      return exportSVG;
    }()
  }]);

  return HorizontalChromosomeLabels;
}(_PixiTrack2.PixiTrack);

exports['default'] = HorizontalChromosomeLabels;

/***/ }),
/* 671 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HorizontalHeatmapTrack = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _pixi = __webpack_require__(9);

var PIXI = _interopRequireWildcard(_pixi);

var _d3Scale = __webpack_require__(12);

var _TiledPixiTrack = __webpack_require__(41);

var _HeatmapTiledPixiTrack = __webpack_require__(82);

var _HeatmapTiledPixiTrack2 = _interopRequireDefault(_HeatmapTiledPixiTrack);

var _services = __webpack_require__(7);

var _utils = __webpack_require__(3);

var _configs = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Services


// Utils


// Configs


var HorizontalHeatmapTrack = exports.HorizontalHeatmapTrack = function (_HeatmapTiledPixiTrac) {
  _inherits(HorizontalHeatmapTrack, _HeatmapTiledPixiTrac);

  /**
   * @param scene: A PIXI.js scene to draw everything to.
   * @param dataConfig: An object defining where the data should be pulled from
   */
  function HorizontalHeatmapTrack(scene, dataConfig, handleTilesetInfoReceived, options, animate, svgElement, onValueScaleChanged, onTrackOptionsChanged) {
    _classCallCheck(this, HorizontalHeatmapTrack);

    var _this = _possibleConstructorReturn(this, (HorizontalHeatmapTrack.__proto__ || Object.getPrototypeOf(HorizontalHeatmapTrack)).call(this, scene, dataConfig, handleTilesetInfoReceived, options, animate, svgElement, onValueScaleChanged, onTrackOptionsChanged));

    _this.pMain = _this.pMobile;

    // [[255,255,255,0], [237,218,10,4] ...
    // a 256 element array mapping the values 0-255 to rgba values
    // not a d3 color scale for speed
    // this.colorScale = HEATED_OBJECT_MAP;
    _this.colorScale = _configs.HEATED_OBJECT_MAP;

    if (options && options.colorRange) {
      _this.colorScale = (0, _utils.colorDomainToRgbaArray)(options.colorRange);
    }
    return _this;
  }

  _createClass(HorizontalHeatmapTrack, [{
    key: 'rerender',
    value: function () {
      function rerender(options, force) {
        _get(HorizontalHeatmapTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalHeatmapTrack.prototype), 'rerender', this).call(this, options, force);

        // zoom so that if the heatmap is flipped, the scale of this.pMain changes
        this.zoomed(this.xScale(), this.yScale(), this.pMain.scale.x, this.pMain.position.x, this.pMain.position.y);
      }

      return rerender;
    }()
  }, {
    key: 'calculateZoomLevel',
    value: function () {
      function calculateZoomLevel() {
        if (this.tilesetInfo.resolutions) {
          var zoomIndexX = _services.tileProxy.calculateZoomLevelFromResolutions(this.tilesetInfo.resolutions, this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);

          var zoomIndexY = _services.tileProxy.calculateZoomLevelFromResolutions(this.tilesetInfo.resolutions, this._xScale, this.tilesetInfo.min_pos[1], this.tilesetInfo.max_pos[1]);

          return Math.min(zoomIndexX, zoomIndexY);
        }

        var xZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);

        var yZoomLevel = _services.tileProxy.calculateZoomLevel(this._xScale, this.tilesetInfo.min_pos[1], this.tilesetInfo.max_pos[1]);

        var zoomLevel = Math.max(xZoomLevel, yZoomLevel);
        zoomLevel = Math.min(zoomLevel, this.maxZoom);

        if (this.options && this.options.maxZoom) {
          if (this.options.maxZoom >= 0) {
            zoomLevel = Math.min(this.options.maxZoom, zoomLevel);
          } else {
            console.error('Invalid maxZoom on track:', this);
          }
        }

        return zoomLevel;
      }

      return calculateZoomLevel;
    }()
  }, {
    key: 'calculateVisibleTiles',
    value: function () {
      function calculateVisibleTiles() {
        // if we don't know anything about this dataset, no point
        // in trying to get tiles
        if (!this.tilesetInfo) {
          return;
        }

        this.zoomLevel = this.calculateZoomLevel();

        // this.zoomLevel = 0;
        var expandedXScale = this._xScale.copy();

        var xDomainWidth = this._xScale.domain()[1] - this._xScale.domain()[0];
        var xRangeWidth = this._xScale.range()[1] - this._xScale.range()[0];

        // we need to expand the domain of the X-scale because we are showing diagonal tiles.
        // to make sure the view is covered up the entire height, we need to expand by viewHeight * sqrt(2)
        // on each side
        expandedXScale.domain([this._xScale.invert(this._xScale.range()[0] - this.dimensions[1] * Math.sqrt(2)), this._xScale.invert(this._xScale.range()[1] + this.dimensions[1] * Math.sqrt(2))]);

        if (this.tilesetInfo.resolutions) {
          var sortedResolutions = this.tilesetInfo.resolutions.map(function (x) {
            return +x;
          }).sort(function (a, b) {
            return b - a;
          });

          this.xTiles = _services.tileProxy.calculateTilesFromResolution(sortedResolutions[this.zoomLevel], expandedXScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);
          this.yTiles = _services.tileProxy.calculateTilesFromResolution(sortedResolutions[this.zoomLevel], expandedXScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);
        } else {
          this.xTiles = _services.tileProxy.calculateTiles(this.zoomLevel, expandedXScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0], this.tilesetInfo.max_zoom, this.tilesetInfo.max_width);

          this.yTiles = _services.tileProxy.calculateTiles(this.zoomLevel, expandedXScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0], this.tilesetInfo.max_zoom, this.tilesetInfo.max_width);
        }

        var rows = this.xTiles;
        var cols = this.yTiles;
        var zoomLevel = this.zoomLevel;

        var maxWidth = this.tilesetInfo.max_width;
        var tileWidth = maxWidth / Math.pow(2, zoomLevel);

        // if we're mirroring tiles, then we only need tiles along the diagonal
        var tiles = [];

        // calculate the ids of the tiles that should be visible
        for (var i = 0; i < rows.length; i++) {
          for (var j = i; j < cols.length; j++) {
            // the length between the bottom of the track and the bottom corner of the tile
            // draw it out to understand better!
            var tileBottomPosition = (j - i - 2) * (this._xScale(tileWidth) - this._xScale(0)) * Math.sqrt(2) / 2;

            if (tileBottomPosition > this.dimensions[1]) {
              // this tile won't be visible so we don't need to fetch it
              continue;
            }

            var newTile = [zoomLevel, rows[i], cols[j]];
            newTile.mirrored = false;
            newTile.dataTransform = this.options.dataTransform ? this.options.dataTransform : 'default';

            tiles.push(newTile);
          }
        }

        this.setVisibleTiles(tiles);
      }

      return calculateVisibleTiles;
    }()
  }, {
    key: 'tileDataToCanvas',
    value: function () {
      function tileDataToCanvas(pixData) {
        var canvas = document.createElement('canvas');

        canvas.width = 256;
        canvas.height = 256;
        //

        var ctx = canvas.getContext('2d');

        ctx.fillStyle = 'transparent';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        var pix = new ImageData(pixData, canvas.width, canvas.height);

        ctx.putImageData(pix, 0, 0);

        return canvas;
      }

      return tileDataToCanvas;
    }()
  }, {
    key: 'setSpriteProperties',
    value: function () {
      function setSpriteProperties(sprite, zoomLevel, tilePos, mirrored) {
        var _getTilePosAndDimensi = this.getTilePosAndDimensions(zoomLevel, tilePos),
            tileX = _getTilePosAndDimensi.tileX,
            tileY = _getTilePosAndDimensi.tileY,
            tileWidth = _getTilePosAndDimensi.tileWidth,
            tileHeight = _getTilePosAndDimensi.tileHeight;

        var tileEndX = tileX + tileWidth;
        var tileEndY = tileY + tileHeight;

        var spriteWidth = this._refXScale(tileEndX) - this._refXScale(tileX);
        var spriteHeight = this._refYScale(tileEndY) - this._refYScale(tileY);

        sprite.width = this._refXScale(tileEndX) - this._refXScale(tileX);
        sprite.height = this._refYScale(tileEndY) - this._refYScale(tileY);

        sprite.x = this._refXScale(tileX);
        sprite.y = this._refYScale(tileY);
      }

      return setSpriteProperties;
    }()

    /**
     * Convert the raw tile data to a rendered array of values which can be represented as a sprite.
     *
     * @param tile: The data structure containing all the tile information. Relevant to
     *              this function are tile.tileData = {'dense': [...], ...}
     *              and tile.graphics
     */

  }, {
    key: 'renderTile',
    value: function () {
      function renderTile(tile) {
        var _this2 = this;

        var _getValueScale = (0, _TiledPixiTrack.getValueScale)(this.options.heatmapValueScaling, this.scale.minValue, this.medianVisibleValue, this.scale.maxValue, 'log'),
            _getValueScale2 = _slicedToArray(_getValueScale, 2),
            scaleType = _getValueScale2[0],
            valueScale = _getValueScale2[1];

        this.valueScale = valueScale;
        var pseudocount = 0;

        if (scaleType == 'log') pseudocount = this.valueScale.domain()[0];

        this.limitedValueScale = this.valueScale.copy();

        if (this.options && typeof this.options.scaleStartPercent !== 'undefined' && typeof this.options.scaleEndPercent !== 'undefined') {
          this.limitedValueScale.domain([this.valueScale.domain()[0] + (this.valueScale.domain()[1] - this.valueScale.domain()[0]) * this.options.scaleStartPercent, this.valueScale.domain()[0] + (this.valueScale.domain()[1] - this.valueScale.domain()[0]) * this.options.scaleEndPercent]);
        }

        _services.tileProxy.tileDataToPixData(tile, this.limitedValueScale, pseudocount, // used as a pseudocount to prevent taking the log of 0
        this.colorScale, function (pixData) {
          // the tileData has been converted to pixData by the worker script and needs to be loaded
          // as a sprite
          var graphics = tile.graphics;

          var canvas = _this2.tileDataToCanvas(pixData);

          var sprite = null;

          if (tile.tileData.zoomLevel === _this2.maxZoom) {
            sprite = new PIXI.Sprite(PIXI.Texture.fromCanvas(canvas, PIXI.SCALE_MODES.NEAREST));
          } else {
            sprite = new PIXI.Sprite(PIXI.Texture.fromCanvas(canvas));
          }

          tile.sprite = sprite;
          tile.canvas = canvas;

          _this2.setSpriteProperties(tile.sprite, tile.tileData.zoomLevel, tile.tileData.tilePos, tile.mirrored);

          graphics.pivot.x = _this2._refXScale(0);
          graphics.pivot.y = _this2._refYScale(0);
          graphics.scale.x = -1 / Math.sqrt(2);
          graphics.rotation = -3 * Math.PI / 4;
          graphics.scale.y = 1 / Math.sqrt(2);

          graphics.position.x = _this2._refXScale(0);
          graphics.position.y = 0;

          graphics.removeChildren();
          graphics.addChild(tile.sprite);
        });
      }

      return renderTile;
    }()
  }, {
    key: 'refScalesChanged',
    value: function () {
      function refScalesChanged(refXScale, refYScale) {
        _get(HorizontalHeatmapTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalHeatmapTrack.prototype), 'refScalesChanged', this).call(this, refXScale, refYScale);

        for (var uid in this.fetchedTiles) {
          var tile = this.fetchedTiles[uid];

          if (tile.sprite) {
            this.setSpriteProperties(tile.sprite, tile.tileData.zoomLevel, tile.tileData.tilePos, tile.mirrored);

            var graphics = tile.graphics;

            graphics.pivot.x = this._refXScale(0);
            graphics.pivot.y = this._refYScale(0);
            graphics.scale.x = -1 / Math.sqrt(2);
            graphics.rotation = -3 * Math.PI / 4;
            graphics.scale.y = 1 / Math.sqrt(2);

            graphics.position.x = this._refXScale(0);
            graphics.position.y = 0;
          } else {
            // console.log('skipping...', tile.tileId);
          }
        }
      }

      return refScalesChanged;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale, k, tx, ty) {
        _get(HorizontalHeatmapTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalHeatmapTrack.prototype), 'zoomed', this).call(this, newXScale, newYScale, k, tx, ty);
        _get(HorizontalHeatmapTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalHeatmapTrack.prototype), 'draw', this).call(this);

        this.pMain.position.x = tx;
        this.pMain.position.y = this.position[1] + this.dimensions[1]; // translateY;

        this.pMain.scale.x = k; // scaleX;
        this.pMain.scale.y = k; // scaleY;

        if (this.options.oneDHeatmapFlipped) {
          this.pMain.scale.y = -k;
          this.pMain.position.y = this.position[1];
        }
      }

      return zoomed;
    }()
  }, {
    key: 'exportSVG',
    value: function () {
      function exportSVG() {
        var track = null;
        var base = null;

        var _get$call = _get(HorizontalHeatmapTrack.prototype.__proto__ || Object.getPrototypeOf(HorizontalHeatmapTrack.prototype), 'superSVG', this).call(this);

        var _get$call2 = _slicedToArray(_get$call, 2);

        base = _get$call2[0];
        track = _get$call2[1];


        var output = document.createElement('g');
        track.appendChild(output);

        output.setAttribute('transform', 'translate(' + this.pMain.position.x + ',' + this.pMain.position.y + ') scale(' + this.pMain.scale.x + ',' + this.pMain.scale.y + ')');

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.visibleAndFetchedTiles()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tile = _step.value;

            var gGraphics = document.createElement('g');
            var graphics = tile.graphics;
            var graphicsRotation = graphics.rotation * 180 / Math.PI;
            var transformText = 'translate(' + graphics.position.x + ',' + graphics.position.y + ') rotate(' + graphicsRotation + ') scale(' + graphics.scale.x + ',' + graphics.scale.y + ') translate(' + -graphics.pivot.x + ',' + -graphics.pivot.y + ')';
            gGraphics.setAttribute('transform', transformText);

            var rotation = tile.sprite.rotation * 180 / Math.PI;
            var g = document.createElement('g');
            g.setAttribute('transform', 'translate(' + tile.sprite.x + ',' + tile.sprite.y + ') rotate(' + rotation + ') scale(' + tile.sprite.scale.x + ',' + tile.sprite.scale.y + ')');

            var image = document.createElement('image');
            image.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', tile.canvas.toDataURL());
            image.setAttribute('width', 256);
            image.setAttribute('height', 256);

            g.appendChild(image);
            gGraphics.appendChild(g);

            output.appendChild(gGraphics);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var gColorbar = this.exportColorBarSVG();
        track.appendChild(gColorbar);

        return [base, base];
      }

      return exportSVG;
    }()
  }]);

  return HorizontalHeatmapTrack;
}(_HeatmapTiledPixiTrack2['default']);

exports['default'] = HorizontalHeatmapTrack;

/***/ }),
/* 672 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UnknownPixiTrack = undefined;

var _PixiTrack2 = __webpack_require__(42);

var _PixiTrack3 = _interopRequireDefault(_PixiTrack2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UnknownPixiTrack = exports.UnknownPixiTrack = function (_PixiTrack) {
  _inherits(UnknownPixiTrack, _PixiTrack);

  function UnknownPixiTrack() {
    _classCallCheck(this, UnknownPixiTrack);

    return _possibleConstructorReturn(this, (UnknownPixiTrack.__proto__ || Object.getPrototypeOf(UnknownPixiTrack)).apply(this, arguments));
  }

  return UnknownPixiTrack;
}(_PixiTrack3['default']);

exports['default'] = UnknownPixiTrack;

/***/ }),
/* 673 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ValueIntervalTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _d3Scale = __webpack_require__(12);

var _HorizontalLine1DPixiTrack = __webpack_require__(85);

var _HorizontalLine1DPixiTrack2 = _interopRequireDefault(_HorizontalLine1DPixiTrack);

var _AxisPixi = __webpack_require__(83);

var _AxisPixi2 = _interopRequireDefault(_AxisPixi);

var _utils = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ValueIntervalTrack = exports.ValueIntervalTrack = function (_HorizontalLine1DPixi) {
  _inherits(ValueIntervalTrack, _HorizontalLine1DPixi);

  function ValueIntervalTrack(scene, server, uid, handleTilesetInfoReceived, options, animate) {
    _classCallCheck(this, ValueIntervalTrack);

    var _this = _possibleConstructorReturn(this, (ValueIntervalTrack.__proto__ || Object.getPrototypeOf(ValueIntervalTrack)).call(this, scene, server, uid, handleTilesetInfoReceived, options, animate));

    _this.axis = new _AxisPixi2['default'](_this);
    _this.pBase.addChild(_this.axis.pAxis);
    return _this;
  }

  _createClass(ValueIntervalTrack, [{
    key: 'initTile',
    value: function () {
      function initTile(tile) {
        // create the tile
        // should be overwritten by child classes
        this.scale.minRawValue = this.minVisibleValue();
        this.scale.maxRawValue = this.maxVisibleValue();

        this.scale.minValue = this.scale.minRawValue;
        this.scale.maxValue = this.scale.maxRawValue;

        this.drawTile(tile);
      }

      return initTile;
    }()
  }, {
    key: 'drawTile',
    value: function () {
      function drawTile(tile) {
        var _this2 = this;

        if (!tile.graphics) {
          return;
        }

        var graphics = tile.graphics;
        var RECT_HEIGHT = 6;
        var MIN_RECT_WIDTH = 4;

        graphics.clear();

        this.valueScale = (0, _d3Scale.scaleLog)().domain([this.minValue() + 0.01, this.maxValue()]).range([this.dimensions[1] - RECT_HEIGHT / 2, RECT_HEIGHT / 2]);

        var fill = (0, _utils.colorToHex)('black');

        graphics.lineStyle(1, fill, 0.3);
        graphics.beginFill(fill, 0.3);

        this.drawAxis(this.valueScale);

        tile.tileData.forEach(function (td) {
          var fields = td.fields;

          var chrOffset = +td.chrOffset;

          var genomeStart = +fields[1] + chrOffset;
          var genomeEnd = +fields[2] + chrOffset;
          var value = +fields[3];

          var startPos = _this2._xScale(genomeStart);
          var endPos = _this2._xScale(genomeEnd);

          var width = Math.max(endPos - startPos, MIN_RECT_WIDTH);
          var midY = _this2.valueScale(value);
          var midX = (endPos + startPos) / 2;

          graphics.drawRect(midX - width / 2, midY - RECT_HEIGHT / 2, width, RECT_HEIGHT);
        });
      }

      return drawTile;
    }()
  }, {
    key: 'minVisibleValue',
    value: function () {
      function minVisibleValue() {
        var _this3 = this;

        var visibleAndFetchedIds = this.visibleAndFetchedIds();

        if (visibleAndFetchedIds.length == 0) {
          visibleAndFetchedIds = Object.keys(this.fetchedTiles);
        }

        var min = Math.min.apply(null, visibleAndFetchedIds.map(function (x) {
          return +Math.min.apply(Math, _toConsumableArray(_this3.fetchedTiles[x].tileData.filter(function (y) {
            return !isNaN(y.fields[3]);
          }).map(function (y) {
            return +y.fields[3];
          })));
        }));

        return min;
      }

      return minVisibleValue;
    }()
  }, {
    key: 'maxVisibleValue',
    value: function () {
      function maxVisibleValue() {
        var _this4 = this;

        var visibleAndFetchedIds = this.visibleAndFetchedIds();

        if (visibleAndFetchedIds.length == 0) {
          visibleAndFetchedIds = Object.keys(this.fetchedTiles);
        }

        var max = Math.max.apply(null, visibleAndFetchedIds.map(function (x) {
          return +Math.max.apply(Math, _toConsumableArray(_this4.fetchedTiles[x].tileData.filter(function (y) {
            return !isNaN(y.fields[3]);
          }).map(function (y) {
            return +y.fields[3];
          })));
        }));

        return max;
      }

      return maxVisibleValue;
    }()
  }]);

  return ValueIntervalTrack;
}(_HorizontalLine1DPixiTrack2['default']);

exports['default'] = ValueIntervalTrack;

/***/ }),
/* 674 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ViewportTracker2D = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _SVGTrack2 = __webpack_require__(61);

var _SVGTrack3 = _interopRequireDefault(_SVGTrack2);

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _d3Brush = __webpack_require__(25);

var _d3Selection = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ViewportTracker2D = exports.ViewportTracker2D = function (_SVGTrack) {
  _inherits(ViewportTracker2D, _SVGTrack);

  function ViewportTracker2D(svgElement, registerViewportChanged, removeViewportChanged, setDomainsCallback, options) {
    _classCallCheck(this, ViewportTracker2D);

    var _this = _possibleConstructorReturn(this, (ViewportTracker2D.__proto__ || Object.getPrototypeOf(ViewportTracker2D)).call(this, svgElement, true));
    // create a clipped SVG Path


    var uid = _slugid2['default'].nice();
    _this.uid = uid;
    _this.options = options;

    _this.removeViewportChanged = removeViewportChanged;
    _this.setDomainsCallback = setDomainsCallback;

    _this.viewportXDomain = null;
    _this.viewportYDomain = null;

    _this.brush = (0, _d3Brush.brush)(true).extent([[-Number.MAX_VALUE / 2, -Number.MAX_VALUE / 2], [Number.MAX_VALUE / 2, Number.MAX_VALUE / 2]]).on('brush', _this.brushed.bind(_this));

    _this.gBrush = _this.gMain.append('g').attr('id', 'brush-' + _this.uid).call(_this.brush);

    /*
    // This is used to draw a border that is completely outside of the 
    // drawn rectangle
    this.gBorder = this.gMain
      .append('path')
      .style('pointer-events', 'none');
    */

    // turn off the ability to select new regions for this brush
    _this.gBrush.selectAll('.overlay').style('pointer-events', 'none');

    // turn off the ability to modify the aspect ratio of the brush
    _this.gBrush.selectAll('.handle--n').style('pointer-events', 'none');

    _this.gBrush.selectAll('.handle--s').style('pointer-events', 'none');

    _this.gBrush.selectAll('.handle--w').style('pointer-events', 'none');

    _this.gBrush.selectAll('.handle--e').style('pointer-events', 'none');

    registerViewportChanged(uid, _this.viewportChanged.bind(_this));

    // the viewport will call this.viewportChanged immediately upon
    // hearing registerViewportChanged
    _this.draw();
    return _this;
  }

  _createClass(ViewportTracker2D, [{
    key: 'brushed',
    value: function () {
      function brushed() {
        /**
         * Should only be called  on active brushing, not in response to the
         * draw event
         */
        var s = _d3Selection.event.selection;

        if (!this._xScale || !this._yScale) {
          return;
        }

        var xDomain = [this._xScale.invert(s[0][0]), this._xScale.invert(s[1][0])];

        var yDomain = [this._yScale.invert(s[0][1]), this._yScale.invert(s[1][1])];

        this.setDomainsCallback(xDomain, yDomain);
      }

      return brushed;
    }()
  }, {
    key: 'viewportChanged',
    value: function () {
      function viewportChanged(viewportXScale, viewportYScale) {
        var viewportXDomain = viewportXScale.domain();
        var viewportYDomain = viewportYScale.domain();

        this.viewportXDomain = viewportXDomain;
        this.viewportYDomain = viewportYDomain;

        this.draw();
      }

      return viewportChanged;
    }()
  }, {
    key: 'remove',
    value: function () {
      function remove() {
        // remove the event handler that updates this viewport tracker
        this.removeViewportChanged(this.uid);

        _get(ViewportTracker2D.prototype.__proto__ || Object.getPrototypeOf(ViewportTracker2D.prototype), 'remove', this).call(this);
      }

      return remove;
    }()
  }, {
    key: 'rerender',
    value: function () {
      function rerender() {
        // set the fill and stroke colors
        this.gBrush.selectAll('.selection').attr('fill', this.options.projectionFillColor).attr('stroke', this.options.projectionStrokeColor).attr('fill-opacity', this.options.projectionFillOpacity).attr('stroke-opacity', this.options.projectionStrokeOpacity).attr('stroke-width', this.options.strokeWidth);

        /*
        this.gBorder
          .style('fill', this.options.projectionStrokeColor)
          .style('opacity', this.options.projectionStrokeOpacity)
        */
      }

      return rerender;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        if (!this._xScale || !this.yScale) {
          return;
        }

        if (!this.viewportXDomain || !this.viewportYDomain) {
          return;
        }

        var x0 = this._xScale(this.viewportXDomain[0]);
        var y0 = this._yScale(this.viewportYDomain[0]);

        var x1 = this._xScale(this.viewportXDomain[1]);
        var y1 = this._yScale(this.viewportYDomain[1]);

        var dest = [[x0, y0], [x1, y1]];

        // user hasn't actively brushed so we don't want to emit a
        // 'brushed' event
        this.brush.on('brush', null);
        this.gBrush.call(this.brush.move, dest);
        this.brush.on('brush', this.brushed.bind(this));

        /*
        const sW = this.options.strokeWidth;
         this.gBorder
        .attr('d', `M${x0} ${y0} H ${x1} V ${y1} H ${x0} V ${y0 - sW} H ${x0 - sW} V ${y1 + sW} H ${x1 + sW} V ${y0 - sW} H ${x0 - sW} V ${y0}`);
        */
      }

      return draw;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        this.xScale(newXScale);
        this.yScale(newYScale);

        this.draw();
      }

      return zoomed;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(ViewportTracker2D.prototype.__proto__ || Object.getPrototypeOf(ViewportTracker2D.prototype), 'setPosition', this).call(this, newPosition);

        this.draw();
      }

      return setPosition;
    }()
  }]);

  return ViewportTracker2D;
}(_SVGTrack3['default']);

exports['default'] = ViewportTracker2D;

/***/ }),
/* 675 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ViewportTrackerHorizontal = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _d3Brush = __webpack_require__(25);

var _d3Selection = __webpack_require__(4);

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _SVGTrack2 = __webpack_require__(61);

var _SVGTrack3 = _interopRequireDefault(_SVGTrack2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ViewportTrackerHorizontal = exports.ViewportTrackerHorizontal = function (_SVGTrack) {
  _inherits(ViewportTrackerHorizontal, _SVGTrack);

  function ViewportTrackerHorizontal(svgElement, registerViewportChanged, removeViewportChanged, setDomainsCallback, options) {
    _classCallCheck(this, ViewportTrackerHorizontal);

    var _this = _possibleConstructorReturn(this, (ViewportTrackerHorizontal.__proto__ || Object.getPrototypeOf(ViewportTrackerHorizontal)).call(this, svgElement, true));
    // create a clipped SVG Path


    var uid = _slugid2['default'].nice();
    _this.uid = uid;
    _this.options = options;

    _this.removeViewportChanged = removeViewportChanged;
    _this.setDomainsCallback = setDomainsCallback;

    _this.viewportXDomain = null;
    _this.viewportYDomain = null;

    _this.brush = (0, _d3Brush.brush)(true).on('brush', _this.brushed.bind(_this));

    _this.gBrush = _this.gMain.append('g').attr('id', 'brush-' + _this.uid).call(_this.brush);

    // turn off the ability to select new regions for this brush
    _this.gBrush.selectAll('.overlay').style('pointer-events', 'none');

    // turn off the ability to modify the aspect ratio of the brush
    _this.gBrush.selectAll('.handle--ne').style('pointer-events', 'none');

    _this.gBrush.selectAll('.handle--nw').style('pointer-events', 'none');

    _this.gBrush.selectAll('.handle--sw').style('pointer-events', 'none');

    _this.gBrush.selectAll('.handle--se').style('pointer-events', 'none');

    _this.gBrush.selectAll('.handle--n').style('pointer-events', 'none');

    _this.gBrush.selectAll('.handle--s').style('pointer-events', 'none');

    registerViewportChanged(uid, _this.viewportChanged.bind(_this));

    // the viewport will call this.viewportChanged immediately upon
    // hearing registerViewportChanged
    _this.draw();
    return _this;
  }

  _createClass(ViewportTrackerHorizontal, [{
    key: 'brushed',
    value: function () {
      function brushed() {
        /**
             * Should only be called  on active brushing, not in response to the
             * draw event
             */
        var s = _d3Selection.event.selection;

        if (!this._xScale || !this._yScale) {
          return;
        }

        var xDomain = [this._xScale.invert(s[0][0]), this._xScale.invert(s[1][0])];

        var yDomain = this.viewportYDomain;

        // console.log('xDomain:', xDomain);
        // console.log('yDomain:', yDomain);

        this.setDomainsCallback(xDomain, yDomain);
      }

      return brushed;
    }()
  }, {
    key: 'viewportChanged',
    value: function () {
      function viewportChanged(viewportXScale, viewportYScale) {
        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        // console.log('viewport changed:', viewportXScale.domain());
        var viewportXDomain = viewportXScale.domain();
        var viewportYDomain = viewportYScale.domain();

        this.viewportXDomain = viewportXDomain;
        this.viewportYDomain = viewportYDomain;

        this.draw();
      }

      return viewportChanged;
    }()
  }, {
    key: 'remove',
    value: function () {
      function remove() {
        // remove the event handler that updates this viewport tracker
        this.removeViewportChanged(this.uid);

        _get(ViewportTrackerHorizontal.prototype.__proto__ || Object.getPrototypeOf(ViewportTrackerHorizontal.prototype), 'remove', this).call(this);
      }

      return remove;
    }()
  }, {
    key: 'rerender',
    value: function () {
      function rerender() {
        // set the fill and stroke colors
        this.gBrush.selectAll('.selection').attr('fill', this.options.projectionFillColor).attr('stroke', this.options.projectionStrokeColor).attr('fill-opacity', this.options.projectionFillOpacity).attr('stroke-opacity', this.options.projectionStrokeOpacity).attr('stroke-width', this.options.strokeWidth);
      }

      return rerender;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        if (!this._xScale || !this.yScale) {
          return;
        }

        if (!this.viewportXDomain || !this.viewportYDomain) {
          return;
        }

        var x0 = this._xScale(this.viewportXDomain[0]);
        var y0 = 0;

        var x1 = this._xScale(this.viewportXDomain[1]);
        var y1 = this.dimensions[1];

        var dest = [[x0, y0], [x1, y1]];

        // console.log('dest:', dest[0], dest[1]);

        // user hasn't actively brushed so we don't want to emit a
        // 'brushed' event
        this.brush.on('brush', null);
        this.gBrush.call(this.brush.move, dest);
        this.brush.on('brush', this.brushed.bind(this));
      }

      return draw;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        this.xScale(newXScale);
        this.yScale(newYScale);

        this.draw();
      }

      return zoomed;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(ViewportTrackerHorizontal.prototype.__proto__ || Object.getPrototypeOf(ViewportTrackerHorizontal.prototype), 'setPosition', this).call(this, newPosition);

        this.draw();
      }

      return setPosition;
    }()
  }]);

  return ViewportTrackerHorizontal;
}(_SVGTrack3['default']);

exports['default'] = ViewportTrackerHorizontal;

/***/ }),
/* 676 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ViewportTrackerVertical = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _SVGTrack2 = __webpack_require__(61);

var _SVGTrack3 = _interopRequireDefault(_SVGTrack2);

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _d3Brush = __webpack_require__(25);

var _d3Selection = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ViewportTrackerVertical = exports.ViewportTrackerVertical = function (_SVGTrack) {
  _inherits(ViewportTrackerVertical, _SVGTrack);

  function ViewportTrackerVertical(svgElement, registerViewportChanged, removeViewportChanged, setDomainsCallback, options) {
    _classCallCheck(this, ViewportTrackerVertical);

    var _this = _possibleConstructorReturn(this, (ViewportTrackerVertical.__proto__ || Object.getPrototypeOf(ViewportTrackerVertical)).call(this, svgElement, true));
    // create a clipped SVG Path


    var uid = _slugid2['default'].nice();
    _this.uid = uid;
    _this.options = options;

    _this.removeViewportChanged = removeViewportChanged;
    _this.setDomainsCallback = setDomainsCallback;

    _this.viewportXDomain = null;
    _this.viewportYDomain = null;

    var MAX_VALUE = 10000;

    _this.brush = (0, _d3Brush.brush)(true).on('brush', _this.brushed.bind(_this));

    _this.gBrush = _this.gMain.append('g').attr('id', 'brush-' + _this.uid).call(_this.brush);

    // turn off the ability to select new regions for this brush
    _this.gBrush.selectAll('.overlay').style('pointer-events', 'none');

    // turn off the ability to modify the aspect ratio of the brush
    _this.gBrush.selectAll('.handle--ne').style('pointer-events', 'none');

    _this.gBrush.selectAll('.handle--nw').style('pointer-events', 'none');

    _this.gBrush.selectAll('.handle--sw').style('pointer-events', 'none');

    _this.gBrush.selectAll('.handle--se').style('pointer-events', 'none');

    _this.gBrush.selectAll('.handle--e').style('pointer-events', 'none');

    _this.gBrush.selectAll('.handle--w').style('pointer-events', 'none');

    registerViewportChanged(uid, _this.viewportChanged.bind(_this));

    // the viewport will call this.viewportChanged immediately upon
    // hearing registerViewportChanged
    _this.draw();
    return _this;
  }

  _createClass(ViewportTrackerVertical, [{
    key: 'brushed',
    value: function () {
      function brushed() {
        /**
             * Should only be called  on active brushing, not in response to the
             * draw event
             */
        var s = _d3Selection.event.selection;

        if (!this._xScale || !this._yScale) {
          return;
        }

        var xDomain = this.viewportXDomain;

        var yDomain = [this._yScale.invert(s[0][1]), this._yScale.invert(s[1][1])];

        // console.log('xDomain:', xDomain);
        // console.log('yDomain:', yDomain);

        this.setDomainsCallback(xDomain, yDomain);
      }

      return brushed;
    }()
  }, {
    key: 'viewportChanged',
    value: function () {
      function viewportChanged(viewportXScale, viewportYScale) {
        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        // console.log('viewport changed:', viewportXScale.domain());
        var viewportXDomain = viewportXScale.domain();
        var viewportYDomain = viewportYScale.domain();

        this.viewportXDomain = viewportXDomain;
        this.viewportYDomain = viewportYDomain;

        this.draw();
      }

      return viewportChanged;
    }()
  }, {
    key: 'remove',
    value: function () {
      function remove() {
        // remove the event handler that updates this viewport tracker
        this.removeViewportChanged(this.uid);

        _get(ViewportTrackerVertical.prototype.__proto__ || Object.getPrototypeOf(ViewportTrackerVertical.prototype), 'remove', this).call(this);
      }

      return remove;
    }()
  }, {
    key: 'rerender',
    value: function () {
      function rerender() {
        // set the fill and stroke colors
        this.gBrush.selectAll('.selection').attr('fill', this.options.projectionFillColor).attr('stroke', this.options.projectionStrokeColor).attr('fill-opacity', this.options.projectionFillOpacity).attr('stroke-opacity', this.options.projectionStrokeOpacity).attr('stroke-width', this.options.strokeWidth);
      }

      return rerender;
    }()
  }, {
    key: 'draw',
    value: function () {
      function draw() {
        if (!this._xScale || !this.yScale) {
          return;
        }

        if (!this.viewportXDomain || !this.viewportYDomain) {
          return;
        }

        var x0 = 0;
        var y0 = this._yScale(this.viewportYDomain[0]);

        var x1 = this.dimensions[0];
        var y1 = this._yScale(this.viewportYDomain[1]);

        var dest = [[x0, y0], [x1, y1]];

        // console.log('dest:', dest[0], dest[1]);

        // user hasn't actively brushed so we don't want to emit a
        // 'brushed' event
        this.brush.on('brush', null);
        this.gBrush.call(this.brush.move, dest);
        this.brush.on('brush', this.brushed.bind(this));
      }

      return draw;
    }()
  }, {
    key: 'zoomed',
    value: function () {
      function zoomed(newXScale, newYScale) {
        this.xScale(newXScale);
        this.yScale(newYScale);

        this.draw();
      }

      return zoomed;
    }()
  }, {
    key: 'setPosition',
    value: function () {
      function setPosition(newPosition) {
        _get(ViewportTrackerVertical.prototype.__proto__ || Object.getPrototypeOf(ViewportTrackerVertical.prototype), 'setPosition', this).call(this, newPosition);

        this.draw();
      }

      return setPosition;
    }()
  }]);

  return ViewportTrackerVertical;
}(_SVGTrack3['default']);

exports['default'] = ViewportTrackerVertical;

/***/ }),
/* 677 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MapboxTilesTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _OSMTilesTrack2 = __webpack_require__(246);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MapboxTilesTrack = exports.MapboxTilesTrack = function (_OSMTilesTrack) {
  _inherits(MapboxTilesTrack, _OSMTilesTrack);

  /**
     * A track that must pull remote tiles
     */
  function MapboxTilesTrack(scene, options, animate) {
    _classCallCheck(this, MapboxTilesTrack);

    var _this = _possibleConstructorReturn(this, (MapboxTilesTrack.__proto__ || Object.getPrototypeOf(MapboxTilesTrack)).call(this, scene, options, animate));
    /**
         * @param scene: A PIXI.js scene to draw everything to.
         * @param server: The server to pull tiles from.
         * @param tilesetUid: The data set to get the tiles from the server
         */


    _this.currentStyle = options.mapboxStyle;
    return _this;
  }

  _createClass(MapboxTilesTrack, [{
    key: 'rerender',
    value: function () {
      function rerender(newOptions) {
        _get(MapboxTilesTrack.prototype.__proto__ || Object.getPrototypeOf(MapboxTilesTrack.prototype), 'rerender', this).call(this, newOptions);

        if (newOptions.mapboxStyle == this.currentStyle) {
          return;
        }

        this.currentStyle = newOptions.mapboxStyle;

        this.removeAllTiles();
        this.refreshTiles();
      }

      return rerender;
    }()
  }, {
    key: 'getTileUrl',
    value: function () {
      function getTileUrl(tileZxy) {
        /**
             * Get the url used to fetch the tile data
             */
        var mapStyle = 'mapbox.streets';

        if (this.options && this.options.mapboxStyle) {
          mapStyle = this.options.mapboxStyle;
        }

        var accessToken = 'pk.eyJ1IjoicGtlcnBlZGppZXYiLCJhIjoiY2o1OW44dnN0MGFqZDMxcXFoYW04cmh4biJ9.WGEDSUhcn4W4x7IaA8DFRw';
        var src = 'http://api.tiles.mapbox.com/v4/' + mapStyle + '/' + tileZxy[0] + '/' + tileZxy[1] + '/' + tileZxy[2] + '.png?access_token=' + accessToken;

        return src;
      }

      return getTileUrl;
    }()
  }]);

  return MapboxTilesTrack;
}(_OSMTilesTrack2.OSMTilesTrack);

exports['default'] = MapboxTilesTrack;

/***/ }),
/* 678 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"track-renderer":"TrackRenderer-module_track-renderer-3TM7n"};

/***/ }),
/* 679 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AddTrackModal = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactBootstrap = __webpack_require__(59);

var _TilesetFinder = __webpack_require__(680);

var _PlotTypeChooser = __webpack_require__(681);

var _configs = __webpack_require__(6);

__webpack_require__(683);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Configs


// Styles


var AddTrackModal = exports.AddTrackModal = function (_React$Component) {
  _inherits(AddTrackModal, _React$Component);

  function AddTrackModal(props) {
    _classCallCheck(this, AddTrackModal);

    var _this = _possibleConstructorReturn(this, (AddTrackModal.__proto__ || Object.getPrototypeOf(AddTrackModal)).call(this, props));

    _this.tilesetFinder = null;
    _this.multiSelect = null;

    _this.options = {};

    _this.state = {
      selectedTilesets: [{ datatype: 'none' }],
      normalizeTilesetUuid: null
    };
    return _this;
  }

  _createClass(AddTrackModal, [{
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {}

      return componentDidMount;
    }()
  }, {
    key: 'handleSubmit',
    value: function () {
      function handleSubmit() {
        this.props.onTracksChosen(this.state.selectedTilesets, this.props.position, this.props.host);
      }

      return handleSubmit;
    }()
  }, {
    key: 'selectedTilesetsChanged',
    value: function () {
      function selectedTilesetsChanged(selectedTilesets) {
        var allSame = true;

        var firstDatatype = selectedTilesets[0].datatype;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = selectedTilesets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _tileset2 = _step.value;

            if (_tileset2.datatype !== firstDatatype) {
              allSame = false;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (allSame) {
          // only one datatype is present in the set of selected tilesets
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = selectedTilesets[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var tileset = _step2.value;

              tileset.type = this.selectedPlotType;
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                _iterator2['return']();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        } else {
          // more than one dataype present, we assign the default track type
          // to each tileset
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = selectedTilesets[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _tileset = _step3.value;

              _tileset.type = (0, _configs.AVAILABLE_TRACK_TYPES)([_tileset.datatype], this.getOrientation(this.props.position))[0].type;
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                _iterator3['return']();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }

        this.setState({
          selectedTilesets: selectedTilesets
        });
      }

      return selectedTilesetsChanged;
    }()
  }, {
    key: 'handleTilesetPickerDoubleClick',
    value: function () {
      function handleTilesetPickerDoubleClick(tileset) {
        /**
         * The user double clicked a tileset in the tileset finder dialog.
         * This means that only one is selected.
         *
         * Arguments
         * ---------
         *  tileset: { uuid: 'CXCX', filetype: 'cooler' ....}
         */
        this.selectedTilesetsChanged([tileset]);

        // should iterate over the selected tilesets
        this.props.onTracksChosen(this.state.selectedTilesets, this.props.position, this.props.host);
      }

      return handleTilesetPickerDoubleClick;
    }()
  }, {
    key: 'handleOptionsChanged',
    value: function () {
      function handleOptionsChanged(newOptions) {
        this.options = newOptions;
      }

      return handleOptionsChanged;
    }()
  }, {
    key: 'handlePlotTypeSelected',
    value: function () {
      function handlePlotTypeSelected(newPlotType) {
        var selectedTilesets = this.state.selectedTilesets;

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = selectedTilesets[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var tileset = _step4.value;
            tileset.type = newPlotType;
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4['return']) {
              _iterator4['return']();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        this.selectedPlotType = newPlotType;

        this.setState({
          selectedTilesets: selectedTilesets
        });
      }

      return handlePlotTypeSelected;
    }()
  }, {
    key: 'getOrientation',
    value: function () {
      function getOrientation(position) {
        /**
         * Get the track available track orientations for the given
         * track position. Generally "top" or "bottom" equal "1d-horizontal",
         * "left" or "right" correspond to "1d-vertical" and "center" means "2d".
         *
         * Arguments
         * ---------
         *  position: string
         *
         * Returns
         * -------
         *
         *  A string containing the track orientation.
         */
        var orientation = null;

        if (position === 'top' || position === 'bottom') {
          orientation = '1d-horizontal';
        } else if (position === 'left' || position === 'right') {
          orientation = '1d-vertical';
        } else {
          orientation = '2d';
        }

        return orientation;
      }

      return getOrientation;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        var orientation = this.getOrientation(this.props.position);

        var form = _react2['default'].createElement(
          'div',
          null,
          _react2['default'].createElement(_TilesetFinder.TilesetFinder, {
            onDoubleClick: this.handleTilesetPickerDoubleClick.bind(this),
            onTracksChosen: function () {
              function onTracksChosen(value) {
                return _this2.props.onTracksChosen(value, _this2.props.position);
              }

              return onTracksChosen;
            }(),
            orientation: orientation,
            ref: function () {
              function ref(c) {
                _this2.tilesetFinder = c;
              }

              return ref;
            }(),
            selectedTilesetChanged: this.selectedTilesetsChanged.bind(this),
            trackSourceServers: this.props.trackSourceServers
          })
        );

        return _react2['default'].createElement(
          _reactBootstrap.Modal,
          {
            onHide: this.props.onCancel,
            show: this.props.show
          },
          _react2['default'].createElement(
            _reactBootstrap.Modal.Header,
            { closeButton: true },
            _react2['default'].createElement(
              _reactBootstrap.Modal.Title,
              null,
              'Add Track'
            )
          ),
          _react2['default'].createElement(
            _reactBootstrap.Modal.Body,
            null,
            form,
            _react2['default'].createElement(_PlotTypeChooser.PlotTypeChooser, {
              ref: function () {
                function ref(c) {
                  _this2.plotTypeChooser = c;
                }

                return ref;
              }(),
              datatypes: this.state.selectedTilesets.map(function (x) {
                return x.datatype;
              }),
              onPlotTypeSelected: this.handlePlotTypeSelected.bind(this),
              orientation: orientation
            })
          ),
          _react2['default'].createElement(
            _reactBootstrap.Modal.Footer,
            null,
            _react2['default'].createElement(
              _reactBootstrap.Button,
              { onClick: this.props.onCancel },
              'Cancel'
            ),
            _react2['default'].createElement(
              _reactBootstrap.Button,
              { onClick: this.handleSubmit.bind(this) },
              'Submit'
            )
          )
        );
      }

      return render;
    }()
  }]);

  return AddTrackModal;
}(_react2['default'].Component);

AddTrackModal.defaultProps = {
  position: 'top',
  show: false
};

AddTrackModal.propTypes = {
  host: _propTypes2['default'].object,
  onCancel: _propTypes2['default'].func.isRequired,
  onTracksChosen: _propTypes2['default'].func.isRequired,
  position: _propTypes2['default'].string,
  show: _propTypes2['default'].bool,
  trackSourceServers: _propTypes2['default'].array.isRequired
};

exports['default'] = AddTrackModal;

/***/ }),
/* 680 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TilesetFinder = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _services = __webpack_require__(7);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactBootstrap = __webpack_require__(59);

var _reactDom = __webpack_require__(8);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _configs = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Configs


var TilesetFinder = exports.TilesetFinder = function (_React$Component) {
  _inherits(TilesetFinder, _React$Component);

  function TilesetFinder(props) {
    _classCallCheck(this, TilesetFinder);

    // this.localTracks = TRACKS_INFO.filter

    // local tracks are ones that don't have a filetype associated with them
    var _this = _possibleConstructorReturn(this, (TilesetFinder.__proto__ || Object.getPrototypeOf(TilesetFinder)).call(this, props));

    _this.localTracks = _configs.TRACKS_INFO.filter(function (x) {
      return x.local && !x.hidden;
    }).filter(function (x) {
      return x.orientation == _this.props.orientation;
    }).filter(function (x) {
      return !x.hidden;
    });

    _this.localTracks.forEach(function (x) {
      return x.uuid = _slugid2['default'].nice();
    });

    var newOptions = _this.prepareNewEntries('', _this.localTracks, {});
    var availableTilesetKeys = Object.keys(newOptions);
    var selectedUuid = availableTilesetKeys.length ? [availableTilesetKeys[0]] : null;
    _this.mounted = false;

    _this.state = {
      selectedUuid: selectedUuid,
      options: newOptions,
      filter: ''
    };

    _this.requestTilesetLists();
    return _this;
  }

  _createClass(TilesetFinder, [{
    key: 'serverUidKey',
    value: function () {
      function serverUidKey(server, uid) {
        /**
             * Create a key for a server and uid
             */
        return server + '/' + uid;
      }

      return serverUidKey;
    }()
  }, {
    key: 'prepareNewEntries',
    value: function () {
      function prepareNewEntries(sourceServer, newEntries, existingOptions) {
        var _this2 = this;

        /**
             * Add meta data to new tileset entries before adding
             * them to the list of available options.
             */
        var newOptions = existingOptions;

        var entries = newEntries.map(function (ne) {
          var ane = Object.assign({}, ne, {
            server: sourceServer,
            tilesetUid: ne.uuid,
            serverUidKey: _this2.serverUidKey(sourceServer, ne.uuid),
            datatype: ne.datatype,
            name: ne.name,
            uid: _slugid2['default'].nice()
          });

          return ane;
        });

        entries.forEach(function (ne) {
          newOptions[ne.serverUidKey] = ne;
        });

        return newOptions;
      }

      return prepareNewEntries;
    }()
  }, {
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {
        // we want to query for a list of tracks that are compatible with this
        // track orientation

        this.mounted = true;

        this.requestTilesetLists();

        var selectedTilesets = [this.state.options[this.state.selectedUuid]];

        if (selectedTilesets) {
          this.props.selectedTilesetChanged(selectedTilesets);
        }
      }

      return componentDidMount;
    }()
  }, {
    key: 'componentWillUnmount',
    value: function () {
      function componentWillUnmount() {
        this.mounted = false;
      }

      return componentWillUnmount;
    }()
  }, {
    key: 'requestTilesetLists',
    value: function () {
      function requestTilesetLists() {
        var _this3 = this;

        var datatypes = new Set(_configs.TRACKS_INFO.filter(function (x) {
          return x.datatype;
        }).filter(function (x) {
          return x.orientation == _this3.props.orientation;
        }).map(function (x) {
          return x.datatype;
        }));
        var datatypesQuery = [].concat(_toConsumableArray(datatypes)).map(function (x) {
          return 'dt=' + x;
        }).join('&');

        if (!this.props.trackSourceServers) {
          console.warn("No track source servers specified in the viewconf");
          return;
        }

        this.props.trackSourceServers.forEach(function (sourceServer) {
          _services.tileProxy.json(sourceServer + '/tilesets/?limit=10000&' + datatypesQuery, function (error, data) {
            if (error) {
              console.error('ERROR:', error);
            } else {
              var newOptions = _this3.prepareNewEntries(sourceServer, data.results, _this3.state.options);
              var availableTilesetKeys = Object.keys(newOptions);
              var selectedUuid = _this3.state.selectedUuid;

              // if there isn't a selected tileset, select the first received one
              if (!selectedUuid) {
                selectedUuid = availableTilesetKeys.length ? [availableTilesetKeys[0]] : null;
                var selectedTileset = _this3.state.options[selectedUuid];
                _this3.props.selectedTilesetChanged(selectedTileset);
              }

              if (_this3.mounted) {
                _this3.setState({
                  selectedUuid: selectedUuid,
                  options: newOptions
                });
              }
            }
          });
        });
      }

      return requestTilesetLists;
    }()
  }, {
    key: 'handleOptionDoubleClick',
    value: function () {
      function handleOptionDoubleClick(x, y) {
        /**
             * Double clicked on an element. Should be selected
             * and this window will be closed.
             */

        // this should give the dataset the PlotType that's selected in the parent
        // this.props.selectedTilesetChanged(this.state.options[x.target.value]);

        // console.log('x.target.value:', x.target.value);

        var value = this.state.options[x.target.value];
        this.props.onDoubleClick(value);
      }

      return handleOptionDoubleClick;
    }()
  }, {
    key: 'handleSelectedOptions',
    value: function () {
      function handleSelectedOptions(selectedOptions) {
        var selectedValues = [];
        var selectedTilesets = [];

        // I don't know why selectedOptions.map doesn't work
        for (var i = 0; i < selectedOptions.length; i++) {
          selectedValues.push(selectedOptions[i]);
          selectedTilesets.push(this.state.options[selectedOptions[i]]);
        }

        //

        this.props.selectedTilesetChanged(selectedTilesets);

        this.setState({
          selectedUuid: selectedValues
          // selectedUuid: selectedValues
        });
      }

      return handleSelectedOptions;
    }()
  }, {
    key: 'handleSelect',
    value: function () {
      function handleSelect(x) {
        var selectedOptions = _reactDom2['default'].findDOMNode(this.multiSelect).selectedOptions;
        var selectedOptionsList = [];

        for (var i = 0; i < selectedOptions.length; i++) {
          var selectedOption = selectedOptions[i];
          selectedOptionsList.push(selectedOption.value);
        }

        this.handleSelectedOptions(selectedOptionsList);
      }

      return handleSelect;
    }()
  }, {
    key: 'handleSearchChange',
    value: function () {
      function handleSearchChange() {
        var domElement = _reactDom2['default'].findDOMNode(this.searchBox);

        this.setState({ filter: domElement.value });
      }

      return handleSearchChange;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this4 = this;

        var optionsList = [];
        for (var key in this.state.options) {
          optionsList.push(this.state.options[key]);
        }

        // the list of tilesets / tracks available
        var options = optionsList.filter(function (x) {
          return x.name.toLowerCase().includes(_this4.state.filter);
        }).map(function (x) {
          return _react2['default'].createElement(
            'option',
            {
              onDoubleClick: _this4.handleOptionDoubleClick.bind(_this4),
              key: x.serverUidKey,
              value: x.serverUidKey
            },
            x.name
          );
        });

        var form = _react2['default'].createElement(
          _reactBootstrap.Form,
          {
            horizontal: true
          },
          _react2['default'].createElement(
            _reactBootstrap.FormGroup,
            null,
            _react2['default'].createElement(
              _reactBootstrap.Col,
              { sm: 3 },
              _react2['default'].createElement(
                _reactBootstrap.ControlLabel,
                null,
                'Select tileset'
              )
            ),
            _react2['default'].createElement(
              _reactBootstrap.Col,
              { smOffset: 5, sm: 4 },
              _react2['default'].createElement(_reactBootstrap.FormControl, {
                placeholder: 'Search Term',
                ref: function () {
                  function ref(c) {
                    _this4.searchBox = c;
                  }

                  return ref;
                }(),
                onChange: this.handleSearchChange.bind(this),
                autoFocus: true
              }),
              _react2['default'].createElement('div', { style: { height: 10 } })
            ),
            _react2['default'].createElement(
              _reactBootstrap.Col,
              { sm: 12 },
              _react2['default'].createElement(
                _reactBootstrap.FormControl,
                {
                  componentClass: 'select',
                  multiple: true,
                  className: 'tileset-list',
                  value: this.state.selectedUuid ? this.state.selectedUuid : ['x'],
                  onChange: this.handleSelect.bind(this),
                  ref: function () {
                    function ref(c) {
                      return _this4.multiSelect = c;
                    }

                    return ref;
                  }(),
                  size: 15
                },
                options
              )
            )
          )
        );

        return _react2['default'].createElement(
          'div',
          null,
          form
        );
      }

      return render;
    }()
  }]);

  return TilesetFinder;
}(_react2['default'].Component);

exports['default'] = TilesetFinder;

/***/ }),
/* 681 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PlotTypeChooser = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _configs = __webpack_require__(6);

__webpack_require__(682);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Configs


// Styles


var PlotTypeChooser = exports.PlotTypeChooser = function (_React$Component) {
  _inherits(PlotTypeChooser, _React$Component);

  function PlotTypeChooser(props) {
    _classCallCheck(this, PlotTypeChooser);

    var _this = _possibleConstructorReturn(this, (PlotTypeChooser.__proto__ || Object.getPrototypeOf(PlotTypeChooser)).call(this, props));

    _this.DATATYPE_TO_TRACK_TYPE = (0, _configs.DATATYPE_TO_TRACK_TYPE)(_this.props.orientation);
    _this.AVAILABLE_TRACK_TYPES = (0, _configs.AVAILABLE_TRACK_TYPES)(_this.props.datatypes, _this.props.orientation);

    _this.state = {
      selectedPlotType: _this.AVAILABLE_TRACK_TYPES[0]
    };
    return _this;
  }

  _createClass(PlotTypeChooser, [{
    key: 'componentWillReceiveProps',
    value: function () {
      function componentWillReceiveProps(newProps) {
        this.AVAILABLE_TRACK_TYPES = (0, _configs.AVAILABLE_TRACK_TYPES)(newProps.datatypes, this.props.orientation);

        if (!this.AVAILABLE_TRACK_TYPES) {
          return;
        }

        if (this.AVAILABLE_TRACK_TYPES.length > 0) {
          if (!this.AVAILABLE_TRACK_TYPES.includes(this.state.selectedPlotType)) {
            this.handlePlotTypeSelected(this.AVAILABLE_TRACK_TYPES[0]);
          }
        } else {
          // no available track types
          // this could be because the datatype is unknown
          // or because there's multiple different datatypes
        }
      }

      return componentWillReceiveProps;
    }()
  }, {
    key: 'handlePlotTypeSelected',
    value: function () {
      function handlePlotTypeSelected(key) {
        this.setState({
          selectedPlotType: key
        });

        this.props.onPlotTypeSelected(key.type);
      }

      return handlePlotTypeSelected;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        var AVAILABLE_TRACK_TYPESList = 'No plot types available for track';
        var trackTypeToInfo = {};

        _configs.TRACKS_INFO.forEach(function (ti) {
          trackTypeToInfo[ti.type] = ti;
        });

        if (this.AVAILABLE_TRACK_TYPES) {
          AVAILABLE_TRACK_TYPESList = this.AVAILABLE_TRACK_TYPES.sort(function (a, b) {
            return a.type < b.type;
          }).map(function (x) {
            var thumbnail = trackTypeToInfo[x.type].thumbnail;
            var plotTypeClass = _this2.state.selectedPlotType.type == x.type ? 'plot-type-selected' : 'unselected';
            var imgTag = trackTypeToInfo[x.type].thumbnail ? _react2['default'].createElement('div', {
              style: { display: 'inline-block', marginRight: 10, verticalAlign: 'middle' },
              dangerouslySetInnerHTML: { __html: thumbnail.outerHTML }
            }) : _react2['default'].createElement(
              'div',
              { style: { display: 'inline-block', marginRight: 10, verticalAlign: 'middle' } },
              _react2['default'].createElement('svg', { width: 30, height: 20 })
            );
            return _react2['default'].createElement(
              'li',
              {
                className: plotTypeClass,
                key: x.type,
                onClick: function () {
                  function onClick(e) {
                    _this2.setState({ selectedPlotType: x });
                    _this2.props.onPlotTypeSelected(x.type);
                  }

                  return onClick;
                }(),
                style: { listStyle: 'none', paddingLeft: 5, paddingBottom: 0 }
              },
              imgTag,
              _react2['default'].createElement(
                'span',
                {
                  style: { verticalAlign: 'middle' }
                },
                x.type
              )
            );
          });
        }

        return _react2['default'].createElement(
          'div',
          null,
          AVAILABLE_TRACK_TYPESList
        );
      }

      return render;
    }()
  }]);

  return PlotTypeChooser;
}(_react2['default'].Component);

exports['default'] = PlotTypeChooser;

/***/ }),
/* 682 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 683 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 684 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConfigTrackMenu = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _ContextMenuContainer2 = __webpack_require__(62);

var _ContextMenuContainer3 = _interopRequireDefault(_ContextMenuContainer2);

var _ContextMenuItem = __webpack_require__(63);

var _ContextMenuItem2 = _interopRequireDefault(_ContextMenuItem);

var _SeriesListMenu = __webpack_require__(685);

var _configs = __webpack_require__(6);

__webpack_require__(44);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Configs


// Styles


var ConfigTrackMenu = exports.ConfigTrackMenu = function (_ContextMenuContainer) {
  _inherits(ConfigTrackMenu, _ContextMenuContainer);

  function ConfigTrackMenu(props) {
    _classCallCheck(this, ConfigTrackMenu);

    var _this = _possibleConstructorReturn(this, (ConfigTrackMenu.__proto__ || Object.getPrototypeOf(ConfigTrackMenu)).call(this, props));
    /**
     * A window that is opened when a user clicks on the track configuration icon.
     */


    _this.seriesRefs = {};
    _this.seriesListMenu = null;
    return _this;
  }

  _createClass(ConfigTrackMenu, [{
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {
        _get(ConfigTrackMenu.prototype.__proto__ || Object.getPrototypeOf(ConfigTrackMenu.prototype), 'componentDidMount', this).call(this);
      }

      return componentDidMount;
    }()
  }, {
    key: 'getSeriesItems',
    value: function () {
      function getSeriesItems() {
        var _this2 = this;

        // this code is duplicated in CloseTrackMenu, needs to be consolidated
        if (!this.props.track) return null;

        var trackTypeToInfo = {};

        _configs.TRACKS_INFO.forEach(function (ti) {
          trackTypeToInfo[ti.type] = ti;
        });

        // check if this is a combined track (has contents)
        var series = this.props.track.contents ? this.props.track.contents : [this.props.track];

        return series.map(function (x) {
          var thumbnail = trackTypeToInfo[x.type].thumbnail;
          var imgTag = trackTypeToInfo[x.type].thumbnail ? _react2['default'].createElement('div', {
            dangerouslySetInnerHTML: { __html: thumbnail.outerHTML },
            style: {
              display: 'inline-block',
              marginRight: 10,
              verticalAlign: 'middle'
            }
          }) : _react2['default'].createElement(
            'div',
            {
              style: {
                display: 'inline-block',
                marginRight: 10,
                verticalAlign: 'middle'
              }
            },
            _react2['default'].createElement('svg', {
              height: 20,
              width: 30
            })
          );

          return _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              key: x.uid,
              onMouseEnter: function () {
                function onMouseEnter(e) {
                  return _this2.handleItemMouseEnter(e, x);
                }

                return onMouseEnter;
              }(),
              onMouseLeave: function () {
                function onMouseLeave(e) {
                  return _this2.handleMouseLeave(e);
                }

                return onMouseLeave;
              }(),
              ref: function () {
                function ref(c) {
                  return _this2.seriesRefs[x.uid] = c;
                }

                return ref;
              }(),
              className: 'ContextMenu-module_context-menu-item-1HeVv'
            },
            imgTag,
            _react2['default'].createElement(
              'span',
              {
                className: 'ContextMenu-module_context-menu-span-8EUfZ'
              },
              x.name && x.name.length ? x.name : x.uid,
              _react2['default'].createElement(
                'svg',
                { className: 'ContextMenu-module_play-icon-R4pIO' },
                _react2['default'].createElement('use', { xlinkHref: '#play' })
              )
            )
          );
        });
      }

      return getSeriesItems;
    }()
  }, {
    key: 'getSubmenu',
    value: function () {
      function getSubmenu() {
        var _this3 = this;

        if (this.state.submenuShown) {
          // the bounding box of the element which initiated the subMenu
          // necessary so that we can position the submenu next to the initiating
          // element
          var bbox = this.state.submenuSourceBbox;
          var position = null;

          if (this.state.orientation == 'left') {
            position = {
              left: this.state.left,
              top: bbox.top
            };
          } else {
            position = {
              left: this.state.left + bbox.width + 7,
              top: bbox.top
            };
          }

          var selectedTrack = this.props.track.contents ? this.props.track.contents.filter(function (t) {
            return t.uid == _this3.state.submenuShown.uid;
          })[0] : this.props.track;

          return _react2['default'].createElement(_SeriesListMenu.SeriesListMenu, {
            closeMenu: this.props.closeMenu,
            hostTrack: this.props.track,
            onAddSeries: this.props.onAddSeries,
            onChangeTrackType: this.props.onChangeTrackType,
            onCloseTrack: function () {
              function onCloseTrack() {
                return _this3.props.onCloseTrack(_this3.state.submenuShown.uid);
              }

              return onCloseTrack;
            }(),
            onConfigureTrack: this.props.onConfigureTrack,
            onExportData: this.props.onExportData,
            onLockScales: this.props.onLockScales,
            onTrackOptionsChanged: this.props.onTrackOptionsChanged,
            onDivideSeries: this.props.onDivideSeries,
            orientation: this.state.orientation,
            ref: function () {
              function ref(c) {
                return _this3.seriesListMenu = c;
              }

              return ref;
            }(),
            parentBbox: bbox,
            position: position,
            series: this.state.submenuShown,
            track: selectedTrack,
            trackOrientation: this.props.trackOrientation
          });
        }
        return _react2['default'].createElement('div', null);
      }

      return getSubmenu;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this4 = this;

        return _react2['default'].createElement(
          'div',
          {
            ref: function () {
              function ref(c) {
                return _this4.div = c;
              }

              return ref;
            }(),
            style: {
              left: this.state.left,
              top: this.state.top
            },
            className: 'ContextMenu-module_context-menu-2OwvL'
          },
          this.getSeriesItems(),
          _react2['default'].createElement('hr', { className: 'ContextMenu-module_context-menu-hr-3yapb' }),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              contextMenu: this,
              onClick: function () {
                function onClick() {
                  return _this4.props.onLockValueScale(_this4.props.track.uid);
                }

                return onClick;
              }(),
              onMouseEnter: function () {
                function onMouseEnter(e) {
                  return _this4.handleOtherMouseEnter(e);
                }

                return onMouseEnter;
              }()
            },
            'Lock Value Scale With'
          ),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              contextMenu: this,
              onClick: function () {
                function onClick() {
                  return _this4.props.onUnlockValueScale(_this4.props.track.uid);
                }

                return onClick;
              }(),
              onMouseEnter: function () {
                function onMouseEnter(e) {
                  return _this4.handleOtherMouseEnter(e);
                }

                return onMouseEnter;
              }()
            },
            'Unlock Value Scale'
          ),
          _react2['default'].createElement('hr', { className: 'ContextMenu-module_context-menu-hr-3yapb' }),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              contextMenu: this,
              onClick: function () {
                function onClick() {
                  return _this4.props.onAddSeries(_this4.props.track.uid);
                }

                return onClick;
              }(),
              onMouseEnter: function () {
                function onMouseEnter(e) {
                  return _this4.handleOtherMouseEnter(e);
                }

                return onMouseEnter;
              }()
            },
            'Add Series'
          ),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick() {
                  return _this4.props.onCloseTrack(_this4.props.track.uid);
                }

                return onClick;
              }()
            },
            'Close Track'
          ),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick() {
                  _this4.props.onReplaceTrack(_this4.props.track.uid, _this4.props.trackOrientation);
                }

                return onClick;
              }()
            },
            'Replace Track'
          ),
          this.getSubmenu()
        );
      }

      return render;
    }()
  }]);

  return ConfigTrackMenu;
}(_ContextMenuContainer3['default']);

exports['default'] = ConfigTrackMenu;

/***/ }),
/* 685 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SeriesListMenu = exports.ConfigureSeriesMenu = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _getClassName2 = __webpack_require__(36);

var _getClassName3 = _interopRequireDefault(_getClassName2);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _ContextMenuContainer3 = __webpack_require__(62);

var _ContextMenuContainer4 = _interopRequireDefault(_ContextMenuContainer3);

var _ContextMenuItem = __webpack_require__(63);

var _ContextMenuItem2 = _interopRequireDefault(_ContextMenuItem);

var _NestedContextMenu = __webpack_require__(686);

var _NestedContextMenu2 = _interopRequireDefault(_NestedContextMenu);

var _configs = __webpack_require__(6);

__webpack_require__(44);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _styleModuleImportMap = {
  '../styles/ContextMenu.module.scss': {
    'context-menu': 'ContextMenu-module_context-menu-2OwvL',
    'context-menu-item': 'ContextMenu-module_context-menu-item-1HeVv',
    'context-menu-hr': 'ContextMenu-module_context-menu-hr-3yapb',
    'play-icon': 'ContextMenu-module_play-icon-R4pIO',
    'context-menu-span': 'ContextMenu-module_context-menu-span-8EUfZ',
    'context-menu-thumbnail': 'ContextMenu-module_context-menu-thumbnail-2vHLD',
    'context-menu-thumbnail-inline': 'ContextMenu-module_context-menu-thumbnail-inline-1iOcg'
  }
};

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Configs


// Styles


var ConfigureSeriesMenu = exports.ConfigureSeriesMenu = function (_ContextMenuContainer) {
  _inherits(ConfigureSeriesMenu, _ContextMenuContainer);

  function ConfigureSeriesMenu() {
    _classCallCheck(this, ConfigureSeriesMenu);

    return _possibleConstructorReturn(this, (ConfigureSeriesMenu.__proto__ || Object.getPrototypeOf(ConfigureSeriesMenu)).apply(this, arguments));
  }

  _createClass(ConfigureSeriesMenu, [{
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        return _react2['default'].createElement('div', {
          onMouseLeave: this.props.handleMouseLeave,
          ref: function () {
            function ref(c) {
              return _this2.div = c;
            }

            return ref;
          }(),
          style: {
            left: this.state.left,
            top: this.state.top
          },
          className: (0, _getClassName3['default'])('context-menu', _styleModuleImportMap)
        });
      }

      return render;
    }()
  }]);

  return ConfigureSeriesMenu;
}(_ContextMenuContainer4['default']);

var SeriesListMenu = exports.SeriesListMenu = function (_ContextMenuContainer2) {
  _inherits(SeriesListMenu, _ContextMenuContainer2);

  function SeriesListMenu() {
    _classCallCheck(this, SeriesListMenu);

    return _possibleConstructorReturn(this, (SeriesListMenu.__proto__ || Object.getPrototypeOf(SeriesListMenu)).apply(this, arguments));
  }

  _createClass(SeriesListMenu, [{
    key: 'getConfigureSeriesMenu',
    value: function () {
      function getConfigureSeriesMenu(position, bbox, track) {
        var _this4 = this;

        var menuItems = {};

        if (!_configs.TRACKS_INFO_BY_TYPE[track.type].availableOptions) {
          return null;
        }

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          var _loop = function () {
            function _loop() {
              var optionType = _step.value;

              if (_configs.OPTIONS_INFO.hasOwnProperty(optionType)) {
                menuItems[optionType] = { name: _configs.OPTIONS_INFO[optionType].name };

                // can we dynamically generate some options?
                // should be used if the options depend on tileset info or other current state
                if (_configs.OPTIONS_INFO[optionType].generateOptions) {
                  var generatedOptions = _configs.OPTIONS_INFO[optionType].generateOptions(track);

                  if (!menuItems[optionType].children) {
                    menuItems[optionType].children = {};
                  }

                  var _iteratorNormalCompletion2 = true;
                  var _didIteratorError2 = false;
                  var _iteratorError2 = undefined;

                  try {
                    var _loop2 = function () {
                      function _loop2() {
                        var generatedOption = _step2.value;

                        var optionSelectorSettings = {
                          name: generatedOption.name,
                          value: generatedOption.value,
                          handler: function () {
                            function handler() {
                              track.options[optionType] = generatedOption.value;
                              _this4.props.onTrackOptionsChanged(track.uid, track.options);
                              _this4.props.closeMenu();
                            }

                            return handler;
                          }()
                        };

                        menuItems[optionType].children[generatedOption.value] = optionSelectorSettings;
                      }

                      return _loop2;
                    }();

                    for (var _iterator2 = generatedOptions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                      _loop2();
                    }
                  } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                        _iterator2['return']();
                      }
                    } finally {
                      if (_didIteratorError2) {
                        throw _iteratorError2;
                      }
                    }
                  }
                }

                if (_configs.OPTIONS_INFO[optionType].inlineOptions) {
                  var _loop3 = function () {
                    function _loop3(inlineOptionKey) {
                      var inlineOption = _configs.OPTIONS_INFO[optionType].inlineOptions[inlineOptionKey];

                      // check if there's already available options (e.g.
                      // "Top right") for this option type (e.g. "Label
                      // position")
                      if (!menuItems[optionType].children) {
                        menuItems[optionType].children = {};
                      }

                      var optionSelectorSettings = {
                        name: inlineOption.name,
                        value: inlineOption.value
                        // missing handler to be filled in below
                      };

                      // is there a custom component available for picking this
                      // option type value (e.g. 'custom' color scale)
                      if (inlineOption.componentPickers && inlineOption.componentPickers[track.type]) {
                        optionSelectorSettings.handler = function () {
                          _this4.props.onConfigureTrack(track, inlineOption.componentPickers[track.type]);
                          _this4.props.closeMenu();
                        };
                      } else {
                        // the menu option defines a potential value for this option
                        // type (e.g. "top right")
                        optionSelectorSettings.handler = function () {
                          track.options[optionType] = inlineOption.value;
                          _this4.props.onTrackOptionsChanged(track.uid, track.options);
                          _this4.props.closeMenu();
                        };
                      }

                      menuItems[optionType].children[inlineOptionKey] = optionSelectorSettings;
                    }

                    return _loop3;
                  }();

                  // we can simply select this option from the menu
                  for (var inlineOptionKey in _configs.OPTIONS_INFO[optionType].inlineOptions) {
                    _loop3(inlineOptionKey);
                  }
                } else if (_configs.OPTIONS_INFO[optionType].componentPickers && _configs.OPTIONS_INFO[optionType].componentPickers[track.type]) {
                  // there's an option picker registered
                  menuItems[optionType].handler = function () {
                    _this4.props.onConfigureTrack(track, _configs.OPTIONS_INFO[optionType].componentPickers[track.type]);
                    _this4.props.closeMenu();
                  };
                }
              }
            }

            return _loop;
          }();

          for (var _iterator = _configs.TRACKS_INFO_BY_TYPE[track.type].availableOptions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            _loop();
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return _react2['default'].createElement(_NestedContextMenu2['default'], {
          key: 'config-series-menu',
          closeMenu: this.props.closeMenu,
          menuItems: menuItems,
          orientation: this.state.orientation,
          parentBbox: bbox,
          position: position
        });
      }

      return getConfigureSeriesMenu;
    }()
  }, {
    key: 'getTrackTypeItems',
    value: function () {
      function getTrackTypeItems(position, bbox, track) {
        var _this5 = this;

        /**
         * Return a list of track types that can be used
         * with the data for this track
         *
         * Parameters
         * ----------
         *
         * position: {left: 42, top: 88}
         *  The position where to draw ths menu.
         *
         * bbox: { }
         *  The bounding box of the parent menu, used to determine whether
         *  to draw the child menu on the left or the right
         *
         *  track: {}
         *    The track definition for this series (as in the viewconf)
         */

        // get the datatype of the current track
        var datatype = _configs.TRACKS_INFO_BY_TYPE[track.type].datatype[0];
        var orientation = _configs.TRACKS_INFO_BY_TYPE[track.type].orientation;

        // see which other tracks can display a similar datatype
        var availableTrackTypes = _configs.TRACKS_INFO.filter(function (x) {
          return x.datatype;
        }).filter(function (x) {
          return x.orientation;
        }).filter(function (x) {
          return x.datatype[0] == datatype;
        }).filter(function (x) {
          return x.orientation == orientation;
        }).map(function (x) {
          return x.type;
        });

        var menuItems = {};

        var _loop4 = function () {
          function _loop4(i) {
            menuItems[availableTrackTypes[i]] = {
              value: availableTrackTypes[i],
              name: availableTrackTypes[i],
              handler: function () {
                function handler() {
                  _this5.props.onChangeTrackType(track.uid, availableTrackTypes[i]);
                }

                return handler;
              }()
            };
          }

          return _loop4;
        }();

        for (var i = 0; i < availableTrackTypes.length; i++) {
          _loop4(i);
        }

        return _react2['default'].createElement(_NestedContextMenu2['default'], {
          key: 'track-type-items',
          closeMenu: this.props.closeMenu,
          menuItems: menuItems,
          orientation: this.state.orientation,
          parentBbox: bbox,
          position: position
        });
      }

      return getTrackTypeItems;
    }()
  }, {
    key: 'getSubmenu',
    value: function () {
      function getSubmenu() {
        if (this.state.submenuShown) {
          // the bounding box of the element which initiated the subMenu
          // necessary so that we can position the submenu next to the initiating
          // element
          var bbox = this.state.submenuSourceBbox;
          var position = this.state.orientation === 'left' ? {
            left: this.state.left,
            top: bbox.top
          } : {
            left: this.state.left + bbox.width + 7,
            top: bbox.top
          };

          // When a submenu is requested, the onMouseEnter handler of the
          // item that requested it provides a structure containing the option
          // picked as well as some data associated with it
          // e.g. {"option": "configure-series", data: track}
          var subMenuData = this.state.submenuShown;
          var track = subMenuData.value;

          if (subMenuData.option == 'track-type') {
            return this.getTrackTypeItems(position, bbox, track);
          } else {
            return this.getConfigureSeriesMenu(position, bbox, track);
          }
        }
        return _react2['default'].createElement('div', null);
      }

      return getSubmenu;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this6 = this;

        var exportDataMenuItem = null;
        // console.log('series props:', this.props);

        /*
        if (TRACKS_INFO_BY_TYPE[this.props.hostTrack.type]) {
          exportDataMenuItem = (
            <ContextMenuItem
              onClick={() => this.props.onExportData(this.props.hostTrack.uid, this.props.track.uid)}
              onMouseEnter={e => this.handleOtherMouseEnter(e)}
              styleName="context-menu-item"
            >
              <span
                styleName="context-menu-span"
              >
                {'Export Data'}
              </span>
            </ContextMenuItem>
          );
        }
        */

        return _react2['default'].createElement(
          'div',
          {
            onMouseLeave: this.props.handleMouseLeave,
            ref: function () {
              function ref(c) {
                return _this6.div = c;
              }

              return ref;
            }(),
            style: {
              left: this.state.left,
              top: this.state.top
            },
            className: 'ContextMenu-module_context-menu-2OwvL'
          },
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: this.props.onConfigureTrack,
              onMouseEnter: function () {
                function onMouseEnter(e) {
                  return _this6.handleItemMouseEnter(e, {
                    option: 'configure-series',
                    value: _this6.props.track
                  });
                }

                return onMouseEnter;
              }(),
              onMouseLeave: function () {
                function onMouseLeave(e) {
                  return _this6.handleMouseLeave(e);
                }

                return onMouseLeave;
              }()
            },
            'Configure Series',
            _react2['default'].createElement(
              'svg',
              { className: 'ContextMenu-module_play-icon-R4pIO' },
              _react2['default'].createElement('use', { xlinkHref: '#play' })
            )
          ),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick() {}

                return onClick;
              }(),
              onMouseEnter: function () {
                function onMouseEnter(e) {
                  return _this6.handleItemMouseEnter(e, {
                    option: 'track-type',
                    value: _this6.props.track
                  });
                }

                return onMouseEnter;
              }(),
              onMouseLeave: function () {
                function onMouseLeave(e) {
                  return _this6.handleMouseLeave(e);
                }

                return onMouseLeave;
              }(),
              className: 'ContextMenu-module_context-menu-item-1HeVv'
            },
            _react2['default'].createElement(
              'span',
              { className: 'ContextMenu-module_context-menu-span-8EUfZ' },
              'Track Type',
              _react2['default'].createElement(
                'svg',
                { className: 'ContextMenu-module_play-icon-R4pIO' },
                _react2['default'].createElement('use', { xlinkHref: '#play' })
              )
            )
          ),
          exportDataMenuItem,
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: this.props.onCloseTrack,
              onMouseEnter: function () {
                function onMouseEnter(e) {
                  return _this6.handleOtherMouseEnter(e);
                }

                return onMouseEnter;
              }(),
              className: 'ContextMenu-module_context-menu-item-1HeVv'
            },
            _react2['default'].createElement(
              'span',
              { className: 'ContextMenu-module_context-menu-span-8EUfZ' },
              'Close Series'
            )
          ),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick() {
                  _this6.props.onCloseTrack(_this6.props.series.uid);
                  _this6.props.onAddSeries(_this6.props.hostTrack.uid);
                }

                return onClick;
              }(),
              onMouseEnter: function () {
                function onMouseEnter(e) {
                  return _this6.handleOtherMouseEnter(e);
                }

                return onMouseEnter;
              }(),
              className: 'ContextMenu-module_context-menu-item-1HeVv'
            },
            _react2['default'].createElement(
              'span',
              { className: 'ContextMenu-module_context-menu-span-8EUfZ' },
              'Replace Series'
            )
          ),
          this.getSubmenu()
        );
      }

      return render;
    }()
  }]);

  return SeriesListMenu;
}(_ContextMenuContainer4['default']);

/***/ }),
/* 686 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NestedContextMenu = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _ContextMenuContainer2 = __webpack_require__(62);

var _ContextMenuContainer3 = _interopRequireDefault(_ContextMenuContainer2);

var _ContextMenuItem = __webpack_require__(63);

var _ContextMenuItem2 = _interopRequireDefault(_ContextMenuItem);

__webpack_require__(44);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Styles


var NestedContextMenu = exports.NestedContextMenu = function (_ContextMenuContainer) {
  _inherits(NestedContextMenu, _ContextMenuContainer);

  function NestedContextMenu() {
    _classCallCheck(this, NestedContextMenu);

    return _possibleConstructorReturn(this, (NestedContextMenu.__proto__ || Object.getPrototypeOf(NestedContextMenu)).apply(this, arguments));
  }

  _createClass(NestedContextMenu, [{
    key: 'getSubmenu',
    value: function () {
      function getSubmenu() {
        if (this.state.submenuShown) {
          // the bounding box of the element which initiated the subMenu
          // necessary so that we can position the submenu next to the initiating
          // element
          var bbox = this.state.submenuSourceBbox;
          var position = this.state.orientation === 'left' ? {
            left: this.state.left,
            top: bbox.top
          } : {
            left: this.state.left + bbox.width + 7,
            top: bbox.top
          };

          var menuItem = this.state.submenuShown;

          return _react2['default'].createElement(NestedContextMenu, {
            menuItems: menuItem.children,
            orientation: this.state.orientation,
            parentBbox: bbox,
            position: position
          });
        }
        return _react2['default'].createElement('div', null);
      }

      return getSubmenu;
    }()
  }, {
    key: 'componentWillUnmount',
    value: function () {
      function componentWillUnmount() {}

      return componentWillUnmount;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        var menuItems = [];

        // iterate over the list

        var _loop = function () {
          function _loop(menuItemKey) {
            var menuItem = _this2.props.menuItems[menuItemKey];

            menuItems.push(_react2['default'].createElement(
              _ContextMenuItem2['default'],
              {
                key: menuItemKey,
                onClick: menuItem.handler ? menuItem.handler : function () {
                  return null;
                },
                onMouseEnter: menuItem.children ? function (e) {
                  return _this2.handleItemMouseEnter(e, menuItem);
                } : _this2.handleOtherMouseEnter.bind(_this2),
                onMouseLeave: _this2.handleMouseLeave
              },
              menuItem.name,
              menuItem.children && _react2['default'].createElement(
                'svg',
                {
                  className: 'ContextMenu-module_play-icon-R4pIO'
                },
                _react2['default'].createElement('use', { xlinkHref: '#play' })
              )
            ));
          }

          return _loop;
        }();

        for (var menuItemKey in this.props.menuItems) {
          _loop(menuItemKey);
        }

        return _react2['default'].createElement(
          'div',
          {
            ref: function () {
              function ref(c) {
                return _this2.div = c;
              }

              return ref;
            }(),
            style: {
              left: this.state.left,
              top: this.state.top
            },
            className: 'ContextMenu-module_context-menu-2OwvL'
          },
          menuItems,
          this.getSubmenu()
        );
      }

      return render;
    }()
  }]);

  return NestedContextMenu;
}(_ContextMenuContainer3['default']);

exports['default'] = NestedContextMenu;

/***/ }),
/* 687 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CloseTrackMenu = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _ContextMenuItem = __webpack_require__(63);

var _ContextMenuItem2 = _interopRequireDefault(_ContextMenuItem);

var _configs = __webpack_require__(6);

__webpack_require__(44);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Styles


var CloseTrackMenu = exports.CloseTrackMenu = function (_React$Component) {
  _inherits(CloseTrackMenu, _React$Component);

  /**
   * A window that is opened when a user clicks on the track configuration icon.
   */
  function CloseTrackMenu(props) {
    _classCallCheck(this, CloseTrackMenu);

    var _this = _possibleConstructorReturn(this, (CloseTrackMenu.__proto__ || Object.getPrototypeOf(CloseTrackMenu)).call(this, props));

    _this.seriesRefs = {};
    return _this;
  }

  _createClass(CloseTrackMenu, [{
    key: 'getSeriesItems',
    value: function () {
      function getSeriesItems() {
        var _this2 = this;

        // this code is duplicated in ConfigTrackMenu, needs to be consolidated

        // check if this is a combined track (has contents)
        if (!this.props.track) {
          return null;
        }

        var trackTypeToInfo = {};

        _configs.TRACKS_INFO.forEach(function (ti) {
          trackTypeToInfo[ti.type] = ti;
        });

        var series = this.props.track.contents ? this.props.track.contents : [this.props.track];

        return series.map(function (x) {
          var thumbnail = trackTypeToInfo[x.type].thumbnail;
          var imgTag = trackTypeToInfo[x.type].thumbnail ? _react2['default'].createElement('div', {
            dangerouslySetInnerHTML: { __html: thumbnail.outerHTML },
            className: 'ContextMenu-module_context-menu-thumbnail-inline-1iOcg'
          }) : _react2['default'].createElement(
            'div',
            { className: 'ContextMenu-module_context-menu-thumbnail-inline-1iOcg' },
            _react2['default'].createElement('svg', { width: 30, height: 20 })
          );

          return _react2['default'].createElement(
            'div',
            {
              key: x.uid,
              ref: function () {
                function ref(c) {
                  _this2.seriesRefs[x.uid] = c;
                }

                return ref;
              }(),
              onClick: function () {
                function onClick() {
                  return _this2.props.onCloseTrack(x.uid);
                }

                return onClick;
              }(),
              className: 'ContextMenu-module_context-menu-item-1HeVv'
            },
            imgTag,
            _react2['default'].createElement(
              'span',
              { className: 'ContextMenu-module_context-menu-span-8EUfZ' },
              x.name && x.name.length ? x.name : x.uid
            )
          );
        });
      }

      return getSeriesItems;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this3 = this;

        return _react2['default'].createElement(
          'div',
          null,
          this.getSeriesItems(),
          _react2['default'].createElement('hr', { className: 'ContextMenu-module_context-menu-hr-3yapb' }),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick() {
                  return _this3.props.onCloseTrack(_this3.props.track.uid);
                }

                return onClick;
              }()
            },
            'Close track'
          )
        );
      }

      return render;
    }()
  }]);

  return CloseTrackMenu;
}(_react2['default'].Component);

CloseTrackMenu.propTypes = {
  onCloseTrack: _propTypes2['default'].func.isRequired,
  track: _propTypes2['default'].object.isRequired
};

exports['default'] = CloseTrackMenu;

/***/ }),
/* 688 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HorizontalTiledPlot = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _getClassName2 = __webpack_require__(36);

var _getClassName3 = _interopRequireDefault(_getClassName2);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _d3Brush = __webpack_require__(25);

var _d3Selection = __webpack_require__(4);

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _ListWrapper = __webpack_require__(247);

var _ListWrapper2 = _interopRequireDefault(_ListWrapper);

var _HorizontalItem = __webpack_require__(689);

var _HorizontalItem2 = _interopRequireDefault(_HorizontalItem);

var _SortableList = __webpack_require__(249);

var _SortableList2 = _interopRequireDefault(_SortableList);

var _utils = __webpack_require__(3);

var _configs = __webpack_require__(6);

var _HorizontalTiledPlotModule = __webpack_require__(694);

var _HorizontalTiledPlotModule2 = _interopRequireDefault(_HorizontalTiledPlotModule);

var _TiledPlotModule = __webpack_require__(144);

var _TiledPlotModule2 = _interopRequireDefault(_TiledPlotModule);

var _TrackModule = __webpack_require__(139);

var _TrackModule2 = _interopRequireDefault(_TrackModule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _styleModuleImportMap = {
  'styles': {
    'horizontal-tiled-plot': 'HorizontalTiledPlot-module_horizontal-tiled-plot-3EK65'
  },
  'stylesPlot': {
    'tiled-plot': 'TiledPlot-module_tiled-plot-uFHiB',
    'horizontalList': 'TiledPlot-module_horizontalList-1c1P8',
    'list': 'TiledPlot-module_list-24zgV',
    'stylizedList': 'TiledPlot-module_stylizedList-Mt4JL',
    'stylizedItem': 'TiledPlot-module_stylizedItem-2bQBK',
    'stylizedHelper': 'TiledPlot-module_stylizedHelper-3IVEu',
    'horizontalItem': 'TiledPlot-module_horizontalItem-2-ZjU',
    'resizable-track': 'TiledPlot-module_resizable-track-2oLT9',
    'domain': 'TiledPlot-module_domain-qYw6K'
  },
  'stylesTrack': {
    'track-range-selection': 'Track-module_track-range-selection-1yrDf',
    'track-range-selection-active': 'Track-module_track-range-selection-active-1oljJ Track-module_track-range-selection-1yrDf',
    'track-range-selection-active-primary': 'Track-module_track-range-selection-active-primary-29M73 Track-module_track-range-selection-active-1oljJ Track-module_track-range-selection-1yrDf',
    'track-range-selection-active-secondary': 'Track-module_track-range-selection-active-secondary-1s0t5 Track-module_track-range-selection-active-1oljJ Track-module_track-range-selection-1yrDf',
    'track-range-selection-group-inactive': 'Track-module_track-range-selection-group-inactive-YNRM4'
  }
};

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Utils


// Configs


// Styles
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars


// eslint-disable-line no-unused-vars


var HorizontalTiledPlot = exports.HorizontalTiledPlot = function (_React$Component) {
  _inherits(HorizontalTiledPlot, _React$Component);

  function HorizontalTiledPlot(props) {
    _classCallCheck(this, HorizontalTiledPlot);

    var _this = _possibleConstructorReturn(this, (HorizontalTiledPlot.__proto__ || Object.getPrototypeOf(HorizontalTiledPlot)).call(this, props));

    _this.brushBehavior = (0, _d3Brush.brushX)(true).on('start', _this.brushStarted.bind(_this)).on('brush', _this.brushed.bind(_this)).on('end', _this.brushedEnded.bind(_this));
    return _this;
  }

  /* -------------------------- Life Cycle Methods -------------------------- */

  _createClass(HorizontalTiledPlot, [{
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {
        if (this.props.isRangeSelectionActive) {
          this.addBrush();
        }
      }

      return componentDidMount;
    }()
  }, {
    key: 'shouldComponentUpdate',
    value: function () {
      function shouldComponentUpdate(nextProps, nextState) {
        if (this.rangeSelectionTriggered) {
          this.rangeSelectionTriggered = false;
          return this.state !== nextState;
        } else if (this.props.rangeSelection !== nextProps.rangeSelection) {
          if (this.props.chromInfo) {
            this.moveBrush(nextProps.rangeSelection[0] ? (0, _utils.genomeLociToPixels)(nextProps.rangeSelection[0], this.props.chromInfo) : null);
          }
          return this.state !== nextState;
        }
        return true;
      }

      return shouldComponentUpdate;
    }()
  }, {
    key: 'componentDidUpdate',
    value: function () {
      function componentDidUpdate() {
        if (this.props.isRangeSelectionActive) {
          this.addBrush();
        } else {
          this.removeBrush();
        }
      }

      return componentDidUpdate;
    }()

    /* ---------------------------- Custom Methods ---------------------------- */

  }, {
    key: 'addBrush',
    value: function () {
      function addBrush() {
        if (!this.brushEl || this.brushElAddedBefore === this.brushEl) {
          return;
        }

        if (this.brushElAddedBefore) {
          // Remove event listener on old element to avoid memory leaks
          this.brushElAddedBefore.on('.brush', null);
        }

        this.brushEl.call(this.brushBehavior);
        this.brushElAddedBefore = this.brushEl;
      }

      return addBrush;
    }()
  }, {
    key: 'brushed',
    value: function () {
      function brushed() {
        // Need to reassign variable to check after reset
        var rangeSelectionMoved = this.rangeSelectionMoved;
        this.rangeSelectionMoved = false;

        if (!_d3Selection.event.sourceEvent || !this.props.onRangeSelection || rangeSelectionMoved) return;

        this.rangeSelectionTriggered = true;
        this.props.onRangeSelection(_d3Selection.event.selection);
      }

      return brushed;
    }()
  }, {
    key: 'brushStarted',
    value: function () {
      function brushStarted() {
        if (!_d3Selection.event.sourceEvent || !_d3Selection.event.selection) return;

        this.props.onRangeSelectionStart();
      }

      return brushStarted;
    }()
  }, {
    key: 'brushedEnded',
    value: function () {
      function brushedEnded() {
        if (!_d3Selection.event.selection && this.props.is1dRangeSelection) {
          this.rangeSelectionTriggered = true;
          this.props.onRangeSelectionEnd();
        }
      }

      return brushedEnded;
    }()
  }, {
    key: 'moveBrush',
    value: function () {
      function moveBrush(rangeSelection) {
        if (!this.brushEl) {
          return;
        }

        var relRange = rangeSelection ? [this.props.scale(rangeSelection[0]), this.props.scale(rangeSelection[1])] : null;

        this.rangeSelectionMoved = true;
        this.brushEl.call(this.brushBehavior.move, relRange);
      }

      return moveBrush;
    }()
  }, {
    key: 'removeBrush',
    value: function () {
      function removeBrush() {
        if (this.brushElAddedBefore) {
          // Reset brush selection
          this.brushElAddedBefore.call(this.brushBehavior.move, null);

          // Remove brush behavior
          this.brushElAddedBefore.on('.brush', null);
          this.brushElAddedBefore = undefined;

          this.props.onRangeSelectionEnd();
        }
      }

      return removeBrush;
    }()

    /* ------------------------------ Rendering ------------------------------- */

  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        var height = this.props.tracks.map(function (x) {
          return x.height;
        }).reduce(_utils.sum, 0);

        var isBrushable = this.props.tracks.map(function (track) {
          return (0, _configs.IS_TRACK_RANGE_SELECTABLE)(track);
        }).reduce(_utils.or, false);

        var rangeSelectorClass = this.props.isRangeSelectionActive ? 'stylesTrack.track-range-selection-active' : 'stylesTrack.track-range-selection';

        return _react2['default'].createElement(
          'div',
          { className: 'HorizontalTiledPlot-module_horizontal-tiled-plot-3EK65' },
          isBrushable && _react2['default'].createElement('svg', {
            ref: function () {
              function ref(el) {
                return _this2.brushEl = (0, _d3Selection.select)(el);
              }

              return ref;
            }(),
            style: {
              height: height,
              width: this.props.width
            },

            xmlns: 'http://www.w3.org/2000/svg',
            className: (0, _getClassName3['default'])(rangeSelectorClass, _styleModuleImportMap)
          }),
          _react2['default'].createElement(_ListWrapper2['default'], {
            className: _TiledPlotModule2['default'].list + ' ' + _TiledPlotModule2['default'].stylizedList,
            component: _SortableList2['default'],
            editable: this.props.editable,
            handleConfigTrack: this.props.handleConfigTrack,
            handleResizeTrack: this.props.handleResizeTrack,
            height: height,
            helperClass: _TiledPlotModule2['default'].stylizedHelper,
            itemClass: _TiledPlotModule2['default'].stylizedItem,
            itemReactClass: _HorizontalItem2['default'],
            items: this.props.tracks.map(function (d) {
              return {
                configMenuVisible: d.uid === _this2.props.configTrackMenuId,
                uid: d.uid || _slugid2['default'].nice(),
                width: _this2.props.width,
                height: d.height,
                value: d.value
              };
            }),
            onAddSeries: this.props.onAddSeries,
            onCloseTrack: this.props.onCloseTrack,
            onCloseTrackMenuOpened: this.props.onCloseTrackMenuOpened,
            onConfigTrackMenuOpened: this.props.onConfigTrackMenuOpened,
            onSortEnd: this.props.handleSortEnd,
            referenceAncestor: this.props.referenceAncestor,
            resizeHandles: this.props.resizeHandles,
            useDragHandle: true,
            width: this.props.width
          })
        );
      }

      return render;
    }()
  }]);

  return HorizontalTiledPlot;
}(_react2['default'].Component);

HorizontalTiledPlot.propTypes = {
  configTrackMenuId: _propTypes2['default'].string,
  chromInfo: _propTypes2['default'].object,
  editable: _propTypes2['default'].bool,
  handleConfigTrack: _propTypes2['default'].func,
  handleResizeTrack: _propTypes2['default'].func,
  handleSortEnd: _propTypes2['default'].func,
  is1dRangeSelection: _propTypes2['default'].bool,
  isRangeSelectionActive: _propTypes2['default'].bool,
  onAddSeries: _propTypes2['default'].func,
  onCloseTrack: _propTypes2['default'].func,
  onCloseTrackMenuOpened: _propTypes2['default'].func,
  onConfigTrackMenuOpened: _propTypes2['default'].func,
  onRangeSelection: _propTypes2['default'].func,
  onRangeSelectionEnd: _propTypes2['default'].func,
  onRangeSelectionStart: _propTypes2['default'].func,
  rangeSelection: _propTypes2['default'].array,
  referenceAncestor: _propTypes2['default'].func,
  resizeHandles: _propTypes2['default'].object,
  scale: _propTypes2['default'].func,
  tracks: _propTypes2['default'].array,
  width: _propTypes2['default'].number
};

exports['default'] = HorizontalTiledPlot;

/***/ }),
/* 689 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HorizontalItem = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactSortableHoc = __webpack_require__(47);

var _HorizontalTrack = __webpack_require__(690);

var _HorizontalTrack2 = _interopRequireDefault(_HorizontalTrack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var HorizontalItem = exports.HorizontalItem = (0, _reactSortableHoc.SortableElement)(function (props) {
  return _react2['default'].createElement(_HorizontalTrack2['default'], {
    className: props.className,
    editable: props.editable,
    handleConfigTrack: props.handleConfigTrack,
    handleResizeTrack: props.handleResizeTrack,
    height: props.height,
    item: props.item,
    onAddSeries: props.onAddSeries,
    onCloseTrack: props.onCloseTrack,
    onCloseTrackMenuOpened: props.onCloseTrackMenuOpened,
    onConfigTrackMenuOpened: props.onConfigTrackMenuOpened,
    resizeHandles: props.resizeHandles,
    uid: props.uid,
    width: props.width
  });
});

exports['default'] = HorizontalItem;

/***/ }),
/* 690 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HorizontalTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _MoveableTrack2 = __webpack_require__(248);

var _MoveableTrack3 = _interopRequireDefault(_MoveableTrack2);

var _TrackControl = __webpack_require__(122);

var _TrackControl2 = _interopRequireDefault(_TrackControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var STYLES = {
  pointerEvents: 'all'
};

var HorizontalTrack = exports.HorizontalTrack = function (_MoveableTrack) {
  _inherits(HorizontalTrack, _MoveableTrack);

  function HorizontalTrack() {
    _classCallCheck(this, HorizontalTrack);

    return _possibleConstructorReturn(this, (HorizontalTrack.__proto__ || Object.getPrototypeOf(HorizontalTrack)).apply(this, arguments));
  }

  _createClass(HorizontalTrack, [{
    key: 'getControls',
    value: function () {
      function getControls(isVisible) {
        return _react2['default'].createElement(_TrackControl2['default'], {
          configMenuVisible: this.props.item.configMenuVisible,
          imgStyleAdd: STYLES,
          imgStyleClose: STYLES,
          imgStyleMove: STYLES,
          imgStyleSettings: STYLES,
          isMoveable: this.moveable,
          isVisible: isVisible,
          onAddSeries: this.props.onAddSeries,
          onCloseTrackMenuOpened: this.props.onCloseTrackMenuOpened,
          onConfigTrackMenuOpened: this.props.onConfigTrackMenuOpened,
          uid: this.props.uid
        });
      }

      return getControls;
    }()
  }]);

  return HorizontalTrack;
}(_MoveableTrack3['default']);

exports['default'] = HorizontalTrack;

/***/ }),
/* 691 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DraggableDiv = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _d3Drag = __webpack_require__(120);

var _d3Selection = __webpack_require__(4);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

__webpack_require__(692);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DraggableDiv = exports.DraggableDiv = function (_React$Component) {
  _inherits(DraggableDiv, _React$Component);

  function DraggableDiv(props) {
    _classCallCheck(this, DraggableDiv);

    var _this = _possibleConstructorReturn(this, (DraggableDiv.__proto__ || Object.getPrototypeOf(DraggableDiv)).call(this, props));

    _this.dragTopRight = (0, _d3Drag.drag)().on('start', _this.dragStart.bind(_this)).on('drag', _this.dragTopRightFunc.bind(_this));
    _this.dragTopLeft = (0, _d3Drag.drag)().on('start', _this.dragStart.bind(_this)).on('drag', _this.dragTopLeftFunc.bind(_this));
    _this.dragBottomRight = (0, _d3Drag.drag)().on('start', _this.dragStart.bind(_this)).on('drag', _this.dragBottomRightFunc.bind(_this));
    _this.dragBottomLeft = (0, _d3Drag.drag)().on('start', _this.dragStart.bind(_this)).on('drag', _this.dragBottomLeftFunc.bind(_this));

    _this.dragBottom = (0, _d3Drag.drag)().on('start', _this.dragStart.bind(_this)).on('drag', _this.dragBottomFunc.bind(_this));
    _this.dragTop = (0, _d3Drag.drag)().on('start', _this.dragStart.bind(_this)).on('drag', _this.dragTopFunc.bind(_this));
    _this.dragLeft = (0, _d3Drag.drag)().on('start', _this.dragStart.bind(_this)).on('drag', _this.dragLeftFunc.bind(_this));
    _this.dragRight = (0, _d3Drag.drag)().on('start', _this.dragStart.bind(_this)).on('drag', _this.dragRightFunc.bind(_this));

    _this.minWidth = 10;
    _this.minHeight = 10;
    _this.bottomHandleWidth = 20;

    _this.state = {
      uid: _this.props.uid,
      width: _this.props.width,
      height: _this.props.height,
      top: _this.props.top,
      left: _this.props.left
    };

    _this.domBody = (0, _d3Selection.select)('body').node();
    return _this;
  }

  /* -------------------------- Life Cycle Methods -------------------------- */

  _createClass(DraggableDiv, [{
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {
        (0, _d3Selection.select)(this.bottomHandle).call(this.dragBottom);
        (0, _d3Selection.select)(this.topHandle).call(this.dragTop);

        (0, _d3Selection.select)(this.leftHandle).call(this.dragLeft);
        (0, _d3Selection.select)(this.rightHandle).call(this.dragRight);
      }

      return componentDidMount;
    }()
  }, {
    key: 'componentWillReceiveProps',
    value: function () {
      function componentWillReceiveProps(newProps) {
        if ('width' in newProps) {
          this.setState({ width: newProps.width });
        }

        if ('height' in newProps) {
          this.setState({ height: newProps.height });
        }
      }

      return componentWillReceiveProps;
    }()

    /* ---------------------------- Custom Methods ---------------------------- */

  }, {
    key: 'dragBottomFunc',
    value: function () {
      function dragBottomFunc() {
        var ms = (0, _d3Selection.mouse)(this.domBody);

        var newHeight = this.dragStartHeight + (ms[1] - this.dragStartMousePos[1]);
        newHeight = newHeight > this.minHeight ? newHeight : this.minHeight;

        var newState = {
          'height': newHeight };
        this.setState(newState);

        _d3Selection.event.sourceEvent.stopPropagation();
        this.sizeChanged();
      }

      return dragBottomFunc;
    }()
  }, {
    key: 'dragLeftFunc',
    value: function () {
      function dragLeftFunc() {
        var ms = (0, _d3Selection.mouse)(this.domBody);

        var newWidth = this.dragStartWidth - (ms[0] - this.dragStartMousePos[0]);
        newWidth = newWidth > this.minWidth ? newWidth : this.minWidth;

        var newLeft = this.dragStartLeft + ms[0] - this.dragStartMousePos[0];
        newLeft = newWidth > this.minWidth ? newLeft : this.dragStartLeft + this.dragStartWidth - this.minWidth;

        var newState = {
          'left': newLeft,
          'width': newWidth
        };
        this.setState(newState);

        _d3Selection.event.sourceEvent.stopPropagation();
        this.sizeChanged();
      }

      return dragLeftFunc;
    }()
  }, {
    key: 'dragTopFunc',
    value: function () {
      function dragTopFunc() {
        var ms = (0, _d3Selection.mouse)(this.domBody);
        //console.log('ms:', ms);

        var newHeight = this.dragStartHeight - (ms[1] - this.dragStartMousePos[1]);
        newHeight = newHeight > this.minHeight ? newHeight : this.minHeight;

        var newTop = this.dragStartTop + ms[1] - this.dragStartMousePos[1];
        newTop = newHeight > this.minHeight ? newTop : this.dragStartTop + this.dragStartHeight - this.minHeight;

        var newState = { 'top': newTop,
          'height': newHeight };

        this.setState(newState);

        _d3Selection.event.sourceEvent.stopPropagation();
        this.sizeChanged();
      }

      return dragTopFunc;
    }()
  }, {
    key: 'dragRightFunc',
    value: function () {
      function dragRightFunc() {
        var ms = (0, _d3Selection.mouse)(this.domBody);

        var newWidth = this.dragStartWidth + (ms[0] - this.dragStartMousePos[0]);
        newWidth = newWidth > this.minWidth ? newWidth : this.minWidth;

        var newState = {
          'width': newWidth
        };

        this.setState(newState);

        _d3Selection.event.sourceEvent.stopPropagation();
        this.sizeChanged();
      }

      return dragRightFunc;
    }()
  }, {
    key: 'dragBottomLeftFunc',
    value: function () {
      function dragBottomLeftFunc() {
        var ms = (0, _d3Selection.mouse)(this.domBody);

        var newHeight = this.dragStartHeight + (ms[1] - this.dragStartMousePos[1]);
        newHeight = newHeight > this.minHeight ? newHeight : this.minHeight;

        var newWidth = this.dragStartWidth - (ms[0] - this.dragStartMousePos[0]);
        newWidth = newWidth > this.minWidth ? newWidth : this.minWidth;

        var newLeft = this.dragStartLeft + ms[0] - this.dragStartMousePos[0];
        newLeft = newWidth > this.minWidth ? newLeft : this.dragStartLeft + this.dragStartWidth - this.minWidth;

        var newState = { 'top': this.state.top,
          'left': newLeft,
          'width': newWidth,
          'height': newHeight };
        this.setState(newState);

        _d3Selection.event.sourceEvent.stopPropagation();
        this.sizeChanged();
      }

      return dragBottomLeftFunc;
    }()
  }, {
    key: 'dragBottomRightFunc',
    value: function () {
      function dragBottomRightFunc() {
        var ms = (0, _d3Selection.mouse)(this.domBody);

        var newWidth = this.dragStartWidth + (ms[0] - this.dragStartMousePos[0]);
        newWidth = newWidth > this.minWidth ? newWidth : this.minWidth;

        var newHeight = this.dragStartHeight + (ms[1] - this.dragStartMousePos[1]);
        newHeight = newHeight > this.minHeight ? newHeight : this.minHeight;

        var newState = { 'top': this.state.top,
          'left': this.state.left,
          'width': newWidth,
          'height': newHeight };
        this.setState(newState);

        _d3Selection.event.sourceEvent.stopPropagation();
        this.sizeChanged();
      }

      return dragBottomRightFunc;
    }()
  }, {
    key: 'dragTopRightFunc',
    value: function () {
      function dragTopRightFunc() {
        var ms = (0, _d3Selection.mouse)(this.domBody);
        //console.log('ms:', ms);

        var newHeight = this.dragStartHeight - (ms[1] - this.dragStartMousePos[1]);
        newHeight = newHeight > this.minHeight ? newHeight : this.minHeight;

        var newTop = this.dragStartTop + ms[1] - this.dragStartMousePos[1];
        newTop = newHeight > this.minHeight ? newTop : this.dragStartTop + this.dragStartHeight - this.minHeight;

        var newWidth = this.dragStartWidth + (ms[0] - this.dragStartMousePos[0]);
        newWidth = newWidth > this.minWidth ? newWidth : this.minWidth;

        var newState = { 'top': newTop,
          'left': this.state.left,
          'width': newWidth,
          'height': newHeight };

        this.setState(newState);
        //console.log('newHeight:', newHeight);

        _d3Selection.event.sourceEvent.stopPropagation();
        this.sizeChanged();
      }

      return dragTopRightFunc;
    }()
  }, {
    key: 'dragTopLeftFunc',
    value: function () {
      function dragTopLeftFunc() {
        var ms = (0, _d3Selection.mouse)(this.domBody);

        var newWidth = this.dragStartWidth - (ms[0] - this.dragStartMousePos[0]);
        newWidth = newWidth > this.minWidth ? newWidth : this.minWidth;

        var newLeft = this.dragStartLeft + ms[0] - this.dragStartMousePos[0];
        newLeft = newWidth > this.minWidth ? newLeft : this.dragStartLeft + this.dragStartWidth - this.minWidth;

        var newHeight = this.dragStartHeight - (ms[1] - this.dragStartMousePos[1]);
        newHeight = newHeight > this.minHeight ? newHeight : this.minHeight;

        var newTop = this.dragStartTop + ms[1] - this.dragStartMousePos[1];
        newTop = newHeight > this.minHeight ? newTop : this.dragStartTop + this.dragStartHeight - this.minHeight;

        var newState = { 'top': newTop,
          'left': newLeft,
          'width': newWidth,
          'height': newHeight };

        this.setState(newState);

        _d3Selection.event.sourceEvent.stopPropagation();

        this.sizeChanged();
      }

      return dragTopLeftFunc;
    }()
  }, {
    key: 'dragStart',
    value: function () {
      function dragStart() {
        this.dragStartMousePos = (0, _d3Selection.mouse)(this.domBody);

        this.dragStartWidth = this.state.width;
        this.dragStartHeight = this.state.height;

        this.dragStartTop = this.state.top;
        this.dragStartLeft = this.state.left;

        _d3Selection.event.sourceEvent.stopPropagation();
      }

      return dragStart;
    }()
  }, {
    key: 'sizeChanged',
    value: function () {
      function sizeChanged() {
        if ('sizeChanged' in this.props) {
          this.props.sizeChanged(this.state);
        }
      }

      return sizeChanged;
    }()
  }, {
    key: 'rotateClicked',
    value: function () {
      function rotateClicked() {
        this.props.trackRotated(this.state.uid);
      }

      return rotateClicked;
    }()
  }, {
    key: 'closeClicked',
    value: function () {
      function closeClicked() {
        this.props.trackClosed(this.state.uid);
      }

      return closeClicked;
    }()

    /* ------------------------------ Rendering ------------------------------- */

  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        var divStyle = {
          top: this.state.top,
          left: this.state.left,
          width: this.state.width,
          height: this.state.height,
          backgroundColor: 'transparent',
          boxSizing: "border-box",
          opacity: this.props.opacity
        };

        var resizeWidth = 10;
        var resizeHeight = 10;

        var bottomStyle = {
          position: 'absolute',
          left: this.state.width / 2 - resizeWidth / 2,
          bottom: 1,
          width: resizeWidth,
          opacity: 0.2,
          height: 4,
          borderBottom: '1px solid black',
          borderTop: '1px solid black',
          cursor: 'row-resize'
        };
        var topStyle = {
          position: 'absolute',
          left: this.state.width / 2 - resizeWidth / 2,
          top: 1,
          width: resizeWidth,
          opacity: 0.2,
          height: 4,
          borderBottom: '1px solid black',
          borderTop: '1px solid black',
          cursor: 'row-resize'
        };
        var leftStyle = {
          position: 'absolute',
          left: 1,
          top: this.state.height / 2 - resizeHeight / 2,
          opacity: 0.2,
          width: 4,
          height: resizeHeight,
          borderLeft: '1px solid black',
          borderRight: '1px solid black',
          cursor: 'col-resize'
        };
        var rightStyle = {
          position: 'absolute',
          right: 1,
          opacity: 0.2,
          top: this.state.height / 2 - resizeHeight / 2,
          width: 4,
          height: resizeHeight,
          borderLeft: '1px solid black',
          borderRight: '1px solid black',
          cursor: 'col-resize'
        };

        var resizeHandleDivs = {
          'bottom': _react2['default'].createElement('div', {
            className: 'bottom-draggable-handle',
            key: 'bottom',
            ref: function () {
              function ref(c) {
                return _this2.bottomHandle = c;
              }

              return ref;
            }(),
            style: bottomStyle
          }),
          'top': _react2['default'].createElement('div', {
            className: 'top-draggable-handle',
            key: 'top',
            ref: function () {
              function ref(c) {
                return _this2.topHandle = c;
              }

              return ref;
            }(),
            style: topStyle
          }),
          'right': _react2['default'].createElement('div', {
            className: 'right-draggable-handle',
            key: 'right',
            ref: function () {
              function ref(c) {
                return _this2.rightHandle = c;
              }

              return ref;
            }(),
            style: rightStyle
          }),
          'left': _react2['default'].createElement('div', {
            className: 'left-draggable-handle',
            key: 'left',
            ref: function () {
              function ref(c) {
                return _this2.leftHandle = c;
              }

              return ref;
            }(),
            style: leftStyle
          })
        };
        var resizeHandles = [].concat(_toConsumableArray(this.props.resizeHandles)).map(function (x) {
          return resizeHandleDivs[x];
        });

        return _react2['default'].createElement(
          'div',
          {
            className: this.props.className,
            ref: function () {
              function ref(c) {
                return _this2.divContainer = c;
              }

              return ref;
            }(),
            style: divStyle
          },
          resizeHandles
        );
      }

      return render;
    }()
  }]);

  return DraggableDiv;
}(_react2['default'].Component);

DraggableDiv.propTypes = {
  className: _propTypes2['default'].string,
  height: _propTypes2['default'].number,
  left: _propTypes2['default'].number,
  opacity: _propTypes2['default'].number,
  resizeHandles: _propTypes2['default'].object,
  sizeChanged: _propTypes2['default'].func,
  top: _propTypes2['default'].number,
  trackClosed: _propTypes2['default'].func,
  trackRotated: _propTypes2['default'].func,
  uid: _propTypes2['default'].string,
  width: _propTypes2['default'].number
};

exports['default'] = DraggableDiv;

/***/ }),
/* 692 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 693 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TrackArea = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(8);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactSortableHoc = __webpack_require__(47);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TrackArea = exports.TrackArea = function (_React$Component) {
  _inherits(TrackArea, _React$Component);

  function TrackArea(props) {
    _classCallCheck(this, TrackArea);

    var _this = _possibleConstructorReturn(this, (TrackArea.__proto__ || Object.getPrototypeOf(TrackArea)).call(this, props));

    _this.state = {
      controlsVisible: false
    };
    return _this;
  }

  _createClass(TrackArea, [{
    key: 'shouldComponentUpdate',
    value: function () {
      function shouldComponentUpdate() {
        return !this.resizing;
      }

      return shouldComponentUpdate;
    }()
  }, {
    key: 'handleMouseEnter',
    value: function () {
      function handleMouseEnter() {
        this.setState({
          controlsVisible: true
        });
      }

      return handleMouseEnter;
    }()
  }, {
    key: 'handleMouseLeave',
    value: function () {
      function handleMouseLeave() {
        this.setState({
          controlsVisible: false
        });
      }

      return handleMouseLeave;
    }()
  }, {
    key: 'handleMouseMove',
    value: function () {
      function handleMouseMove() {
        this.setState({
          controlsVisible: true
        });
      }

      return handleMouseMove;
    }()
  }, {
    key: 'getControls',
    value: function () {
      function getControls() {
        var _this2 = this;

        var Handle = null;

        if (this.moveable) {
          Handle = (0, _reactSortableHoc.SortableHandle)(function () {
            return _react2['default'].createElement(
              'svg',
              {
                className: 'no-zoom',
                height: '10px',
                onClick: function () {
                  function onClick() {}

                  return onClick;
                }(),
                style: _this2.getMoveImgStyle(),
                width: '10px'
              },
              _react2['default'].createElement('use', { xlinkHref: '#move' })
            );
          });
        } else {
          Handle = (0, _reactSortableHoc.SortableHandle)(function () {
            return _react2['default'].createElement('div', null);
          });
        }

        return _react2['default'].createElement(
          'div',
          {
            style: {
              position: 'absolute',
              backgroundColor: 'rgba(255,255,255,0.7)',
              right: '3px',
              top: '3px',
              pointerEvents: 'none',
              paddingLeft: '5px',
              paddingRight: '5px',
              borderRadius: '5px',
              border: '1px solid #dddddd'
            }
          },
          _react2['default'].createElement(Handle, null),
          _react2['default'].createElement(
            'svg',
            {
              className: 'no-zoom',
              height: '10px',
              onClick: function () {
                function onClick() {
                  var imgDom = _reactDom2['default'].findDOMNode(_this2.imgConfig);
                  var bbox = imgDom.getBoundingClientRect();
                  _this2.props.onConfigTrackMenuOpened(_this2.props.uid, bbox);
                }

                return onClick;
              }(),
              ref: function () {
                function ref(c) {
                  _this2.imgConfig = c;
                }

                return ref;
              }(),
              style: this.getSettingsImgStyle(),
              width: '10px'
            },
            _react2['default'].createElement('use', { xlinkHref: '#cog' })
          ),
          _react2['default'].createElement(
            'svg',
            {
              className: 'no-zoom',
              height: '10px',
              onClick: function () {
                function onClick() {
                  return _this2.props.onAddSeries(_this2.props.uid);
                }

                return onClick;
              }(),
              ref: function () {
                function ref(c) {
                  _this2.imgAdd = c;
                }

                return ref;
              }(),
              style: this.getAddImgStyle(),
              width: '10px'
            },
            _react2['default'].createElement('use', { xlinkHref: '#plus' })
          ),
          _react2['default'].createElement(
            'svg',
            {
              className: 'no-zoom',
              height: '10px',
              onClick: function () {
                function onClick() {
                  var imgDom = _reactDom2['default'].findDOMNode(_this2.imgClose);
                  var bbox = imgDom.getBoundingClientRect();
                  _this2.props.onCloseTrackMenuOpened(_this2.props.uid, bbox);
                }

                return onClick;
              }(),
              ref: function () {
                function ref(c) {
                  _this2.imgClose = c;
                }

                return ref;
              }(),
              style: this.getCloseImgStyle(),
              width: '10px'
            },
            _react2['default'].createElement('use', { xlinkHref: '#cross' })
          )
        );
      }

      return getControls;
    }()
  }]);

  return TrackArea;
}(_react2['default'].Component);

TrackArea.propTypes = {
  configMenuOpen: _propTypes2['default'].bool,
  onConfigTrackMenuOpened: _propTypes2['default'].func,
  onCloseTrackMenuOpened: _propTypes2['default'].func,
  onAddSeries: _propTypes2['default'].func,
  uid: _propTypes2['default'].string
};

exports['default'] = TrackArea;

/***/ }),
/* 694 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"horizontal-tiled-plot":"HorizontalTiledPlot-module_horizontal-tiled-plot-3EK65"};

/***/ }),
/* 695 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerticalTiledPlot = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _getClassName2 = __webpack_require__(36);

var _getClassName3 = _interopRequireDefault(_getClassName2);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _d3Brush = __webpack_require__(25);

var _d3Selection = __webpack_require__(4);

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _ListWrapper = __webpack_require__(247);

var _ListWrapper2 = _interopRequireDefault(_ListWrapper);

var _VerticalItem = __webpack_require__(696);

var _VerticalItem2 = _interopRequireDefault(_VerticalItem);

var _SortableList = __webpack_require__(249);

var _SortableList2 = _interopRequireDefault(_SortableList);

var _utils = __webpack_require__(3);

var _configs = __webpack_require__(6);

var _VerticalTiledPlotModule = __webpack_require__(698);

var _VerticalTiledPlotModule2 = _interopRequireDefault(_VerticalTiledPlotModule);

var _TiledPlotModule = __webpack_require__(144);

var _TiledPlotModule2 = _interopRequireDefault(_TiledPlotModule);

var _TrackModule = __webpack_require__(139);

var _TrackModule2 = _interopRequireDefault(_TrackModule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _styleModuleImportMap = {
  'styles': {
    'vertical-tiled-plot': 'VerticalTiledPlot-module_vertical-tiled-plot-R3sb7'
  },
  'stylesPlot': {
    'tiled-plot': 'TiledPlot-module_tiled-plot-uFHiB',
    'horizontalList': 'TiledPlot-module_horizontalList-1c1P8',
    'list': 'TiledPlot-module_list-24zgV',
    'stylizedList': 'TiledPlot-module_stylizedList-Mt4JL',
    'stylizedItem': 'TiledPlot-module_stylizedItem-2bQBK',
    'stylizedHelper': 'TiledPlot-module_stylizedHelper-3IVEu',
    'horizontalItem': 'TiledPlot-module_horizontalItem-2-ZjU',
    'resizable-track': 'TiledPlot-module_resizable-track-2oLT9',
    'domain': 'TiledPlot-module_domain-qYw6K'
  },
  'stylesTrack': {
    'track-range-selection': 'Track-module_track-range-selection-1yrDf',
    'track-range-selection-active': 'Track-module_track-range-selection-active-1oljJ Track-module_track-range-selection-1yrDf',
    'track-range-selection-active-primary': 'Track-module_track-range-selection-active-primary-29M73 Track-module_track-range-selection-active-1oljJ Track-module_track-range-selection-1yrDf',
    'track-range-selection-active-secondary': 'Track-module_track-range-selection-active-secondary-1s0t5 Track-module_track-range-selection-active-1oljJ Track-module_track-range-selection-1yrDf',
    'track-range-selection-group-inactive': 'Track-module_track-range-selection-group-inactive-YNRM4'
  }
};

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Utils


// Configs


// Styles
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars


// eslint-disable-line no-unused-vars


var VerticalTiledPlot = exports.VerticalTiledPlot = function (_React$Component) {
  _inherits(VerticalTiledPlot, _React$Component);

  function VerticalTiledPlot(props) {
    _classCallCheck(this, VerticalTiledPlot);

    var _this = _possibleConstructorReturn(this, (VerticalTiledPlot.__proto__ || Object.getPrototypeOf(VerticalTiledPlot)).call(this, props));

    _this.brushBehavior = (0, _d3Brush.brushY)(true).on('start', _this.brushStarted.bind(_this)).on('brush', _this.brushed.bind(_this)).on('end', _this.brushedEnded.bind(_this));
    return _this;
  }

  /* -------------------------- Life Cycle Methods -------------------------- */

  _createClass(VerticalTiledPlot, [{
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {
        if (this.props.isRangeSelectionActive) {
          this.addBrush();
        }
      }

      return componentDidMount;
    }()
  }, {
    key: 'shouldComponentUpdate',
    value: function () {
      function shouldComponentUpdate(nextProps, nextState) {
        if (this.rangeSelectionTriggered) {
          this.rangeSelectionTriggered = false;
          return this.state !== nextState;
        } else if (this.props.rangeSelection !== nextProps.rangeSelection) {
          var accessor = this.props.is1dRangeSelection ? 0 : 1;

          if (this.props.chromInfo) {
            this.moveBrush(nextProps.rangeSelection[accessor] ? (0, _utils.genomeLociToPixels)(nextProps.rangeSelection[accessor], this.props.chromInfo) : null);
          }
          return this.state !== nextState;
        }
        return true;
      }

      return shouldComponentUpdate;
    }()
  }, {
    key: 'componentDidUpdate',
    value: function () {
      function componentDidUpdate() {
        if (this.props.isRangeSelectionActive) {
          this.addBrush();
        } else {
          this.removeBrush();
        }
      }

      return componentDidUpdate;
    }()

    /* ---------------------------- Custom Methods ---------------------------- */

  }, {
    key: 'addBrush',
    value: function () {
      function addBrush() {
        if (!this.brushEl || this.brushElAddedBefore === this.brushEl) {
          return;
        }

        if (this.brushElAddedBefore) {
          // Remove event listener on old element to avoid memory leaks
          this.brushElAddedBefore.on('.brush', null);
        }

        this.brushEl.call(this.brushBehavior);
        this.brushElAddedBefore = this.brushEl;
      }

      return addBrush;
    }()
  }, {
    key: 'brushed',
    value: function () {
      function brushed() {
        // Need to reassign variable to check after reset
        var rangeSelectionMoved = this.rangeSelectionMoved;
        this.rangeSelectionMoved = false;

        if (!_d3Selection.event.sourceEvent || !this.props.onRangeSelection || rangeSelectionMoved) return;

        this.rangeSelectionTriggered = true;
        this.props.onRangeSelection(_d3Selection.event.selection);
      }

      return brushed;
    }()
  }, {
    key: 'brushStarted',
    value: function () {
      function brushStarted() {
        if (!_d3Selection.event.sourceEvent || !_d3Selection.event.selection) return;

        this.props.onRangeSelectionStart();
      }

      return brushStarted;
    }()
  }, {
    key: 'brushedEnded',
    value: function () {
      function brushedEnded() {
        if (!_d3Selection.event.selection && this.props.is1dRangeSelection) {
          this.rangeSelectionTriggered = true;
          this.props.onRangeSelectionEnd();
        }
      }

      return brushedEnded;
    }()
  }, {
    key: 'moveBrush',
    value: function () {
      function moveBrush(rangeSelection) {
        if (!this.brushEl) {
          return;
        }

        var relRange = rangeSelection ? [this.props.scale(rangeSelection[0]), this.props.scale(rangeSelection[1])] : null;

        this.rangeSelectionMoved = true;
        this.brushEl.call(this.brushBehavior.move, relRange);
      }

      return moveBrush;
    }()
  }, {
    key: 'removeBrush',
    value: function () {
      function removeBrush() {
        if (this.brushElAddedBefore) {
          // Reset brush selection
          this.brushElAddedBefore.call(this.brushBehavior.move, null);

          // Remove brush behavior
          this.brushElAddedBefore.on('.brush', null);
          this.brushElAddedBefore = undefined;

          this.props.onRangeSelectionEnd();
        }
      }

      return removeBrush;
    }()

    /* ------------------------------ Rendering ------------------------------- */

  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        var width = this.props.tracks.map(function (x) {
          return x.width;
        }).reduce(_utils.sum, 0);

        var isBrushable = this.props.tracks.map(function (track) {
          return (0, _configs.IS_TRACK_RANGE_SELECTABLE)(track);
        }).reduce(_utils.or, false);

        var rangeSelectorClass = this.props.isRangeSelectionActive ? 'stylesTrack.track-range-selection-active' : 'stylesTrack.track-range-selection';

        return _react2['default'].createElement(
          'div',
          { className: 'VerticalTiledPlot-module_vertical-tiled-plot-R3sb7' },
          isBrushable && _react2['default'].createElement('svg', {
            ref: function () {
              function ref(el) {
                return _this2.brushEl = (0, _d3Selection.select)(el);
              }

              return ref;
            }(),
            style: {
              height: this.props.height,
              width: width
            },

            xmlns: 'http://www.w3.org/2000/svg',
            className: (0, _getClassName3['default'])(rangeSelectorClass, _styleModuleImportMap)
          }),
          _react2['default'].createElement(_ListWrapper2['default'], {
            axis: 'x',
            className: _TiledPlotModule2['default'].list + ' ' + _TiledPlotModule2['default'].stylizedList + ' ' + _TiledPlotModule2['default'].horizontalList,
            component: _SortableList2['default'],
            editable: this.props.editable,
            handleConfigTrack: this.props.handleConfigTrack,
            handleResizeTrack: this.props.handleResizeTrack,
            height: this.props.height,
            helperClass: _TiledPlotModule2['default'].stylizedHelper,
            itemClass: _TiledPlotModule2['default'].stylizedItem + ' ' + _TiledPlotModule2['default'].horizontalItem,
            itemControlAlignLeft: this.props.tracksControlAlignLeft,
            itemReactClass: _VerticalItem2['default'],
            items: this.props.tracks.map(function (d) {
              return {
                configMenuVisible: d.uid === _this2.props.configTrackMenuId,
                uid: d.uid || _slugid2['default'].nice(),
                height: _this2.props.height,
                width: d.width,
                value: d.value
              };
            }),
            onAddSeries: this.props.onAddSeries,
            onCloseTrack: this.props.onCloseTrack,
            onCloseTrackMenuOpened: this.props.onCloseTrackMenuOpened,
            onConfigTrackMenuOpened: this.props.onConfigTrackMenuOpened,
            onSortEnd: this.props.handleSortEnd,
            referenceAncestor: this.props.referenceAncestor,
            resizeHandles: this.props.resizeHandles,
            useDragHandle: true,
            width: width
          })
        );
      }

      return render;
    }()
  }]);

  return VerticalTiledPlot;
}(_react2['default'].Component);

VerticalTiledPlot.propTypes = {
  configTrackMenuId: _propTypes2['default'].string,
  chromInfo: _propTypes2['default'].object,
  editable: _propTypes2['default'].bool,
  handleConfigTrack: _propTypes2['default'].func,
  handleResizeTrack: _propTypes2['default'].func,
  handleSortEnd: _propTypes2['default'].func,
  is1dRangeSelection: _propTypes2['default'].bool,
  isRangeSelectionActive: _propTypes2['default'].bool,
  height: _propTypes2['default'].number,
  onAddSeries: _propTypes2['default'].func,
  onCloseTrack: _propTypes2['default'].func,
  onCloseTrackMenuOpened: _propTypes2['default'].func,
  onConfigTrackMenuOpened: _propTypes2['default'].func,
  onRangeSelection: _propTypes2['default'].func,
  onRangeSelectionEnd: _propTypes2['default'].func,
  onRangeSelectionStart: _propTypes2['default'].func,
  rangeSelection: _propTypes2['default'].array,
  referenceAncestor: _propTypes2['default'].func,
  resizeHandles: _propTypes2['default'].object,
  scale: _propTypes2['default'].func,
  tracks: _propTypes2['default'].array,
  tracksControlAlignLeft: _propTypes2['default'].bool
};

exports['default'] = VerticalTiledPlot;

/***/ }),
/* 696 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerticalItem = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactSortableHoc = __webpack_require__(47);

var _VerticalTrack = __webpack_require__(697);

var _VerticalTrack2 = _interopRequireDefault(_VerticalTrack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var VerticalItem = exports.VerticalItem = (0, _reactSortableHoc.SortableElement)(function (props) {
  return _react2['default'].createElement(_VerticalTrack2['default'], {
    className: props.className,
    controlAlignLeft: props.controlAlignLeft,
    editable: props.editable,
    handleConfigTrack: props.handleConfigTrack,
    handleResizeTrack: props.handleResizeTrack,
    height: props.height,
    item: props.item,
    onAddSeries: props.onAddSeries,
    onCloseTrack: props.onCloseTrack,
    onCloseTrackMenuOpened: props.onCloseTrackMenuOpened,
    onConfigTrackMenuOpened: props.onConfigTrackMenuOpened,
    resizeHandles: props.resizeHandles,
    uid: props.uid,
    width: props.width
  });
});

exports['default'] = VerticalItem;

/***/ }),
/* 697 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerticalTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _MoveableTrack2 = __webpack_require__(248);

var _MoveableTrack3 = _interopRequireDefault(_MoveableTrack2);

var _TrackControl = __webpack_require__(122);

var _TrackControl2 = _interopRequireDefault(_TrackControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var STYLES = {
  pointerEvents: 'all'
};

var VerticalTrack = exports.VerticalTrack = function (_MoveableTrack) {
  _inherits(VerticalTrack, _MoveableTrack);

  function VerticalTrack() {
    _classCallCheck(this, VerticalTrack);

    return _possibleConstructorReturn(this, (VerticalTrack.__proto__ || Object.getPrototypeOf(VerticalTrack)).apply(this, arguments));
  }

  _createClass(VerticalTrack, [{
    key: 'getControls',
    value: function () {
      function getControls(isVisible) {
        return _react2['default'].createElement(_TrackControl2['default'], {
          imgStyleAdd: STYLES,
          imgStyleClose: STYLES,
          imgStyleMove: STYLES,
          imgStyleSettings: STYLES,
          isAlignLeft: this.props.controlAlignLeft,
          isMoveable: this.moveable,
          isVertical: true,
          isVisible: isVisible,
          onAddSeries: this.props.onAddSeries,
          onCloseTrackMenuOpened: this.props.onCloseTrackMenuOpened,
          onConfigTrackMenuOpened: this.props.onConfigTrackMenuOpened,
          uid: this.props.uid
        });
      }

      return getControls;
    }()
  }]);

  return VerticalTrack;
}(_MoveableTrack3['default']);

exports['default'] = VerticalTrack;

/***/ }),
/* 698 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"vertical-tiled-plot":"VerticalTiledPlot-module_vertical-tiled-plot-R3sb7"};

/***/ }),
/* 699 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenomePositionSearchBox = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _getClassName2 = __webpack_require__(36);

var _getClassName3 = _interopRequireDefault(_getClassName2);

var _d3Request = __webpack_require__(30);

var _d3Queue = __webpack_require__(700);

var _d3Selection = __webpack_require__(4);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _services = __webpack_require__(7);

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _reactBootstrap = __webpack_require__(59);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Autocomplete = __webpack_require__(703);

var _Autocomplete2 = _interopRequireDefault(_Autocomplete);

var _ChromosomeInfo = __webpack_require__(43);

var _search_field = __webpack_require__(86);

var _PopupMenu = __webpack_require__(143);

var _PopupMenu2 = _interopRequireDefault(_PopupMenu);

var _utils = __webpack_require__(3);

var _GenomePositionSearchBoxModule = __webpack_require__(707);

var _GenomePositionSearchBoxModule2 = _interopRequireDefault(_GenomePositionSearchBoxModule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _styleModuleImportMap = {
  'styles': {
    'genome-position-search': 'GenomePositionSearchBox-module_genome-position-search-SYccr',
    'genome-position-search-focus': 'GenomePositionSearchBox-module_genome-position-search-focus-23by2',
    'genome-position-search-bar': 'GenomePositionSearchBox-module_genome-position-search-bar-1_0ZU',
    'genome-position-search-bar-button': 'GenomePositionSearchBox-module_genome-position-search-bar-button-33SWJ',
    'genome-position-search-bar-button-focus': 'GenomePositionSearchBox-module_genome-position-search-bar-button-focus-1IhAk',
    'genome-position-search-bar-icon': 'GenomePositionSearchBox-module_genome-position-search-bar-icon-14AEk',
    'genome-position-search-bar-icon-focus': 'GenomePositionSearchBox-module_genome-position-search-bar-icon-focus-1Ay7Z',
    'genome-position-search-bar-suggestions': 'GenomePositionSearchBox-module_genome-position-search-bar-suggestions-SrIoU',
    'btn': 'GenomePositionSearchBox-module_btn-2bTUd',
    'btn-sm': 'GenomePositionSearchBox-module_btn-sm-2Ltms',
    'btn-default': 'GenomePositionSearchBox-module_btn-default-2pap4'
  }
};

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Utils


// Styles


// eslint-disable-line no-unused-vars

var GenomePositionSearchBox = exports.GenomePositionSearchBox = function (_React$Component) {
  _inherits(GenomePositionSearchBox, _React$Component);

  function GenomePositionSearchBox(props) {
    _classCallCheck(this, GenomePositionSearchBox);

    var _this = _possibleConstructorReturn(this, (GenomePositionSearchBox.__proto__ || Object.getPrototypeOf(GenomePositionSearchBox)).call(this, props));

    _this.mounted = false;
    _this.uid = _slugid2['default'].nice();
    _this.chromInfo = null;
    _this.searchField = null;
    _this.autocompleteMenu = null;

    _this.xScale = null, _this.yScale = null;
    // this.props.zoomDispatch.on('zoom.' + this.uid, this.zoomed.bind(this))

    /*
    this.xOrigScale = scaleLinear().domain(this.props.xDomain)
              .range(this.props.xRange);
    this.yOrigScale = scaleLinear().domain(this.props.yDomain)
              .range(this.props.yRange);
     this.zoomedXScale = this.xOrigScale.copy();
    this.zoomedYScale = this.yOrigScale.copy();
    */

    _this.prevParts = [];

    _this.props.registerViewportChangedListener(_this.scalesChanged.bind(_this));

    _this.menuPosition = { left: 0, top: 0 };

    _this.state = {
      value: 'chr4:190,998,876-191,000,255',
      loading: false,
      menuPosition: [0, 0],
      genes: [],
      isFocused: false,
      menuOpened: false,
      autocompleteServer: _this.props.autocompleteServer,
      autocompleteId: _this.props.autocompleteId,
      availableAssemblies: [],
      selectedAssembly: null
    };

    _this.styles = {
      item: {
        padding: '2px 6px',
        cursor: 'default'
      },

      highlightedItem: {
        color: 'white',
        background: 'hsl(200, 50%, 50%)',
        padding: '2px 6px',
        cursor: 'default'
      },

      menu: {
        border: 'solid 1px #ccc'
      }
    };

    _this.availableAutocompletes = {};

    if (_this.props.autocompleteId) {
      _this.availableAutocompletes[_this.props.chromInfoId] = new Set([{
        server: _this.props.autocompleteServer,
        acId: _this.props.autocompleteId
      }]);
    }

    _this.availableChromSizes = {};
    // this.availableChromSizes[this.props.chromInfoId] = new Set([{server: this.props.chromInfoServer, uuid: this.props.chromInfoId} ]);


    // this.fetchChromInfo(this.props.chromInfoId);
    return _this;
  }

  _createClass(GenomePositionSearchBox, [{
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {
        this.mounted = true;
        // we want to catch keypresses so we can get that enter
        (0, _d3Selection.select)(this.autocompleteMenu.inputEl).on('keypress', this.autocompleteKeyPress.bind(this));

        this.findAvailableAutocompleteSources();
        this.findAvailableChromSizes();

        this.setPositionText();
      }

      return componentDidMount;
    }()
  }, {
    key: 'componentWillUnmount',
    value: function () {
      function componentWillUnmount() {
        this.mounted = false;
        this.props.removeViewportChangedListener();
      }

      return componentWillUnmount;
    }()
  }, {
    key: 'fetchChromInfo',
    value: function () {
      function fetchChromInfo(chromInfoId) {
        var _this2 = this;

        /**
         * The user has selected an assembly to use for the coordinate search box
         *
         * Parameters
         * ----------
         *  chromInfoId: string
         *      The name of the chromosome info set to use
         *
         * Returns
         * -------
         *  null
         *      Once the appropriate ChromInfo file is fetched, it is stored locally
         */

        if (!this.mounted)
          // component is probably about to be unmounted
          return;

        if (!this.availableChromSizes[chromInfoId])
          // we don't know of any available chromosome sizes so just ignore
          // this function call (usually called from the constructor)
          {
            return;
          }

        // use the first available server that we have on record for this chromInfoId
        var serverAndChromInfoToUse = [].concat(_toConsumableArray(this.availableChromSizes[chromInfoId]))[0];

        this.setState({
          autocompleteServer: serverAndChromInfoToUse.server
        });

        (0, _ChromosomeInfo.ChromosomeInfo)(serverAndChromInfoToUse.server + '/chrom-sizes/?id=' + serverAndChromInfoToUse.uuid, function (newChromInfo) {
          _this2.chromInfo = newChromInfo;
          _this2.searchField = new _search_field.SearchField(_this2.chromInfo);

          _this2.setPositionText();

          if (_this2.gpsbForm) {
            // only set the state if this component is mounted
            _this2.setState({
              selectedAssembly: chromInfoId
            });
          }

          // we need to set a an autocompleteId that matches the chromInfo
          // that was received, but if none has been retrieved yet...
          if (_this2.availableAutocompletes[chromInfoId]) {
            var newAcId = [].concat(_toConsumableArray(_this2.availableAutocompletes[chromInfoId]))[0].acId;
            _this2.props.onSelectedAssemblyChanged(chromInfoId, newAcId, serverAndChromInfoToUse.server);

            if (_this2.gpsbForm) {
              _this2.setState({
                autocompleteId: newAcId
              });
            }
          } else {
            _this2.props.onSelectedAssemblyChanged(chromInfoId, null, serverAndChromInfoToUse.server);

            if (_this2.gpsbForm) {
              _this2.setState({
                autocompleteId: null
              });
            }
          }
        });
      }

      return fetchChromInfo;
    }()
  }, {
    key: 'findAvailableAutocompleteSources',
    value: function () {
      function findAvailableAutocompleteSources() {
        var _this3 = this;

        this.props.trackSourceServers.forEach(function (sourceServer) {
          _services.tileProxy.json(sourceServer + '/tilesets/?limit=100&dt=gene-annotation', function (error, data) {
            if (error) {
              console.error(error);
            } else {
              data.results.map(function (x) {
                if (!(x.coordSystem in _this3.availableAutocompletes)) {
                  _this3.availableAutocompletes[x.coordSystem] = new Set();
                }

                _this3.availableAutocompletes[x.coordSystem].add({ server: sourceServer, acId: x.uuid });
                _this3.setAvailableAssemblies();
              });

              if (!_this3.state.autocompleteId) {
                // We don't have an autocomplete source yet, so set the one matching the current
                // assembly
                if (_this3.gpsbForm) {
                  // only set the state if this component is mounted
                  if (_this3.availableAutocompletes[_this3.props.chromInfoId]) {
                    _this3.setState({
                      autocompleteId: [].concat(_toConsumableArray(_this3.availableAutocompletes[_this3.props.chromInfoId]))[0].acId
                    });
                  }
                }
              }
            }
          });
        });
      }

      return findAvailableAutocompleteSources;
    }()
  }, {
    key: 'findAvailableChromSizes',
    value: function () {
      function findAvailableChromSizes() {
        var _this4 = this;

        this.props.trackSourceServers.forEach(function (sourceServer) {
          _services.tileProxy.json(sourceServer + '/available-chrom-sizes/', function (error, data) {
            if (error) {
              console.error(error);
            } else {
              data.results.map(function (x) {
                if (!(x.uuid in _this4.availableChromSizes)) {
                  _this4.availableChromSizes[x.coordSystem] = new Set();
                }

                _this4.availableChromSizes[x.coordSystem].add({ server: sourceServer, uuid: x.uuid });
                _this4.setAvailableAssemblies();
              });

              // we haven't set an assembly yet so set it now
              // props.chromInfoId will be set to the suggested assembly (e.g. "hg19")
              // this will be mapped to an available chromSize (with its own unique uuid)
              if (!_this4.searchField) {
                _this4.fetchChromInfo(_this4.props.chromInfoId);
              }
            }
          });
        });
      }

      return findAvailableChromSizes;
    }()
  }, {
    key: 'setAvailableAssemblies',
    value: function () {
      function setAvailableAssemblies() {
        var autocompleteKeys = new Set((0, _utils.dictKeys)(this.availableAutocompletes));
        var chromsizeKeys = new Set((0, _utils.dictKeys)(this.availableChromSizes));

        var commonKeys = new Set([].concat(_toConsumableArray(chromsizeKeys)));

        if (this.gpsbForm) {
          // only set the state if this comonent is mounted
          this.setState({
            availableAssemblies: [].concat(_toConsumableArray(commonKeys))
          });
        }
      }

      return setAvailableAssemblies;
    }()
  }, {
    key: 'scalesChanged',
    value: function () {
      function scalesChanged(xScale, yScale) {
        this.xScale = xScale, this.yScale = yScale;

        // make sure that this component is loaded first
        this.setPositionText();
      }

      return scalesChanged;
    }()
  }, {
    key: 'setPositionText',
    value: function () {
      function setPositionText() {
        if (!this.mounted) {
          return;
        }
        if (!this.searchField) {
          return;
        }

        var positionString = this.searchField.scalesToPositionText(this.xScale, this.yScale, this.props.twoD);

        // ReactDOM.findDOMNode( this.refs.searchFieldText).value = positionString;
        // used for autocomplete
        this.prevParts = positionString.split(/[ -]/);
        if (this.gpsbForm) {
          this.setState({ value: positionString });
        }
      }

      return setPositionText;
    }()
  }, {
    key: 'autocompleteKeyPress',
    value: function () {
      function autocompleteKeyPress() {
        var ENTER_KEY_CODE = 13;

        if (_d3Selection.event.keyCode == ENTER_KEY_CODE) {
          this.buttonClick();
        }
      }

      return autocompleteKeyPress;
    }()
  }, {
    key: 'replaceGenesWithLoadedPositions',
    value: function () {
      function replaceGenesWithLoadedPositions(genePositions) {
        // iterate over all non-position oriented words and try
        // to replace them with the positions loaded from the suggestions
        // database
        var spaceParts = this.state.value.split(' ');

        for (var i = 0; i < spaceParts.length; i++) {
          var dashParts = spaceParts[i].split('-');

          for (var j = 0; j < dashParts.length; j++) {
            // if we're in this function, this gene name must have been loaded
            var genePosition = genePositions[dashParts[j].toLowerCase()];

            if (!genePosition) {
              continue;
            }

            // elongate the span of the gene so that it doesn't take up the entire
            // view
            var extension = Math.floor((genePosition.txEnd - genePosition.txStart) / 4);

            if (dashParts.length == 1) {
              // no range, just a position
              dashParts[j] = genePosition.chr + ':' + (genePosition.txStart - extension) + '-' + (genePosition.txEnd + extension);
            } else if (j == 0) {
              // first part of a range

              dashParts[j] = genePosition.chr + ':' + (genePosition.txStart - extension);
            } else {
              // last part of a range

              dashParts[j] = genePosition.chr + ':' + (genePosition.txEnd + extension);
            }

            spaceParts[i] = dashParts.join('-');
          }
        }

        var newValue = spaceParts.join(' ');
        this.prevParts = newValue.split(/[ -]/);
        this.setState({ value: newValue });
      }

      return replaceGenesWithLoadedPositions;
    }()
  }, {
    key: 'replaceGenesWithPositions',
    value: function () {
      function replaceGenesWithPositions(finished) {
        var _this5 = this;

        // replace any gene names in the input with their corresponding positions
        var value_parts = this.state.value.split(/[ -]/);
        var q = (0, _d3Queue.queue)();

        for (var i = 0; i < value_parts.length; i++) {
          if (value_parts[i].length == 0) {
            continue;
          }

          var _searchField$parsePos = this.searchField.parsePosition(value_parts[i]),
              _searchField$parsePos2 = _slicedToArray(_searchField$parsePos, 3),
              chr = _searchField$parsePos2[0],
              pos = _searchField$parsePos2[1],
              retPos = _searchField$parsePos2[2];

          if (retPos == null || isNaN(retPos)) {
            // not a chromsome position, let's see if it's a gene name
            var url = this.state.autocompleteServer + '/suggest/?d=' + this.state.autocompleteId + '&ac=' + value_parts[i].toLowerCase();
            q = q.defer(_services.tileProxy.json, url);
          }
        }

        q.awaitAll(function (error, files) {
          if (files) {
            var genePositions = {};

            // extract the position of the top match from the list of files
            for (var _i = 0; _i < files.length; _i++) {
              if (!files[_i][0]) {
                continue;
              }

              for (var j = 0; j < files[_i].length; j++) {
                genePositions[files[_i][j].geneName.toLowerCase()] = files[_i][j];
              }
            }

            _this5.replaceGenesWithLoadedPositions(genePositions);

            finished();
          }
        });
      }

      return replaceGenesWithPositions;
    }()
  }, {
    key: 'buttonClick',
    value: function () {
      function buttonClick() {
        var _this6 = this;

        this.setState({ genes: [] }); // no menu should be open

        this.replaceGenesWithPositions(function () {
          var searchFieldValue = _this6.state.value; // ReactDOM.findDOMNode( this.refs.searchFieldText ).value;

          if (_this6.searchField != null) {
            var _searchField$searchPo = _this6.searchField.searchPosition(searchFieldValue),
                _searchField$searchPo2 = _slicedToArray(_searchField$searchPo, 2),
                range1 = _searchField$searchPo2[0],
                range2 = _searchField$searchPo2[1];

            if (range1 && (isNaN(range1[0]) || isNaN(range1[1])) || range2 && (isNaN(range2[0]) || isNaN(range2[1]))) {
              return;
            }

            if (!range2) {
              range2 = range1;
            }

            var newXScale = _this6.xScale.copy().domain(range1);
            var newYScale = _this6.yScale.copy().domain(range2);

            var _scalesCenterAndK = (0, _utils.scalesCenterAndK)(newXScale, newYScale),
                _scalesCenterAndK2 = _slicedToArray(_scalesCenterAndK, 3),
                centerX = _scalesCenterAndK2[0],
                centerY = _scalesCenterAndK2[1],
                k = _scalesCenterAndK2[2];

            _this6.props.setCenters(centerX, centerY, k, true);
          }
        });
      }

      return buttonClick;
    }()
  }, {
    key: 'searchFieldSubmit',
    value: function () {
      function searchFieldSubmit() {
        this.buttonClick();
      }

      return searchFieldSubmit;
    }()
  }, {
    key: 'pathJoin',
    value: function () {
      function pathJoin(parts, sep) {
        var separator = sep || '/';
        var replace = new RegExp(separator + '{1,}', 'g');
        return parts.join(separator).replace(replace, separator);
      }

      return pathJoin;
    }()
  }, {
    key: 'onAutocompleteChange',
    value: function () {
      function onAutocompleteChange(event, value) {
        var _this7 = this;

        this.setState({ value: value, loading: true });

        var parts = value.split(/[ -]/);
        this.changedPart = null;

        for (var i = 0; i < parts.length; i++) {
          if (i == this.prevParts.length) {
            // new part added
            this.changedPart = i;
            break;
          }

          if (parts[i] != this.prevParts[i]) {
            this.changedPart = i;
            break;
          }
        }

        this.prevParts = parts;

        // no autocomplete repository is provided, so we don't try to autcomplete anything
        if (!(this.state.autocompleteServer && this.state.autocompleteId)) {
          return;
        }

        if (this.changedPart != null) {
          // if something has changed in the input text
          this.setState({ loading: true });
          // send out a request for the autcomplete suggestions
          var url = this.state.autocompleteServer + '/suggest/?d=' + this.state.autocompleteId + '&ac=' + parts[this.changedPart].toLowerCase();
          _services.tileProxy.json(url, function (error, data) {
            if (error) {
              _this7.setState({ loading: false, genes: [] });
              return;
            }

            // we've received a list of autocomplete suggestions
            _this7.setState({ loading: false, genes: data });
          });
        }
      }

      return onAutocompleteChange;
    }()
  }, {
    key: 'geneSelected',
    value: function () {
      function geneSelected(value, objct) {
        var parts = this.state.value.split(' ');
        var partCount = this.changedPart;

        // change the part that was selected
        for (var i = 0; i < parts.length; i++) {
          var dash_parts = parts[i].split('-');
          if (partCount > dash_parts.length - 1) {
            partCount -= dash_parts.length;
          } else {
            dash_parts[partCount] = objct.geneName;
            parts[i] = dash_parts.join('-');
            break;
          }
        }

        /*
        let new_dash_parts = dash_parts.slice(0, dash_parts.length-1);
        new_dash_parts = new_dash_parts.concat(objct.geneName).join('-');
         let new_parts = parts.splice(0, parts.length-1);
        new_parts = new_parts.concat(new_dash_parts).join(' ');
        */

        this.prevParts = parts.join(' ').split(/[ -]/);
        this.setState({ value: parts.join(' '), genes: [] });
      }

      return geneSelected;
    }()
  }, {
    key: 'handleMenuVisibilityChange',
    value: function () {
      function handleMenuVisibilityChange(isOpen, inputEl) {
        var box = inputEl.getBoundingClientRect();

        this.menuPosition = {
          left: box.left,
          top: box.top + box.height
        };

        this.setState({
          menuOpened: isOpen
        });
      }

      return handleMenuVisibilityChange;
    }()
  }, {
    key: 'handleRenderMenu',
    value: function () {
      function handleRenderMenu(items) {
        return _react2['default'].createElement(
          _PopupMenu2['default'],
          {
            children: items
          },
          _react2['default'].createElement('div', {
            children: items,
            style: {
              left: this.menuPosition.left,
              top: this.menuPosition.top
            },
            className: 'GenomePositionSearchBox-module_genome-position-search-bar-suggestions-SrIoU'
          })
        );
      }

      return handleRenderMenu;
    }()
  }, {
    key: 'handleAssemblySelect',
    value: function () {
      function handleAssemblySelect(evt) {
        this.fetchChromInfo(evt);

        this.setState({
          selectedAssembly: evt
        });
      }

      return handleAssemblySelect;
    }()
  }, {
    key: 'focusHandler',
    value: function () {
      function focusHandler(isFocused) {
        this.setState({
          isFocused: isFocused
        });
      }

      return focusHandler;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this8 = this;

        var assemblyMenuItems = this.state.availableAssemblies.map(function (x) {
          return _react2['default'].createElement(
            _reactBootstrap.MenuItem,
            {
              eventKey: x,
              key: x
            },
            x
          );
        });

        var className = this.state.isFocused ? 'styles.genome-position-search-focus' : 'styles.genome-position-search';

        var classNameButton = this.state.isFocused ? 'styles.genome-position-search-bar-button-focus' : 'styles.genome-position-search-bar-button';

        var classNameIcon = this.state.isFocused ? 'styles.genome-position-search-bar-icon-focus' : 'styles.genome-position-search-bar-icon';

        return _react2['default'].createElement(
          _reactBootstrap.FormGroup,
          {
            bsSize: 'small',

            ref: function () {
              function ref(c) {
                return _this8.gpsbForm = c;
              }

              return ref;
            }(),
            className: (0, _getClassName3['default'])(className, _styleModuleImportMap)
          },
          _react2['default'].createElement(
            _reactBootstrap.DropdownButton,
            {
              bsSize: 'small',
              className: _GenomePositionSearchBoxModule2['default']['genome-position-search-bar-button'],
              id: this.uid,
              onSelect: this.handleAssemblySelect.bind(this),
              ref: function () {
                function ref(c) {
                  return _this8.assemblyPickButton = c;
                }

                return ref;
              }(),
              title: this.state.selectedAssembly ? this.state.selectedAssembly : '(none)'
            },
            assemblyMenuItems
          ),
          _react2['default'].createElement(_Autocomplete2['default'], {
            getItemValue: function () {
              function getItemValue(item) {
                return item.geneName;
              }

              return getItemValue;
            }(),
            inputProps: {
              className: _GenomePositionSearchBoxModule2['default']['genome-position-search-bar']
            },
            items: this.state.genes,
            menuStyle: {
              position: 'absolute',
              left: this.menuPosition.left,
              top: this.menuPosition.top,
              border: '1px solid black'
            },
            onChange: this.onAutocompleteChange.bind(this),
            onFocus: this.focusHandler.bind(this),
            onMenuVisibilityChange: this.handleMenuVisibilityChange.bind(this),
            onSelect: function () {
              function onSelect(value, objct) {
                return _this8.geneSelected(value, objct);
              }

              return onSelect;
            }(),
            onSubmit: this.searchFieldSubmit.bind(this),
            ref: function () {
              function ref(c) {
                return _this8.autocompleteMenu = c;
              }

              return ref;
            }(),
            renderItem: function () {
              function renderItem(item, isHighlighted) {
                return _react2['default'].createElement(
                  'div',
                  {
                    id: item.refseqid,
                    key: item.refseqid,
                    style: isHighlighted ? _this8.styles.highlightedItem : _this8.styles.item
                  },
                  item.geneName
                );
              }

              return renderItem;
            }(),
            renderMenu: this.handleRenderMenu.bind(this),
            value: this.state.value,
            wrapperStyle: { width: '100%' }
          }),
          _react2['default'].createElement(
            'button',
            {
              onClick: this.buttonClick.bind(this),
              className: (0, _getClassName3['default'])(classNameButton, _styleModuleImportMap)
            },
            _react2['default'].createElement(_reactBootstrap.Glyphicon, { glyph: 'search' })
          )
        );
      }

      return render;
    }()
  }]);

  return GenomePositionSearchBox;
}(_react2['default'].Component);

GenomePositionSearchBox.propTypes = {
  autocompleteId: _propTypes2['default'].string,
  autocompleteServer: _propTypes2['default'].string,
  chromInfoId: _propTypes2['default'].string,
  isFocused: _propTypes2['default'].bool,
  onFocus: _propTypes2['default'].func,
  onSelectedAssemblyChanged: _propTypes2['default'].func,
  registerViewportChangedListener: _propTypes2['default'].func,
  removeViewportChangedListener: _propTypes2['default'].func,
  setCenters: _propTypes2['default'].func,
  trackSourceServers: _propTypes2['default'].array,
  twoD: _propTypes2['default'].bool
};

exports['default'] = GenomePositionSearchBox;

/***/ }),
/* 700 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_queue__ = __webpack_require__(701);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "queue", function() { return __WEBPACK_IMPORTED_MODULE_0__src_queue__["a"]; });



/***/ }),
/* 701 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = queue;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(702);


var noabort = {};

function Queue(size) {
  this._size = size;
  this._call =
  this._error = null;
  this._tasks = [];
  this._data = [];
  this._waiting =
  this._active =
  this._ended =
  this._start = 0; // inside a synchronous task callback?
}

Queue.prototype = queue.prototype = {
  constructor: Queue,
  defer: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("defer after await");
    if (this._error != null) return this;
    var t = __WEBPACK_IMPORTED_MODULE_0__array__["a" /* slice */].call(arguments, 1);
    t.push(callback);
    ++this._waiting, this._tasks.push(t);
    poke(this);
    return this;
  },
  abort: function() {
    if (this._error == null) abort(this, new Error("abort"));
    return this;
  },
  await: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = function(error, results) { callback.apply(null, [error].concat(results)); };
    maybeNotify(this);
    return this;
  },
  awaitAll: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = callback;
    maybeNotify(this);
    return this;
  }
};

function poke(q) {
  if (!q._start) {
    try { start(q); } // let the current task complete
    catch (e) {
      if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously
      else if (!q._data) throw e; // await callback errored synchronously
    }
  }
}

function start(q) {
  while (q._start = q._waiting && q._active < q._size) {
    var i = q._ended + q._active,
        t = q._tasks[i],
        j = t.length - 1,
        c = t[j];
    t[j] = end(q, i);
    --q._waiting, ++q._active;
    t = c.apply(null, t);
    if (!q._tasks[i]) continue; // task finished synchronously
    q._tasks[i] = t || noabort;
  }
}

function end(q, i) {
  return function(e, r) {
    if (!q._tasks[i]) return; // ignore multiple callbacks
    --q._active, ++q._ended;
    q._tasks[i] = null;
    if (q._error != null) return; // ignore secondary errors
    if (e != null) {
      abort(q, e);
    } else {
      q._data[i] = r;
      if (q._waiting) poke(q);
      else maybeNotify(q);
    }
  };
}

function abort(q, e) {
  var i = q._tasks.length, t;
  q._error = e; // ignore active callbacks
  q._data = undefined; // allow gc
  q._waiting = NaN; // prevent starting

  while (--i >= 0) {
    if (t = q._tasks[i]) {
      q._tasks[i] = null;
      if (t.abort) {
        try { t.abort(); }
        catch (e) { /* ignore */ }
      }
    }
  }

  q._active = NaN; // allow notification
  maybeNotify(q);
}

function maybeNotify(q) {
  if (!q._active && q._call) {
    var d = q._data;
    q._data = undefined; // allow gc
    q._call(q._error, d);
  }
}

function queue(concurrency) {
  if (concurrency == null) concurrency = Infinity;
  else if (!((concurrency = +concurrency) >= 1)) throw new Error("invalid concurrency");
  return new Queue(concurrency);
}


/***/ }),
/* 702 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return slice; });
var slice = [].slice;


/***/ }),
/* 703 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Autocomplete = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(8);

var _domScrollIntoView = __webpack_require__(704);

var _domScrollIntoView2 = _interopRequireDefault(_domScrollIntoView);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _debugStates = [];

var Autocomplete = exports.Autocomplete = function (_React$Component) {
  _inherits(Autocomplete, _React$Component);

  function Autocomplete(props) {
    _classCallCheck(this, Autocomplete);

    var _this = _possibleConstructorReturn(this, (Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete)).call(this, props));

    _this.state = {
      highlightedIndex: null,
      menuTop: 0,
      menuLeft: 0,
      menuWidth: 0,
      isOpen: false
    };

    _this.keyDownHandlers = {
      ArrowDown: function () {
        function ArrowDown(event) {
          event.preventDefault();
          var itemsLength = this.getFilteredItems().length;
          if (!itemsLength) return;
          var highlightedIndex = this.state.highlightedIndex;

          var index = highlightedIndex === null || highlightedIndex === itemsLength - 1 ? 0 : highlightedIndex + 1;
          this._performAutoCompleteOnKeyUp = true;
          this.setState({
            highlightedIndex: index,
            isOpen: true
          });
        }

        return ArrowDown;
      }(),
      ArrowUp: function () {
        function ArrowUp(event) {
          event.preventDefault();
          var itemsLength = this.getFilteredItems().length;
          if (!itemsLength) return;
          var highlightedIndex = this.state.highlightedIndex;

          var index = highlightedIndex === 0 || highlightedIndex === null ? itemsLength - 1 : highlightedIndex - 1;
          this._performAutoCompleteOnKeyUp = true;
          this.setState({
            highlightedIndex: index,
            isOpen: true
          });
        }

        return ArrowUp;
      }(),
      Enter: function () {
        function Enter(event) {
          var _this2 = this;

          if (this.state.isOpen === false) {
            // menu is closed so there is no selection to accept -> do nothing

          } else if (this.state.highlightedIndex == null) {
            // input has focus but no menu item is selected + enter is hit -> close the menu, highlight whatever's in input
            this.setState({
              isOpen: false
            }, function () {
              _this2.inputEl.select();
            });
          } else {
            // text entered + menu item has been highlighted + enter is hit -> update value to that of selected menu item, close the menu
            event.preventDefault();
            var item = this.getFilteredItems()[this.state.highlightedIndex];
            var value = this.props.getItemValue(item);
            this.setState({
              isOpen: false,
              highlightedIndex: null
            }, function () {
              // this.refs.input.focus() // TODO: file issue
              _this2.inputEl.setSelectionRange(value.length, value.length);
              _this2.props.onSelect(value, item);
            });
          }
        }

        return Enter;
      }(),
      Escape: function () {
        function Escape() {
          this.setState({
            highlightedIndex: null,
            isOpen: false
          });
        }

        return Escape;
      }()
    };
    return _this;
  }

  _createClass(Autocomplete, [{
    key: 'getInitialState',
    value: function () {
      function getInitialState() {
        return {
          isOpen: false,
          highlightedIndex: null
        };
      }

      return getInitialState;
    }()
  }, {
    key: 'componentWillMount',
    value: function () {
      function componentWillMount() {
        this._ignoreBlur = false;
        this._performAutoCompleteOnUpdate = false;
        this._performAutoCompleteOnKeyUp = false;
      }

      return componentWillMount;
    }()
  }, {
    key: 'componentWillReceiveProps',
    value: function () {
      function componentWillReceiveProps(nextProps) {
        this._performAutoCompleteOnUpdate = true;
        // If `items` has changed we want to reset `highlightedIndex`
        // since it probably no longer refers to a relevant item
        if (this.props.items !== nextProps.items ||
        // The entries in `items` may have been changed even though the
        // object reference remains the same, double check by seeing
        // if `highlightedIndex` points to an existing item
        this.state.highlightedIndex >= nextProps.items.length) {
          this.setState({ highlightedIndex: null });
        }
      }

      return componentWillReceiveProps;
    }()
  }, {
    key: 'componentDidUpdate',
    value: function () {
      function componentDidUpdate(prevProps, prevState) {
        if (this.state.isOpen === true && prevState.isOpen === false) {
          this.setMenuPositions();
        }

        if (this.state.isOpen && this._performAutoCompleteOnUpdate) {
          this._performAutoCompleteOnUpdate = false;
          this.maybeAutoCompleteText();
        }

        this.maybeScrollItemIntoView();
        if (prevState.isOpen !== this.state.isOpen) {
          this.props.onMenuVisibilityChange(this.state.isOpen, this.inputEl);
        }
      }

      return componentDidUpdate;
    }()
  }, {
    key: 'maybeScrollItemIntoView',
    value: function () {
      function maybeScrollItemIntoView() {
        if (this.state.isOpen === true && this.state.highlightedIndex !== null) {
          var itemNode = this.refs['item-' + this.state.highlightedIndex];
          var menuNode = this.refs.menu;
          if (itemNode) {
            (0, _domScrollIntoView2['default'])((0, _reactDom.findDOMNode)(itemNode), (0, _reactDom.findDOMNode)(menuNode), { onlyScrollIfNeeded: true });
          }
        }
      }

      return maybeScrollItemIntoView;
    }()
  }, {
    key: 'handleKeyDown',
    value: function () {
      function handleKeyDown(event) {
        if (this.keyDownHandlers[event.key]) {
          this.keyDownHandlers[event.key].call(this, event);
        } else {
          this.setState({
            highlightedIndex: null,
            isOpen: true
          });
        }
      }

      return handleKeyDown;
    }()
  }, {
    key: 'handleChange',
    value: function () {
      function handleChange(event) {
        this._performAutoCompleteOnKeyUp = true;
        this.props.onChange(event, event.target.value);
      }

      return handleChange;
    }()
  }, {
    key: 'handleKeyUp',
    value: function () {
      function handleKeyUp() {
        if (this._performAutoCompleteOnKeyUp) {
          this._performAutoCompleteOnKeyUp = false;
          this.maybeAutoCompleteText();
        }
      }

      return handleKeyUp;
    }()
  }, {
    key: 'getFilteredItems',
    value: function () {
      function getFilteredItems() {
        var _this3 = this;

        var items = this.props.items;

        if (this.props.shouldItemRender) {
          items = items.filter(function (item) {
            return _this3.props.shouldItemRender(item, _this3.props.value);
          });
        }

        if (this.props.sortItems) {
          items.sort(function (a, b) {
            return _this3.props.sortItems(a, b, _this3.props.value);
          });
        }

        return items;
      }

      return getFilteredItems;
    }()
  }, {
    key: 'maybeAutoCompleteText',
    value: function () {
      function maybeAutoCompleteText() {
        if (!this.props.autoHighlight || this.props.value === '') {
          return;
        }
        var highlightedIndex = this.state.highlightedIndex;

        var items = this.getFilteredItems();
        if (items.length === 0) {
          return;
        }
        var matchedItem = highlightedIndex !== null ? items[highlightedIndex] : items[0];
        var itemValue = this.props.getItemValue(matchedItem);
        var itemValueDoesMatch = itemValue.toLowerCase().indexOf(this.props.value.toLowerCase()) === 0;
        if (itemValueDoesMatch && highlightedIndex === null) {
          this.setState({ highlightedIndex: 0 });
        }
      }

      return maybeAutoCompleteText;
    }()
  }, {
    key: 'setMenuPositions',
    value: function () {
      function setMenuPositions() {
        var node = this.inputEl;
        var rect = node.getBoundingClientRect();
        var computedStyle = global.window.getComputedStyle(node);
        var marginBottom = parseInt(computedStyle.marginBottom, 10) || 0;
        var marginLeft = parseInt(computedStyle.marginLeft, 10) || 0;
        var marginRight = parseInt(computedStyle.marginRight, 10) || 0;
        this.setState({
          menuTop: rect.bottom + marginBottom,
          menuLeft: rect.left + marginLeft,
          menuWidth: rect.width + marginLeft + marginRight
        });
      }

      return setMenuPositions;
    }()
  }, {
    key: 'highlightItemFromMouse',
    value: function () {
      function highlightItemFromMouse(index) {
        this.setState({ highlightedIndex: index });
      }

      return highlightItemFromMouse;
    }()
  }, {
    key: 'selectItemFromMouse',
    value: function () {
      function selectItemFromMouse(item) {
        var _this4 = this;

        var value = this.props.getItemValue(item);
        this.setState({
          isOpen: false,
          highlightedIndex: null
        }, function () {
          _this4.props.onSelect(value, item);
          _this4.inputEl.focus();
        });
      }

      return selectItemFromMouse;
    }()
  }, {
    key: 'setIgnoreBlur',
    value: function () {
      function setIgnoreBlur(ignore) {
        this._ignoreBlur = ignore;
      }

      return setIgnoreBlur;
    }()
  }, {
    key: 'renderMenu',
    value: function () {
      function renderMenu() {
        var _this5 = this;

        var items = this.getFilteredItems().map(function (item, index) {
          var element = _this5.props.renderItem(item, _this5.state.highlightedIndex === index, { cursor: 'default' });
          return _react2['default'].cloneElement(element, {
            onMouseDown: function () {
              function onMouseDown() {
                return _this5.setIgnoreBlur(true);
              }

              return onMouseDown;
            }(), // Ignore blur to prevent menu from de-rendering before we can process click
            onMouseEnter: function () {
              function onMouseEnter() {
                return _this5.highlightItemFromMouse(index);
              }

              return onMouseEnter;
            }(),
            onClick: function () {
              function onClick() {
                return _this5.selectItemFromMouse(item);
              }

              return onClick;
            }(),
            ref: 'item-' + index
          });
        });
        var style = {
          left: this.state.menuLeft,
          top: this.state.menuTop,
          minWidth: this.state.menuWidth
        };
        if (!items.length) return null;
        var menu = this.props.renderMenu(items, this.props.value, style);
        return _react2['default'].cloneElement(menu, { ref: 'menu' });
      }

      return renderMenu;
    }()
  }, {
    key: 'handleInputBlur',
    value: function () {
      function handleInputBlur() {
        this.props.onFocus && this.props.onFocus();
        if (this._ignoreBlur) {
          return;
        }
        this.setState({
          isOpen: false,
          highlightedIndex: null
        });
      }

      return handleInputBlur;
    }()
  }, {
    key: 'handleInputFocus',
    value: function () {
      function handleInputFocus() {
        this.props.onFocus && this.props.onFocus(true);
        if (this._ignoreBlur) {
          this.setIgnoreBlur(false);
          return;
        }
        // We don't want `selectItemFromMouse` to trigger when
        // the user clicks into the input to focus it, so set this
        // flag to cancel out the logic in `handleInputClick`.
        // The event order is:  MouseDown -> Focus -> MouseUp -> Click
        this._ignoreClick = true;
        this.setState({ isOpen: true });
      }

      return handleInputFocus;
    }()
  }, {
    key: 'isInputFocused',
    value: function () {
      function isInputFocused() {
        return this.inputEl.ownerDocument && this.inputEl === this.inputEl.ownerDocument.activeElement;
      }

      return isInputFocused;
    }()
  }, {
    key: 'handleInputClick',
    value: function () {
      function handleInputClick() {
        // Input will not be focused if it's disabled
        if (this.isInputFocused() && this.state.isOpen === false) {
          this.setState({ isOpen: true });
        } else if (this.state.highlightedIndex !== null && !this._ignoreClick) {
          this.selectItemFromMouse(this.getFilteredItems()[this.state.highlightedIndex]);
        }
        this._ignoreClick = false;
      }

      return handleInputClick;
    }()
  }, {
    key: 'composeEventHandlers',
    value: function () {
      function composeEventHandlers(internal, external) {
        return external ? function (e) {
          internal(e);external(e);
        } : internal;
      }

      return composeEventHandlers;
    }()

    /* ------------------------------ Rendering ------------------------------- */

  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this6 = this;

        if (this.props.debug) {
          // you don't like it, you love it
          _debugStates.push({
            id: _debugStates.length,
            state: this.state
          });
        }

        var inputProps = this.props.inputProps;

        return _react2['default'].createElement(
          'div',
          _extends({
            style: _extends({}, this.props.wrapperStyle)
          }, this.props.wrapperProps),
          _react2['default'].createElement('input', _extends({}, inputProps, {
            'aria-autocomplete': 'list',
            autoComplete: 'off',
            onBlur: this.composeEventHandlers(this.handleInputBlur.bind(this), inputProps.onBlur && inputProps.onBlur.bind(this)),
            onChange: this.handleChange.bind(this),
            onClick: this.composeEventHandlers(this.handleInputClick.bind(this), inputProps.onClick && inputProps.onClick.bind(this)),
            onFocus: this.composeEventHandlers(this.handleInputFocus.bind(this), inputProps.onFocus && inputProps.onFocus.bind(this)),
            onKeyDown: this.composeEventHandlers(this.handleKeyDown.bind(this), inputProps.onKeyDown && inputProps.onKeyDown.bind(this)),
            onKeyUp: this.composeEventHandlers(this.handleKeyUp.bind(this), inputProps.onKeyUp && inputProps.onKeyUp.bind(this)),
            ref: function () {
              function ref(el) {
                return _this6.inputEl = el;
              }

              return ref;
            }(),
            role: 'combobox',
            value: this.props.value
          })),
          ('open' in this.props ? this.props.open : this.state.isOpen) && this.renderMenu(),
          this.props.debug && _react2['default'].createElement(
            'pre',
            { style: { marginLeft: 300 } },
            JSON.stringify(_debugStates.slice(_debugStates.length - 5, _debugStates.length), null, 2)
          )
        );
      }

      return render;
    }()
  }]);

  return Autocomplete;
}(_react2['default'].Component);

Autocomplete.defaultProps = {
  value: '',
  wrapperProps: {},
  wrapperStyle: {
    display: 'inline-block'
  },
  inputProps: {},
  onChange: function () {
    function onChange() {}

    return onChange;
  }(),
  onSelect: function () {
    function onSelect() {}

    return onSelect;
  }(),
  renderMenu: function () {
    function renderMenu(items, value, style) {
      return _react2['default'].createElement('div', {
        children: items,
        style: _extends({}, style, this.menuStyle)
      });
    }

    return renderMenu;
  }(),
  shouldItemRender: function () {
    function shouldItemRender() {
      return true;
    }

    return shouldItemRender;
  }(),

  menuStyle: {
    borderRadius: '3px',
    boxShadow: '0 2px 12px rgba(0, 0, 0, 0.1)',
    background: 'rgba(255, 255, 255, 0.9)',
    padding: '2px 0',
    fontSize: '90%',
    position: 'fixed',
    overflow: 'auto',
    maxHeight: '50%' // TODO: don't cheat, let it flow to the bottom
  },
  autoHighlight: true,
  onMenuVisibilityChange: function () {
    function onMenuVisibilityChange() {}

    return onMenuVisibilityChange;
  }()
};

Autocomplete.propTypes = {
  autoHighlight: _propTypes2['default'].bool,
  debug: _propTypes2['default'].bool,
  getItemValue: _propTypes2['default'].func.isRequired,
  inputProps: _propTypes2['default'].object,
  items: _propTypes2['default'].array,
  menuStyle: _propTypes2['default'].object,
  onChange: _propTypes2['default'].func,
  onFocus: _propTypes2['default'].func,
  onMenuVisibilityChange: _propTypes2['default'].func,
  onSelect: _propTypes2['default'].func,
  open: _propTypes2['default'].bool,
  renderItem: _propTypes2['default'].func.isRequired,
  renderMenu: _propTypes2['default'].func,
  shouldItemRender: _propTypes2['default'].func,
  sortItems: _propTypes2['default'].func,
  value: _propTypes2['default'].any,
  wrapperProps: _propTypes2['default'].object,
  wrapperStyle: _propTypes2['default'].object
};

exports['default'] = Autocomplete;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)))

/***/ }),
/* 704 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(705);

/***/ }),
/* 705 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(706);

function scrollIntoView(elem, container, config) {
  config = config || {};
  // document  window
  if (container.nodeType === 9) {
    container = util.getWindow(container);
  }

  var allowHorizontalScroll = config.allowHorizontalScroll;
  var onlyScrollIfNeeded = config.onlyScrollIfNeeded;
  var alignWithTop = config.alignWithTop;
  var alignWithLeft = config.alignWithLeft;
  var offsetTop = config.offsetTop || 0;
  var offsetLeft = config.offsetLeft || 0;
  var offsetBottom = config.offsetBottom || 0;
  var offsetRight = config.offsetRight || 0;

  allowHorizontalScroll = allowHorizontalScroll === undefined ? true : allowHorizontalScroll;

  var isWin = util.isWindow(container);
  var elemOffset = util.offset(elem);
  var eh = util.outerHeight(elem);
  var ew = util.outerWidth(elem);
  var containerOffset = undefined;
  var ch = undefined;
  var cw = undefined;
  var containerScroll = undefined;
  var diffTop = undefined;
  var diffBottom = undefined;
  var win = undefined;
  var winScroll = undefined;
  var ww = undefined;
  var wh = undefined;

  if (isWin) {
    win = container;
    wh = util.height(win);
    ww = util.width(win);
    winScroll = {
      left: util.scrollLeft(win),
      top: util.scrollTop(win)
    };
    // elem  container 
    diffTop = {
      left: elemOffset.left - winScroll.left - offsetLeft,
      top: elemOffset.top - winScroll.top - offsetTop
    };
    diffBottom = {
      left: elemOffset.left + ew - (winScroll.left + ww) + offsetRight,
      top: elemOffset.top + eh - (winScroll.top + wh) + offsetBottom
    };
    containerScroll = winScroll;
  } else {
    containerOffset = util.offset(container);
    ch = container.clientHeight;
    cw = container.clientWidth;
    containerScroll = {
      left: container.scrollLeft,
      top: container.scrollTop
    };
    // elem  container 
    // , offset 
    diffTop = {
      left: elemOffset.left - (containerOffset.left + (parseFloat(util.css(container, 'borderLeftWidth')) || 0)) - offsetLeft,
      top: elemOffset.top - (containerOffset.top + (parseFloat(util.css(container, 'borderTopWidth')) || 0)) - offsetTop
    };
    diffBottom = {
      left: elemOffset.left + ew - (containerOffset.left + cw + (parseFloat(util.css(container, 'borderRightWidth')) || 0)) + offsetRight,
      top: elemOffset.top + eh - (containerOffset.top + ch + (parseFloat(util.css(container, 'borderBottomWidth')) || 0)) + offsetBottom
    };
  }

  if (diffTop.top < 0 || diffBottom.top > 0) {
    // 
    if (alignWithTop === true) {
      util.scrollTop(container, containerScroll.top + diffTop.top);
    } else if (alignWithTop === false) {
      util.scrollTop(container, containerScroll.top + diffBottom.top);
    } else {
      // 
      if (diffTop.top < 0) {
        util.scrollTop(container, containerScroll.top + diffTop.top);
      } else {
        util.scrollTop(container, containerScroll.top + diffBottom.top);
      }
    }
  } else {
    if (!onlyScrollIfNeeded) {
      alignWithTop = alignWithTop === undefined ? true : !!alignWithTop;
      if (alignWithTop) {
        util.scrollTop(container, containerScroll.top + diffTop.top);
      } else {
        util.scrollTop(container, containerScroll.top + diffBottom.top);
      }
    }
  }

  if (allowHorizontalScroll) {
    if (diffTop.left < 0 || diffBottom.left > 0) {
      // 
      if (alignWithLeft === true) {
        util.scrollLeft(container, containerScroll.left + diffTop.left);
      } else if (alignWithLeft === false) {
        util.scrollLeft(container, containerScroll.left + diffBottom.left);
      } else {
        // 
        if (diffTop.left < 0) {
          util.scrollLeft(container, containerScroll.left + diffTop.left);
        } else {
          util.scrollLeft(container, containerScroll.left + diffBottom.left);
        }
      }
    } else {
      if (!onlyScrollIfNeeded) {
        alignWithLeft = alignWithLeft === undefined ? true : !!alignWithLeft;
        if (alignWithLeft) {
          util.scrollLeft(container, containerScroll.left + diffTop.left);
        } else {
          util.scrollLeft(container, containerScroll.left + diffBottom.left);
        }
      }
    }
  }
}

module.exports = scrollIntoView;

/***/ }),
/* 706 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

function getClientPosition(elem) {
  var box = undefined;
  var x = undefined;
  var y = undefined;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  //  GBS A-Grade Browsers  getBoundingClientRect 
  box = elem.getBoundingClientRect();

  // jQuery  docElem.clientLeft/clientTop
  //  html  body /
  // ie6  html  margin  html  margin

  x = box.left;
  y = box.top;

  // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.

  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.

  // ie  absolute 
  //  documentElement ,quirks  body
  //  body  html   ie < 9 html  2px 
  //  ie body html  ,ie  html,body 
  //  ie  docElem.clientTop  border-top
  // ie7 html  2
  //  firefox/chrome/ie9  docElem.clientTop  border-top  0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;

  return {
    left: x,
    top: y
  };
}

function getScroll(w, top) {
  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
  var method = 'scroll' + (top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = w.document;
    // ie6,7,8 standard mode
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }
  return ret;
}

function getScrollLeft(w) {
  return getScroll(w);
}

function getScrollTop(w) {
  return getScroll(w, true);
}

function getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}
function _getComputedStyle(elem, name, computedStyle_) {
  var val = '';
  var d = elem.ownerDocument;
  var computedStyle = computedStyle_ || d.defaultView.getComputedStyle(elem, null);

  // https://github.com/kissyteam/kissy/issues/61
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }

  return val;
}

var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var LEFT = 'left';
var PX = 'px';

function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

  //  width/height  pixelLeft  width/height 
  // ! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook @2011-08-19
  //  ie  offset 
  // borderWidth  borderWidth 

  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT];

    // prevent flashing of content
    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

    // Put in the new values to get a computed value out
    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX;

    // Revert the changed values
    style[LEFT] = left;

    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }
  return ret === '' ? 'auto' : ret;
}

var getComputedStyleX = undefined;
if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}

function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}

function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}

var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;

function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name = undefined;

  // Remember the old values, and insert the new ones
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }

  callback.call(elem);

  // Revert the old values
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}

function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop = undefined;
  var j = undefined;
  var i = undefined;
  for (j = 0; j < props.length; j++) {
    prop = props[j];
    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = undefined;
        if (prop === 'border') {
          cssProp = prop + which[i] + 'Width';
        } else {
          cssProp = prop + which[i];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}

/**
 * A crude way of determining if an object is a window
 * @member util
 */
function isWindow(obj) {
  // must use == for ie8
  /* eslint eqeqeq:0 */
  return obj != null && obj == obj.window;
}

var domUtils = {};

each(['Width', 'Height'], function (name) {
  domUtils['doc' + name] = function (refWin) {
    var d = refWin.document;
    return Math.max(
    // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement['scroll' + name],
    // quirks : documentElement.scrollHeight 
    d.body['scroll' + name], domUtils['viewport' + name](d));
  };

  domUtils['viewport' + name] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = 'client' + name;
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    //  documentElement
    // backcompat  body
    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});

/*
 
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */
function getWH(elem, name, extra) {
  if (isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
  var computedStyle = getComputedStyleX(elem);
  var isBorderBox = isBorderBoxFn(elem, computedStyle);
  var cssBoxValue = 0;
  if (borderBoxValue == null || borderBoxValue <= 0) {
    borderBoxValue = undefined;
    // Fall back to computed then un computed css if necessary
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue == null || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    // Normalize '', auto, and prepare for extra
    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }
  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
    }
    return cssBoxValue;
  }
  if (borderBoxValueOrIsBorderBox) {
    var padding = extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle);
    return val + (extra === BORDER_INDEX ? 0 : padding);
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
}

var cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
};

// fix #119 : https://github.com/kissyteam/kissy/issues/119
function getWHIgnoreDisplay(elem) {
  var val = undefined;
  var args = arguments;
  // in case elem is window
  // elem.offsetWidth === undefined
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }
  return val;
}

function css(el, name, v) {
  var value = v;
  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }
    return undefined;
  }
  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value += 'px';
    }
    el.style[name] = value;
    return undefined;
  }
  return getComputedStyleX(el, name);
}

each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);
  domUtils['outer' + first] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

  domUtils[name] = function (elem, val) {
    if (val !== undefined) {
      if (elem) {
        var computedStyle = getComputedStyleX(elem);
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
        }
        return css(elem, name, val);
      }
      return undefined;
    }
    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});

//  elem  elem.ownerDocument 
function setOffset(elem, offset) {
  // set position first, in-case top/left are set even on static elem
  if (css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }

  var old = getOffset(elem);
  var ret = {};
  var current = undefined;
  var key = undefined;

  for (key in offset) {
    if (offset.hasOwnProperty(key)) {
      current = parseFloat(css(elem, key)) || 0;
      ret[key] = current + offset[key] - old[key];
    }
  }
  css(elem, ret);
}

module.exports = _extends({
  getWindow: function getWindow(node) {
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  offset: function offset(el, value) {
    if (typeof value !== 'undefined') {
      setOffset(el, value);
    } else {
      return getOffset(el);
    }
  },

  isWindow: isWindow,
  each: each,
  css: css,
  clone: function clone(obj) {
    var ret = {};
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }
    return ret;
  },
  scrollLeft: function scrollLeft(w, v) {
    if (isWindow(w)) {
      if (v === undefined) {
        return getScrollLeft(w);
      }
      window.scrollTo(v, getScrollTop(w));
    } else {
      if (v === undefined) {
        return w.scrollLeft;
      }
      w.scrollLeft = v;
    }
  },
  scrollTop: function scrollTop(w, v) {
    if (isWindow(w)) {
      if (v === undefined) {
        return getScrollTop(w);
      }
      window.scrollTo(getScrollLeft(w), v);
    } else {
      if (v === undefined) {
        return w.scrollTop;
      }
      w.scrollTop = v;
    }
  },

  viewportWidth: 0,
  viewportHeight: 0
}, domUtils);

/***/ }),
/* 707 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"genome-position-search":"GenomePositionSearchBox-module_genome-position-search-SYccr","genome-position-search-focus":"GenomePositionSearchBox-module_genome-position-search-focus-23by2","genome-position-search-bar":"GenomePositionSearchBox-module_genome-position-search-bar-1_0ZU","genome-position-search-bar-button":"GenomePositionSearchBox-module_genome-position-search-bar-button-33SWJ","genome-position-search-bar-button-focus":"GenomePositionSearchBox-module_genome-position-search-bar-button-focus-1IhAk","genome-position-search-bar-icon":"GenomePositionSearchBox-module_genome-position-search-bar-icon-14AEk","genome-position-search-bar-icon-focus":"GenomePositionSearchBox-module_genome-position-search-bar-icon-focus-1Ay7Z","genome-position-search-bar-suggestions":"GenomePositionSearchBox-module_genome-position-search-bar-suggestions-SrIoU","btn":"GenomePositionSearchBox-module_btn-2bTUd","btn-sm":"GenomePositionSearchBox-module_btn-sm-2Ltms","btn-default":"GenomePositionSearchBox-module_btn-default-2pap4"};

/***/ }),
/* 708 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExportLinkModal = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(236);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(8);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactColor = __webpack_require__(231);

var _SketchInlinePicker = __webpack_require__(223);

var _SketchInlinePicker2 = _interopRequireDefault(_SketchInlinePicker);

var _slugid = __webpack_require__(11);

var _slugid2 = _interopRequireDefault(_slugid);

var _reactBootstrap = __webpack_require__(59);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ExportLinkModal = exports.ExportLinkModal = function (_React$Component) {
  _inherits(ExportLinkModal, _React$Component);

  function ExportLinkModal(props) {
    _classCallCheck(this, ExportLinkModal);

    // props should include the definition of the heatmap data series


    var _this = _possibleConstructorReturn(this, (ExportLinkModal.__proto__ || Object.getPrototypeOf(ExportLinkModal)).call(this, props));

    _this.state = {};
    return _this;
  }

  _createClass(ExportLinkModal, [{
    key: 'render',
    value: function () {
      function render() {
        var linkLocation = this.props.linkLocation ? _react2['default'].createElement('input', {
          style: { width: 500 },
          value: this.props.linkLocation,
          readOnly: true
        }) :

        //
        _react2['default'].createElement(
          'div',
          null,
          _react2['default'].createElement('span', { className: 'glyphicon glyphicon-refresh glyphicon-refresh-animate', 'aria-hidden': 'true' }),
          _react2['default'].createElement(
            'span',
            null,
            '\xA0\xA0We are generating your link...'
          )
        );

        //
        return _react2['default'].createElement(
          'div',
          {
            className: 'modal-container',
            style: {
              position: 'absolute',
              left: 0,
              top: 0,
              height: this.props.height,
              width: this.props.width
            }
          },
          _react2['default'].createElement(
            _reactBootstrap.Modal,
            {
              onHide: this.props.onDone,
              container: this,
              className: 'hg-modal',
              show: true
            },
            _react2['default'].createElement(
              _reactBootstrap.Modal.Header,
              { closeButton: true },
              _react2['default'].createElement(
                _reactBootstrap.Modal.Title,
                null,
                'Share view link'
              )
            ),
            _react2['default'].createElement(
              _reactBootstrap.Modal.Body,
              null,
              linkLocation
            ),
            _react2['default'].createElement(
              _reactBootstrap.Modal.Footer,
              null,
              _react2['default'].createElement(
                _reactBootstrap.Button,
                { onClick: this.props.onDone },
                'Done'
              )
            )
          )
        );
      }

      return render;
    }()
  }]);

  return ExportLinkModal;
}(_react2['default'].Component);

exports['default'] = ExportLinkModal;

/***/ }),
/* 709 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSymbolIcon = createSymbolIcon;
/**
 * Create a path-based symbol icon
 *
 * @method  createSymbolIcon
 * @author  Fritz Lekschas
 * @date    2016-10-09
 * @param   {Object}  el       D3 selected base element to where the symbols
 *   should be appended to.
 * @param   {String}  id       ID of the icon to be created.
 * @param   {Array}   paths    Array of path strings.
 * @param   {String}  viewBox  View box string.
 */
function createSymbolIcon(el, id, paths, viewBox) {
  var symbol = el.append('symbol').attr('id', id).attr('viewBox', viewBox);

  paths.forEach(function (d) {
    return symbol.append('path').attr('d', d).attr('fill', 'currentColor');
  });
}

/***/ }),
/* 710 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ViewHeader = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _getClassName2 = __webpack_require__(36);

var _getClassName3 = _interopRequireDefault(_getClassName2);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _PopupMenu = __webpack_require__(143);

var _ContextMenuContainer = __webpack_require__(62);

var _ContextMenuContainer2 = _interopRequireDefault(_ContextMenuContainer);

var _ConfigViewMenu = __webpack_require__(711);

var _AddTrackPositionMenu = __webpack_require__(712);

var _configs = __webpack_require__(6);

__webpack_require__(250);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _styleModuleImportMap = {
  '../styles/ViewHeader.module.scss': {
    'multitrack-header': 'ViewHeader-module_multitrack-header-3XnZx',
    'multitrack-header-focus': 'ViewHeader-module_multitrack-header-focus-3akkN',
    'multitrack-header-squeazed': 'ViewHeader-module_multitrack-header-squeazed-GHIVd',
    'multitrack-header-id': 'ViewHeader-module_multitrack-header-id-3YURk',
    'multitrack-header-left': 'ViewHeader-module_multitrack-header-left-Qj9Sm',
    'multitrack-header-grabber': 'ViewHeader-module_multitrack-header-grabber-3jrIz',
    'multitrack-header-grabber-squeazed': 'ViewHeader-module_multitrack-header-grabber-squeazed-dU45Z',
    'multitrack-header-search': 'ViewHeader-module_multitrack-header-search-1X_3_',
    'multitrack-header-nav-list': 'ViewHeader-module_multitrack-header-nav-list-2nvcu',
    'multitrack-header-icon': 'ViewHeader-module_multitrack-header-icon-16QKZ',
    'multitrack-header-icon-squeazed': 'ViewHeader-module_multitrack-header-icon-squeazed-25lkF'
  }
};

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Configs


// Styles


var ViewHeader = exports.ViewHeader = function (_React$Component) {
  _inherits(ViewHeader, _React$Component);

  function ViewHeader(props) {
    _classCallCheck(this, ViewHeader);

    var _this = _possibleConstructorReturn(this, (ViewHeader.__proto__ || Object.getPrototypeOf(ViewHeader)).call(this, props));

    _this.configImg = null;
    _this.plusImg = null;

    _this.state = {
      addTrackPositionMenuUid: null,
      addTrackPositionMenuPosition: null,
      configMenuUid: null,
      configMenuPosition: null,
      isFocused: false,
      width: -1
    };
    return _this;
  }

  _createClass(ViewHeader, [{
    key: 'componentDidMount',
    value: function () {
      function componentDidMount() {
        this.setState({ width: this.el.clientWidth });
      }

      return componentDidMount;
    }()
  }, {
    key: 'checkWidth',
    value: function () {
      function checkWidth() {
        var width = this.el.clientWidth;

        if (width !== this.state.width) this.setState({ width: width });
      }

      return checkWidth;
    }()

    /**
     * The user clicked on the `cog` of the menu so we need to open
     * it.
     */

  }, {
    key: 'handleConfigMenuOpened',
    value: function () {
      function handleConfigMenuOpened(uid) {
        this.setState({
          configMenuUid: uid,
          configMenuPosition: this.configImg.getBoundingClientRect()
        });
      }

      return handleConfigMenuOpened;
    }()

    /**
     * The user has clicked on the 'plus' sign at the top of a TiledPlot
     * so we need to open the Track Position Chooser dialog
     */

  }, {
    key: 'handleAddTrackPositionMenuOpened',
    value: function () {
      function handleAddTrackPositionMenuOpened(uid) {
        this.setState({
          addTrackPositionMenuUid: uid,
          addTrackPositionMenuPosition: this.plusImg.getBoundingClientRect()
        });
      }

      return handleAddTrackPositionMenuOpened;
    }()

    /**
     * The user has chosen a position for the new track. The actual
     * track selection will be handled by TiledPlot
     *
     * We just need to close the menu here.
     */

  }, {
    key: 'handleTrackPositionChosen',
    value: function () {
      function handleTrackPositionChosen(position) {
        this.props.onTrackPositionChosen(position);

        this.setState({
          addTrackPositionMenuUid: null,
          addTrackPositionMenuPosition: null
        });
      }

      return handleTrackPositionChosen;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        var configMenu = null;
        var addTrackPositionMenu = null;

        if (this.state.addTrackPositionMenuPosition) {
          addTrackPositionMenu = _react2['default'].createElement(
            _PopupMenu.PopupMenu,
            {
              onMenuClosed: function () {
                function onMenuClosed() {
                  _this2.setState({
                    addTrackPositionMenuUid: null,
                    addTrackPositionMenuPosition: null
                  });
                }

                return onMenuClosed;
              }()
            },
            _react2['default'].createElement(
              _ContextMenuContainer2['default'],
              {
                orientation: 'left',
                position: this.state.addTrackPositionMenuPosition
              },
              _react2['default'].createElement(_AddTrackPositionMenu.AddTrackPositionMenu, {
                onTrackPositionChosen: this.handleTrackPositionChosen.bind(this)
              })
            )
          );
        }

        if (this.state.configMenuUid) {
          configMenu = _react2['default'].createElement(
            _PopupMenu.PopupMenu,
            {
              onMenuClosed: function () {
                function onMenuClosed() {
                  return _this2.setState({ configMenuUid: null });
                }

                return onMenuClosed;
              }()
            },
            _react2['default'].createElement(
              _ContextMenuContainer2['default'],
              {
                orientation: 'left',
                position: this.state.configMenuPosition
              },
              _react2['default'].createElement(_ConfigViewMenu.ConfigViewMenu, {
                onExportSVG: function () {
                  function onExportSVG() {
                    _this2.setState({ configMenuUid: null });
                    _this2.props.onExportSVG();
                  }

                  return onExportSVG;
                }(),
                onClearView: function () {
                  function onClearView() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onClearView();
                  }

                  return onClearView;
                }(),
                onExportViewAsJSON: function () {
                  function onExportViewAsJSON() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onExportViewsAsJSON();
                  }

                  return onExportViewAsJSON;
                }(),
                onExportViewAsLink: function () {
                  function onExportViewAsLink() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onExportViewsAsLink();
                  }

                  return onExportViewAsLink;
                }(),
                onLockLocation: function () {
                  function onLockLocation() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onLockLocation(_this2.state.configMenuUid);
                  }

                  return onLockLocation;
                }(),
                onLockZoom: function () {
                  function onLockZoom() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onLockZoom(_this2.state.configMenuUid);
                  }

                  return onLockZoom;
                }(),
                onLockZoomAndLocation: function () {
                  function onLockZoomAndLocation() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onLockZoomAndLocation(_this2.state.configMenuUid);
                  }

                  return onLockZoomAndLocation;
                }(),
                onProjectViewport: function () {
                  function onProjectViewport() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onProjectViewport(_this2.state.configMenuUid);
                  }

                  return onProjectViewport;
                }(),
                onTakeAndLockZoomAndLocation: function () {
                  function onTakeAndLockZoomAndLocation() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onTakeAndLockZoomAndLocation(_this2.state.configMenuUid);
                  }

                  return onTakeAndLockZoomAndLocation;
                }(),
                onTogglePositionSearchBox: function () {
                  function onTogglePositionSearchBox() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onTogglePositionSearchBox(_this2.state.configMenuUid);
                  }

                  return onTogglePositionSearchBox;
                }(),
                onUnlockLocation: function () {
                  function onUnlockLocation() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onUnlockLocation(_this2.state.configMenuUid);
                  }

                  return onUnlockLocation;
                }(),
                onUnlockZoom: function () {
                  function onUnlockZoom() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onUnlockZoom(_this2.state.configMenuUid);
                  }

                  return onUnlockZoom;
                }(),
                onUnlockZoomAndLocation: function () {
                  function onUnlockZoomAndLocation() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onUnlockZoomAndLocation(_this2.state.configMenuUid);
                  }

                  return onUnlockZoomAndLocation;
                }(),
                onYankLocation: function () {
                  function onYankLocation() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onYankLocation(_this2.state.configMenuUid);
                  }

                  return onYankLocation;
                }(),
                onYankZoom: function () {
                  function onYankZoom() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onYankZoom(_this2.state.configMenuUid);
                  }

                  return onYankZoom;
                }(),
                onYankZoomAndLocation: function () {
                  function onYankZoomAndLocation() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onYankZoomAndLocation(_this2.state.configMenuUid);
                  }

                  return onYankZoomAndLocation;
                }(),
                onZoomToData: function () {
                  function onZoomToData() {
                    _this2.setState({ configMenuUid: null }); // hide the menu
                    _this2.props.onZoomToData(_this2.state.configMenuUid);
                  }

                  return onZoomToData;
                }()
              })
            )
          );
        }

        var GenomePositionSearchBox = this.props.getGenomePositionSearchBox(this.state.isFocused, function (focus) {
          _this2.setState({
            isFocused: focus
          });
        });

        var className = this.state.isFocused ? 'multitrack-header-focus' : 'multitrack-header';

        var classNameIcon = this.state.width <= _configs.VIEW_HEADER_MED_WIDTH_SEARCH_BAR ? 'multitrack-header-icon-squeazed' : 'multitrack-header-icon';

        return _react2['default'].createElement(
          'div',
          {
            ref: function () {
              function ref(c) {
                _this2.el = c;
              }

              return ref;
            }(),
            className: (0, _getClassName3['default'])(className, _styleModuleImportMap)
          },
          _react2['default'].createElement(
            'div',
            { className: 'ViewHeader-module_multitrack-header-left-Qj9Sm' },
            _react2['default'].createElement(
              'div',
              { className: 'ViewHeader-module_multitrack-header-grabber-3jrIz' },
              _react2['default'].createElement('div', null),
              _react2['default'].createElement('div', null),
              _react2['default'].createElement('div', null)
            ),
            this.state.width > _configs.VIEW_HEADER_MIN_WIDTH_SEARCH_BAR && _react2['default'].createElement(
              'div',
              { className: 'ViewHeader-module_multitrack-header-search-1X_3_' },
              this.props.isGenomePositionSearchBoxVisible && GenomePositionSearchBox
            )
          ),
          _react2['default'].createElement(
            'nav',
            { className: 'ViewHeader-module_multitrack-header-nav-list-2nvcu' },
            _react2['default'].createElement(
              'svg',
              {
                onClick: this.props.onAddView,
                className: (0, _getClassName3['default'])(classNameIcon, _styleModuleImportMap)
              },
              _react2['default'].createElement('use', { xlinkHref: '#copy' })
            ),
            _react2['default'].createElement(
              'svg',
              {
                ref: function () {
                  function ref(c) {
                    _this2.configImg = c;
                  }

                  return ref;
                }(),
                onClick: function () {
                  function onClick() {
                    return _this2.handleConfigMenuOpened(_this2.props.viewUid);
                  }

                  return onClick;
                }(),
                className: (0, _getClassName3['default'])(classNameIcon, _styleModuleImportMap)
              },
              _react2['default'].createElement('use', { xlinkHref: '#cog' })
            ),
            _react2['default'].createElement(
              'svg',
              {
                ref: function () {
                  function ref(c) {
                    _this2.plusImg = c;
                  }

                  return ref;
                }(),
                onClick: function () {
                  function onClick() {
                    return _this2.handleAddTrackPositionMenuOpened(_this2.props.viewUid);
                  }

                  return onClick;
                }(),
                className: (0, _getClassName3['default'])(classNameIcon, _styleModuleImportMap)
              },
              _react2['default'].createElement('use', { xlinkHref: '#plus' })
            ),
            _react2['default'].createElement(
              'svg',
              {
                onClick: this.props.onCloseView,
                className: (0, _getClassName3['default'])(classNameIcon, _styleModuleImportMap)
              },
              _react2['default'].createElement('use', { xlinkHref: '#cross' })
            )
          ),
          configMenu,
          addTrackPositionMenu
        );
      }

      return render;
    }()
  }]);

  return ViewHeader;
}(_react2['default'].Component);

ViewHeader.defaultProps = {
  isGenomePositionSearchBoxVisible: false
};

ViewHeader.propTypes = {
  getGenomePositionSearchBox: _propTypes.PropTypes.func.isRequired,
  isGenomePositionSearchBoxVisible: _propTypes.PropTypes.bool,
  onAddView: _propTypes.PropTypes.func.isRequired,
  onClearView: _propTypes.PropTypes.func.isRequired,
  onCloseView: _propTypes.PropTypes.func.isRequired,
  onExportSVG: _propTypes.PropTypes.func.isRequired,
  onExportViewsAsJSON: _propTypes.PropTypes.func.isRequired,
  onExportViewsAsLink: _propTypes.PropTypes.func.isRequired,
  onLockLocation: _propTypes.PropTypes.func.isRequired,
  onLockZoom: _propTypes.PropTypes.func.isRequired,
  onLockZoomAndLocation: _propTypes.PropTypes.func.isRequired,
  onProjectViewport: _propTypes.PropTypes.func.isRequired,
  onTakeAndLockZoomAndLocation: _propTypes.PropTypes.func.isRequired,
  onTogglePositionSearchBox: _propTypes.PropTypes.func.isRequired,
  onTrackPositionChosen: _propTypes.PropTypes.func.isRequired,
  onUnlockLocation: _propTypes.PropTypes.func.isRequired,
  onUnlockZoom: _propTypes.PropTypes.func.isRequired,
  onUnlockZoomAndLocation: _propTypes.PropTypes.func.isRequired,
  onYankLocation: _propTypes.PropTypes.func.isRequired,
  onYankZoom: _propTypes.PropTypes.func.isRequired,
  onYankZoomAndLocation: _propTypes.PropTypes.func.isRequired,
  onZoomToData: _propTypes.PropTypes.func.isRequired,
  viewUid: _propTypes.PropTypes.string.isRequired
};

exports['default'] = ViewHeader;

/***/ }),
/* 711 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConfigViewMenu = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _ContextMenuItem = __webpack_require__(63);

var _ContextMenuItem2 = _interopRequireDefault(_ContextMenuItem);

__webpack_require__(44);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Styles


var ConfigViewMenu = exports.ConfigViewMenu = function (_React$Component) {
  _inherits(ConfigViewMenu, _React$Component);

  function ConfigViewMenu() {
    _classCallCheck(this, ConfigViewMenu);

    return _possibleConstructorReturn(this, (ConfigViewMenu.__proto__ || Object.getPrototypeOf(ConfigViewMenu)).apply(this, arguments));
  }

  _createClass(ConfigViewMenu, [{
    key: 'render',
    value: function () {
      function render() {
        var _this2 = this;

        return _react2['default'].createElement(
          'div',
          null,
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick(e) {
                  return _this2.props.onTogglePositionSearchBox(e);
                }

                return onClick;
              }()
            },
            'Toggle position search box'
          ),
          _react2['default'].createElement('hr', { className: 'ContextMenu-module_context-menu-hr-3yapb' }),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick(e) {
                  return _this2.props.onZoomToData(e);
                }

                return onClick;
              }()
            },
            'Zoom to data extent'
          ),
          _react2['default'].createElement('hr', { className: 'ContextMenu-module_context-menu-hr-3yapb' }),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick(e) {
                  return _this2.props.onClearView(e);
                }

                return onClick;
              }()
            },
            'Clear View'
          ),
          _react2['default'].createElement('hr', { className: 'ContextMenu-module_context-menu-hr-3yapb' }),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick(e) {
                  return _this2.props.onYankZoom(e);
                }

                return onClick;
              }()
            },
            'Take zoom from'
          ),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick(e) {
                  return _this2.props.onYankLocation(e);
                }

                return onClick;
              }()
            },
            'Take location from'
          ),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick(e) {
                  return _this2.props.onYankZoomAndLocation(e);
                }

                return onClick;
              }()
            },
            'Take zoom and location from'
          ),
          _react2['default'].createElement('hr', { className: 'ContextMenu-module_context-menu-hr-3yapb' }),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: this.props.onLockZoom
            },
            'Lock zoom with'
          ),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: this.props.onLockLocation
            },
            'Lock location with'
          ),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: this.props.onLockZoomAndLocation
            },
            'Lock zoom and location with'
          ),
          _react2['default'].createElement('hr', { className: 'ContextMenu-module_context-menu-hr-3yapb' }),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: this.props.onTakeAndLockZoomAndLocation
            },
            'Take and lock zoom and location with'
          ),
          _react2['default'].createElement('hr', { className: 'ContextMenu-module_context-menu-hr-3yapb' }),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick(e) {
                  return _this2.props.onUnlockZoom(e);
                }

                return onClick;
              }()
            },
            'Unlock zoom'
          ),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick(e) {
                  return _this2.props.onUnlockLocation(e);
                }

                return onClick;
              }()
            },
            'Unlock location'
          ),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick(e) {
                  return _this2.props.onUnlockZoomAndLocation(e);
                }

                return onClick;
              }()
            },
            'Unlock zoom and location'
          ),
          _react2['default'].createElement('hr', { className: 'ContextMenu-module_context-menu-hr-3yapb' }),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick(e) {
                  return _this2.props.onProjectViewport(e);
                }

                return onClick;
              }()
            },
            'Show this viewport on'
          ),
          _react2['default'].createElement('hr', { className: 'ContextMenu-module_context-menu-hr-3yapb' }),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick() {
                  return _this2.props.onExportSVG();
                }

                return onClick;
              }()
            },
            'Export views as SVG'
          ),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick() {
                  return _this2.props.onExportViewAsJSON();
                }

                return onClick;
              }()
            },
            'Export views as JSON'
          ),
          _react2['default'].createElement(
            _ContextMenuItem2['default'],
            {
              onClick: function () {
                function onClick() {
                  return _this2.props.onExportViewAsLink();
                }

                return onClick;
              }()
            },
            'Export views as Link'
          )
        );
      }

      return render;
    }()
  }]);

  return ConfigViewMenu;
}(_react2['default'].Component);

ConfigViewMenu.propTypes = {
  onExportSVG: _propTypes2['default'].func,
  onExportViewAsJSON: _propTypes2['default'].func,
  onExportViewAsLink: _propTypes2['default'].func,
  onLockLocation: _propTypes2['default'].func,
  onLockZoom: _propTypes2['default'].func,
  onLockZoomAndLocation: _propTypes2['default'].func,
  onProjectViewport: _propTypes2['default'].func,
  onTakeAndLockZoomAndLocation: _propTypes2['default'].func,
  onTogglePositionSearchBox: _propTypes2['default'].func,
  onUnlockLocation: _propTypes2['default'].func,
  onUnlockZoom: _propTypes2['default'].func,
  onUnlockZoomAndLocation: _propTypes2['default'].func,
  onYankLocation: _propTypes2['default'].func,
  onYankZoom: _propTypes2['default'].func,
  onYankZoomAndLocation: _propTypes2['default'].func,
  onZoomToData: _propTypes2['default'].func
};

exports['default'] = ConfigViewMenu;

/***/ }),
/* 712 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AddTrackPositionMenu = undefined;

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

__webpack_require__(713);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var AddTrackPositionMenu = exports.AddTrackPositionMenu = function () {
  function AddTrackPositionMenu(props) {
    return _react2['default'].createElement(
      'div',
      null,
      _react2['default'].createElement(
        'div',
        { className: 'AddTrackPositionMenu-module_add-track-position-span-2hbwE' },
        'Add Track...'
      ),
      _react2['default'].createElement(
        'table',
        { className: 'AddTrackPositionMenu-module_add-track-position-table-RHODc' },
        _react2['default'].createElement(
          'tbody',
          null,
          _react2['default'].createElement(
            'tr',
            null,
            _react2['default'].createElement('td', { className: 'AddTrackPositionMenu-module_add-track-position-other-lIGbb' }),
            _react2['default'].createElement(
              'td',
              {
                onClick: function () {
                  function onClick() {
                    return props.onTrackPositionChosen('top');
                  }

                  return onClick;
                }(),
                className: 'AddTrackPositionMenu-module_add-track-position-top-center-2Dw4e'
              },
              'top'
            ),
            _react2['default'].createElement('td', { className: 'AddTrackPositionMenu-module_add-track-position-other-lIGbb' })
          ),
          _react2['default'].createElement(
            'tr',
            { style: { height: '80px' } },
            _react2['default'].createElement(
              'td',
              {
                onClick: function () {
                  function onClick() {
                    return props.onTrackPositionChosen('left');
                  }

                  return onClick;
                }(),
                className: 'AddTrackPositionMenu-module_add-track-position-middle-left-2ycaN'
              },
              'left'
            ),
            _react2['default'].createElement(
              'td',
              {
                onClick: function () {
                  function onClick() {
                    return props.onTrackPositionChosen('center');
                  }

                  return onClick;
                }(),
                className: 'AddTrackPositionMenu-module_add-track-position-middle-middle-2YFZd'
              },
              'center'
            ),
            _react2['default'].createElement(
              'td',
              {
                onClick: function () {
                  function onClick() {
                    return props.onTrackPositionChosen('right');
                  }

                  return onClick;
                }(),
                className: 'AddTrackPositionMenu-module_add-track-position-middle-right-Qqjnn'
              },
              'right'
            )
          ),
          _react2['default'].createElement(
            'tr',
            null,
            _react2['default'].createElement('td', { className: 'AddTrackPositionMenu-module_add-track-position-other-lIGbb' }),
            _react2['default'].createElement(
              'td',
              {
                onClick: function () {
                  function onClick() {
                    return props.onTrackPositionChosen('bottom');
                  }

                  return onClick;
                }(),
                className: 'AddTrackPositionMenu-module_add-track-position-bottom-middle-3ityE'
              },
              'bottom'
            ),
            _react2['default'].createElement('td', { className: 'AddTrackPositionMenu-module_add-track-position-other-lIGbb' })
          )
        )
      )
    );
  }

  return AddTrackPositionMenu;
}();

AddTrackPositionMenu.propTypes = {
  onTrackPositionChosen: _propTypes2['default'].func
};

exports['default'] = AddTrackPositionMenu;

/***/ }),
/* 713 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"add-track-position-table":"AddTrackPositionMenu-module_add-track-position-table-RHODc","add-track-position-other":"AddTrackPositionMenu-module_add-track-position-other-lIGbb","add-track-position-top-center":"AddTrackPositionMenu-module_add-track-position-top-center-2Dw4e","add-track-position-middle-left":"AddTrackPositionMenu-module_add-track-position-middle-left-2ycaN","add-track-position-middle-right":"AddTrackPositionMenu-module_add-track-position-middle-right-Qqjnn","add-track-position-middle-middle":"AddTrackPositionMenu-module_add-track-position-middle-middle-2YFZd","add-track-position-bottom-middle":"AddTrackPositionMenu-module_add-track-position-bottom-middle-3ityE","add-track-position-span":"AddTrackPositionMenu-module_add-track-position-span-2hbwE"};

/***/ }),
/* 714 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.api = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _utils = __webpack_require__(3);

var _configs = __webpack_require__(6);

var _pubSub = __webpack_require__(40);

var _pubSub2 = _interopRequireDefault(_pubSub);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var api = exports.api = function () {
  function api(context) {
    var self = context;

    return {
      setViewConfig: function () {
        function setViewConfig(newViewConfig) {
          var _this = this;

          /**
           * Set a new view config to define the layout and data
           * of this component
           *
           * Parameters
           * ----------
           *  newViewConfig: {}
           *    A JSON object that defines the state of the HiGlassComponent
           *
           * Returns
           * -------
           *  dataLoaded: Promise
           *    A promise that resolves when all of the data for this viewconfig
           *    is loaded
           */
          var viewsByUid = self.processViewConfig(newViewConfig);
          var p = new Promise(function (resolve, reject) {

            _this.requestsInFlight = 0;

            var requestsSent = _pubSub2['default'].subscribe('requestSent', function (url) {
              _this.requestsInFlight += 1;
            });

            var requestsReceived = _pubSub2['default'].subscribe('requestReceived', function (url) {
              _this.requestsInFlight -= 1;

              if (_this.requestsInFlight == 0) {
                resolve();
              }
            });

            self.setState({
              views: viewsByUid
            }, function () {});
          });

          return p;
        }

        return setViewConfig;
      }(),
      zoomToDataExtent: function () {
        function zoomToDataExtent(viewUid) {
          /**
           * Zoom so that the entire dataset is visible
           *
           * Parameters
           * ----------
           *  viewUid: string
           *    The view uid to zoom to extent to
           *
           * Returns
           * -------
           *  nothing
           */
          self.handleZoomToData(viewUid);
        }

        return zoomToDataExtent;
      }(),
      activateTool: function () {
        function activateTool(tool) {
          switch (tool) {
            case 'select':
              self.setMouseTool(_configs.MOUSE_TOOL_SELECT);
              break;

            default:
              self.setMouseTool(_configs.MOUSE_TOOL_MOVE);
              break;
          }
        }

        return activateTool;
      }(),


      /**
       * Get a property of HiGlass.
       *
       * @description
       * Returns the current value for any of the available listeners, e.g.,
       * `get(rangeSelection)` will return the current range selection without
       * requiring that a range selection event is fired.
       *
       * @param {string} prop - Name of the property.
       * @param {string} viewId - UUID of the view `prop` relates to.
       * @return {object} Promise resolving to the value.
       */
      get: function () {
        function get(prop, viewId) {
          switch (prop) {
            case 'location':
              if (typeof viewId === 'undefined') {
                return Promise.reject('Please provide the view UUID sweetheart ');
              }
              return self.getGenomeLocation(viewId);

            case 'rangeSelection':
              return Promise.resolve(self.rangeSelection);

            case 'viewConfig':
              return Promise.resolve(self.getViewsAsString());

            default:
              return Promise.reject('Propert "' + prop + '" unknown');
          }
        }

        return get;
      }(),
      goTo: function () {
        function goTo(viewUid, chrom1, start1, end1, chrom2, start2, end2) {
          var animate = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
          var animateTime = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 3000;


          // Set chromInfo if not available
          if (!self.chromInfo) {
            self.setChromInfo(self.state.views[viewUid].chromInfoPath, function () {
              self.api.goTo(viewUid, chrom1, start1, end1, chrom2, start2, end2, animate, animateTime);
            });
            return;
          }

          var _relToAbsChromPos = (0, _utils.relToAbsChromPos)(chrom1, start1, end1, self.chromInfo),
              _relToAbsChromPos2 = _slicedToArray(_relToAbsChromPos, 2),
              start1Abs = _relToAbsChromPos2[0],
              end1Abs = _relToAbsChromPos2[1];

          var _relToAbsChromPos3 = (0, _utils.relToAbsChromPos)(chrom2, start2, end2, self.chromInfo),
              _relToAbsChromPos4 = _slicedToArray(_relToAbsChromPos3, 2),
              start2Abs = _relToAbsChromPos4[0],
              end2Abs = _relToAbsChromPos4[1];

          var _scalesCenterAndK = (0, _utils.scalesCenterAndK)(self.xScales[viewUid].copy().domain([start1Abs, end1Abs]), self.yScales[viewUid].copy().domain([start2Abs, end2Abs])),
              _scalesCenterAndK2 = _slicedToArray(_scalesCenterAndK, 3),
              centerX = _scalesCenterAndK2[0],
              centerY = _scalesCenterAndK2[1],
              k = _scalesCenterAndK2[2];

          self.setCenters[viewUid](centerX, centerY, k, false, animate, animateTime);
        }

        return goTo;
      }(),
      off: function () {
        function off(event, listenerId, viewId) {
          switch (event) {
            case 'location':
              self.offLocationChange(viewId, listenerId);
              break;

            case 'rangeSelection':
              self.offRangeSelection(listenerId);
              break;

            case 'viewConfig':
              self.offViewChange(listenerId);
              break;

            default:
              // nothing
              break;
          }
        }

        return off;
      }(),
      on: function () {
        function on(event, callback, viewId, callbackId) {
          switch (event) {
            case 'location':
              self.onLocationChange(viewId, callback, callbackId);
              break;

            case 'rangeSelection':
              return self.onRangeSelection(callback);

            case 'viewConfig':
              return self.onViewChange(callback);

            default:
              // nothing
              break;
          }
        }

        return on;
      }()
    };
  }

  return api;
}();

exports['default'] = api;

/***/ }),
/* 715 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"higlass":"HiGlass-module_higlass-1NHR2","higlass-canvas":"HiGlass-module_higlass-canvas-_mP9r","higlass-drawing-surface":"HiGlass-module_higlass-drawing-surface-3aQQo","higlass-svg":"HiGlass-module_higlass-svg-JJZbf","tiled-area":"HiGlass-module_tiled-area-22H1L"};

/***/ }),
/* 716 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ })
/******/ ]);
});
//# sourceMappingURL=hglib.js.map
